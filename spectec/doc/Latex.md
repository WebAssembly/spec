## Generating Latex

### Running

Latex is generated by pre-processing files. To pre-process a set of files, run:
```
watsup <source-files ...> --<format> -p <patch-files ...>
```
to pre-process the files `<patch-files ...>`, which are assumed to be in the format `<format>` -- currently either `latex` (default) or `sphinx`.

The processed files are expected to contain an arbitrary number of [splice anchors](#splicing), which are then replaced by embedded Latex formulas.

The respective formular are generated from the definitions in the `<source-files ...>`, which must be a well-formed in the [language](Language.md).


## Splicing

Splices specify where and what to insert during pre-processing.


#### Syntax

The syntax of splices is as follows:
```
tag ::= ...

splice ::=
  tag"{" desc "}"

desc ::=
  ":" exp                               expression splice
  sort ":" group*                       definition splice

group ::=
  name                                  individual definition
  "{" name* "}"                         grouped definitions

name ::=
  id                                    flat or singleton definition
  id "/" regexp                         set definition

id ::=
  (letter | digit | "_" | "-" | "'" | "`")+

regexp ::=
  (id | '*' | '?')+
```

The `tag` can be configured differently for different file formats. Currently, two formats are supported:

* _Latex._ Tags are `@@` and `@@@`, generating `$...$` and `$$...$$`, respectively.

* _Sphinx._ Tags are `$` and `$$`, generating `:math:'...'` and `.. math:: ...`, respectively.

There are two forms of splices:

1. _Expression splices_ (`tag{: exp }`). The body of this splice is an [expression](Language.md#expressions) in the DSL. The effect is to render this expression and insert it.

2. _Definition splices_ (`tag{sort: group* }`). This splice renders and inserts (a set of) [definitions](Language.md#definitions) from the DSL, identified by the _names_ in the `group`. The following `sort`s are recognised:

   * `syntax`: the identifiers refer to [syntax definition](Language.md#definitions), whose grammar is rendered,

   * `syntax+`: same as `syntax`, but the rendering includes any _descriptions_ provided through [description hints](#description-hints-desc),

   * `relation`: the identifiers refer to definitions of [relations](Language.md#definitions), whose schema is rendered,

   * `rule`: the identifiers refer to definitions of [rules](Language.md#definitions), which are rendered depending on the kind of relation:
     * _typing rules_ (`... |- ...`) are rendered as inference rules,
     * _reduction rules_ (`... ~> ...`) are rendered as an array of one-line rules,

     other forms of rules are not recognised and will be rejected.,

   * `rule+`: same as `rule`, but the rule is decorated with its [name](#definiiton-names),

   * `definition`: the identifiers refer to [function definitions](Language.md#definitions), whose clauses are rendered.

Each splice may contain a list of identifiers, whose definitions will be arranged and aligned together in a single array, with multiple definitions separated by (`0.8ex`) vertical space.

In addition, definitions can be grouped together by using braces `{ name* }`, which removes the vertical space between them. In the case of typing rules, the rules are placed on a single line.

In the case of syntax, grouping together multiple [fragments](Language.md#definitions) of the same variant type also _merges_ the fragments, removing trailing and leading dots in the middle.


#### Definition names

The names in a definition splice refer to definitions according to the indicated sort.

* Relations and definitions have a _flat_ namespace, and are hence named by a single identifier.

* Syntax fragments and rules have a _nested_ namespace, and are hence named by a pair of identifiers, `id1/id2`. If only one element exists in the nested namespace, `/id2` can be omitted, in case it was also omitted in the respective syntax or rule definition.

* Nested namespaces can also be named by a regular expression, which expands to all `id2` matching it in the given namespace.


#### Examples

```
;; insert definitions of types
@@@{syntax: numtype vectype valtype}

;; insert grammar for control and reference instructions together
@@@{syntax: {instr/control instr/reference}}

;; insert grammar for all instructions in a single grammar
@@@{syntax: {instr/*}}

;; insert typing rules for `unreachable`, `nop` and `drop`,
;; putting the first on its own, the latter two on the same line
@@@{rule: Instr_ok/unreachable {Instr_ok/nop Instr_ok/drop}}

;; insert reduction rules for `block`, `loop` and all the ones for `if`,
;; as well as `br` and `br_if`, but with small vertical space
@@@{rule: {Step/block Step/loop Step/if-*} {Step/br Step/br_if}}
```


#### Coverage warnings

By setting the `-w` option, the tool will invoke warnings for any definition name from the spec sources that either has not been inserted, or was inserted multiple times.



## Rendering

The rendering of the DSL should be mostly intuitive. A few points of note:

* The use of underscores in identifiers activates rendering as subscripts (e.g. `t_1`), except in atoms, where they render as underscores -- to support Wasm keywords containing underscores. In particular, a trailing underscore in an atom or function identifier will render the first argument to this as a subscript (e.g., `LABEL_ n`, or `default_(t)`).

* Variant names with a _leading_ underscore are hidden, i.e., not rendered.

* Premises on typing rules are rendered as premises; premises on reduction rules and definitions are rendered as side conditions.

* Whitespace is insignificant except for line breaks in a few places:

  - a line break after the comma of a record causes a line break in the redering,

  - a line break before a bar in a variant definition causes a line break in the rendering,

  - an empty line between two premises in a typing rule causes a line break in the premise of the inference rule.


### Hints

Some aspects of rendering can be custimised by [hints](Language.md#definitions).


#### Display hints (`show`)

Hints of the form `hint(show <exp>)` are recognised on a number of constructs and change how the repsective definition is rendered:

* on a syntax definition or variable declaration they control how the variable is printed; `<exp>` will typically be another variable name:
  ```
  syntax admininstr  hint(show instr) = ...
  ```

* on a variant case or function declaration they control how the case is rendered; the expression will typically be a _pattern_ containing _holes_ `%`, which are substituted by the arguments in order of appearance:
  ```
  syntax instr = | CONST valtype c  hint(show %.CONST %)

  definition $size(valtype) : nat   hint(show |valtype|)
  ```

* on a record field they control how the atom is rendered; the expression typically is some other atom,

* on a relation declaration they control how the rule names are rendered; the expression must be a text literal:
  ```
  relation Instr_ok: context |- instr : functype   hint(show "T")
  rule Instr_ok: C |- DROP : t -> eps

  relation Step: instr* ~> instr*                  hint(show "S")
  rule Step/drop: val DROP ~> eps
  ```
  After this, the splice `@@@{rule+: Instr_ok/nop}` will generate (in proper Latex)
  ```
  ------------------------ [T-drop]
  C |- DROP : t -> eps
  ```
  Similarly, the splice `@@@{rule+: Step/nop}` will generate
  ```
  [S-nop]  val DROP ~> eps
  ```

Show hints for variant cases or function definition are expressions with two additional pieces of syntax:

* _holes_ `%` are placeholders for the real arguments of the identifier at uses sites, substituted in order of appearance,

* _fuses_ `exp#exp` remove spacing between two expressions.

For example, with
```
syntax instr = ...
  | CONST numtype c    hint(show %.CONST %)
  | EXTEND numtype n   hint(show %.EXTEND#%)
```
  the expressions `CONST f64 5` and `EXTEND i32 8` will be rendered as `f64.const 5` and `i32.extend8`, respectively (in proper Latex).


#### Description hints (`desc`)

Hints of the form `hint(desc <exp>)` are recognised on syntax definitions and define a description of the production. The expression must be a text literal. When rendering the respective syntax defininition with `syntax+`, this description will show up on the left. For example,
```
syntax valtype hint(desc "value type") =
  | numtype
  | vectype
  | reftype
```
will render as
```
(value type)  valtype ::= numtype
                        | vectype
                        | reftype
```
