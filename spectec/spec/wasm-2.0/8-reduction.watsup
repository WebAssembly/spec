;;
;; Configurations
;;

relation Step: config ~> config                 hint(show "E")
relation Step_pure: admininstr* ~> admininstr*  hint(show "E")
relation Step_read: config ~> admininstr*       hint(show "E")
relation Steps: config ~>* config               hint(show "E")

rule Step/pure:
  z; instr*  ~>  z; instr'*
  -- Step_pure: instr* ~> instr'*

rule Step/read:
  z; instr*  ~>  z; instr'*
  -- Step_read: z; instr* ~> instr'*

rule Steps/refl:
  z; admininstr* ~>* z; admininstr*

rule Steps/trans:
  z; admininstr*  ~>*  z''; admininstr''*
  -- Step: z; admininstr*  ~>  z'; admininstr'*
  -- Steps: z'; admininstr'  ~>*  z''; admininstr''*


;; Expressions

relation Eval_expr: state; expr ~>* state; val*  hint(show "E-expr")

rule Eval_expr:
  z; instr*  ~>*  z'; val*
  -- Steps: z; instr*  ~>*  z'; val*


;;
;; Instructions
;;

;; Polymorphic instructions

rule Step_pure/unreachable:
  UNREACHABLE  ~>  TRAP

rule Step_pure/nop:
  NOP  ~>  eps

rule Step_pure/drop:
  val DROP  ~>  eps


rule Step_pure/select-true:
  val_1 val_2 (CONST I32 c) (SELECT t*?)  ~>  val_1
  -- if c =/= 0

rule Step_pure/select-false:
  val_1 val_2 (CONST I32 c) (SELECT t*?)  ~>  val_2
  -- if c = 0


;; Block instructions

def $blocktype(state, blocktype) : functype  hint(show $blocktype_(%,%))
def $blocktype(z, _RESULT eps) = eps -> eps
def $blocktype(z, _RESULT t) = eps -> t
def $blocktype(z, _IDX x) = $type(z, x)

rule Step_read/block:
  z; val^k (BLOCK bt instr*)  ~>  (LABEL_ n `{eps} val^k instr*)
  -- if $blocktype(z, bt) = t_1^k -> t_2^n

rule Step_read/loop:
  z; val^k (LOOP bt instr*)  ~>  (LABEL_ k `{LOOP bt instr*} val^k instr*)
  -- if $blocktype(z, bt) = t_1^k -> t_2^n

rule Step_pure/if-true:
  (CONST I32 c) (IF bt instr_1* ELSE instr_2*)  ~>  (BLOCK bt instr_1*)
  -- if c =/= 0

rule Step_pure/if-false:
  (CONST I32 c) (IF bt instr_1* ELSE instr_2*)  ~>  (BLOCK bt instr_2*)
  -- if c = 0


rule Step_pure/label-vals:
  (LABEL_ n `{instr*} val*)  ~>  val*


;; Branch instructions

;; TODO: may want a label context instead of bubbling up
rule Step_pure/br-zero:
  (LABEL_ n `{instr'*} val'* val^n (BR 0) instr*)  ~>  val^n instr'*

rule Step_pure/br-succ:
  (LABEL_ n `{instr'*} val* (BR $(l+1)) instr*)  ~>  val* (BR l)


rule Step_pure/br_if-true:
  (CONST I32 c) (BR_IF l)  ~>  (BR l)
  -- if c =/= 0

rule Step_pure/br_if-false:
  (CONST I32 c) (BR_IF l)  ~>  eps
  -- if c = 0


rule Step_pure/br_table-lt:
  (CONST I32 i) (BR_TABLE l* l')  ~>  (BR l*[i])
  -- if i < |l*|

rule Step_pure/br_table-ge:
  (CONST I32 i) (BR_TABLE l* l')  ~>  (BR l')
  -- if i >= |l*|


;; Function instructions

rule Step_read/call:
  z; (CALL x)  ~>  (CALL_ADDR $funcaddr(z)[x])  ;; TODO

rule Step_read/call_indirect-call:
  z; (CONST I32 i) (CALL_INDIRECT x y)  ~>  (CALL_ADDR a)
  -- if $table(z, x).ELEM[i] = (REF.FUNC_ADDR a)
  -- if $type(z, y) = $funcinst(z)[a].TYPE

rule Step_read/call_indirect-trap:
  z; (CONST I32 i) (CALL_INDIRECT x y)  ~>  TRAP
  -- otherwise

rule Step_read/call_addr:
  z; val^k (CALL_ADDR a)  ~>  (FRAME_ n `{f} (LABEL_ n `{eps} instr*))
  -- if $funcinst(z)[a] = {TYPE (t_1^k -> t_2^n), MODULE mm, CODE func}
  -- if func = FUNC x (LOCAL t)* instr*
  -- if f = {LOCAL val^k ($default(t))*, MODULE mm}


rule Step_pure/frame-vals:
  (FRAME_ n `{f} val^n)  ~>  val^n

rule Step_pure/return-frame:
  (FRAME_ n `{f} val'* val^n RETURN instr*)  ~>  val^n

rule Step_pure/return-label:
  (LABEL_ k `{instr'*} val* RETURN instr*)  ~>  val* RETURN


;; Numeric instructions

rule Step_pure/unop-val:
  (CONST nt c_1) (UNOP nt unop)  ~>  (CONST nt c)
  -- if $unop(nt, unop, c_1) = c  ;; TODO

rule Step_pure/unop-trap:
  (CONST nt c_1) (UNOP nt unop)  ~>  TRAP
  -- if $unop(nt, unop, c_1) = eps  ;; TODO


rule Step_pure/binop-val:
  (CONST nt c_1) (CONST nt c_2) (BINOP nt binop)  ~>  (CONST nt c)
  -- if $binop(nt, binop, c_1, c_2) = c  ;; TODO

rule Step_pure/binop-trap:
  (CONST nt c_1) (CONST nt c_2) (BINOP nt binop)  ~>  TRAP
  -- if $binop(nt, binop, c_1, c_2) = eps  ;; TODO


rule Step_pure/testop:
  (CONST nt c_1) (TESTOP nt testop)  ~>  (CONST I32 c)
  -- if c = $testop(nt, testop, c_1)

rule Step_pure/relop:
  (CONST nt c_1) (CONST nt c_2) (RELOP nt relop)  ~>  (CONST I32 c)
  -- if c = $relop(nt, relop, c_1, c_2)


rule Step_pure/cvtop-val:
  (CONST nt_1 c_1) (CVTOP nt_2 cvtop nt_1 sx?)  ~>  (CONST nt_2 c)
  -- if $cvtop(nt_1, nt_2, cvtop, sx?, c_1) = c  ;; TODO

rule Step_pure/cvtop-trap:
  (CONST nt_1 c_1) (CVTOP nt_2 cvtop nt_1 sx?)  ~>  TRAP
  -- if $cvtop(nt_1, nt_2, cvtop, sx?, c_1) = eps  ;; TODO


;; Reference instructions

rule Step_read/ref.func:
  z; (REF.FUNC x) ~> (REF.FUNC_ADDR $funcaddr(z)[x])


rule Step_pure/ref.is_null-true:
  val REF.IS_NULL  ~>  (CONST I32 1)
  -- if val = (REF.NULL rt)

rule Step_pure/ref.is_null-false:
  val REF.IS_NULL  ~>  (CONST I32 0)
  -- otherwise


;; Vector instructions

rule Step_pure/vvunop:
  (VCONST V128 c_1) (VVUNOP V128 vvunop)  ~>  (VCONST V128 c)
  -- if $vvunop(V128, vvunop, c_1) = c ;; TODO


rule Step_pure/vvbinop:
  (VCONST V128 c_1) (VCONST V128 c_2) (VVBINOP V128 vvbinop)  ~>  (VCONST V128 c)
  -- if $vvbinop(V128, vvbinop, c_1, c_2) = c ;; TODO


rule Step_pure/vvternop:
  (VCONST V128 c_1) (VCONST V128 c_2) (VCONST V128 c_3) (VVTERNOP V128 vvternop)  ~>  (VCONST V128 c)
  -- if $vvternop(V128, vvternop, c_1, c_2, c_3) = c ;; TODO


rule Step_pure/vvtestop:
  (VCONST V128 c_1) (VVTESTOP V128 ANY_TRUE) ~> (CONST I32 c)
  -- if c = $ine($size(V128), c_1, 0)


rule Step_pure/vswizzle:
  (VCONST V128 c_1) (VCONST V128 c_2) (VSWIZZLE (inn X N)) ~> (VCONST V128 c')
  -- var c : iN($size(inn))
  -- if ci* = $lanes_(inn X N, c_2)
  -- if c* = $lanes_(inn X N, c_1) 0^(256 - N)
  -- if c' = $invlanes_(inn X N, c*[$(ci*[k])]^(k<N))


rule Step_pure/vshuffle:
  (VCONST V128 c_1) (VCONST V128 c_2) (VSHUFFLE (inn X N) i*) ~> (VCONST V128 c)
  -- var c' : iN($size(inn))
  -- if c'* = $lanes_(inn X N, c_1) $lanes_(inn X N, c_2)
  -- if c = $invlanes_(inn X N, c'*[$(i*[k])]^(k<N))


rule Step_pure/vsplat:
  (CONST $unpack(lnn) c_1) (VSPLAT (lnn X N)) ~> (VCONST V128 c)
  -- if c = $invlanes_(lnn X N, $packnum(lnn, c_1)^N)


rule Step_pure/vextract_lane-num:
  (VCONST V128 c_1) (VEXTRACT_LANE (nt X N) i) ~> (CONST nt c_2)
  -- if c_2 = $lanes_(nt X N, c_1)[i]

rule Step_pure/vextract_lane-pack:
  (VCONST V128 c_1) (VEXTRACT_LANE (pt X N) sx i) ~> (CONST I32 c_2)
  -- if c_2 = $ext($psize(pt), 32, sx, $lanes_(pt X N, c_1)[i])


rule Step_pure/vreplace_lane:
  (VCONST V128 c_1) (CONST $unpack(lnn) c_2) (VREPLACE_LANE (lnn X N) i) ~> (VCONST V128 c)
  -- if c = $invlanes_(lnn X N, $lanes_(lnn X N, c_1)[[i] = $packnum(lnn, c_2)])


rule Step_pure/vunop:
  (VCONST V128 c_1) (VUNOP sh vunop)  ~>  (VCONST V128 c)
  -- if c = $vunop(sh, vunop, c_1)


rule Step_pure/vbinop-val:
  (VCONST V128 c_1) (VCONST V128 c_2) (VBINOP sh vbinop)  ~>  (VCONST V128 c)
  -- if $vbinop(sh, vbinop, c_1, c_2) = c

rule Step_pure/vbinop-trap:
  (VCONST V128 c_1) (VCONST V128 c_2) (VBINOP sh vbinop)  ~>  TRAP
  -- if $vbinop(sh, vbinop, c_1, c_2) = eps


rule Step_pure/vrelop:
  (VCONST V128 c_1) (VCONST V128 c_2) (VRELOP sh vrelop)  ~>  (VCONST V128 c)
  -- if $vrelop(sh, vrelop, c_1, c_2) = c
(; TODO: this should be implemented at the same level as other pointwise ops
  -- if c'_1* = $lanes_(lnn X N, c_1)
  -- if c'_2* = $lanes_(lnn X N, c_2)
  -- if c = $invlanes_($IN($lsize(lnn)) X N, $ext(1, $lsize(lnn), S, $vrelop(lnn X N, vrelop, c'_1, c'_2))*)
;)


rule Step_pure/vshiftop:
  (VCONST V128 c_1) (CONST I32 n) (VSHIFTOP (imm X N) vshiftop) ~> (VCONST V128 c)
  -- if ci* = $lanes_(imm X N, c_1)
  -- if c = $invlanes_(imm X N, $vishiftop(imm X N, vshiftop, ci, n)*)


;; TODO: introduce $vitestop for uniformity
rule Step_pure/vtestop-true:
  (VCONST V128 c) (VTESTOP (inn X N) ALL_TRUE) ~> (CONST I32 1)
  -- if ci* = $lanes_(inn X N, c)
  -- (if $(ci =/= 0))*

rule Step_pure/vtestop-false:
  (VCONST V128 c) (VTESTOP (inn X N) ALL_TRUE) ~> (CONST I32 0)
  -- otherwise


rule Step_pure/vbitmask:
  (VCONST V128 c) (VBITMASK (inn X N)) ~> (CONST I32 i)
  -- if ci* = $lanes_(inn X N, c)
  -- if $ibits(32, i) = $ilt($size(inn), S, ci, 0)*


rule Step_pure/vnarrow:
  (VCONST V128 c_1) (VCONST V128 c_2) (VNARROW (inn_1 X N_1) (inn_2 X N_2) sx) ~> (VCONST V128 c)
  -- if ci_1* = $lanes_(inn_1 X N_1, c_1)
  -- if ci_2* = $lanes_(inn_1 X N_1, c_2)
  -- if cj_1* = $narrow($size(inn_1), $size(inn_2), sx, i_1)*
  -- if cj_2* = $narrow($size(inn_1), $size(inn_2), sx, i_2)*
  -- if c = $invlanes_(inn_2 X N_2, cj_1* cj_2*)


rule Step_pure/vcvtop-normal:
  (VCONST V128 c_1) (VCVTOP (lnn_2 X N_2) vcvtop eps (lnn_1 X N_1) sx) ~> (VCONST V128 c)
  -- if c'* = $lanes_(lnn_1 X N_1, c_1)
  -- if c = $invlanes_(lnn_2 X N_2, $vcvtop(lnn_1 X N_1, lnn_2 X N_2, vcvtop, sx, c')*)

var hf : half  ;; TODO: this declaration shouldn't be needed
rule Step_pure/vcvtop-half:
  (VCONST V128 c_1) (VCVTOP (inn_2 X N_2) vcvtop hf (inn_1 X N_1) sx?) ~> (VCONST V128 c)
  -- if ci* = $lanes_(inn_1 X N_1, c_1)[$halfop(hf, 0, N_2) : N_2]
  -- if c = $invlanes_(inn_2 X N_2, $vcvtop(inn_1 X N_1, inn_2 X N_2, vcvtop, sx?, ci)*)

rule Step_pure/vcvtop-zero:
  (VCONST V128 c_1) (VCVTOP (inn_2 X N_2) vcvtop eps (inn_1 X N_1) sx? ZERO) ~> (VCONST V128 c)
  -- if ci* = $lanes_(inn_1 X N_1, c_1)
  -- if c = $invlanes_(inn_2 X N_2, $vcvtop(inn_1 X N_1, inn_2 X N_2, vcvtop, sx?, ci)* 0^N_1)


rule Step_pure/vextunop:
  (VCONST V128 c_1) (VEXTUNOP sh_1 sh_2 vextunop sx) ~> (VCONST V128 c)
  -- if $vextunop(sh_1, sh_2, vextunop, sx, c_1) = c


rule Step_pure/vextbinop:
  (VCONST V128 c_1) (VCONST V128 c_2) (VEXTBINOP sh_1 sh_2 vextbinop sx) ~> (VCONST V128 c)
  -- if $vextbinop(sh_1, sh_2, vextbinop, sx, c_1, c_2) = c


;; Local instructions

rule Step_read/local.get:
  z; (LOCAL.GET x)  ~>  $local(z, x)

rule Step/local.set:
  z; val (LOCAL.SET x)  ~>  $with_local(z, x, val); eps

rule Step_pure/local.tee:
  val (LOCAL.TEE x)  ~>  val val (LOCAL.SET x)


;; Global instructions

rule Step_read/global.get:
  z; (GLOBAL.GET x)  ~>  $global(z, x).VALUE

rule Step/global.set:
  z; val (GLOBAL.SET x)  ~>  $with_global(z, x, val); eps


;; Table instructions

rule Step_read/table.get-trap:
  z; (CONST I32 i) (TABLE.GET x)  ~>  TRAP
  -- if i >= |$table(z, x).ELEM|

rule Step_read/table.get-val:
  z; (CONST I32 i) (TABLE.GET x)  ~>  $table(z,x).ELEM[i]
  -- if i < |$table(z, x).ELEM|

rule Step/table.set-trap:
  z; (CONST I32 i) ref (TABLE.SET x)  ~>  z; TRAP
  -- if i >= |$table(z, x).ELEM|

rule Step/table.set-val:
  z; (CONST I32 i) ref (TABLE.SET x)  ~>  $with_table(z, x, i, ref); eps
  -- if i < |$table(z, x).ELEM|


rule Step_read/table.size:
  z; (TABLE.SIZE x)  ~>  (CONST I32 n)
  -- if |$table(z, x).ELEM| = n  ;; TODO: inline this


rule Step/table.grow-succeed:
  z; ref (CONST I32 n) (TABLE.GROW x)  ~>  $with_tableinst(z, x, ti); (CONST I32 $(|$table(z, x).ELEM|))
  -- if $growtable($table(z, x), n, ref) = ti

rule Step/table.grow-fail:
  z; ref (CONST I32 n) (TABLE.GROW x)  ~>  z; (CONST I32 $invsigned(32, $(-1)))


rule Step_read/table.fill-trap:
  z; (CONST I32 i) val (CONST I32 n) (TABLE.FILL x)  ~>  TRAP
  -- if $(i + n) > |$table(z, x).ELEM|

rule Step_read/table.fill-zero:
  z; (CONST I32 i) val (CONST I32 n) (TABLE.FILL x)  ~>  eps
  -- otherwise
  -- if n = 0

rule Step_read/table.fill-succ:
  z; (CONST I32 i) val (CONST I32 n) (TABLE.FILL x)  ~>
    (CONST I32 i) val (TABLE.SET x)
    (CONST I32 $(i+1)) val (CONST I32 $(n-1)) (TABLE.FILL x)
  -- otherwise


rule Step_read/table.copy-trap:
  z; (CONST I32 j) (CONST I32 i) (CONST I32 n) (TABLE.COPY x y)  ~>  TRAP
  -- if $(i + n) > |$table(z, y).ELEM| \/ $(j + n) > |$table(z, x).ELEM|

rule Step_read/table.copy-zero:
  z; (CONST I32 j) (CONST I32 i) (CONST I32 n) (TABLE.COPY x y)  ~>  eps
  -- otherwise
  -- if n = 0

rule Step_read/table.copy-le:
  z; (CONST I32 j) (CONST I32 i) (CONST I32 n) (TABLE.COPY x y)  ~>
    (CONST I32 j) (CONST I32 i) (TABLE.GET y) (TABLE.SET x)
    (CONST I32 $(j+1)) (CONST I32 $(i+1)) (CONST I32 $(n-1)) (TABLE.COPY x y)
  -- otherwise
  -- if j <= i

rule Step_read/table.copy-gt:
  z; (CONST I32 j) (CONST I32 i) (CONST I32 n) (TABLE.COPY x y)  ~>
    (CONST I32 $(j+n-1)) (CONST I32 $(i+n-1)) (TABLE.GET y) (TABLE.SET x)
    (CONST I32 j) (CONST I32 i) (CONST I32 $(n-1)) (TABLE.COPY x y)
  -- otherwise


rule Step_read/table.init-trap:
  z; (CONST I32 j) (CONST I32 i) (CONST I32 n) (TABLE.INIT x y)  ~>  TRAP
  -- if $(i + n) > |$elem(z, y).ELEM| \/ $(j + n) > |$table(z, x).ELEM|

rule Step_read/table.init-zero:
  z; (CONST I32 j) (CONST I32 i) (CONST I32 n) (TABLE.INIT x y)  ~>  eps
  -- otherwise
  -- if n = 0

rule Step_read/table.init-succ:
  z; (CONST I32 j) (CONST I32 i) (CONST I32 n) (TABLE.INIT x y)  ~>
    (CONST I32 j) $elem(z,y).ELEM[i] (TABLE.SET x)
    (CONST I32 $(j+1)) (CONST I32 $(i+1)) (CONST I32 $(n-1)) (TABLE.INIT x y)
  -- otherwise


rule Step/elem.drop:
  z; (ELEM.DROP x)  ~>  $with_elem(z, x, eps); eps


;; Memory instructions

rule Step_read/load-num-trap:
  z; (CONST I32 i) (LOAD nt mo)  ~>  TRAP
  -- if $(i + mo.OFFSET + $size(nt)/8 > |$mem(z, 0).DATA|)

rule Step_read/load-num-val:
  z; (CONST I32 i) (LOAD nt mo)  ~>  (CONST nt c)
  -- if $nbytes(nt, c) = $mem(z, 0).DATA[i + mo.OFFSET : $size(nt)/8]

rule Step_read/load-pack-trap:
  z; (CONST I32 i) (LOAD inn (n _ sx) mo)  ~>  TRAP
  -- if $(i + mo.OFFSET + n/8 > |$mem(z, 0).DATA|)

rule Step_read/load-pack-val:
  z; (CONST I32 i) (LOAD inn (n _ sx) mo)  ~>  (CONST inn $ext(n, $size(inn), sx, c))
  -- if $ibytes(n, c) = $mem(z, 0).DATA[i + mo.OFFSET : n/8]

rule Step_read/vload-oob:
  z; (CONST I32 i) (VLOAD mo)  ~>  TRAP
  -- if $(i + mo.OFFSET + $size(V128)/8 > |$mem(z, 0).DATA|)

rule Step_read/vload-val:
  z; (CONST I32 i) (VLOAD mo)  ~>  (VCONST V128 c)
  -- if $vbytes(V128, c) = $mem(z, 0).DATA[i + mo.OFFSET : $size(V128)/8]


rule Step_read/vload-shape-oob:
  z; (CONST I32 i) (VLOAD (SHAPE M X N sx) mo)  ~>  TRAP
  -- if $(i + mo.OFFSET + M * N/8) > |$mem(z, 0).DATA|

rule Step_read/vload-shape-val:
  z; (CONST I32 i) (VLOAD (SHAPE M X N sx) mo)  ~>  (VCONST V128 c)
  -- (if $ibytes(M, j) = $mem(z, 0).DATA[i + mo.OFFSET + k * M/8 : M/8])^(k<N)
  -- if $size(inn) = $(M * 2)  ;; TODO: relate implicitly
  -- if c = $invlanes_(inn X N, $ext(M, $size(inn), sx, j)^N)


rule Step_read/vload-splat-oob:
  z; (CONST I32 i) (VLOAD (SPLAT N) mo)  ~>  TRAP
  -- if $(i + mo.OFFSET + N/8) > |$mem(z, 0).DATA|

rule Step_read/vload-splat-val:
  z; (CONST I32 i) (VLOAD (SPLAT N) mo)  ~>  (VCONST V128 c)
  -- if $ibytes(N, j) = $mem(z, 0).DATA[i + mo.OFFSET : N/8]
  -- if N = $lsize(imm)  ;; TODO: relate implicitly
  -- if M = $(128/N)
  -- if c = $invlanes_(imm X M, j*)


rule Step_read/vload-zero-oob:
  z; (CONST I32 i) (VLOAD (ZERO N) mo)  ~>  TRAP
  -- if $(i + mo.OFFSET + N/8) > |$mem(z, 0).DATA|

rule Step_read/vload-zero-val:
  z; (CONST I32 i) (VLOAD (ZERO N) mo)  ~>  (VCONST V128 c)
  -- if $ibytes(N, j) = $mem(z, 0).DATA[i + mo.OFFSET : N/8]
  -- if c = $ext(N, 128, U, j)


rule Step_read/vload_lane-oob:
  z; (CONST I32 i) (VCONST V128 c_1) (VLOAD_LANE N mo j)  ~>  TRAP
  -- if $(i + mo.OFFSET + N/8 > |$mem(z, 0).DATA|)

rule Step_read/vload_lane-val:
  z; (CONST I32 i) (VCONST V128 c_1) (VLOAD_LANE N mo j)  ~>  (VCONST V128 c)
  -- if $ibytes(N, k) = $mem(z, 0).DATA[i + mo.OFFSET : N/8]
  -- if N = $lsize(imm)  ;; TODO: relate implicitly
  -- if M = $(128/N)
  -- if c = $invlanes_(imm X M, $lanes_(imm X M, c_1)[[j] = k])


rule Step/store-num-trap:
  z; (CONST I32 i) (CONST nt c) (STORE nt mo)  ~>  z; TRAP
  -- if $(i + mo.OFFSET + $size(nt)/8) > |$mem(z, 0).DATA|

rule Step/store-num-val:
  z; (CONST I32 i) (CONST nt c) (STORE nt mo)  ~>  $with_mem(z, 0, $(i + mo.OFFSET), $($size(nt)/8), b*); eps
  -- if b* = $nbytes(nt, c)

rule Step/store-pack-trap:
  z; (CONST I32 i) (CONST inn c) (STORE inn n mo)  ~>  z; TRAP
  -- if $(i + mo.OFFSET + n/8) > |$mem(z, 0).DATA|

rule Step/store-pack-val:
  z; (CONST I32 i) (CONST inn c) (STORE inn n mo)  ~>  $with_mem(z, 0, $(i + mo.OFFSET), $(n/8), b*); eps
  -- if b* = $ibytes(n, $wrap($size(inn), n, c))

rule Step/vstore-oob:
  z; (CONST I32 i) (VCONST V128 c) (VSTORE mo)  ~>  z; TRAP
  -- if $(i + mo.OFFSET + $size(V128)/8) > |$mem(z, 0).DATA|

rule Step/vstore-val:
  z; (CONST I32 i) (VCONST V128 c) (VSTORE mo)  ~>  $with_mem(z, 0, $(i + mo.OFFSET), $($size(V128)/8), b*); eps
  -- if b* = $vbytes(V128, c)


rule Step/vstore_lane-oob:
  z; (CONST I32 i) (VCONST V128 c) (VSTORE_LANE N mo j)  ~>  z; TRAP
  -- if $(i + mo.OFFSET + N) > |$mem(z, 0).DATA|

rule Step/vstore_lane-val:
  z; (CONST I32 i) (VCONST V128 c) (VSTORE_LANE N mo j)  ~>  $with_mem(z, 0, $(i + mo.OFFSET), $(N/8), b*); eps
  -- if N = $lsize(imm)  ;; TODO: relate implicitly
  -- if M = $(128/N)
  -- if b* = $ibytes(N, $lanes_(imm X M, c)[j])


rule Step_read/memory.size:
  z; (MEMORY.SIZE)  ~>  (CONST I32 n)
  -- if $(n * 64 * $Ki) = |$mem(z, 0).DATA|


rule Step/memory.grow-succeed:
  z; (CONST I32 n) (MEMORY.GROW)  ~>  $with_meminst(z, 0, mi); (CONST I32 $(|$mem(z, 0).DATA| / (64 * $Ki)))
  -- if $growmemory($mem(z, 0), n) = mi

rule Step/memory.grow-fail:
  z; (CONST I32 n) (MEMORY.GROW)  ~>  z; (CONST I32 $invsigned(32, $(-1)))


rule Step_read/memory.fill-trap:
  z; (CONST I32 i) val (CONST I32 n) (MEMORY.FILL)  ~>  TRAP
  -- if $(i + n) > |$mem(z, 0).DATA|

rule Step_read/memory.fill-zero:
  z; (CONST I32 i) val (CONST I32 n) (MEMORY.FILL)  ~>  eps
  -- otherwise
  -- if n = 0

rule Step_read/memory.fill-succ:
  z; (CONST I32 i) val (CONST I32 n) (MEMORY.FILL)  ~>
    (CONST I32 i) val (STORE I32 8 $memop0)
    (CONST I32 $(i+1)) val (CONST I32 $(n-1)) (MEMORY.FILL)
  -- otherwise


rule Step_read/memory.copy-trap:
  z; (CONST I32 j) (CONST I32 i) (CONST I32 n) (MEMORY.COPY)  ~>  TRAP
  -- if $(i + n) > |$mem(z, 0).DATA| \/ $(j + n) > |$mem(z, 0).DATA|

rule Step_read/memory.copy-zero:
  z; (CONST I32 j) (CONST I32 i) (CONST I32 n) (MEMORY.COPY)  ~>  eps
  -- otherwise
  -- if n = 0

rule Step_read/memory.copy-le:
  z; (CONST I32 j) (CONST I32 i) (CONST I32 n) (MEMORY.COPY)  ~>
    (CONST I32 j) (CONST I32 i) (LOAD I32 (8 _ U) $memop0) (STORE I32 8 $memop0)
    (CONST I32 $(j+1)) (CONST I32 $(i+1)) (CONST I32 $(n-1)) (MEMORY.COPY)
  -- otherwise
  -- if j <= i

rule Step_read/memory.copy-gt:
  z; (CONST I32 j) (CONST I32 i) (CONST I32 n) (MEMORY.COPY)  ~>
    (CONST I32 $(j+n-1)) (CONST I32 $(i+n-1)) (LOAD I32 (8 _ U) $memop0) (STORE I32 8 $memop0)
    (CONST I32 j) (CONST I32 i) (CONST I32 $(n-1)) (MEMORY.COPY)
  -- otherwise


rule Step_read/memory.init-trap:
  z; (CONST I32 j) (CONST I32 i) (CONST I32 n) (MEMORY.INIT x)  ~>  TRAP
  -- if $(i + n) > |$data(z, x).DATA| \/ $(j + n) > |$mem(z, 0).DATA|

rule Step_read/memory.init-zero:
  z; (CONST I32 j) (CONST I32 i) (CONST I32 n) (MEMORY.INIT x)  ~>  eps
  -- otherwise
  -- if n = 0

rule Step_read/memory.init-succ:
  z; (CONST I32 j) (CONST I32 i) (CONST I32 n) (MEMORY.INIT x)  ~>
    (CONST I32 j) (CONST I32 $data(z,x).DATA[i]) (STORE I32 8 $memop0)
    (CONST I32 $(j+1)) (CONST I32 $(i+1)) (CONST I32 $(n-1)) (MEMORY.INIT x)
  -- otherwise


rule Step/data.drop:
  z; (DATA.DROP x)  ~>  $with_data(z, x, eps); eps
