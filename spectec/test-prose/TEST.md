# Preview

```sh
$ for v in 1 2 3; do ( \
>   echo "Generating prose for Wasm $v.0..." && \
>   ../src/exe-spectec/main.exe ../../../../specification/wasm-$v.0/*.spectec -v -l --prose-rst && \
>   ../src/exe-spectec/main.exe ../../../../specification/wasm-$v.0/*.spectec -v -l --prose \
> ) done
Generating prose for Wasm 1.0...
spectec 0.5 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...



The limits :math:`{}[ n .. {m^?} ]` is :ref:`valid <valid-val>` with :math:`k` if:


   * :math:`n` is less than or equal to :math:`k`.

   * If :math:`m` is defined, then:

      * :math:`n` is less than or equal to :math:`m`.

      * :math:`m` is less than or equal to :math:`k`.




The function type :math:`{t_1^\ast}~\rightarrow~{t_2^?}` is always :ref:`valid <valid-val>`.




The global type :math:`({\mathsf{mut}^?}~t)` is always :ref:`valid <valid-val>`.




The table type :math:`{\mathit{limits}}` is :ref:`valid <valid-val>` if:


   * The limits :math:`{\mathit{limits}}` is :ref:`valid <valid-val>` with :math:`{2^{32}} - 1`.




The memory type :math:`{\mathit{limits}}` is :ref:`valid <valid-val>` if:


   * The limits :math:`{\mathit{limits}}` is :ref:`valid <valid-val>` with :math:`{2^{16}}`.




The external type :math:`{\mathit{externtype}}` is :ref:`valid <valid-val>` if:


   * Either:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{func}~{\mathit{functype}})`.

      * The function type :math:`{\mathit{functype}}` is :ref:`valid <valid-val>`.

   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{global}~{\mathit{globaltype}})`.

      * The global type :math:`{\mathit{globaltype}}` is :ref:`valid <valid-val>`.
   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{table}~{\mathit{tabletype}})`.

      * The table type :math:`{\mathit{tabletype}}` is :ref:`valid <valid-val>`.
   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{mem}~{\mathit{memtype}})`.

      * The memory type :math:`{\mathit{memtype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{func}~{\mathit{functype}})` is :ref:`valid <valid-val>` if:


   * The function type :math:`{\mathit{functype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{global}~{\mathit{globaltype}})` is :ref:`valid <valid-val>` if:


   * The global type :math:`{\mathit{globaltype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{table}~{\mathit{tabletype}})` is :ref:`valid <valid-val>` if:


   * The table type :math:`{\mathit{tabletype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{mem}~{\mathit{memtype}})` is :ref:`valid <valid-val>` if:


   * The memory type :math:`{\mathit{memtype}}` is :ref:`valid <valid-val>`.




The limits :math:`{}[ n_{11} .. n_{12} ]` :ref:`matches <match>` the limits :math:`{}[ n_{21} .. n_{22} ]` if:


   * :math:`n_{11}` is greater than or equal to :math:`n_{21}`.

   * :math:`n_{12}` is less than or equal to :math:`n_{22}`.




The function type :math:`{\mathit{ft}}` :ref:`matches <match>` only itself.




The global type :math:`{\mathit{gt}}` :ref:`matches <match>` only itself.




The table type :math:`{\mathit{lim}}_1` :ref:`matches <match>` the table type :math:`{\mathit{lim}}_2` if:


   * The limits :math:`{\mathit{lim}}_1` :ref:`matches <match>` the limits :math:`{\mathit{lim}}_2`.




The memory type :math:`{\mathit{lim}}_1` :ref:`matches <match>` the memory type :math:`{\mathit{lim}}_2` if:


   * The limits :math:`{\mathit{lim}}_1` :ref:`matches <match>` the limits :math:`{\mathit{lim}}_2`.




The external type :math:`{\mathit{externtype}}_1` :ref:`matches <match>` the external type :math:`{\mathit{externtype}}_2` if:


   * Either:

      * The external type :math:`{\mathit{externtype}}_1` is of the form :math:`(\mathsf{func}~{\mathit{ft}}_1)`.

      * The external type :math:`{\mathit{externtype}}_2` is of the form :math:`(\mathsf{func}~{\mathit{ft}}_2)`.

      * The function type :math:`{\mathit{ft}}_1` :ref:`matches <match>` the function type :math:`{\mathit{ft}}_2`.

   * Or:

      * The external type :math:`{\mathit{externtype}}_1` is of the form :math:`(\mathsf{global}~{\mathit{gt}}_1)`.

      * The external type :math:`{\mathit{externtype}}_2` is of the form :math:`(\mathsf{global}~{\mathit{gt}}_2)`.

      * The global type :math:`{\mathit{gt}}_1` :ref:`matches <match>` the global type :math:`{\mathit{gt}}_2`.
   * Or:

      * The external type :math:`{\mathit{externtype}}_1` is of the form :math:`(\mathsf{table}~{\mathit{tt}}_1)`.

      * The external type :math:`{\mathit{externtype}}_2` is of the form :math:`(\mathsf{table}~{\mathit{tt}}_2)`.

      * The table type :math:`{\mathit{tt}}_1` :ref:`matches <match>` the table type :math:`{\mathit{tt}}_2`.
   * Or:

      * The external type :math:`{\mathit{externtype}}_1` is of the form :math:`(\mathsf{mem}~{\mathit{mt}}_1)`.

      * The external type :math:`{\mathit{externtype}}_2` is of the form :math:`(\mathsf{mem}~{\mathit{mt}}_2)`.

      * The memory type :math:`{\mathit{mt}}_1` :ref:`matches <match>` the memory type :math:`{\mathit{mt}}_2`.




The external type :math:`(\mathsf{func}~{\mathit{ft}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{func}~{\mathit{ft}}_2)` if:


   * The function type :math:`{\mathit{ft}}_1` :ref:`matches <match>` the function type :math:`{\mathit{ft}}_2`.




The external type :math:`(\mathsf{global}~{\mathit{gt}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{global}~{\mathit{gt}}_2)` if:


   * The global type :math:`{\mathit{gt}}_1` :ref:`matches <match>` the global type :math:`{\mathit{gt}}_2`.




The external type :math:`(\mathsf{table}~{\mathit{tt}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{table}~{\mathit{tt}}_2)` if:


   * The table type :math:`{\mathit{tt}}_1` :ref:`matches <match>` the table type :math:`{\mathit{tt}}_2`.




The external type :math:`(\mathsf{mem}~{\mathit{mt}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{mem}~{\mathit{mt}}_2)` if:


   * The memory type :math:`{\mathit{mt}}_1` :ref:`matches <match>` the memory type :math:`{\mathit{mt}}_2`.




The instruction :math:`\mathsf{nop}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction :math:`\mathsf{unreachable}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`\mathsf{drop}` is :ref:`valid <valid-val>` with the function type :math:`t~\rightarrow~\epsilon`.




The instruction :math:`\mathsf{select}` is :ref:`valid <valid-val>` with the function type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t`.




The instruction :math:`(\mathsf{block}~{t^?}~{{\mathit{instr}}^\ast})` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~{t^?}` if:


   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t^?}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~{t^?}`.




The instruction :math:`(\mathsf{loop}~{t^?}~{{\mathit{instr}}^\ast})` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~{t^?}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction :math:`(\mathsf{if}~{t^?}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{t^?}` if:


   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t^?}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_1^\ast}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~{t^?}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~{t^?}`.




The instruction :math:`(\mathsf{br}~l)` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~{t^?}~\rightarrow~{t_2^\ast}` if:


   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The number type :math:`C{.}\mathsf{labels}{}[l]` is of the form :math:`{t^?}`.




The instruction :math:`(\mathsf{br\_if}~l)` is :ref:`valid <valid-val>` with the function type :math:`{t^?}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t^?}` if:


   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The number type :math:`C{.}\mathsf{labels}{}[l]` is of the form :math:`{t^?}`.




The instruction :math:`(\mathsf{br\_table}~{l^\ast}~{l'})` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~{t^?}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


   * The result type :math:`C{.}\mathsf{labels}{}[{l'}]` exists.

   * The result type :math:`{t^?}` is of the form :math:`C{.}\mathsf{labels}{}[{l'}]`.

   * For all :math:`l` in :math:`{l^\ast}`:

      * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

      * The result type :math:`{t^?}` is of the form :math:`C{.}\mathsf{labels}{}[l]`.




The instruction :math:`(\mathsf{call}~x)` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^?}` if:


   * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`{t_1^\ast}~\rightarrow~{t_2^?}`.




The instruction :math:`(\mathsf{call\_indirect}~x)` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^?}` if:


   * The function type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{types}{}[x]` is of the form :math:`{t_1^\ast}~\rightarrow~{t_2^?}`.




The instruction :math:`\mathsf{return}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~{t^?}~\rightarrow~{t_2^\ast}` if:


   * The result type :math:`C{.}\mathsf{return}` is of the form :math:`{t^?}`.




The instruction :math:`(t{.}\mathsf{const}~c_t)` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~t`.




The instruction :math:`(t~{.}~{\mathit{unop}}_t)` is :ref:`valid <valid-val>` with the function type :math:`t~\rightarrow~t`.




The instruction :math:`(t~{.}~{\mathit{binop}}_t)` is :ref:`valid <valid-val>` with the function type :math:`t~t~\rightarrow~t`.




The instruction :math:`(t~{.}~{\mathit{testop}}_t)` is :ref:`valid <valid-val>` with the function type :math:`t~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`(t~{.}~{\mathit{relop}}_t)` is :ref:`valid <valid-val>` with the function type :math:`t~t~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({{\mathit{nt}}_1~{.}~{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_2})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1` if:


   * Either:

      * :math:`{\mathit{cvtop}}` is of the form :math:`\mathsf{reinterpret}`.

      * :math:`{|{\mathit{nt}}_1|}` is of the form :math:`{|{\mathit{nt}}_2|}`.

   * Or:




The instruction :math:`(\mathsf{local{.}get}~x)` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~t` if:


   * The number type :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The number type :math:`C{.}\mathsf{locals}{}[x]` is of the form :math:`t`.




The instruction :math:`(\mathsf{local{.}set}~x)` is :ref:`valid <valid-val>` with the function type :math:`t~\rightarrow~\epsilon` if:


   * The number type :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The number type :math:`C{.}\mathsf{locals}{}[x]` is of the form :math:`t`.




The instruction :math:`(\mathsf{local{.}tee}~x)` is :ref:`valid <valid-val>` with the function type :math:`t~\rightarrow~t` if:


   * The number type :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The number type :math:`C{.}\mathsf{locals}{}[x]` is of the form :math:`t`.




The instruction :math:`(\mathsf{global{.}get}~x)` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~t` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`({\mathit{mut}}~t)`.




The instruction :math:`(\mathsf{global{.}set}~x)` is :ref:`valid <valid-val>` with the function type :math:`t~\rightarrow~\epsilon` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`(\mathsf{mut}~t)`.




The instruction :math:`\mathsf{memory{.}size}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`\mathsf{memory{.}grow}` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({t{.}\mathsf{load}}{{{\mathit{loadop}}^?}}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{t'}` if:


   * Either:

      * :math:`{{\mathit{loadop}}^?}` is absent.

      * The number type :math:`{t'}` is of the form :math:`t`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|t|} / 8`.

   * Or:

      * The number type :math:`t` is of the form :math:`{\mathsf{i}}{n}`.

      * :math:`{{\mathit{loadop}}^?}` is of the form :math:`{M}{\mathsf{\_}}{{\mathit{sx}}}`.

      * The number type :math:`{t'}` is of the form :math:`{\mathsf{i}}{n}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({t{.}\mathsf{store}}{{{\mathit{sz}}^?}}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~{t'}~\rightarrow~\epsilon` if:


   * Either:

      * The pack size :math:`{{\mathit{sz}}^?}` is absent.

      * The number type :math:`{t'}` is of the form :math:`t`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|t|} / 8`.

   * Or:

      * The number type :math:`t` is of the form :math:`{\mathsf{i}}{n}`.

      * The pack size :math:`{{\mathit{sz}}^?}` is of the form :math:`M`.

      * The number type :math:`{t'}` is of the form :math:`{\mathsf{i}}{n}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({{\mathit{nt}}_1~{.}~\mathsf{reinterpret}}{\mathsf{\_}}{{\mathit{nt}}_2})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1` if:


   * :math:`{|{\mathit{nt}}_1|}` is of the form :math:`{|{\mathit{nt}}_2|}`.




The instruction :math:`({{\mathit{nt}}_1~{.}~{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_2})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1`.




The instruction :math:`(\mathsf{load}~t~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|t|} / 8`.




The instruction :math:`({{\mathsf{i}}{n}{.}\mathsf{load}}{{M}{\mathsf{\_}}{{\mathit{sx}}}}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathsf{i}}{n}` if:


   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`(\mathsf{store}~t~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~t~\rightarrow~\epsilon` if:


   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|t|} / 8`.




The instruction :math:`({{\mathsf{i}}{n}{.}\mathsf{store}}{M}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathsf{i}}{n}~\rightarrow~\epsilon` if:


   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{{\mathit{valtype}}^\ast}~\rightarrow~{{\mathit{valtype}'}^\ast}` if:


   * Either:

      * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is empty.

      * The number type sequence :math:`{{\mathit{valtype}}^\ast}` is empty.

      * The number type sequence :math:`{{\mathit{valtype}'}^\ast}` is empty.

   * Or:

      * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is of the form :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}`.

      * The instruction :math:`{\mathit{instr}}_1` is :ref:`valid <valid-val>` with the function type :math:`{{\mathit{valtype}}^\ast}~\rightarrow~{t_2^\ast}`.

      * The instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_2^\ast}~\rightarrow~{{\mathit{valtype}'}^\ast}`.
   * Or:

      * The number type sequence :math:`{{\mathit{valtype}}^\ast}` is of the form :math:`{t^\ast}~{t_1^\ast}`.

      * The number type sequence :math:`{{\mathit{valtype}'}^\ast}` is of the form :math:`{t^\ast}~{t_2^\ast}`.

      * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction sequence :math:`\epsilon` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction sequence :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_3^\ast}` if:


   * The instruction :math:`{\mathit{instr}}_1` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * The instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_2^\ast}~\rightarrow~{t_3^\ast}`.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t^\ast}~{t_1^\ast}~\rightarrow~{t^\ast}~{t_2^\ast}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The expression :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the result type :math:`{t^?}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~{t^?}`.




:math:`{\mathit{instr}}` is constant if:


   * Either:

      * The instruction :math:`{\mathit{instr}}` is of the form :math:`(t{.}\mathsf{const}~c)`.

   * Or:

      * The instruction :math:`{\mathit{instr}}` is of the form :math:`(\mathsf{global{.}get}~x)`.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`(\epsilon~t)`.




:math:`(t{.}\mathsf{const}~c)` is constant.




:math:`(\mathsf{global{.}get}~x)` is constant if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`(\epsilon~t)`.




:math:`{{\mathit{instr}}^\ast}` is constant if:


   * For all :math:`{\mathit{instr}}` in :math:`{{\mathit{instr}}^\ast}`:

      * :math:`{\mathit{instr}}` is constant.




The type :math:`(\mathsf{type}~{\mathit{ft}})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{ft}}` if:


   * The function type :math:`{\mathit{ft}}` is :ref:`valid <valid-val>`.




The function :math:`(\mathsf{func}~x~{(\mathsf{local}~t)^\ast}~{\mathit{expr}})` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^?}` if:


   * The function type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{types}{}[x]` is of the form :math:`{t_1^\ast}~\rightarrow~{t_2^?}`.

   * Under the context :math:`C` with the field :math:`\mathsf{locals}` appended by :math:`{t_1^\ast}~{t^\ast}` and the field :math:`\mathsf{labels}` appended by :math:`{t_2^?}` and the field :math:`\mathsf{return}` appended by :math:`{t_2^?}`, the expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the result type :math:`{t_2^?}`.




The global :math:`(\mathsf{global}~{\mathit{gt}}~{\mathit{expr}})` is :ref:`valid <valid-val>` with the global type :math:`{\mathit{gt}}` if:


   * The global type :math:`{\mathit{gt}}` is :ref:`valid <valid-val>`.

   * The global type :math:`{\mathit{gt}}` is of the form :math:`({\mathit{mut}}~t)`.

   * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the number type :math:`t`.

   * :math:`{\mathit{expr}}` is constant.




The table :math:`(\mathsf{table}~{\mathit{tt}})` is :ref:`valid <valid-val>` with the table type :math:`{\mathit{tt}}` if:


   * The table type :math:`{\mathit{tt}}` is :ref:`valid <valid-val>`.




The memory :math:`(\mathsf{memory}~{\mathit{mt}})` is :ref:`valid <valid-val>` with the memory type :math:`{\mathit{mt}}` if:


   * The memory type :math:`{\mathit{mt}}` is :ref:`valid <valid-val>`.




The table segment :math:`(\mathsf{elem}~{\mathit{expr}}~{x^\ast})` is :ref:`valid <valid-val>` if:


   * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the number type :math:`\mathsf{i{\scriptstyle 32}}`.

   * :math:`{\mathit{expr}}` is constant.

   * For all :math:`x` in :math:`{x^\ast}`:

      * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.




The memory segment :math:`(\mathsf{data}~{\mathit{expr}}~{b^\ast})` is :ref:`valid <valid-val>` if:


   * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the number type :math:`\mathsf{i{\scriptstyle 32}}`.

   * :math:`{\mathit{expr}}` is constant.




The start function :math:`(\mathsf{start}~x)` is :ref:`valid <valid-val>` if:


   * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`\epsilon~\rightarrow~\epsilon`.




The import :math:`(\mathsf{import}~{\mathit{name}}_1~{\mathit{name}}_2~{\mathit{xt}})` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}` if:


   * The external type :math:`{\mathit{xt}}` is :ref:`valid <valid-val>`.




The external index :math:`{\mathit{externidx}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{externtype}}` if:


   * Either:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{func}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{func}~{\mathit{ft}})`.

      * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

      * The function type :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`{\mathit{ft}}`.

   * Or:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{global}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{global}~{\mathit{gt}})`.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`{\mathit{gt}}`.
   * Or:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{table}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{table}~{\mathit{tt}})`.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`{\mathit{tt}}`.
   * Or:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{mem}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{mem}~{\mathit{mt}})`.

      * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

      * The memory type :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`{\mathit{mt}}`.




The external index :math:`(\mathsf{func}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{func}~{\mathit{ft}})` if:


   * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`{\mathit{ft}}`.




The external index :math:`(\mathsf{global}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{global}~{\mathit{gt}})` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`{\mathit{gt}}`.




The external index :math:`(\mathsf{table}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{table}~{\mathit{tt}})` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`{\mathit{tt}}`.




The external index :math:`(\mathsf{mem}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{mem}~{\mathit{mt}})` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`{\mathit{mt}}`.




The export :math:`(\mathsf{export}~{\mathit{name}}~{\mathit{externidx}})` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}` if:


   * The external index :math:`{\mathit{externidx}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}`.




The module :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` is :ref:`valid <valid-val>` if:


   * For all :math:`{\mathit{type}}` in :math:`{{\mathit{type}}^\ast}`:

      * The type :math:`{\mathit{type}}` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{ft}'}`.

   * :math:`{{\mathit{ft}'}^\ast}` is the concatenation of all such :math:`{\mathit{ft}'}`.

   * For all :math:`{\mathit{import}}` in :math:`{{\mathit{import}}^\ast}`:

      * Under the context :math:`\{ \mathsf{types}~{{\mathit{ft}'}^\ast},\;\allowbreak \mathsf{return}~\epsilon \}`, the import :math:`{\mathit{import}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{ixt}}`.

   * :math:`{{\mathit{ixt}}^\ast}` is the concatenation of all such :math:`{\mathit{ixt}}`.

   * For all :math:`{\mathit{global}}` in :math:`{{\mathit{global}}^\ast}`:

      * Under the context :math:`{C'}`, the global :math:`{\mathit{global}}` is :ref:`valid <valid-val>` with the global type :math:`{\mathit{gt}}`.

   * :math:`{{\mathit{gt}}^\ast}` is the concatenation of all such :math:`{\mathit{gt}}`.

   * For all :math:`{\mathit{func}}` in :math:`{{\mathit{func}}^\ast}`:

      * The function :math:`{\mathit{func}}` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{ft}}`.

   * :math:`{{\mathit{ft}}^\ast}` is the concatenation of all such :math:`{\mathit{ft}}`.

   * For all :math:`{\mathit{table}}` in :math:`{{\mathit{table}}^\ast}`:

      * The table :math:`{\mathit{table}}` is :ref:`valid <valid-val>` with the table type :math:`{\mathit{tt}}`.

   * :math:`{{\mathit{tt}}^\ast}` is the concatenation of all such :math:`{\mathit{tt}}`.

   * For all :math:`{\mathit{mem}}` in :math:`{{\mathit{mem}}^\ast}`:

      * The memory :math:`{\mathit{mem}}` is :ref:`valid <valid-val>` with the memory type :math:`{\mathit{mt}}`.

   * :math:`{{\mathit{mt}}^\ast}` is the concatenation of all such :math:`{\mathit{mt}}`.

   * For all :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}`:

      * The table segment :math:`{\mathit{elem}}` is :ref:`valid <valid-val>`.

   * For all :math:`{\mathit{data}}` in :math:`{{\mathit{data}}^\ast}`:

      * The memory segment :math:`{\mathit{data}}` is :ref:`valid <valid-val>`.

   * If :math:`{\mathit{start}}` is defined, then:

      * The start function :math:`{\mathit{start}}` is :ref:`valid <valid-val>`.

   * For all :math:`{\mathit{export}}` in :math:`{{\mathit{export}}^\ast}`:

      * The export :math:`{\mathit{export}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}`.

   * The length of :math:`{{\mathit{tt}}^\ast}` is less than or equal to :math:`1`.

   * The length of :math:`{{\mathit{mt}}^\ast}` is less than or equal to :math:`1`.

   * The context :math:`{C'}` is of the form :math:`\{ \mathsf{types}~{{\mathit{ft}'}^\ast},\;\allowbreak \mathsf{funcs}~{{\mathit{ift}}^\ast}~{{\mathit{ft}}^\ast},\;\allowbreak \mathsf{globals}~{{\mathit{igt}}^\ast},\;\allowbreak \mathsf{return}~\epsilon \}`.

   * The function type sequence :math:`{{\mathit{ift}}^\ast}` is of the form :math:`{\mathrm{funcs}}({{\mathit{ixt}}^\ast})`.

   * The global type sequence :math:`{{\mathit{igt}}^\ast}` is of the form :math:`{\mathrm{globals}}({{\mathit{ixt}}^\ast})`.

   * The table type sequence :math:`{{\mathit{itt}}^\ast}` is of the form :math:`{\mathrm{tables}}({{\mathit{ixt}}^\ast})`.

   * The memory type sequence :math:`{{\mathit{imt}}^\ast}` is of the form :math:`{\mathrm{mems}}({{\mathit{ixt}}^\ast})`.


:math:`\mathsf{load}~t~{\mathit{ao}}`
.....................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|t|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{t}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|t|} / 8]`.

#. Push the value :math:`(t{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}{.}\mathsf{load}}{{n}{\mathsf{\_}}{{\mathit{sx}}}}~{\mathit{ao}}`
........................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8]`.

#. Push the value :math:`({\mathsf{i}}{n}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{n, {|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{(c)})` to the stack.


:math:`\mathsf{store}~t~{\mathit{ao}}`
......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`t` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|t|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{t}(c)`.

#. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|t|} / 8] = {b^\ast}]`.


:math:`{{\mathsf{i}}{n}{.}\mathsf{store}}{n}~{\mathit{ao}}`
...........................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`{\mathsf{i}}{n}` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}({{\mathrm{wrap}}}_{{|{\mathsf{i}}{n}|}, n}(c))`.

#. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8] = {b^\ast}]`.


:math:`\mathsf{unreachable}`
............................


1. Trap.


:math:`\mathsf{nop}`
....................


1. Do nothing.


:math:`\mathsf{drop}`
.....................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.


:math:`\mathsf{select}`
.......................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_2` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_1` from the stack.

#. If :math:`c \neq 0`, then:

   a. Push the value :math:`{\mathit{val}}_1` to the stack.

#. Else:

   a. Push the value :math:`{\mathit{val}}_2` to the stack.


:math:`\mathsf{if}~{t^?}~{{\mathit{instr}}_1^\ast}~{{\mathit{instr}}_2^\ast}`
.............................................................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

   a. Execute the instruction :math:`(\mathsf{block}~{t^?}~{{\mathit{instr}}_1^\ast})`.

#. Else:

   a. Execute the instruction :math:`(\mathsf{block}~{t^?}~{{\mathit{instr}}_2^\ast})`.


:math:`\mathsf{label}`
......................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

#. Pop the :math:`\mathsf{label}` from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.


:math:`\mathsf{br}~{n'}`
........................


1. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

#. Let :math:`L` be the topmost :math:`\mathsf{label}`.

#. Let :math:`n` be the arity of :math:`L`

#. If :math:`{n'} = 0`, then:

   a. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

   #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

   #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{label}` from the stack.

   #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

   #. Jump to the continuation of :math:`L`.

#. Else:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Let :math:`l` be the label index :math:`{n'} - 1`.

   #. Pop the :math:`\mathsf{label}` from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{br\_if}~l`
.........................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

   a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

   a. Do nothing.


:math:`\mathsf{br\_table}~{l^\ast}~{l'}`
........................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i < {|{l^\ast}|}`, then:

   a. Execute the instruction :math:`(\mathsf{br}~{l^\ast}{}[i])`.

#. Else:

   a. Execute the instruction :math:`(\mathsf{br}~{l'})`.


:math:`\mathsf{frame}`
......................


1. Let :math:`f` be the topmost :math:`\mathsf{frame}`.

#. Let :math:`n` be the arity of :math:`f`

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{frame}`.

#. Pop the :math:`\mathsf{frame}` from the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.


:math:`\mathsf{return}`
.......................


1. If the first non-value entry of the stack is a :math:`\mathsf{frame}`, then:

   a. Let :math:`f` be the topmost :math:`\mathsf{frame}`.

   #. Let :math:`n` be the arity of :math:`f`

   #. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

   #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

   #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{frame}` from the stack.

   #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Else:

   a. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

   #. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{label}` from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`\mathsf{return}`.


:math:`t~{.}~{\mathit{unop}}`
.............................


1. Assert: Due to validation, a value of number type :math:`t` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{unop}}}{{}_{t}}{(c_1)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{unop}}}{{}_{t}}{(c_1)}`.

#. Push the value :math:`(t{.}\mathsf{const}~c)` to the stack.


:math:`t~{.}~{\mathit{binop}}`
..............................


1. Assert: Due to validation, a value of number type :math:`t` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a num is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{binop}}}{{}_{t}}{(c_1, c_2)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{binop}}}{{}_{t}}{(c_1, c_2)}`.

#. Push the value :math:`(t{.}\mathsf{const}~c)` to the stack.


:math:`t~{.}~{\mathit{testop}}`
...............................


1. Assert: Due to validation, a value of number type :math:`t` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{testop}}}{{}_{t}}{(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`t~{.}~{\mathit{relop}}`
..............................


1. Assert: Due to validation, a value of number type :math:`t` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a num is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{relop}}}{{}_{t}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{t_2~{.}~{\mathit{cvtop}}}{\mathsf{\_}}{t_1}`
....................................................


1. Assert: Due to validation, a value of number type :math:`t_1` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{cvtop}}}{{}_{t_1, t_2}}{(c_1)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{cvtop}}}{{}_{t_1, t_2}}{(c_1)}`.

#. Push the value :math:`(t_2{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{local{.}tee}~x`
..............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Execute the instruction :math:`(\mathsf{local{.}set}~x)`.


:math:`\mathsf{block}~{t^?}~{{\mathit{instr}}^\ast}`
....................................................


1. Let :math:`n` be :math:`0`.

#. If :math:`{t^?}` is not defined, then:

   #. Let :math:`L` be the :math:`\mathsf{label}` whose arity is :math:`n` and whose continuation is the end of the block.

   a. Enter the block :math:`{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` :math:`L`.

#. Let :math:`n` be :math:`1`.

#. If :math:`{t^?} \neq \epsilon`, then:

   #. Let :math:`L` be the :math:`\mathsf{label}` whose arity is :math:`n` and whose continuation is the end of the block.

   a. Enter the block :math:`{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` :math:`L`.


:math:`\mathsf{loop}~{t^?}~{{\mathit{instr}}^\ast}`
...................................................


#. Let :math:`L` be the :math:`\mathsf{label}` whose continuation is the start of the block.

1. Enter the block :math:`{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` :math:`L`.


:math:`\mathsf{call}~x`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Execute the instruction :math:`(\mathsf{call}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x])`.


:math:`\mathsf{call\_indirect}~x`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[0]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`z{.}\mathsf{tables}{}[0]{.}\mathsf{refs}{}[i]` is not defined, then:

   a. Trap.

#. Let :math:`a` be :math:`z{.}\mathsf{tables}{}[0]{.}\mathsf{refs}{}[i]`.

#. If :math:`a \geq {|z{.}\mathsf{funcs}|}`, then:

   a. Trap.

#. If :math:`z{.}\mathsf{types}{}[x] \neq z{.}\mathsf{funcs}{}[a]{.}\mathsf{type}`, then:

   a. Trap.

#. Execute the instruction :math:`(\mathsf{call}~a)`.


:math:`\mathsf{call}~a`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`a < {|z{.}\mathsf{funcs}|}`.

#. Let :math:`\{ \mathsf{type}~{t_1^{k}}~\rightarrow~{t_2^{n}},\;\allowbreak \mathsf{module}~{\mathit{mm}},\;\allowbreak \mathsf{code}~{\mathit{func}} \}` be the destructuring of :math:`z{.}\mathsf{funcs}{}[a]`.

#. Let :math:`(\mathsf{func}~x~{{\mathit{local}}_0^\ast}~{{\mathit{instr}}^\ast})` be the destructuring of :math:`{\mathit{func}}`.

#. Let :math:`{t^\ast}` be the number type sequence :math:`\epsilon`.

#. For each :math:`{\mathit{local}}_0` in :math:`{{\mathit{local}}_0^\ast}`, do:

   a. Let :math:`(\mathsf{local}~t)` be the destructuring of :math:`{\mathit{local}}_0`.

   #. Append :math:`t` to :math:`{t^\ast}`.

#. Assert: Due to validation, there are at least :math:`k` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Let :math:`f` be the frame :math:`\{ \mathsf{locals}~{{\mathit{val}}^{k}}~{{{\mathrm{default}}}_{t}^\ast},\;\allowbreak \mathsf{module}~{\mathit{mm}} \}`.

#. Let :math:`{f'}` be the :math:`\mathsf{frame}` :math:`f` whose arity is :math:`n`.

#. Push the :math:`\mathsf{frame}` :math:`{f'}`.

#. Let :math:`L` be the :math:`\mathsf{label}` whose arity is :math:`n` and whose continuation is the end of the block.

#. Enter the block :math:`{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` :math:`L`.


:math:`\mathsf{local{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Push the value :math:`z{.}\mathsf{locals}{}[x]` to the stack.


:math:`\mathsf{global{.}get}~x`
...............................


1. Let :math:`z` be the current state.

#. Push the value :math:`z{.}\mathsf{globals}{}[x]{.}\mathsf{value}` to the stack.


:math:`{t{.}\mathsf{load}}{{{\mathit{loadop}}^?}}~{\mathit{ao}}`
................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`{{\mathit{loadop}}^?}` is not defined, then:

   a. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|t|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{t}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|t|} / 8]`.

   #. Push the value :math:`(t{.}\mathsf{const}~c)` to the stack.

#. Else:

   a. Assert: Due to validation, :math:`t` is :math:`{\mathsf{i}}{n}`.

   #. Let :math:`{\mathit{loadop}}_0` be :math:`{{\mathit{loadop}}^?}`.

   #. Let :math:`{n}{\mathsf{\_}}{{\mathit{sx}}}` be the destructuring of :math:`{\mathit{loadop}}_0`.

   #. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8]`.

   #. Push the value :math:`(t{.}\mathsf{const}~{{{{\mathrm{extend}}}_{n, {|t|}}^{{\mathit{sx}}}}}{(c)})` to the stack.


:math:`\mathsf{memory{.}size}`
..............................


1. Let :math:`z` be the current state.

#. Let :math:`n \cdot 64 \cdot {\mathrm{Ki}}` be the length of :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{local{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{locals}{}[x] = {\mathit{val}}]`.


:math:`\mathsf{global{.}set}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = {\mathit{val}}]`.


:math:`{t{.}\mathsf{store}}{{{\mathit{sz}}^?}}~{\mathit{ao}}`
.............................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a num is on the top of the stack.

#. Pop the value :math:`({t'}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, :math:`t = {t'}`.

#. If :math:`{{\mathit{sz}}^?}` is not defined, then:

   a. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{t'}|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{t'}}(c)`.

   #. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{t'}|} / 8] = {b^\ast}]`.

#. Else:

   a. Assert: Due to validation, :math:`{t'}` is :math:`{\mathsf{i}}{n}`.

   #. Let :math:`n` be :math:`{{\mathit{sz}}^?}`.

   #. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}({{\mathrm{wrap}}}_{{|{t'}|}, n}(c))`.

   #. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8] = {b^\ast}]`.


:math:`\mathsf{memory{.}grow}`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Either:

   a. Let :math:`{\mathit{mi}}` be the memory instance :math:`{\mathrm{growmemory}}(z{.}\mathsf{mems}{}[0], n)`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|} / (64 \, {\mathrm{Ki}}))` to the stack.

   #. Perform :math:`z{}[{.}\mathsf{mems}{}[0] = {\mathit{mi}}]`.

#. Or:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{32}^{{-1}}}}{({-1})})` to the stack.


:math:`{\mathrm{Ki}}`
.....................


1. Return :math:`1024`.


:math:`{\mathrm{min}}(i, j)`
............................


1. If :math:`i \leq j`, then:

   a. Return :math:`i`.

#. Return :math:`j`.


:math:`{\mathrm{sum}}({{n''}^\ast})`
....................................


1. If :math:`{{n''}^\ast} = \epsilon`, then:

   a. Return :math:`0`.

#. Let :math:`n~{{n'}^\ast}` be :math:`{{n''}^\ast}`.

#. Return :math:`n + {\mathrm{sum}}({{n'}^\ast})`.


:math:`{X^\ast}`
................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{X^\ast}|} = 1`.

#. Let :math:`w` be :math:`{X^\ast}`.

#. Return :math:`w`.


:math:`{X^?}`
.............


1. If :math:`{X^?}` is not defined, then:

   a. Return :math:`\epsilon`.

#. Let :math:`w` be :math:`{X^?}`.

#. Return :math:`w`.


:math:`{\mathrm{concat}}({X^\ast})`
...................................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{w^\ast}~{{{w'}^\ast}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`{w^\ast}~{\mathrm{concat}}({{{w'}^\ast}^\ast})`.


:math:`{\mathrm{signif}}(N)`
............................


1. If :math:`N = 32`, then:

   a. Return :math:`23`.

#. Assert: Due to validation, :math:`N = 64`.

#. Return :math:`52`.


:math:`{\mathrm{expon}}(N)`
...........................


1. If :math:`N = 32`, then:

   a. Return :math:`8`.

#. Assert: Due to validation, :math:`N = 64`.

#. Return :math:`11`.


:math:`M`
.........


1. Return :math:`{\mathrm{signif}}(N)`.


:math:`E`
.........


1. Return :math:`{\mathrm{expon}}(N)`.


:math:`{+0}`
............


1. Return :math:`({+((0 + 0 \cdot {2^{{-M}}}) \cdot {2^{e}})})`.


:math:`{+1}`
............


1. Return :math:`({+((1 + 1 \cdot {2^{{-M}}}) \cdot {2^{0}})})`.


:math:`{{\mathrm{canon}}}_{N}`
..............................


1. Return :math:`{2^{{\mathrm{signif}}(N) - 1}}`.


:math:`{|{\mathit{valtype}}|}`
..............................


1. If :math:`{\mathit{valtype}} = \mathsf{i{\scriptstyle 32}}`, then:

   a. Return :math:`32`.

#. If :math:`{\mathit{valtype}} = \mathsf{i{\scriptstyle 64}}`, then:

   a. Return :math:`64`.

#. If :math:`{\mathit{valtype}} = \mathsf{f{\scriptstyle 32}}`, then:

   a. Return :math:`32`.

#. Assert: Due to validation, :math:`{\mathit{valtype}} = \mathsf{f{\scriptstyle 64}}`.

#. Return :math:`64`.


:math:`{\mathrm{funcs}}({{\mathit{externtype}'}^\ast})`
.......................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{func}~{\mathit{functype}}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{ft}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{ft}}~{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externtype}'}^\ast})`
.........................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{global}~{\mathit{globaltype}}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{gt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{gt}}~{\mathrm{globals}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externtype}'}^\ast})`
........................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{table}~{\mathit{tabletype}}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{tt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{tt}}~{\mathrm{tables}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externtype}'}^\ast})`
......................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{mem}~{\mathit{memtype}}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{mt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{mt}}~{\mathrm{mems}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xt}}^\ast})`.






1. Return :math:`\{ \mathsf{align}~0,\;\allowbreak \mathsf{offset}~0 \}`.


:math:`\mathbb{B}(b)`
.....................


1. If :math:`b` is false, then:

   a. Return :math:`0`.

#. Assert: Due to validation, :math:`b` is true.

#. Return :math:`1`.


:math:`{{\mathrm{signed}}}_{N}(i)`
..................................


1. If :math:`i < {2^{N - 1}}`, then:

   a. Return :math:`i`.

#. Assert: Due to validation, :math:`{2^{N - 1}} \leq i`.

#. Assert: Due to validation, :math:`i < {2^{N}}`.

#. Return :math:`i - {2^{N}}`.


:math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{(i)}`
...............................................


1. If :math:`0 \leq i` and :math:`i < {2^{N - 1}}`, then:

   a. Return :math:`i`.

#. Assert: Due to validation, :math:`{-{2^{N - 1}}} \leq i`.

#. Assert: Due to validation, :math:`i < 0`.

#. Return :math:`i + {2^{N}}`.


:math:`{{\mathit{unop}}}{{}_{{\mathit{valtype}}}}{({\mathit{iN}})}`
...................................................................


1. If :math:`{\mathit{valtype}}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{unop}} = \mathsf{clz}`, then:

      1) Return :math:`{{\mathrm{iclz}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}})`.

   #. If :math:`{\mathit{unop}} = \mathsf{ctz}`, then:

      1) Return :math:`{{\mathrm{ictz}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}})`.

   #. If :math:`{\mathit{unop}} = \mathsf{popcnt}`, then:

      1) Return :math:`{{\mathrm{ipopcnt}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}})`.

#. Assert: Due to validation, :math:`{\mathit{valtype}}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{unop}} = \mathsf{abs}`, then:

   a. Return :math:`{{\mathrm{fabs}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}})`.

#. If :math:`{\mathit{unop}} = \mathsf{neg}`, then:

   a. Return :math:`{{\mathrm{fneg}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}})`.

#. If :math:`{\mathit{unop}} = \mathsf{sqrt}`, then:

   a. Return :math:`{{\mathrm{fsqrt}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}})`.

#. If :math:`{\mathit{unop}} = \mathsf{ceil}`, then:

   a. Return :math:`{{\mathrm{fceil}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}})`.

#. If :math:`{\mathit{unop}} = \mathsf{floor}`, then:

   a. Return :math:`{{\mathrm{ffloor}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}})`.

#. If :math:`{\mathit{unop}} = \mathsf{trunc}`, then:

   a. Return :math:`{{\mathrm{ftrunc}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}})`.

#. Assert: Due to validation, :math:`{\mathit{unop}} = \mathsf{nearest}`.

#. Return :math:`{{\mathrm{fnearest}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}})`.


:math:`{{\mathrm{iadd}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`(i_1 + i_2) \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{{{\mathrm{idiv}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
.............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. If :math:`i_2 = 0`, then:

      1) Return :math:`\epsilon`.

   #. Return :math:`{\mathrm{truncz}}(i_1 / i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. If :math:`i_2 = 0`, then:

   a. Return :math:`\epsilon`.

#. If :math:`{{\mathrm{signed}}}_{N}(i_1) / {{\mathrm{signed}}}_{N}(i_2) = {2^{N - 1}}`, then:

   a. Return :math:`\epsilon`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({\mathrm{truncz}}({{\mathrm{signed}}}_{N}(i_1) / {{\mathrm{signed}}}_{N}(i_2)))}`.


:math:`{{\mathrm{imul}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`i_1 \cdot i_2 \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{{{\mathrm{irem}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
.............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. If :math:`i_2 = 0`, then:

      1) Return :math:`\epsilon`.

   #. Return :math:`i_1 - i_2 \cdot {\mathrm{truncz}}(i_1 / i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. If :math:`i_2 = 0`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`j_1` be :math:`{{\mathrm{signed}}}_{N}(i_1)`.

#. Let :math:`j_2` be :math:`{{\mathrm{signed}}}_{N}(i_2)`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{(j_1 - j_2 \cdot {\mathrm{truncz}}(j_1 / j_2))}`.


:math:`{{\mathrm{isub}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`({2^{N}} + i_1 - i_2) \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{\mathit{binop}}}{{}_{{\mathit{valtype}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`
.......................................................................................


1. If :math:`{\mathit{valtype}}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{binop}} = \mathsf{add}`, then:

      1) Return :math:`{{\mathrm{iadd}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}} = \mathsf{sub}`, then:

      1) Return :math:`{{\mathrm{isub}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}} = \mathsf{mul}`, then:

      1) Return :math:`{{\mathrm{imul}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}}` is some :math:`{\mathsf{div}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{div}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{binop}}`.

      #) Return :math:`{{{{\mathrm{idiv}}}_{{|{\mathit{valtype}}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{binop}}` is some :math:`{\mathsf{rem}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{rem}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{binop}}`.

      #) Return :math:`{{{{\mathrm{irem}}}_{{|{\mathit{valtype}}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{binop}} = \mathsf{and}`, then:

      1) Return :math:`{{\mathrm{iand}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}} = \mathsf{or}`, then:

      1) Return :math:`{{\mathrm{ior}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}} = \mathsf{xor}`, then:

      1) Return :math:`{{\mathrm{ixor}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}} = \mathsf{shl}`, then:

      1) Return :math:`{{\mathrm{ishl}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}}` is some :math:`{\mathsf{shr}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{shr}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{binop}}`.

      #) Return :math:`{{{{\mathrm{ishr}}}_{{|{\mathit{valtype}}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{binop}} = \mathsf{rotl}`, then:

      1) Return :math:`{{\mathrm{irotl}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}} = \mathsf{rotr}`, then:

      1) Return :math:`{{\mathrm{irotr}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{valtype}}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{binop}} = \mathsf{add}`, then:

   a. Return :math:`{{\mathrm{fadd}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop}} = \mathsf{sub}`, then:

   a. Return :math:`{{\mathrm{fsub}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop}} = \mathsf{mul}`, then:

   a. Return :math:`{{\mathrm{fmul}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop}} = \mathsf{div}`, then:

   a. Return :math:`{{\mathrm{fdiv}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop}} = \mathsf{min}`, then:

   a. Return :math:`{{\mathrm{fmin}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop}} = \mathsf{max}`, then:

   a. Return :math:`{{\mathrm{fmax}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{binop}} = \mathsf{copysign}`.

#. Return :math:`{{\mathrm{fcopysign}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.


:math:`{{\mathrm{ieqz}}}_{N}(i_1)`
..................................


1. Return :math:`\mathbb{B}(i_1 = 0)`.


:math:`{\mathsf{eqz}}{{}_{{\mathsf{i}}{n}}}{({\mathit{iN}})}`
.............................................................


1. Return :math:`{{\mathrm{ieqz}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}})`.


:math:`{{\mathrm{ieq}}}_{N}(i_1, i_2)`
......................................


1. Return :math:`\mathbb{B}(i_1 = i_2)`.


:math:`{{{{\mathrm{ige}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 \geq i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) \geq {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{{{\mathrm{igt}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 > i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) > {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{{{\mathrm{ile}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 \leq i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) \leq {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{{{\mathrm{ilt}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 < i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) < {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{\mathrm{ine}}}_{N}(i_1, i_2)`
......................................


1. Return :math:`\mathbb{B}(i_1 \neq i_2)`.


:math:`{{\mathit{relop}}}{{}_{{\mathit{valtype}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`
.......................................................................................


1. If :math:`{\mathit{valtype}}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{relop}} = \mathsf{eq}`, then:

      1) Return :math:`{{\mathrm{ieq}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{relop}} = \mathsf{ne}`, then:

      1) Return :math:`{{\mathrm{ine}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{relop}}` is some :math:`{\mathsf{lt}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{lt}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{{{\mathrm{ilt}}}_{{|{\mathit{valtype}}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{relop}}` is some :math:`{\mathsf{gt}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{gt}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{{{\mathrm{igt}}}_{{|{\mathit{valtype}}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{relop}}` is some :math:`{\mathsf{le}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{le}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{{{\mathrm{ile}}}_{{|{\mathit{valtype}}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{relop}}` is some :math:`{\mathsf{ge}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{ge}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{{{\mathrm{ige}}}_{{|{\mathit{valtype}}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

#. Assert: Due to validation, :math:`{\mathit{valtype}}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{relop}} = \mathsf{eq}`, then:

   a. Return :math:`{{\mathrm{feq}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{relop}} = \mathsf{ne}`, then:

   a. Return :math:`{{\mathrm{fne}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{relop}} = \mathsf{lt}`, then:

   a. Return :math:`{{\mathrm{flt}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{relop}} = \mathsf{gt}`, then:

   a. Return :math:`{{\mathrm{fgt}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{relop}} = \mathsf{le}`, then:

   a. Return :math:`{{\mathrm{fle}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{relop}} = \mathsf{ge}`.

#. Return :math:`{{\mathrm{fge}}}_{{|{\mathit{valtype}}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.


:math:`{{\mathit{cvtop}}}{{}_{{\mathit{valtype}}, {\mathit{valtype}'}}}{({\mathit{iN}})}`
.........................................................................................


1. If :math:`{\mathit{cvtop}}` is some :math:`\mathsf{extend}~{\mathit{sx}}`, then:

   a. Let :math:`(\mathsf{extend}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{cvtop}}`.

   #. If :math:`{\mathit{valtype}} = \mathsf{i{\scriptstyle 32}}` and :math:`{\mathit{valtype}'} = \mathsf{i{\scriptstyle 64}}`, then:

      1) Return :math:`{{{{\mathrm{extend}}}_{32, 64}^{{\mathit{sx}}}}}{({\mathit{iN}})}`.

#. If :math:`{\mathit{valtype}} = \mathsf{i{\scriptstyle 64}}` and :math:`{\mathit{valtype}'} = \mathsf{i{\scriptstyle 32}}` and :math:`{\mathit{cvtop}} = \mathsf{wrap}`, then:

   a. Return :math:`{{\mathrm{wrap}}}_{64, 32}({\mathit{iN}})`.

#. If :math:`{\mathit{valtype}}` is :math:`{\mathsf{f}}{n}` and :math:`{\mathit{valtype}'}` is :math:`{\mathsf{i}}{n}` and :math:`{\mathit{cvtop}}` is some :math:`\mathsf{trunc}~{\mathit{sx}}`, then:

   a. Let :math:`(\mathsf{trunc}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{cvtop}}`.

   #. Return :math:`{{{{\mathrm{trunc}}}_{{|{\mathit{valtype}}|}, {|{\mathit{valtype}'}|}}^{{\mathit{sx}}}}}{({\mathit{iN}})}`.

#. If :math:`{\mathit{valtype}} = \mathsf{f{\scriptstyle 32}}` and :math:`{\mathit{valtype}'} = \mathsf{f{\scriptstyle 64}}` and :math:`{\mathit{cvtop}} = \mathsf{promote}`, then:

   a. Return :math:`{{\mathrm{promote}}}_{32, 64}({\mathit{iN}})`.

#. If :math:`{\mathit{valtype}} = \mathsf{f{\scriptstyle 64}}` and :math:`{\mathit{valtype}'} = \mathsf{f{\scriptstyle 32}}` and :math:`{\mathit{cvtop}} = \mathsf{demote}`, then:

   a. Return :math:`{{\mathrm{demote}}}_{64, 32}({\mathit{iN}})`.

#. If :math:`{\mathit{valtype}}` is :math:`{\mathsf{i}}{n}` and :math:`{\mathit{valtype}'}` is :math:`{\mathsf{f}}{n}`, then:

   a. If :math:`{\mathit{cvtop}}` is some :math:`\mathsf{convert}~{\mathit{sx}}`, then:

      1) Let :math:`(\mathsf{convert}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{cvtop}}`.

      #) Return :math:`{{{{\mathrm{convert}}}_{{|{\mathit{valtype}}|}, {|{\mathit{valtype}'}|}}^{{\mathit{sx}}}}}{({\mathit{iN}})}`.

   #. If :math:`{\mathit{cvtop}} = \mathsf{reinterpret}` and :math:`{|{\mathit{valtype}}|} = {|{\mathit{valtype}'}|}`, then:

      1) Return :math:`{{\mathrm{reinterpret}}}_{{\mathit{valtype}}, {\mathit{valtype}'}}({\mathit{iN}})`.

#. Assert: Due to validation, :math:`{\mathit{valtype}}` is :math:`{\mathsf{f}}{n}`.

#. Assert: Due to validation, :math:`{\mathit{valtype}'}` is :math:`{\mathsf{i}}{n}`.

#. Assert: Due to validation, :math:`{\mathit{cvtop}} = \mathsf{reinterpret}`.

#. Assert: Due to validation, :math:`{|{\mathit{valtype}'}|} = {|{\mathit{valtype}}|}`.

#. Return :math:`{{\mathrm{reinterpret}}}_{{\mathit{valtype}}, {\mathit{valtype}'}}({\mathit{iN}})`.


:math:`{{\mathrm{inez}}}_{N}(i_1)`
..................................


1. Return :math:`\mathbb{B}(i_1 \neq 0)`.


:math:`{{\mathrm{default}}}_{{\mathit{valtype}}}`
.................................................


1. If :math:`{\mathit{valtype}} = \mathsf{i{\scriptstyle 32}}`, then:

   a. Return :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)`.

#. If :math:`{\mathit{valtype}} = \mathsf{i{\scriptstyle 64}}`, then:

   a. Return :math:`(\mathsf{i{\scriptstyle 64}}{.}\mathsf{const}~0)`.

#. If :math:`{\mathit{valtype}} = \mathsf{f{\scriptstyle 32}}`, then:

   a. Return :math:`(\mathsf{f{\scriptstyle 32}}{.}\mathsf{const}~{+0})`.

#. Assert: Due to validation, :math:`{\mathit{valtype}} = \mathsf{f{\scriptstyle 64}}`.

#. Return :math:`(\mathsf{f{\scriptstyle 64}}{.}\mathsf{const}~{+0})`.


:math:`{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`
.......................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{func}~{\mathit{funcaddr}}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{fa}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{fa}}~{\mathrm{funcs}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`
.........................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{global}~{\mathit{globaladdr}}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{ga}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ga}}~{\mathrm{globals}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`
........................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{table}~{\mathit{tableaddr}}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{ta}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ta}}~{\mathrm{tables}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`
......................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{mem}~{\mathit{memaddr}}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{ma}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ma}}~{\mathrm{mems}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xv}}^\ast})`.


:math:`(s, f){.}\mathsf{store}`
...............................


1. Return.


:math:`(s, f){.}\mathsf{frame}`
...............................


1. Return :math:`f`.


:math:`(s, f){.}\mathsf{module}{.}\mathsf{funcs}`
.................................................


1. Return :math:`f{.}\mathsf{module}{.}\mathsf{funcs}`.


:math:`(s, f){.}\mathsf{funcs}`
...............................


1. Return :math:`s{.}\mathsf{funcs}`.


:math:`(s, f){.}\mathsf{globals}`
.................................


1. Return :math:`s{.}\mathsf{globals}`.


:math:`(s, f){.}\mathsf{tables}`
................................


1. Return :math:`s{.}\mathsf{tables}`.


:math:`(s, f){.}\mathsf{mems}`
..............................


1. Return :math:`s{.}\mathsf{mems}`.


:math:`(s, f){.}\mathsf{module}`
................................


1. Return :math:`f{.}\mathsf{module}`.


:math:`(s, f){.}\mathsf{types}{}[x]`
....................................


1. Return :math:`f{.}\mathsf{module}{.}\mathsf{types}{}[x]`.


:math:`(s, f){.}\mathsf{funcs}{}[x]`
....................................


1. Return :math:`s{.}\mathsf{funcs}{}[f{.}\mathsf{module}{.}\mathsf{funcs}{}[x]]`.


:math:`(s, f){.}\mathsf{globals}{}[x]`
......................................


1. Return :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]`.


:math:`(s, f){.}\mathsf{tables}{}[x]`
.....................................


1. Return :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]`.


:math:`(s, f){.}\mathsf{mems}{}[x]`
...................................


1. Return :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]`.


:math:`(s, f){.}\mathsf{locals}{}[x]`
.....................................


1. Return :math:`f{.}\mathsf{locals}{}[x]`.


:math:`(s, f){}[{.}\mathsf{locals}{}[x] = v]`
.............................................


1. Replace :math:`f{.}\mathsf{locals}{}[x]` with :math:`v`.


:math:`(s, f){}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = v]`
...............................................................


1. Replace :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]{.}\mathsf{value}` with :math:`v`.


:math:`(s, f){}[{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i] = a]`
..................................................................


1. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]{.}\mathsf{refs}{}[i]` with :math:`a`.


:math:`(s, f){}[{.}\mathsf{tables}{}[x] = {\mathit{ti}}]`
.........................................................


1. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]` with :math:`{\mathit{ti}}`.


:math:`(s, f){}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i : j] = {b^\ast}]`
............................................................................


1. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]{.}\mathsf{bytes}{}[i : j]` with :math:`{b^\ast}`.


:math:`(s, f){}[{.}\mathsf{mems}{}[x] = {\mathit{mi}}]`
.......................................................


1. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]` with :math:`{\mathit{mi}}`.


:math:`{\mathrm{growtable}}({\mathit{ti}}, n)`
..............................................


1. Let :math:`\{ \mathsf{type}~{}[ i .. {j^?} ],\;\allowbreak \mathsf{refs}~{a^\ast} \}` be the destructuring of :math:`{\mathit{ti}}`.

#. Let :math:`{i'}` be :math:`{|{a^\ast}|} + n`.

#. If :math:`{({i'} \leq j)^?}`, then:

   a. Let :math:`{\mathit{ti}'}` be the table instance :math:`\{ \mathsf{type}~{}[ {i'} .. {j^?} ],\;\allowbreak \mathsf{refs}~{a^\ast}~{\epsilon^{n}} \}`.

   #. Return :math:`{\mathit{ti}'}`.

#. Fail.


:math:`{\mathrm{growmemory}}({\mathit{mi}}, n)`
...............................................


1. Let :math:`\{ \mathsf{type}~{}[ i .. {j^?} ],\;\allowbreak \mathsf{bytes}~{b^\ast} \}` be the destructuring of :math:`{\mathit{mi}}`.

#. Let :math:`{i'}` be :math:`{|{b^\ast}|} / (64 \, {\mathrm{Ki}}) + n`.

#. If :math:`{({i'} \leq j)^?}`, then:

   a. Let :math:`{\mathit{mi}'}` be the memory instance :math:`\{ \mathsf{type}~{}[ {i'} .. {j^?} ],\;\allowbreak \mathsf{bytes}~{b^\ast}~{\mathtt{0x00}^{n \cdot 64 \, {\mathrm{Ki}}}} \}`.

   #. Return :math:`{\mathit{mi}'}`.

#. Fail.


:math:`{\mathrm{funcs}}({{\mathit{externaddr}''}^\ast})`
........................................................


1. If :math:`{{\mathit{externaddr}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{func}~{\mathit{funcaddr}}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{fa}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{fa}}~{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externaddr}''}^\ast})`
..........................................................


1. If :math:`{{\mathit{externaddr}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{global}~{\mathit{globaladdr}}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{ga}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ga}}~{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externaddr}''}^\ast})`
.........................................................


1. If :math:`{{\mathit{externaddr}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{table}~{\mathit{tableaddr}}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{ta}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ta}}~{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externaddr}''}^\ast})`
.......................................................


1. If :math:`{{\mathit{externaddr}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{mem}~{\mathit{memaddr}}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{ma}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ma}}~{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{allocfunc}}(s, {\mathit{moduleinst}}, {\mathit{func}})`
.......................................................................


1. Let :math:`(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}})` be the destructuring of :math:`{\mathit{func}}`.

#. Let :math:`{\mathit{fi}}` be the function instance :math:`\{ \mathsf{type}~{\mathit{moduleinst}}{.}\mathsf{types}{}[x],\;\allowbreak \mathsf{module}~{\mathit{moduleinst}},\;\allowbreak \mathsf{code}~{\mathit{func}} \}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{funcs}`.

#. Append :math:`{\mathit{fi}}` to :math:`s{.}\mathsf{funcs}`.

#. Return :math:`a`.


:math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}''}^\ast})`
.................................................................................


1. If :math:`{{\mathit{func}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{func}}~{{\mathit{func}'}^\ast}` be :math:`{{\mathit{func}''}^\ast}`.

#. Let :math:`{\mathit{fa}}` be :math:`{\mathrm{allocfunc}}(s, {\mathit{moduleinst}}, {\mathit{func}})`.

#. Let :math:`{{\mathit{fa}'}^\ast}` be :math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}'}^\ast})`.

#. Return :math:`{\mathit{fa}}~{{\mathit{fa}'}^\ast}`.


:math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`
........................................................................


1. Let :math:`{\mathit{gi}}` be the global instance :math:`\{ \mathsf{type}~{\mathit{globaltype}},\;\allowbreak \mathsf{value}~{\mathit{val}} \}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{globals}`.

#. Append :math:`{\mathit{gi}}` to :math:`s{.}\mathsf{globals}`.

#. Return :math:`a`.


:math:`{\mathrm{allocglobals}}(s, {{\mathit{globaltype}''}^\ast}, {{\mathit{val}''}^\ast})`
...........................................................................................


1. If :math:`{{\mathit{globaltype}''}^\ast} = \epsilon`, then:

   a. Assert: :math:`{{\mathit{val}''}^\ast} = \epsilon`.

   #. Return :math:`\epsilon`.

#. Else:

   a. Let :math:`{\mathit{globaltype}}~{{\mathit{globaltype}'}^\ast}` be :math:`{{\mathit{globaltype}''}^\ast}`.

   #. Assert: :math:`{|{{\mathit{val}''}^\ast}|} \geq 1`.

   #. Let :math:`{\mathit{val}}~{{\mathit{val}'}^\ast}` be :math:`{{\mathit{val}''}^\ast}`.

   #. Let :math:`{\mathit{ga}}` be :math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`.

   #. Let :math:`{{\mathit{ga}'}^\ast}` be :math:`{\mathrm{allocglobals}}(s, {{\mathit{globaltype}'}^\ast}, {{\mathit{val}'}^\ast})`.

   #. Return :math:`{\mathit{ga}}~{{\mathit{ga}'}^\ast}`.


:math:`{\mathrm{alloctable}}(s, {}[ i .. {j^?} ])`
..................................................


1. Let :math:`{\mathit{ti}}` be the table instance :math:`\{ \mathsf{type}~{}[ i .. {j^?} ],\;\allowbreak \mathsf{refs}~{\epsilon^{i}} \}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{tables}`.

#. Append :math:`{\mathit{ti}}` to :math:`s{.}\mathsf{tables}`.

#. Return :math:`a`.


:math:`{\mathrm{alloctables}}(s, {{\mathit{tabletype}''}^\ast})`
................................................................


1. If :math:`{{\mathit{tabletype}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{tabletype}}~{{\mathit{tabletype}'}^\ast}` be :math:`{{\mathit{tabletype}''}^\ast}`.

#. Let :math:`{\mathit{ta}}` be :math:`{\mathrm{alloctable}}(s, {\mathit{tabletype}})`.

#. Let :math:`{{\mathit{ta}'}^\ast}` be :math:`{\mathrm{alloctables}}(s, {{\mathit{tabletype}'}^\ast})`.

#. Return :math:`{\mathit{ta}}~{{\mathit{ta}'}^\ast}`.


:math:`{\mathrm{allocmem}}(s, {}[ i .. {j^?} ])`
................................................


1. Let :math:`{\mathit{mi}}` be the memory instance :math:`\{ \mathsf{type}~{}[ i .. {j^?} ],\;\allowbreak \mathsf{bytes}~{\mathtt{0x00}^{i \cdot 64 \, {\mathrm{Ki}}}} \}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{mems}`.

#. Append :math:`{\mathit{mi}}` to :math:`s{.}\mathsf{mems}`.

#. Return :math:`a`.


:math:`{\mathrm{allocmems}}(s, {{\mathit{memtype}''}^\ast})`
............................................................


1. If :math:`{{\mathit{memtype}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{memtype}}~{{\mathit{memtype}'}^\ast}` be :math:`{{\mathit{memtype}''}^\ast}`.

#. Let :math:`{\mathit{ma}}` be :math:`{\mathrm{allocmem}}(s, {\mathit{memtype}})`.

#. Let :math:`{{\mathit{ma}'}^\ast}` be :math:`{\mathrm{allocmems}}(s, {{\mathit{memtype}'}^\ast})`.

#. Return :math:`{\mathit{ma}}~{{\mathit{ma}'}^\ast}`.


:math:`{\mathrm{instexport}}({{\mathit{fa}}^\ast}, {{\mathit{ga}}^\ast}, {{\mathit{ta}}^\ast}, {{\mathit{ma}}^\ast}, \mathsf{export}~{\mathit{name}}~{\mathit{externidx}})`
...........................................................................................................................................................................


1. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{func}~{\mathit{funcidx}}`, then:

   a. Let :math:`(\mathsf{func}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`\{ \mathsf{name}~{\mathit{name}},\;\allowbreak \mathsf{addr}~(\mathsf{func}~{{\mathit{fa}}^\ast}{}[x]) \}`.

#. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{global}~{\mathit{globalidx}}`, then:

   a. Let :math:`(\mathsf{global}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`\{ \mathsf{name}~{\mathit{name}},\;\allowbreak \mathsf{addr}~(\mathsf{global}~{{\mathit{ga}}^\ast}{}[x]) \}`.

#. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{table}~{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`\{ \mathsf{name}~{\mathit{name}},\;\allowbreak \mathsf{addr}~(\mathsf{table}~{{\mathit{ta}}^\ast}{}[x]) \}`.

#. Assert: :math:`{\mathit{externidx}}` is some :math:`\mathsf{mem}~{\mathit{memidx}}`.

#. Let :math:`(\mathsf{mem}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

#. Return :math:`\{ \mathsf{name}~{\mathit{name}},\;\allowbreak \mathsf{addr}~(\mathsf{mem}~{{\mathit{ma}}^\ast}{}[x]) \}`.


:math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}^\ast})`
.........................................................................................................


1. Let :math:`(\mathsf{module}~{{\mathit{type}}_0^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^{n_{\mathit{func}}}}~{{\mathit{global}}_1^\ast}~{{\mathit{table}}_2^\ast}~{{\mathit{mem}}_3^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be the destructuring of :math:`{\mathit{module}}`.

#. Let :math:`{(\mathsf{memory}~{\mathit{memtype}})^{n_{\mathit{mem}}}}` be :math:`{{\mathit{mem}}_3^\ast}`.

#. Let :math:`{(\mathsf{table}~{\mathit{tabletype}})^{n_{\mathit{table}}}}` be :math:`{{\mathit{table}}_2^\ast}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_1)^{n_{\mathit{global}}}}` be :math:`{{\mathit{global}}_1^\ast}`.

#. Let :math:`{{\mathit{ft}}^\ast}` be the function type sequence :math:`\epsilon`.

#. For each :math:`{\mathit{type}}_0` in :math:`{{\mathit{type}}_0^\ast}`, do:

   a. Let :math:`(\mathsf{type}~{\mathit{ft}})` be the destructuring of :math:`{\mathit{type}}_0`.

   #. Append :math:`{\mathit{ft}}` to :math:`{{\mathit{ft}}^\ast}`.

#. Let :math:`{{\mathit{fa}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ga}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{globals}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ma}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{mems}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ta}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{tables}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{fa}}^\ast}` be :math:`{|s{.}\mathsf{funcs}|} + i_{\mathit{func}}` for all :math:`i_{\mathit{func}}` from :math:`0` to :math:`n_{\mathit{func}} - 1`.

#. Let :math:`{{\mathit{ga}}^\ast}` be :math:`{|s{.}\mathsf{globals}|} + i_{\mathit{global}}` for all :math:`i_{\mathit{global}}` from :math:`0` to :math:`n_{\mathit{global}} - 1`.

#. Let :math:`{{\mathit{ta}}^\ast}` be :math:`{|s{.}\mathsf{tables}|} + i_{\mathit{table}}` for all :math:`i_{\mathit{table}}` from :math:`0` to :math:`n_{\mathit{table}} - 1`.

#. Let :math:`{{\mathit{ma}}^\ast}` be :math:`{|s{.}\mathsf{mems}|} + i_{\mathit{mem}}` for all :math:`i_{\mathit{mem}}` from :math:`0` to :math:`n_{\mathit{mem}} - 1`.

#. Let :math:`{{\mathit{xi}}^\ast}` be the export instance sequence :math:`\epsilon`.

#. For each :math:`{\mathit{export}}` in :math:`{{\mathit{export}}^\ast}`, do:

   a. Let :math:`{\mathit{xi}}` be the export instance :math:`{\mathrm{instexport}}({{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast}, {{\mathit{ga}}_{\mathit{ex}}^\ast}~{{\mathit{ga}}^\ast}, {{\mathit{ta}}_{\mathit{ex}}^\ast}~{{\mathit{ta}}^\ast}, {{\mathit{ma}}_{\mathit{ex}}^\ast}~{{\mathit{ma}}^\ast}, {\mathit{export}})`.

   #. Append :math:`{\mathit{xi}}` to :math:`{{\mathit{xi}}^\ast}`.

#. Let :math:`{\mathit{moduleinst}}` be the module instance :math:`\{ \mathsf{types}~{{\mathit{ft}}^\ast},\;\allowbreak \mathsf{funcs}~{{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast},\;\allowbreak \mathsf{globals}~{{\mathit{ga}}_{\mathit{ex}}^\ast}~{{\mathit{ga}}^\ast},\;\allowbreak \mathsf{tables}~{{\mathit{ta}}_{\mathit{ex}}^\ast}~{{\mathit{ta}}^\ast},\;\allowbreak \mathsf{mems}~{{\mathit{ma}}_{\mathit{ex}}^\ast}~{{\mathit{ma}}^\ast},\;\allowbreak \mathsf{exports}~{{\mathit{xi}}^\ast} \}`.

#. Let :math:`{{\mathit{funcaddr}}_0^\ast}` be :math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}}^{n_{\mathit{func}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{funcaddr}}_0^\ast} = {{\mathit{fa}}^\ast}`.

#. Let :math:`{{\mathit{globaladdr}}_0^\ast}` be :math:`{\mathrm{allocglobals}}(s, {{\mathit{globaltype}}^{n_{\mathit{global}}}}, {{\mathit{val}}^\ast})`.

#. Assert: Due to validation, :math:`{{\mathit{globaladdr}}_0^\ast} = {{\mathit{ga}}^\ast}`.

#. Let :math:`{{\mathit{tableaddr}}_0^\ast}` be :math:`{\mathrm{alloctables}}(s, {{\mathit{tabletype}}^{n_{\mathit{table}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{tableaddr}}_0^\ast} = {{\mathit{ta}}^\ast}`.

#. Let :math:`{{\mathit{memaddr}}_0^\ast}` be :math:`{\mathrm{allocmems}}(s, {{\mathit{memtype}}^{n_{\mathit{mem}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{memaddr}}_0^\ast} = {{\mathit{ma}}^\ast}`.

#. Return :math:`{\mathit{moduleinst}}`.


:math:`{\mathrm{initelem}}(s, {\mathit{moduleinst}}, {{\mathit{u{\kern-0.1em\scriptstyle 32}}}^\ast}, {{\mathit{funcaddr}}^\ast})`
..................................................................................................................................


1. If :math:`{{\mathit{funcaddr}}^\ast} = \epsilon`, then:

   a. Assert: :math:`{{\mathit{u{\kern-0.1em\scriptstyle 32}}}^\ast} = \epsilon`.

   #. Return.

#. Else:

   a. Let :math:`{a^\ast}~{{{a'}^\ast}^\ast}` be :math:`{{\mathit{funcaddr}}^\ast}`.

   #. Assert: :math:`{|{{\mathit{u{\kern-0.1em\scriptstyle 32}}}^\ast}|} \geq 1`.

   #. Let :math:`i~{{i'}^\ast}` be :math:`{{\mathit{u{\kern-0.1em\scriptstyle 32}}}^\ast}`.

   #. Replace :math:`s{.}\mathsf{tables}{}[{\mathit{moduleinst}}{.}\mathsf{tables}{}[0]]{.}\mathsf{refs}{}[i : {|{a^\ast}|}]` with :math:`{a^\ast}`.

   #. Perform :math:`{\mathrm{initelem}}(s, {\mathit{moduleinst}}, {{i'}^\ast}, {{{a'}^\ast}^\ast})`.

   #. Return.


:math:`{\mathrm{initdata}}(s, {\mathit{moduleinst}}, {{\mathit{u{\kern-0.1em\scriptstyle 32}}}^\ast}, {{\mathit{byte}}^\ast})`
..............................................................................................................................


1. If :math:`{{\mathit{byte}}^\ast} = \epsilon`, then:

   a. Assert: :math:`{{\mathit{u{\kern-0.1em\scriptstyle 32}}}^\ast} = \epsilon`.

   #. Return.

#. Else:

   a. Let :math:`{b^\ast}~{{{b'}^\ast}^\ast}` be :math:`{{\mathit{byte}}^\ast}`.

   #. Assert: :math:`{|{{\mathit{u{\kern-0.1em\scriptstyle 32}}}^\ast}|} \geq 1`.

   #. Let :math:`i~{{i'}^\ast}` be :math:`{{\mathit{u{\kern-0.1em\scriptstyle 32}}}^\ast}`.

   #. Replace :math:`s{.}\mathsf{mems}{}[{\mathit{moduleinst}}{.}\mathsf{mems}{}[0]]{.}\mathsf{bytes}{}[i : {|{b^\ast}|}]` with :math:`{b^\ast}`.

   #. Perform :math:`{\mathrm{initdata}}(s, {\mathit{moduleinst}}, {{i'}^\ast}, {{{b'}^\ast}^\ast})`.

   #. Return.


:math:`{\mathrm{instantiate}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast})`
..................................................................................


1. Let :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be the destructuring of :math:`{\mathit{module}}`.

#. Let :math:`{{\mathit{functype}}^\ast}` be the function type sequence :math:`\epsilon`.

#. For each :math:`{\mathit{type}}` in :math:`{{\mathit{type}}^\ast}`, do:

   a. Let :math:`(\mathsf{type}~{\mathit{functype}})` be the destructuring of :math:`{\mathit{type}}`.

   #. Append :math:`{\mathit{functype}}` to :math:`{{\mathit{functype}}^\ast}`.

#. Let :math:`n_{\mathsf{f}}` be the length of :math:`{{\mathit{func}}^\ast}`.

#. Let :math:`{{b^\ast}^\ast}` be the byte sequence sequence :math:`\epsilon`.

#. Let :math:`{{\mathit{expr}}_{\mathsf{d}}^\ast}` be the expression sequence :math:`\epsilon`.

#. For each :math:`{\mathit{data}}` in :math:`{{\mathit{data}}^\ast}`, do:

   a. Let :math:`(\mathsf{data}~{\mathit{expr}}_{\mathsf{d}}~{b^\ast})` be the destructuring of :math:`{\mathit{data}}`.

   #. Append :math:`{b^\ast}` to :math:`{{b^\ast}^\ast}`.

   #. Append :math:`{\mathit{expr}}_{\mathsf{d}}` to :math:`{{\mathit{expr}}_{\mathsf{d}}^\ast}`.

#. Let :math:`{{\mathit{expr}}_{\mathsf{e}}^\ast}` be the expression sequence :math:`\epsilon`.

#. Let :math:`{{x^\ast}^\ast}` be the function index sequence sequence :math:`\epsilon`.

#. For each :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}`, do:

   a. Let :math:`(\mathsf{elem}~{\mathit{expr}}_{\mathsf{e}}~{x^\ast})` be the destructuring of :math:`{\mathit{elem}}`.

   #. Append :math:`{\mathit{expr}}_{\mathsf{e}}` to :math:`{{\mathit{expr}}_{\mathsf{e}}^\ast}`.

   #. Append :math:`{x^\ast}` to :math:`{{x^\ast}^\ast}`.

#. Let :math:`{{\mathit{expr}}_{\mathsf{g}}^\ast}` be the expression sequence :math:`\epsilon`.

#. For each :math:`{\mathit{global}}` in :math:`{{\mathit{global}}^\ast}`, do:

   a. Let :math:`(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_{\mathsf{g}})` be the destructuring of :math:`{\mathit{global}}`.

   #. Append :math:`{\mathit{expr}}_{\mathsf{g}}` to :math:`{{\mathit{expr}}_{\mathsf{g}}^\ast}`.

#. Let :math:`{\mathit{moduleinst}}_{\mathit{init}}` be the module instance :math:`\{ \mathsf{types}~{{\mathit{functype}}^\ast},\;\allowbreak \mathsf{funcs}~{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})~{({|s{.}\mathsf{funcs}|} + i_{\mathsf{f}})^{i_{\mathsf{f}}<n_{\mathsf{f}}}},\;\allowbreak \mathsf{globals}~{\mathrm{globals}}({{\mathit{externaddr}}^\ast}) \}`.

#. Let :math:`f_{\mathit{init}}` be the frame :math:`\{ \mathsf{module}~{\mathit{moduleinst}}_{\mathit{init}} \}`.

#. Let :math:`z` be the state :math:`(s, f_{\mathit{init}})`.

#. Let :math:`F` be the :math:`\mathsf{frame}` :math:`z{.}\mathsf{frame}`.

#. Push the :math:`\mathsf{frame}` :math:`F`.

#. Let :math:`{i_{\mathsf{d}}^\ast}` be :math:`\epsilon`.

#. For each :math:`{\mathit{expr}}_{\mathsf{d}}` in :math:`{{\mathit{expr}}_{\mathsf{d}}^\ast}`, do:

   a. Let :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_{\mathsf{d}})` be the result of :ref:`evaluating <exec-expr>` :math:`{\mathit{expr}}_{\mathsf{d}}` with state :math:`z`.

   #. Append :math:`i_{\mathsf{d}}` to :math:`{i_{\mathsf{d}}^\ast}`.

#. Let :math:`{i_{\mathsf{e}}^\ast}` be :math:`\epsilon`.

#. For each :math:`{\mathit{expr}}_{\mathsf{e}}` in :math:`{{\mathit{expr}}_{\mathsf{e}}^\ast}`, do:

   a. Let :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_{\mathsf{e}})` be the result of :ref:`evaluating <exec-expr>` :math:`{\mathit{expr}}_{\mathsf{e}}` with state :math:`z`.

   #. Append :math:`i_{\mathsf{e}}` to :math:`{i_{\mathsf{e}}^\ast}`.

#. Let :math:`{{\mathit{val}}^\ast}` be the value sequence :math:`\epsilon`.

#. For each :math:`{\mathit{expr}}_{\mathsf{g}}` in :math:`{{\mathit{expr}}_{\mathsf{g}}^\ast}`, do:

   a. Let :math:`{\mathit{val}}` be the result of :ref:`evaluating <exec-expr>` :math:`{\mathit{expr}}_{\mathsf{g}}` with state :math:`z`.

   #. Append :math:`{\mathit{val}}` to :math:`{{\mathit{val}}^\ast}`.

#. Pop the :math:`\mathsf{frame}` from the stack.

#. Let :math:`{\mathit{moduleinst}}` be :math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}^\ast})`.

#. Let :math:`f` be the frame :math:`\{ \mathsf{module}~{\mathit{moduleinst}} \}`.

#. Perform :math:`{\mathrm{initelem}}(s, {\mathit{moduleinst}}, {i_{\mathsf{e}}^\ast}, {{{\mathit{moduleinst}}{.}\mathsf{funcs}{}[x]^\ast}^\ast})`.

#. Perform :math:`{\mathrm{initdata}}(s, {\mathit{moduleinst}}, {i_{\mathsf{d}}^\ast}, {{b^\ast}^\ast})`.

#. Let :math:`{f'}` be the :math:`\mathsf{frame}` :math:`f`.

#. Push the :math:`\mathsf{frame}` :math:`{f'}`.

#. If :math:`{{\mathit{start}}^?}` is defined, then:

   a. Let :math:`(\mathsf{start}~{x'})` be :math:`{{\mathit{start}}^?}`.

   #. Let :math:`{\mathit{instr}}_0` be the administrative instruction :math:`(\mathsf{call}~{x'})`.

   #. Execute the instruction :math:`{\mathit{instr}}_0`.

#. Pop the :math:`\mathsf{frame}` from the stack.

#. Return :math:`f{.}\mathsf{module}`.


:math:`{\mathrm{invoke}}(s, {\mathit{fa}}, {{\mathit{val}}^{n}})`
.................................................................


1. Let :math:`f` be the frame :math:`\{ \mathsf{module}~\{  \} \}`.

#. Let :math:`F` be the :math:`\mathsf{frame}` :math:`(s, f)`.

#. Push the :math:`\mathsf{frame}` :math:`F`.

#. Let :math:`{t_1^{n}}~\rightarrow~{t_2^\ast}` be the destructuring of :math:`(s, f){.}\mathsf{funcs}{}[{\mathit{fa}}]{.}\mathsf{type}`.

#. Pop the :math:`\mathsf{frame}` from the stack.

#. Let :math:`k` be the length of :math:`{t_2^\ast}`.

#. Let :math:`{f'}` be the :math:`\mathsf{frame}` :math:`f` whose arity is :math:`k`.

#. Push the :math:`\mathsf{frame}` :math:`{f'}`.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{call}~{\mathit{fa}})`.

#. Pop the values :math:`{{\mathit{val}'}^{k}}` from the stack.

#. Pop the :math:`\mathsf{frame}` from the stack.

#. Return :math:`{{\mathit{val}'}^{k}}`.


:math:`\mathsf{eval\_expr}~{{\mathit{instr}}^\ast}`
...................................................


1. Execute the sequence :math:`{{\mathit{instr}}^\ast}`.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Return :math:`{\mathit{val}}`.


== Complete.
spectec 0.5 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...
Limits_ok
- the limits ([ n .. m? ]) is valid with k if:
  - n is less than or equal to k.
  - If m is defined, then:
    - n is less than or equal to m.
    - m is less than or equal to k.

Functype_ok
- the function type t_1* -> t_2? is always valid.

Globaltype_ok
- the global type (MUT? t) is always valid.

Tabletype_ok
- the table type limits is valid if:
  - limits is valid with ((2 ^ 32) - 1).

Memtype_ok
- the memory type limits is valid if:
  - limits is valid with (2 ^ 16).

Externtype_ok
- the external type externtype is valid if:
  - Either:
    - externtype is (FUNC functype).
    - the function type functype is valid.
  - Or:
    - externtype is (GLOBAL globaltype).
    - the global type globaltype is valid.
  - Or:
    - externtype is (TABLE tabletype).
    - the table type tabletype is valid.
  - Or:
    - externtype is (MEM memtype).
    - the memory type memtype is valid.

Externtype_ok/func
- the external type (FUNC functype) is valid if:
  - the function type functype is valid.

Externtype_ok/global
- the external type (GLOBAL globaltype) is valid if:
  - the global type globaltype is valid.

Externtype_ok/table
- the external type (TABLE tabletype) is valid if:
  - the table type tabletype is valid.

Externtype_ok/mem
- the external type (MEM memtype) is valid if:
  - the memory type memtype is valid.

Limits_sub
- the limits ([ n_11 .. ?(n_12) ]) matches the limits ([ n_21 .. ?(n_22) ]) if:
  - n_11 is greater than or equal to n_21.
  - n_12 is less than or equal to n_22.

Functype_sub
- the function type ft matches only itself.

Globaltype_sub
- the global type gt matches only itself.

Tabletype_sub
- the table type lim_1 matches the table type lim_2 if:
  - lim_1 matches lim_2.

Memtype_sub
- the memory type lim_1 matches the memory type lim_2 if:
  - lim_1 matches lim_2.

Externtype_sub
- the external type externtype_1 matches the external type externtype_2 if:
  - Either:
    - externtype_1 is (FUNC ft_1).
    - externtype_2 is (FUNC ft_2).
    - the function type ft_1 matches the function type ft_2.
  - Or:
    - externtype_1 is (GLOBAL gt_1).
    - externtype_2 is (GLOBAL gt_2).
    - the global type gt_1 matches the global type gt_2.
  - Or:
    - externtype_1 is (TABLE tt_1).
    - externtype_2 is (TABLE tt_2).
    - the table type tt_1 matches the table type tt_2.
  - Or:
    - externtype_1 is (MEM mt_1).
    - externtype_2 is (MEM mt_2).
    - the memory type mt_1 matches the memory type mt_2.

Externtype_sub/func
- the external type (FUNC ft_1) matches the external type (FUNC ft_2) if:
  - the function type ft_1 matches the function type ft_2.

Externtype_sub/global
- the external type (GLOBAL gt_1) matches the external type (GLOBAL gt_2) if:
  - the global type gt_1 matches the global type gt_2.

Externtype_sub/table
- the external type (TABLE tt_1) matches the external type (TABLE tt_2) if:
  - the table type tt_1 matches the table type tt_2.

Externtype_sub/mem
- the external type (MEM mt_1) matches the external type (MEM mt_2) if:
  - the memory type mt_1 matches the memory type mt_2.

Instr_ok/nop
- the instruction NOP is valid with the function type [] -> [].

Instr_ok/unreachable
- the instruction UNREACHABLE is valid with the function type t_1* -> t_2*.

Instr_ok/drop
- the instruction DROP is valid with the function type [t] -> [].

Instr_ok/select
- the instruction SELECT is valid with the function type [t, t, I32] -> [t].

Instr_ok/block
- the instruction (BLOCK t? instr*) is valid with the function type [] -> t? if:
  - the context C' is the context C with .LABELS prepended by [t?].
  - Under the context C', the instruction sequence instr* is valid with [] -> t?.

Instr_ok/loop
- the instruction (LOOP t? instr*) is valid with the function type [] -> t? if:
  - the instruction sequence instr* is valid with the function type [] -> [].

Instr_ok/if
- the instruction (IF t? instr_1* ELSE instr_2*) is valid with the function type [I32] -> t? if:
  - the context C' is the context C with .LABELS prepended by [t?].
  - Under the context C', the instruction sequence instr_1* is valid with the function type [] -> t?.
  - Under the context C', the instruction sequence instr_2* is valid with [] -> t?.

Instr_ok/br
- the instruction (BR l) is valid with the function type t_1* :: t? -> t_2* if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t?.

Instr_ok/br_if
- the instruction (BR_IF l) is valid with the function type t? :: [I32] -> t? if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t?.

Instr_ok/br_table
- the instruction (BR_TABLE l* l') is valid with the function type t_1* :: t? :: [I32] -> t_2* if:
  - the result type C.LABELS[l'] exists.
  - the result type t? is C.LABELS[l'].
  - For all l in l*:
    - the result type C.LABELS[l] exists.
    - t? is C.LABELS[l].

Instr_ok/call
- the instruction (CALL x) is valid with the function type t_1* -> t_2? if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is t_1* -> t_2?.

Instr_ok/call_indirect
- the instruction (CALL_INDIRECT x) is valid with the function type t_1* :: [I32] -> t_2? if:
  - the function type C.TYPES[x] exists.
  - C.TYPES[x] is t_1* -> t_2?.

Instr_ok/return
- the instruction RETURN is valid with the function type t_1* :: t? -> t_2* if:
  - the result type C.RETURN is ?(t?).

Instr_ok/const
- the instruction (t.CONST c_t) is valid with the function type [] -> [t].

Instr_ok/unop
- the instruction (UNOP t unop_t) is valid with the function type [t] -> [t].

Instr_ok/binop
- the instruction (BINOP t binop_t) is valid with the function type [t, t] -> [t].

Instr_ok/testop
- the instruction (TESTOP t testop_t) is valid with the function type [t] -> [I32].

Instr_ok/relop
- the instruction (RELOP t relop_t) is valid with the function type [t, t] -> [I32].

Instr_ok/cvtop
- the instruction (CVTOP nt_1 nt_2 cvtop) is valid with the function type [nt_2] -> [nt_1] if:
  - Either:
    - cvtop is REINTERPRET.
    - $size(nt_1) is $size(nt_2).
  - Or:


Instr_ok/local.get
- the instruction (LOCAL.GET x) is valid with the function type [] -> [t] if:
  - the number type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/local.set
- the instruction (LOCAL.SET x) is valid with the function type [t] -> [] if:
  - the number type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/local.tee
- the instruction (LOCAL.TEE x) is valid with the function type [t] -> [t] if:
  - the number type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/global.get
- the instruction (GLOBAL.GET x) is valid with the function type [] -> [t] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (mut t).

Instr_ok/global.set
- the instruction (GLOBAL.SET x) is valid with the function type [t] -> [] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?(MUT) t).

Instr_ok/memory.size
- the instruction MEMORY.SIZE is valid with the function type [] -> [I32].

Instr_ok/memory.grow
- the instruction MEMORY.GROW is valid with the function type [I32] -> [I32].

Instr_ok/load
- the instruction (LOAD t loadop_? memarg) is valid with the function type [I32] -> [t'] if:
  - Either:
    - loadop_? is ?().
    - the number type t' is t.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(t) / 8).
  - Or:
    - the number type t is Inn.
    - loadop_? is ?(M _ sx).
    - t' is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store
- the instruction (STORE t sz? memarg) is valid with the function type [I32, t'] -> [] if:
  - Either:
    - the pack size sz? is ?().
    - the number type t' is t.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(t) / 8).
  - Or:
    - the number type t is Inn.
    - sz? is ?(M).
    - t' is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/cvtop-reinterpret
- the instruction (CVTOP nt_1 nt_2 REINTERPRET) is valid with the function type [nt_2] -> [nt_1] if:
  - $size(nt_1) is $size(nt_2).

Instr_ok/cvtop-convert
- the instruction (CVTOP nt_1 nt_2 cvtop) is valid with [nt_2] -> [nt_1].

Instr_ok/load-val
- the instruction (LOAD t ?() memarg) is valid with the function type [I32] -> [t] if:
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(t) / 8).

Instr_ok/load-pack
- the instruction (LOAD Inn ?(M _ sx) memarg) is valid with the function type [I32] -> [Inn] if:
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store-val
- the instruction (STORE t ?() memarg) is valid with the function type [I32, t] -> [] if:
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(t) / 8).

Instr_ok/store-pack
- the instruction (STORE Inn ?(M) memarg) is valid with the function type [I32, Inn] -> [] if:
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instrs_ok
- the instruction sequence instr* is valid with the function type valtype* -> valtype'* if:
  - Either:
    - instr* is [].
    - the number type sequence valtype* is [].
    - the number type sequence valtype'* is [].
  - Or:
    - instr* is [instr_1] :: instr_2*.
    - the instruction instr_1 is valid with the function type valtype* -> t_2*.
    - the instruction sequence instr_2* is valid with the function type t_2* -> valtype'*.
  - Or:
    - valtype* is t* :: t_1*.
    - valtype'* is t* :: t_2*.
    - instr* is valid with the function type t_1* -> t_2*.

Instrs_ok/empty
- the instruction sequence [] is valid with the function type [] -> [].

Instrs_ok/seq
- the instruction sequence [instr_1] :: instr_2* is valid with the function type t_1* -> t_3* if:
  - the instruction instr_1 is valid with the function type t_1* -> t_2*.
  - the instruction sequence instr_2* is valid with the function type t_2* -> t_3*.

Instrs_ok/frame
- the instruction sequence instr* is valid with the function type t* :: t_1* -> t* :: t_2* if:
  - instr* is valid with the function type t_1* -> t_2*.

Expr_ok
- the expression instr* is valid with the result type t? if:
  - instr* is valid with the function type [] -> t?.

Instr_const
- the instruction instr is constant if:
  - Either:
    - instr is (t.CONST c).
  - Or:
    - instr is (GLOBAL.GET x).
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is (?() t).

Instr_const/const
- the instruction (t.CONST c) is constant.

Instr_const/global.get
- the instruction (GLOBAL.GET x) is constant if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?() t).

Expr_const
- the expression instr* is constant if:
  - For all instr in instr*:
    - the instruction instr is constant.

Type_ok
- the type (TYPE ft) is valid with the function type ft if:
  - ft is valid.

Func_ok
- the function (FUNC x (LOCAL t)* expr) is valid with the function type t_1* -> t_2? if:
  - the function type C.TYPES[x] exists.
  - C.TYPES[x] is t_1* -> t_2?.
  - Under the context C with .LOCALS appended by t_1* :: t* and .LABELS appended by [t_2?] and .RETURN appended by ?(t_2?), the expression expr is valid with the result type t_2?.

Global_ok
- the global (GLOBAL gt expr) is valid with the global type gt if:
  - gt is valid.
  - gt is (mut t).
  - the expression expr is valid with the number type ?(t).
  - expr is constant.

Table_ok
- the table (TABLE tt) is valid with the table type tt if:
  - tt is valid.

Mem_ok
- the memory (MEMORY mt) is valid with the memory type mt if:
  - mt is valid.

Elem_ok
- the table segment (ELEM expr x*) is valid if:
  - the expression expr is valid with the number type ?(I32).
  - expr is constant.
  - For all x in x*:
    - the function type C.FUNCS[x] exists.

Data_ok
- the memory segment (DATA expr b*) is valid if:
  - the expression expr is valid with the number type ?(I32).
  - expr is constant.

Start_ok
- the start function (START x) is valid if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is [] -> [].

Import_ok
- the import (IMPORT name_1 name_2 xt) is valid with the external type xt if:
  - xt is valid.

Externidx_ok
- the external index externidx is valid with the external type externtype if:
  - Either:
    - externidx is (FUNC x).
    - externtype is (FUNC ft).
    - the function type C.FUNCS[x] exists.
    - C.FUNCS[x] is ft.
  - Or:
    - externidx is (GLOBAL x).
    - externtype is (GLOBAL gt).
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is gt.
  - Or:
    - externidx is (TABLE x).
    - externtype is (TABLE tt).
    - the table type C.TABLES[x] exists.
    - C.TABLES[x] is tt.
  - Or:
    - externidx is (MEM x).
    - externtype is (MEM mt).
    - the memory type C.MEMS[x] exists.
    - C.MEMS[x] is mt.

Externidx_ok/func
- the external index (FUNC x) is valid with the external type (FUNC ft) if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is ft.

Externidx_ok/global
- the external index (GLOBAL x) is valid with the external type (GLOBAL gt) if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is gt.

Externidx_ok/table
- the external index (TABLE x) is valid with the external type (TABLE tt) if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is tt.

Externidx_ok/mem
- the external index (MEM x) is valid with the external type (MEM mt) if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is mt.

Export_ok
- the export (EXPORT name externidx) is valid with the external type xt if:
  - the external index externidx is valid with xt.

Module_ok
- the module (MODULE type* import* func* global* table* mem* elem* data* start? export*) is valid if:
  - For all type in type*:
    - the type type is valid with the function type ft'.
  - ft'* is the concatenation of all such ft'.
  - For all import in import*:
    - Under the context { TYPES: ft'*; RETURN: ?() }, the import import is valid with the external type ixt.
  - ixt* is the concatenation of all such ixt.
  - For all global in global*:
    - Under the context C', the global global is valid with the global type gt.
  - gt* is the concatenation of all such gt.
  - For all func in func*:
    - the function func is valid with the function type ft.
  - ft* is the concatenation of all such ft.
  - For all table in table*:
    - the table table is valid with the table type tt.
  - tt* is the concatenation of all such tt.
  - For all mem in mem*:
    - the memory mem is valid with the memory type mt.
  - mt* is the concatenation of all such mt.
  - For all elem in elem*:
    - the table segment elem is valid.
  - For all data in data*:
    - the memory segment data is valid.
  - If start is defined, then:
    - the start function start is valid.
  - For all export in export*:
    - the export export is valid with the external type xt.
  - |tt*| is less than or equal to 1.
  - |mt*| is less than or equal to 1.
  - the context C' is { TYPES: ft'*; FUNCS: ift* :: ft*; GLOBALS: igt*; RETURN: ?() }.
  - the function type sequence ift* is $funcsxt(ixt*).
  - the global type sequence igt* is $globalsxt(ixt*).
  - the table type sequence itt* is $tablesxt(ixt*).
  - the memory type sequence imt* is $memsxt(ixt*).

Step_read/load-num-* t ?() ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (((i + ao.OFFSET) + ($size(t) / 8)) > |$mem(z, 0).BYTES|), then:
  a. Trap.
5. Let c be $bytes__1^-1(t, $mem(z, 0).BYTES[(i + ao.OFFSET) : ($size(t) / 8)]).
6. Push the value (t.CONST c) to the stack.

Step_read/load-pack-* Inn ?(n _ sx) ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
  a. Trap.
5. Let c be $ibytes__1^-1(n, $mem(z, 0).BYTES[(i + ao.OFFSET) : (n / 8)]).
6. Push the value (Inn.CONST $extend__(n, $size(Inn), sx, c)) to the stack.

Step/store-num-* t ?() ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type t is on the top of the stack.
3. Pop the value (valtype_0.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + ($size(t) / 8)) > |$mem(z, 0).BYTES|), then:
  a. Trap.
7. Let b* be $bytes_(t, c).
8. Perform $with_mem(z, 0, (i + ao.OFFSET), ($size(t) / 8), b*).

Step/store-pack-* Inn ?(n) ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type Inn is on the top of the stack.
3. Pop the value (valtype_0.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
  a. Trap.
7. Let b* be $ibytes_(n, $wrap__($size(Inn), n, c)).
8. Perform $with_mem(z, 0, (i + ao.OFFSET), (n / 8), b*).

Step_pure/unreachable
1. Trap.

Step_pure/nop
1. Do nothing.

Step_pure/drop
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.

Step_pure/select
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. Assert: Due to validation, a value is on the top of the stack.
4. Pop the value val_2 from the stack.
5. Assert: Due to validation, a value is on the top of the stack.
6. Pop the value val_1 from the stack.
7. If (c =/= 0), then:
  a. Push the value val_1 to the stack.
8. Else:
  a. Push the value val_2 to the stack.

Step_pure/if t? instr_1* instr_2*
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BLOCK t? instr_1*).
4. Else:
  a. Execute the instruction (BLOCK t? instr_2*).

Step_pure/label
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
3. Pop the label (LABEL_ _ { _ }) from the stack.
4. Push the values val* to the stack.

Step_pure/br n'
1. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
2. Let (LABEL_ n { instr'* }) be the topmost LABEL_.
3. If (n' = 0), then:
  a. Assert: Due to validation, there are at least n values on the top of the stack.
  b. Pop the values val^n from the stack.
  c. Pop all values val'* from the top of the stack.
  d. Pop the label (LABEL_ _ { _ }) from the stack.
  e. Push the values val^n to the stack.
  f. Execute the sequence instr'*.
4. Else:
  a. Pop all values val* from the top of the stack.
  b. Let l be (n' - 1).
  c. Pop the label (LABEL_ _ { _ }) from the stack.
  d. Push the values val* to the stack.
  e. Execute the instruction (BR l).

Step_pure/br_if l
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BR l).
4. Else:
  a. Do nothing.

Step_pure/br_table l* l'
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. If (i < |l*|), then:
  a. Execute the instruction (BR l*[i]).
4. Else:
  a. Execute the instruction (BR l').

Step_pure/frame
1. Let (FRAME_ n { f }) be the topmost FRAME_.
2. Assert: Due to validation, there are at least n values on the top of the stack.
3. Assert: Due to validation, there are at least n values on the top of the stack.
4. Pop the values val^n from the stack.
5. Assert: Due to validation, the first non-value entry of the stack is a FRAME_.
6. Pop the frame (FRAME_ _ { _ }) from the stack.
7. Push the values val^n to the stack.

Step_pure/return
1. If the first non-value entry of the stack is a FRAME_, then:
  a. Let (FRAME_ n { f }) be the topmost FRAME_.
  b. Assert: Due to validation, there are at least n values on the top of the stack.
  c. Pop the values val^n from the stack.
  d. Pop all values val'* from the top of the stack.
  e. Pop the frame (FRAME_ _ { _ }) from the stack.
  f. Push the values val^n to the stack.
2. Else:
  a. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
  b. Pop all values val* from the top of the stack.
  c. Pop the label (LABEL_ _ { _ }) from the stack.
  d. Push the values val* to the stack.
  e. Execute the instruction RETURN.

Step_pure/unop t unop
1. Assert: Due to validation, a value of value type t is on the top of the stack.
2. Pop the value (valtype_0.CONST c_1) from the stack.
3. If (|$unop_(t, unop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $unop_(t, unop, c_1).
5. Push the value (t.CONST c) to the stack.

Step_pure/binop t binop
1. Assert: Due to validation, a value of value type t is on the top of the stack.
2. Pop the value (valtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type num is on the top of the stack.
4. Pop the value (valtype_0.CONST c_1) from the stack.
5. If (|$binop_(t, binop, c_1, c_2)| <= 0), then:
  a. Trap.
6. Let c be an element of $binop_(t, binop, c_1, c_2).
7. Push the value (t.CONST c) to the stack.

Step_pure/testop t testop
1. Assert: Due to validation, a value of value type t is on the top of the stack.
2. Pop the value (valtype_0.CONST c_1) from the stack.
3. Let c be $testop_(t, testop, c_1).
4. Push the value (I32.CONST c) to the stack.

Step_pure/relop t relop
1. Assert: Due to validation, a value of value type t is on the top of the stack.
2. Pop the value (valtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type num is on the top of the stack.
4. Pop the value (valtype_0.CONST c_1) from the stack.
5. Let c be $relop_(t, relop, c_1, c_2).
6. Push the value (I32.CONST c) to the stack.

Step_pure/cvtop t_2 t_1 cvtop
1. Assert: Due to validation, a value of value type t_1 is on the top of the stack.
2. Pop the value (valtype_0.CONST c_1) from the stack.
3. If (|$cvtop__(t_1, t_2, cvtop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $cvtop__(t_1, t_2, cvtop, c_1).
5. Push the value (t_2.CONST c) to the stack.

Step_pure/local.tee x
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Push the value val to the stack.
4. Push the value val to the stack.
5. Execute the instruction (LOCAL.SET x).

Step_read/block t? instr*
1. Let n be 0.
2. If t? is not defined, then:
  a. Enter instr* with label (LABEL_ n { [] }).
3. Let n be 1.
4. If (t? =/= ?()), then:
  a. Enter instr* with label (LABEL_ n { [] }).

Step_read/loop t? instr*
1. Enter instr* with label (LABEL_ 0 { [(LOOP t? instr*)] }).

Step_read/call x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$funcaddr(z)|).
3. Execute the instruction (CALL_ADDR $funcaddr(z)[x]).

Step_read/call_indirect x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (i >= |$table(z, 0).REFS|), then:
  a. Trap.
5. If $table(z, 0).REFS[i] is not defined, then:
  a. Trap.
6. Let ?(a) be $table(z, 0).REFS[i].
7. If (a >= |$funcinst(z)|), then:
  a. Trap.
8. If ($type(z, x) =/= $funcinst(z)[a].TYPE), then:
  a. Trap.
9. Execute the instruction (CALL_ADDR a).

Step_read/call_addr a
1. Let z be the current state.
2. Assert: Due to validation, (a < |$funcinst(z)|).
3. Let { TYPE: t_1^k -> t_2^n; MODULE: mm; CODE: func } be $funcinst(z)[a].
4. Let (FUNC x local_0* instr*) be func.
5. Let t* be [].
6. For each local_0 in local_0*, do:
  a. Let (LOCAL t) be local_0.
  b. Append t to the t*.
7. Assert: Due to validation, there are at least k values on the top of the stack.
8. Pop the values val^k from the stack.
9. Let f be { LOCALS: val^k :: $default_(t)*; MODULE: mm }.
10. Push the frame (FRAME_ n { f }) to the stack.
11. Enter instr* with label (LABEL_ n { [] }).

Step_read/local.get x
1. Let z be the current state.
2. Push the value $local(z, x) to the stack.

Step_read/global.get x
1. Let z be the current state.
2. Push the value $global(z, x).VALUE to the stack.

Step_read/load t loadop_? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If loadop_? is not defined, then:
  a. If (((i + ao.OFFSET) + ($size(t) / 8)) > |$mem(z, 0).BYTES|), then:
    1) Trap.
  b. Let c be $bytes__1^-1(t, $mem(z, 0).BYTES[(i + ao.OFFSET) : ($size(t) / 8)]).
  c. Push the value (t.CONST c) to the stack.
5. Else:
  a. Assert: Due to validation, t is Inn.
  b. Let ?(loadop_0) be loadop_?.
  c. Let n _ sx be loadop_0.
  d. If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
    1) Trap.
  e. Let c be $ibytes__1^-1(n, $mem(z, 0).BYTES[(i + ao.OFFSET) : (n / 8)]).
  f. Push the value (t.CONST $extend__(n, $size(t), sx, c)) to the stack.

Step_read/memory.size
1. Let z be the current state.
2. Let ((n * 64) * $Ki()) be |$mem(z, 0).BYTES|.
3. Push the value (I32.CONST n) to the stack.

Step/local.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_local(z, x, val).

Step/global.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_global(z, x, val).

Step/store t sz? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (t'.CONST c) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, (t = t').
7. If sz? is not defined, then:
  a. If (((i + ao.OFFSET) + ($size(t') / 8)) > |$mem(z, 0).BYTES|), then:
    1) Trap.
  b. Let b* be $bytes_(t', c).
  c. Perform $with_mem(z, 0, (i + ao.OFFSET), ($size(t') / 8), b*).
8. Else:
  a. Assert: Due to validation, t' is Inn.
  b. Let ?(n) be sz?.
  c. If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
    1) Trap.
  d. Let b* be $ibytes_(n, $wrap__($size(t'), n, c)).
  e. Perform $with_mem(z, 0, (i + ao.OFFSET), (n / 8), b*).

Step/memory.grow
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Either:
  a. Let mi be $growmemory($mem(z, 0), n).
  b. Push the value (I32.CONST (|$mem(z, 0).BYTES| / (64 * $Ki()))) to the stack.
  c. Perform $with_meminst(z, 0, mi).
5. Or:
  a. Push the value (I32.CONST $inv_signed_(32, (- 1))) to the stack.

Ki
1. Return 1024.

min i j
1. If (i <= j), then:
  a. Return i.
2. Return j.

sum n''*
1. If (n''* = []), then:
  a. Return 0.
2. Let [n] :: n'* be n''*.
3. Return (n + $sum(n'*)).

opt_ `X X*
1. If (X* = []), then:
  a. Return ?().
2. Assert: Due to validation, (|X*| = 1).
3. Let [w] be X*.
4. Return ?(w).

list_ `X X?
1. If X? is not defined, then:
  a. Return [].
2. Let ?(w) be X?.
3. Return [w].

concat_ `X X*
1. If (X* = []), then:
  a. Return [].
2. Let [w*] :: w'** be X*.
3. Return w* :: $concat_(`X, w'**).

signif N
1. If (N = 32), then:
  a. Return 23.
2. Assert: Due to validation, (N = 64).
3. Return 52.

expon N
1. If (N = 32), then:
  a. Return 8.
2. Assert: Due to validation, (N = 64).
3. Return 11.

M N
1. Return $signif(N).

E N
1. Return $expon(N).

fzero N
1. Return (POS (SUBNORM 0)).

fone N
1. Return (POS (NORM 1 0)).

canon_ N
1. Return (2 ^ ($signif(N) - 1)).

size valtype
1. If (valtype = I32), then:
  a. Return 32.
2. If (valtype = I64), then:
  a. Return 64.
3. If (valtype = F32), then:
  a. Return 32.
4. Assert: Due to validation, (valtype = F64).
5. Return 64.

funcsxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some FUNC, then:
  a. Let (FUNC ft) be externtype_0.
  b. Return [ft] :: $funcsxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $funcsxt(xt*).

globalsxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some GLOBAL, then:
  a. Let (GLOBAL gt) be externtype_0.
  b. Return [gt] :: $globalsxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $globalsxt(xt*).

tablesxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some TABLE, then:
  a. Let (TABLE tt) be externtype_0.
  b. Return [tt] :: $tablesxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $tablesxt(xt*).

memsxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some MEM, then:
  a. Let (MEM mt) be externtype_0.
  b. Return [mt] :: $memsxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $memsxt(xt*).

memarg0
1. Return { ALIGN: 0; OFFSET: 0 }.

bool b
1. If (b = false), then:
  a. Return 0.
2. Assert: Due to validation, (b = true).
3. Return 1.

signed_ N i
1. If (i < (2 ^ (N - 1))), then:
  a. Return i.
2. Assert: Due to validation, ((2 ^ (N - 1)) <= i).
3. Assert: Due to validation, (i < (2 ^ N)).
4. Return (i - (2 ^ N)).

inv_signed_ N i
1. If ((0 <= i) /\ (i < (2 ^ (N - 1)))), then:
  a. Return i.
2. Assert: Due to validation, ((- (2 ^ (N - 1))) <= i).
3. Assert: Due to validation, (i < 0).
4. Return (i + (2 ^ N)).

unop_ valtype unop_ iN
1. If valtype is Inn, then:
  a. If (unop_ = CLZ), then:
    1) Return [$iclz_($size(valtype), iN)].
  b. If (unop_ = CTZ), then:
    1) Return [$ictz_($size(valtype), iN)].
  c. If (unop_ = POPCNT), then:
    1) Return [$ipopcnt_($size(valtype), iN)].
2. Assert: Due to validation, valtype is Fnn.
3. If (unop_ = ABS), then:
  a. Return $fabs_($size(valtype), iN).
4. If (unop_ = NEG), then:
  a. Return $fneg_($size(valtype), iN).
5. If (unop_ = SQRT), then:
  a. Return $fsqrt_($size(valtype), iN).
6. If (unop_ = CEIL), then:
  a. Return $fceil_($size(valtype), iN).
7. If (unop_ = FLOOR), then:
  a. Return $ffloor_($size(valtype), iN).
8. If (unop_ = TRUNC), then:
  a. Return $ftrunc_($size(valtype), iN).
9. Assert: Due to validation, (unop_ = NEAREST).
10. Return $fnearest_($size(valtype), iN).

iadd_ N i_1 i_2
1. Return ((i_1 + i_2) \ (2 ^ N)).

idiv_ N sx i_1 i_2
1. If (sx = U), then:
  a. If (i_2 = 0), then:
    1) Return ?().
  b. Return ?($truncz((i_1 / i_2))).
2. Assert: Due to validation, (sx = S).
3. If (i_2 = 0), then:
  a. Return ?().
4. If (($signed_(N, i_1) / $signed_(N, i_2)) = (2 ^ (N - 1))), then:
  a. Return ?().
5. Return ?($inv_signed_(N, $truncz(($signed_(N, i_1) / $signed_(N, i_2))))).

imul_ N i_1 i_2
1. Return ((i_1 * i_2) \ (2 ^ N)).

irem_ N sx i_1 i_2
1. If (sx = U), then:
  a. If (i_2 = 0), then:
    1) Return ?().
  b. Return ?((i_1 - (i_2 * $truncz((i_1 / i_2))))).
2. Assert: Due to validation, (sx = S).
3. If (i_2 = 0), then:
  a. Return ?().
4. Let j_1 be $signed_(N, i_1).
5. Let j_2 be $signed_(N, i_2).
6. Return ?($inv_signed_(N, (j_1 - (j_2 * $truncz((j_1 / j_2)))))).

isub_ N i_1 i_2
1. Return ((((2 ^ N) + i_1) - i_2) \ (2 ^ N)).

binop_ valtype binop_ iN_1 iN_2
1. If valtype is Inn, then:
  a. If (binop_ = ADD), then:
    1) Return [$iadd_($size(valtype), iN_1, iN_2)].
  b. If (binop_ = SUB), then:
    1) Return [$isub_($size(valtype), iN_1, iN_2)].
  c. If (binop_ = MUL), then:
    1) Return [$imul_($size(valtype), iN_1, iN_2)].
  d. If binop_ is some DIV, then:
    1) Let (DIV sx) be binop_.
    2) Return $list_(`val_((Inn : Inn <: valtype)), $idiv_($size(valtype), sx, iN_1, iN_2)).
  e. If binop_ is some REM, then:
    1) Let (REM sx) be binop_.
    2) Return $list_(`val_((Inn : Inn <: valtype)), $irem_($size(valtype), sx, iN_1, iN_2)).
  f. If (binop_ = AND), then:
    1) Return [$iand_($size(valtype), iN_1, iN_2)].
  g. If (binop_ = OR), then:
    1) Return [$ior_($size(valtype), iN_1, iN_2)].
  h. If (binop_ = XOR), then:
    1) Return [$ixor_($size(valtype), iN_1, iN_2)].
  i. If (binop_ = SHL), then:
    1) Return [$ishl_($size(valtype), iN_1, iN_2)].
  j. If binop_ is some SHR, then:
    1) Let (SHR sx) be binop_.
    2) Return [$ishr_($size(valtype), sx, iN_1, iN_2)].
  k. If (binop_ = ROTL), then:
    1) Return [$irotl_($size(valtype), iN_1, iN_2)].
  l. If (binop_ = ROTR), then:
    1) Return [$irotr_($size(valtype), iN_1, iN_2)].
2. Assert: Due to validation, valtype is Fnn.
3. If (binop_ = ADD), then:
  a. Return $fadd_($size(valtype), iN_1, iN_2).
4. If (binop_ = SUB), then:
  a. Return $fsub_($size(valtype), iN_1, iN_2).
5. If (binop_ = MUL), then:
  a. Return $fmul_($size(valtype), iN_1, iN_2).
6. If (binop_ = DIV), then:
  a. Return $fdiv_($size(valtype), iN_1, iN_2).
7. If (binop_ = MIN), then:
  a. Return $fmin_($size(valtype), iN_1, iN_2).
8. If (binop_ = MAX), then:
  a. Return $fmax_($size(valtype), iN_1, iN_2).
9. Assert: Due to validation, (binop_ = COPYSIGN).
10. Return $fcopysign_($size(valtype), iN_1, iN_2).

ieqz_ N i_1
1. Return $bool((i_1 = 0)).

testop_ Inn EQZ iN
1. Return $ieqz_($size(Inn), iN).

ieq_ N i_1 i_2
1. Return $bool((i_1 = i_2)).

ige_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 >= i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) >= $signed_(N, i_2))).

igt_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 > i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) > $signed_(N, i_2))).

ile_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 <= i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) <= $signed_(N, i_2))).

ilt_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 < i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) < $signed_(N, i_2))).

ine_ N i_1 i_2
1. Return $bool((i_1 =/= i_2)).

relop_ valtype relop_ iN_1 iN_2
1. If valtype is Inn, then:
  a. If (relop_ = EQ), then:
    1) Return $ieq_($size(valtype), iN_1, iN_2).
  b. If (relop_ = NE), then:
    1) Return $ine_($size(valtype), iN_1, iN_2).
  c. If relop_ is some LT, then:
    1) Let (LT sx) be relop_.
    2) Return $ilt_($size(valtype), sx, iN_1, iN_2).
  d. If relop_ is some GT, then:
    1) Let (GT sx) be relop_.
    2) Return $igt_($size(valtype), sx, iN_1, iN_2).
  e. If relop_ is some LE, then:
    1) Let (LE sx) be relop_.
    2) Return $ile_($size(valtype), sx, iN_1, iN_2).
  f. If relop_ is some GE, then:
    1) Let (GE sx) be relop_.
    2) Return $ige_($size(valtype), sx, iN_1, iN_2).
2. Assert: Due to validation, valtype is Fnn.
3. If (relop_ = EQ), then:
  a. Return $feq_($size(valtype), iN_1, iN_2).
4. If (relop_ = NE), then:
  a. Return $fne_($size(valtype), iN_1, iN_2).
5. If (relop_ = LT), then:
  a. Return $flt_($size(valtype), iN_1, iN_2).
6. If (relop_ = GT), then:
  a. Return $fgt_($size(valtype), iN_1, iN_2).
7. If (relop_ = LE), then:
  a. Return $fle_($size(valtype), iN_1, iN_2).
8. Assert: Due to validation, (relop_ = GE).
9. Return $fge_($size(valtype), iN_1, iN_2).

cvtop__ valtype valtype' cvtop iN
1. If cvtop is some EXTEND, then:
  a. Let (EXTEND sx) be cvtop.
  b. If ((valtype = I32) /\ (valtype' = I64)), then:
    1) Return [$extend__(32, 64, sx, iN)].
2. If ((valtype = I64) /\ ((valtype' = I32) /\ (cvtop = WRAP))), then:
  a. Return [$wrap__(64, 32, iN)].
3. If (valtype is Fnn /\ (valtype' is Inn /\ cvtop is some TRUNC)), then:
  a. Let (TRUNC sx) be cvtop.
  b. Return $list_(`val_((Inn : Inn <: valtype)), $trunc__($size(valtype), $size(valtype'), sx, iN)).
4. If ((valtype = F32) /\ ((valtype' = F64) /\ (cvtop = PROMOTE))), then:
  a. Return $promote__(32, 64, iN).
5. If ((valtype = F64) /\ ((valtype' = F32) /\ (cvtop = DEMOTE))), then:
  a. Return $demote__(64, 32, iN).
6. If (valtype is Inn /\ valtype' is Fnn), then:
  a. If cvtop is some CONVERT, then:
    1) Let (CONVERT sx) be cvtop.
    2) Return [$convert__($size(valtype), $size(valtype'), sx, iN)].
  b. If ((cvtop = REINTERPRET) /\ ($size(valtype) = $size(valtype'))), then:
    1) Return [$reinterpret__(valtype, valtype', iN)].
7. Assert: Due to validation, valtype is Fnn.
8. Assert: Due to validation, valtype' is Inn.
9. Assert: Due to validation, (cvtop = REINTERPRET).
10. Assert: Due to validation, ($size(valtype') = $size(valtype)).
11. Return [$reinterpret__(valtype, valtype', iN)].

inez_ N i_1
1. Return $bool((i_1 =/= 0)).

default_ valtype
1. If (valtype = I32), then:
  a. Return (I32.CONST 0).
2. If (valtype = I64), then:
  a. Return (I64.CONST 0).
3. If (valtype = F32), then:
  a. Return (F32.CONST $fzero(32)).
4. Assert: Due to validation, (valtype = F64).
5. Return (F64.CONST $fzero(64)).

funcsxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr'*.
3. If externaddr_0 is some FUNC, then:
  a. Let (FUNC fa) be externaddr_0.
  b. Return [fa] :: $funcsxa(xv*).
4. Let [externaddr] :: xv* be externaddr'*.
5. Return $funcsxa(xv*).

globalsxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr'*.
3. If externaddr_0 is some GLOBAL, then:
  a. Let (GLOBAL ga) be externaddr_0.
  b. Return [ga] :: $globalsxa(xv*).
4. Let [externaddr] :: xv* be externaddr'*.
5. Return $globalsxa(xv*).

tablesxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr'*.
3. If externaddr_0 is some TABLE, then:
  a. Let (TABLE ta) be externaddr_0.
  b. Return [ta] :: $tablesxa(xv*).
4. Let [externaddr] :: xv* be externaddr'*.
5. Return $tablesxa(xv*).

memsxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr'*.
3. If externaddr_0 is some MEM, then:
  a. Let (MEM ma) be externaddr_0.
  b. Return [ma] :: $memsxa(xv*).
4. Let [externaddr] :: xv* be externaddr'*.
5. Return $memsxa(xv*).

store (s, f)
1. Return.

frame (s, f)
1. Return f.

funcaddr (s, f)
1. Return f.MODULE.FUNCS.

funcinst (s, f)
1. Return s.FUNCS.

globalinst (s, f)
1. Return s.GLOBALS.

tableinst (s, f)
1. Return s.TABLES.

meminst (s, f)
1. Return s.MEMS.

moduleinst (s, f)
1. Return f.MODULE.

type (s, f) x
1. Return f.MODULE.TYPES[x].

func (s, f) x
1. Return s.FUNCS[f.MODULE.FUNCS[x]].

global (s, f) x
1. Return s.GLOBALS[f.MODULE.GLOBALS[x]].

table (s, f) x
1. Return s.TABLES[f.MODULE.TABLES[x]].

mem (s, f) x
1. Return s.MEMS[f.MODULE.MEMS[x]].

local (s, f) x
1. Return f.LOCALS[x].

with_local (s, f) x v
1. Replace f.LOCALS[x] with v.

with_global (s, f) x v
1. Replace s.GLOBALS[f.MODULE.GLOBALS[x]].VALUE with v.

with_table (s, f) x i a
1. Replace s.TABLES[f.MODULE.TABLES[x]].REFS[i] with ?(a).

with_tableinst (s, f) x ti
1. Replace s.TABLES[f.MODULE.TABLES[x]] with ti.

with_mem (s, f) x i j b*
1. Replace s.MEMS[f.MODULE.MEMS[x]].BYTES[i : j] with b*.

with_meminst (s, f) x mi
1. Replace s.MEMS[f.MODULE.MEMS[x]] with mi.

growtable ti n
1. Let { TYPE: ([ i .. j? ]); REFS: ?(a)* } be ti.
2. Let i' be (|a*| + n).
3. If (i' <= j)?, then:
  a. Let ti' be { TYPE: ([ i' .. j? ]); REFS: ?(a)* :: ?()^n }.
  b. Return ti'.
4. Fail.

growmemory mi n
1. Let { TYPE: ([ i .. j? ]); BYTES: b* } be mi.
2. Let i' be ((|b*| / (64 * $Ki())) + n).
3. If (i' <= j)?, then:
  a. Let mi' be { TYPE: ([ i' .. j? ]); BYTES: b* :: 0^(n * (64 * $Ki())) }.
  b. Return mi'.
4. Fail.

funcs externaddr''*
1. If (externaddr''* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr''*.
3. If externaddr_0 is some FUNC, then:
  a. Let (FUNC fa) be externaddr_0.
  b. Return [fa] :: $funcs(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr''*.
5. Return $funcs(externaddr'*).

globals externaddr''*
1. If (externaddr''* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr''*.
3. If externaddr_0 is some GLOBAL, then:
  a. Let (GLOBAL ga) be externaddr_0.
  b. Return [ga] :: $globals(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr''*.
5. Return $globals(externaddr'*).

tables externaddr''*
1. If (externaddr''* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr''*.
3. If externaddr_0 is some TABLE, then:
  a. Let (TABLE ta) be externaddr_0.
  b. Return [ta] :: $tables(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr''*.
5. Return $tables(externaddr'*).

mems externaddr''*
1. If (externaddr''* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr''*.
3. If externaddr_0 is some MEM, then:
  a. Let (MEM ma) be externaddr_0.
  b. Return [ma] :: $mems(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr''*.
5. Return $mems(externaddr'*).

allocfunc s moduleinst func
1. Let (FUNC x local* expr) be func.
2. Let fi be { TYPE: moduleinst.TYPES[x]; MODULE: moduleinst; CODE: func }.
3. Let a be |s.FUNCS|.
4. Append fi to the s.FUNCS.
5. Return a.

allocfuncs s moduleinst func''*
1. If (func''* = []), then:
  a. Return [].
2. Let [func] :: func'* be func''*.
3. Let fa be $allocfunc(s, moduleinst, func).
4. Let fa'* be $allocfuncs(s, moduleinst, func'*).
5. Return [fa] :: fa'*.

allocglobal s globaltype val
1. Let gi be { TYPE: globaltype; VALUE: val }.
2. Let a be |s.GLOBALS|.
3. Append gi to the s.GLOBALS.
4. Return a.

allocglobals s globaltype''* val''*
1. If (globaltype''* = []), then:
  a. Assert: Due to validation, (val''* = []).
  b. Return [].
2. Else:
  a. Let [globaltype] :: globaltype'* be globaltype''*.
  b. Assert: Due to validation, (|val''*| >= 1).
  c. Let [val] :: val'* be val''*.
  d. Let ga be $allocglobal(s, globaltype, val).
  e. Let ga'* be $allocglobals(s, globaltype'*, val'*).
  f. Return [ga] :: ga'*.

alloctable s ([ i .. j? ])
1. Let ti be { TYPE: ([ i .. j? ]); REFS: ?()^i }.
2. Let a be |s.TABLES|.
3. Append ti to the s.TABLES.
4. Return a.

alloctables s tabletype''*
1. If (tabletype''* = []), then:
  a. Return [].
2. Let [tabletype] :: tabletype'* be tabletype''*.
3. Let ta be $alloctable(s, tabletype).
4. Let ta'* be $alloctables(s, tabletype'*).
5. Return [ta] :: ta'*.

allocmem s ([ i .. j? ])
1. Let mi be { TYPE: ([ i .. j? ]); BYTES: 0^(i * (64 * $Ki())) }.
2. Let a be |s.MEMS|.
3. Append mi to the s.MEMS.
4. Return a.

allocmems s memtype''*
1. If (memtype''* = []), then:
  a. Return [].
2. Let [memtype] :: memtype'* be memtype''*.
3. Let ma be $allocmem(s, memtype).
4. Let ma'* be $allocmems(s, memtype'*).
5. Return [ma] :: ma'*.

instexport fa* ga* ta* ma* (EXPORT name externidx)
1. If externidx is some FUNC, then:
  a. Let (FUNC x) be externidx.
  b. Return { NAME: name; ADDR: (FUNC fa*[x]) }.
2. If externidx is some GLOBAL, then:
  a. Let (GLOBAL x) be externidx.
  b. Return { NAME: name; ADDR: (GLOBAL ga*[x]) }.
3. If externidx is some TABLE, then:
  a. Let (TABLE x) be externidx.
  b. Return { NAME: name; ADDR: (TABLE ta*[x]) }.
4. Assert: Due to validation, externidx is some MEM.
5. Let (MEM x) be externidx.
6. Return { NAME: name; ADDR: (MEM ma*[x]) }.

allocmodule s module externaddr* val*
1. Let (MODULE type_0* import* func^n_func global_1* table_2* mem_3* elem* data* start? export*) be module.
2. Let (MEMORY memtype)^n_mem be mem_3*.
3. Let (TABLE tabletype)^n_table be table_2*.
4. Let (GLOBAL globaltype expr_1)^n_global be global_1*.
5. Let ft* be [].
6. For each type_0 in type_0*, do:
  a. Let (TYPE ft) be type_0.
  b. Append ft to the ft*.
7. Let fa_ex* be $funcs(externaddr*).
8. Let ga_ex* be $globals(externaddr*).
9. Let ma_ex* be $mems(externaddr*).
10. Let ta_ex* be $tables(externaddr*).
11. Let fa* be (|s.FUNCS| + i_func)^(i_func<n_func).
12. Let ga* be (|s.GLOBALS| + i_global)^(i_global<n_global).
13. Let ta* be (|s.TABLES| + i_table)^(i_table<n_table).
14. Let ma* be (|s.MEMS| + i_mem)^(i_mem<n_mem).
15. Let xi* be [].
16. For each export in export*, do:
  a. Let xi be $instexport(fa_ex* :: fa*, ga_ex* :: ga*, ta_ex* :: ta*, ma_ex* :: ma*, export).
  b. Append xi to the xi*.
17. Let moduleinst be { TYPES: ft*; FUNCS: fa_ex* :: fa*; GLOBALS: ga_ex* :: ga*; TABLES: ta_ex* :: ta*; MEMS: ma_ex* :: ma*; EXPORTS: xi* }.
18. Let funcaddr_0* be $allocfuncs(s, moduleinst, func^n_func).
19. Assert: Due to validation, (funcaddr_0* = fa*).
20. Let globaladdr_0* be $allocglobals(s, globaltype^n_global, val*).
21. Assert: Due to validation, (globaladdr_0* = ga*).
22. Let tableaddr_0* be $alloctables(s, tabletype^n_table).
23. Assert: Due to validation, (tableaddr_0* = ta*).
24. Let memaddr_0* be $allocmems(s, memtype^n_mem).
25. Assert: Due to validation, (memaddr_0* = ma*).
26. Return moduleinst.

initelem s moduleinst u32* funcaddr*
1. If (funcaddr* = []), then:
  a. Assert: Due to validation, (u32* = []).
  b. Return.
2. Else:
  a. Let [a*] :: a'** be funcaddr*.
  b. Assert: Due to validation, (|u32*| >= 1).
  c. Let [i] :: i'* be u32*.
  d. Replace s.TABLES[moduleinst.TABLES[0]].REFS[i : |a*|] with ?(a)*.
  e. Perform $initelem(s, moduleinst, i'*, a'**).
  f. Return.

initdata s moduleinst u32* byte*
1. If (byte* = []), then:
  a. Assert: Due to validation, (u32* = []).
  b. Return.
2. Else:
  a. Let [b*] :: b'** be byte*.
  b. Assert: Due to validation, (|u32*| >= 1).
  c. Let [i] :: i'* be u32*.
  d. Replace s.MEMS[moduleinst.MEMS[0]].BYTES[i : |b*|] with b*.
  e. Perform $initdata(s, moduleinst, i'*, b'**).
  f. Return.

instantiate s module externaddr*
1. Let (MODULE type* import* func* global* table* mem* elem* data* start? export*) be module.
2. Let functype* be [].
3. For each type in type*, do:
  a. Let (TYPE functype) be type.
  b. Append functype to the functype*.
4. Let n_F be |func*|.
5. Let b** be [].
6. Let expr_D* be [].
7. For each data in data*, do:
  a. Let (DATA expr_D b*) be data.
  b. Append b* to the b**.
  c. Append expr_D to the expr_D*.
8. Let expr_E* be [].
9. Let x** be [].
10. For each elem in elem*, do:
  a. Let (ELEM expr_E x*) be elem.
  b. Append expr_E to the expr_E*.
  c. Append x* to the x**.
11. Let expr_G* be [].
12. For each global in global*, do:
  a. Let (GLOBAL globaltype expr_G) be global.
  b. Append expr_G to the expr_G*.
13. Let moduleinst_init be { TYPES: functype*; FUNCS: $funcs(externaddr*) :: (|s.FUNCS| + i_F)^(i_F<n_F); GLOBALS: $globals(externaddr*) }.
14. Let f_init be { MODULE: moduleinst_init }.
15. Let z be (s, f_init).
16. Push the frame (FRAME_ 0 { $frame(z) }) to the stack.
17. Let i_D* be [].
18. For each expr_D in expr_D*, do:
  a. Let [(I32.CONST i_D)] be $Eval_expr(z, expr_D).
  b. Append i_D to the i_D*.
19. Let i_E* be [].
20. For each expr_E in expr_E*, do:
  a. Let [(I32.CONST i_E)] be $Eval_expr(z, expr_E).
  b. Append i_E to the i_E*.
21. Let val* be [].
22. For each expr_G in expr_G*, do:
  a. Let [val] be $Eval_expr(z, expr_G).
  b. Append val to the val*.
23. Pop the frame (FRAME_ 0 { $frame(z) }) from the stack.
24. Let moduleinst be $allocmodule(s, module, externaddr*, val*).
25. Let f be { MODULE: moduleinst }.
26. Perform $initelem(s, moduleinst, i_E*, moduleinst.FUNCS[x]**).
27. Perform $initdata(s, moduleinst, i_D*, b**).
28. Push the frame (FRAME_ 0 { f }) to the stack.
29. If start? is defined, then:
  a. Let ?((START x')) be start?.
  b. Let instr_0 be (CALL x').
  c. Execute the instruction instr_0.
30. Pop the frame (FRAME_ 0 { f }) from the stack.
31. Return f.MODULE.

invoke s fa val^n
1. Let f be { MODULE: {} }.
2. Push the frame (FRAME_ 0 { (s, f) }) to the stack.
3. Let t_1^n -> t_2* be $funcinst((s, f))[fa].TYPE.
4. Pop the frame (FRAME_ 0 { _f }) from the stack.
5. Let k be |t_2*|.
6. Push the frame (FRAME_ k { f }) to the stack.
7. Push the values val^n to the stack.
8. Execute the instruction (CALL_ADDR fa).
9. Pop the values val'^k from the stack.
10. Pop the frame (FRAME_ k { f }) from the stack.
11. Return val'^k.

Eval_expr instr*
1. Execute the sequence instr*.
2. Pop the value val from the stack.
3. Return [val].

== Complete.
Generating prose for Wasm 2.0...
spectec 0.5 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...



The limits :math:`{}[ n .. {m^?} ]` is :ref:`valid <valid-val>` with :math:`k` if:


   * :math:`n` is less than or equal to :math:`k`.

   * If :math:`m` is defined, then:

      * :math:`n` is less than or equal to :math:`m`.

      * :math:`m` is less than or equal to :math:`k`.




The function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is always :ref:`valid <valid-val>`.




The global type :math:`({\mathsf{mut}^?}~t)` is always :ref:`valid <valid-val>`.




The table type :math:`({\mathit{limits}}~{\mathit{reftype}})` is :ref:`valid <valid-val>` if:


   * The limits :math:`{\mathit{limits}}` is :ref:`valid <valid-val>` with :math:`{2^{32}} - 1`.




The memory type :math:`{\mathit{limits}}~\mathsf{page}` is :ref:`valid <valid-val>` if:


   * The limits :math:`{\mathit{limits}}` is :ref:`valid <valid-val>` with :math:`{2^{16}}`.




The external type :math:`{\mathit{externtype}}` is :ref:`valid <valid-val>` if:


   * Either:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{func}~{\mathit{functype}})`.

      * The function type :math:`{\mathit{functype}}` is :ref:`valid <valid-val>`.

   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{global}~{\mathit{globaltype}})`.

      * The global type :math:`{\mathit{globaltype}}` is :ref:`valid <valid-val>`.
   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{table}~{\mathit{tabletype}})`.

      * The table type :math:`{\mathit{tabletype}}` is :ref:`valid <valid-val>`.
   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{mem}~{\mathit{memtype}})`.

      * The memory type :math:`{\mathit{memtype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{func}~{\mathit{functype}})` is :ref:`valid <valid-val>` if:


   * The function type :math:`{\mathit{functype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{global}~{\mathit{globaltype}})` is :ref:`valid <valid-val>` if:


   * The global type :math:`{\mathit{globaltype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{table}~{\mathit{tabletype}})` is :ref:`valid <valid-val>` if:


   * The table type :math:`{\mathit{tabletype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{mem}~{\mathit{memtype}})` is :ref:`valid <valid-val>` if:


   * The memory type :math:`{\mathit{memtype}}` is :ref:`valid <valid-val>`.




The value type :math:`t_2` :ref:`matches <match>` the value type :math:`t_1` if:


   * Either:

      * The value type :math:`t_2` is of the form :math:`t_1`.

   * Or:

      * The value type :math:`t_2` is of the form :math:`\mathsf{bot}`.




The value type :math:`t` :ref:`matches <match>` only itself.




The value type :math:`\mathsf{bot}` :ref:`matches <match>` the value type :math:`t`.




The result type :math:`{t_1^\ast}` :ref:`matches <match>` the result type :math:`{t_2^\ast}` if:


   * For all :math:`t_1` in :math:`{t_1^\ast}`, and corresponding :math:`t_2` in :math:`{t_2^\ast}`:

      * The value type :math:`t_1` :ref:`matches <match>` the value type :math:`t_2`.




The limits :math:`{}[ n_{11} .. n_{12} ]` :ref:`matches <match>` the limits :math:`{}[ n_{21} .. n_{22} ]` if:


   * :math:`n_{11}` is greater than or equal to :math:`n_{21}`.

   * :math:`n_{12}` is less than or equal to :math:`n_{22}`.




The function type :math:`{\mathit{ft}}` :ref:`matches <match>` only itself.




The global type :math:`{\mathit{gt}}` :ref:`matches <match>` only itself.




The table type :math:`({\mathit{lim}}_1~{\mathit{rt}})` :ref:`matches <match>` the table type :math:`({\mathit{lim}}_2~{\mathit{rt}})` if:


   * The limits :math:`{\mathit{lim}}_1` :ref:`matches <match>` the limits :math:`{\mathit{lim}}_2`.




The memory type :math:`{\mathit{lim}}_1~\mathsf{page}` :ref:`matches <match>` the memory type :math:`{\mathit{lim}}_2~\mathsf{page}` if:


   * The limits :math:`{\mathit{lim}}_1` :ref:`matches <match>` the limits :math:`{\mathit{lim}}_2`.




The external type :math:`{\mathit{externtype}}_1` :ref:`matches <match>` the external type :math:`{\mathit{externtype}}_2` if:


   * Either:

      * The external type :math:`{\mathit{externtype}}_1` is of the form :math:`(\mathsf{func}~{\mathit{ft}}_1)`.

      * The external type :math:`{\mathit{externtype}}_2` is of the form :math:`(\mathsf{func}~{\mathit{ft}}_2)`.

      * The function type :math:`{\mathit{ft}}_1` :ref:`matches <match>` the function type :math:`{\mathit{ft}}_2`.

   * Or:

      * The external type :math:`{\mathit{externtype}}_1` is of the form :math:`(\mathsf{global}~{\mathit{gt}}_1)`.

      * The external type :math:`{\mathit{externtype}}_2` is of the form :math:`(\mathsf{global}~{\mathit{gt}}_2)`.

      * The global type :math:`{\mathit{gt}}_1` :ref:`matches <match>` the global type :math:`{\mathit{gt}}_2`.
   * Or:

      * The external type :math:`{\mathit{externtype}}_1` is of the form :math:`(\mathsf{table}~{\mathit{tt}}_1)`.

      * The external type :math:`{\mathit{externtype}}_2` is of the form :math:`(\mathsf{table}~{\mathit{tt}}_2)`.

      * The table type :math:`{\mathit{tt}}_1` :ref:`matches <match>` the table type :math:`{\mathit{tt}}_2`.
   * Or:

      * The external type :math:`{\mathit{externtype}}_1` is of the form :math:`(\mathsf{mem}~{\mathit{mt}}_1)`.

      * The external type :math:`{\mathit{externtype}}_2` is of the form :math:`(\mathsf{mem}~{\mathit{mt}}_2)`.

      * The memory type :math:`{\mathit{mt}}_1` :ref:`matches <match>` the memory type :math:`{\mathit{mt}}_2`.




The external type :math:`(\mathsf{func}~{\mathit{ft}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{func}~{\mathit{ft}}_2)` if:


   * The function type :math:`{\mathit{ft}}_1` :ref:`matches <match>` the function type :math:`{\mathit{ft}}_2`.




The external type :math:`(\mathsf{global}~{\mathit{gt}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{global}~{\mathit{gt}}_2)` if:


   * The global type :math:`{\mathit{gt}}_1` :ref:`matches <match>` the global type :math:`{\mathit{gt}}_2`.




The external type :math:`(\mathsf{table}~{\mathit{tt}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{table}~{\mathit{tt}}_2)` if:


   * The table type :math:`{\mathit{tt}}_1` :ref:`matches <match>` the table type :math:`{\mathit{tt}}_2`.




The external type :math:`(\mathsf{mem}~{\mathit{mt}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{mem}~{\mathit{mt}}_2)` if:


   * The memory type :math:`{\mathit{mt}}_1` :ref:`matches <match>` the memory type :math:`{\mathit{mt}}_2`.




The block type :math:`{\mathit{blocktype}}` is :ref:`valid <valid-val>` with the function type :math:`{{\mathit{valtype}}^\ast}~\rightarrow~{{\mathit{valtype}'}^\ast}` if:


   * Either:

      * The block type :math:`{\mathit{blocktype}}` is of the form :math:`{{\mathit{valtype}''}^?}`.

      * The value type sequence :math:`{{\mathit{valtype}}^\ast}` is empty.

      * The value type sequence :math:`{{\mathit{valtype}'}^\ast}` is of the form :math:`{{\mathit{valtype}''}^?}`.

   * Or:

      * The block type :math:`{\mathit{blocktype}}` is of the form :math:`{\mathit{typeidx}}`.

      * The function type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

      * The function type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is of the form :math:`{{\mathit{valtype}}^\ast}~\rightarrow~{{\mathit{valtype}'}^\ast}`.




The block type :math:`{{\mathit{valtype}}^?}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~{{\mathit{valtype}}^?}`.




The block type :math:`{\mathit{typeidx}}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The function type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

   * The function type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is of the form :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`\mathsf{nop}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction :math:`\mathsf{unreachable}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`\mathsf{drop}` is :ref:`valid <valid-val>` with the function type :math:`t~\rightarrow~\epsilon`.




The instruction :math:`(\mathsf{select}~{{\mathit{valtype}}^?})` is :ref:`valid <valid-val>` with the function type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


   * Either:

      * The value type sequence :math:`{{\mathit{valtype}}^?}` is of the form :math:`t`.

   * Or:

      * The value type sequence :math:`{{\mathit{valtype}}^?}` is absent.

      * The value type :math:`t` :ref:`matches <match>` the value type :math:`{t'}`.

      * The value type :math:`{t'}` is of the form :math:`{\mathit{numtype}}` or :math:`{t'}` is of the form :math:`{\mathit{vectype}}`.




The instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}^\ast})` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{bt}}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`(\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast})` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{bt}}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_1^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`(\mathsf{if}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast})` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{bt}}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_1^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`(\mathsf{br}~l)` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The result type :math:`C{.}\mathsf{labels}{}[l]` is of the form :math:`{t^\ast}`.




The instruction :math:`(\mathsf{br\_if}~l)` is :ref:`valid <valid-val>` with the function type :math:`{t^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t^\ast}` if:


   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The result type :math:`C{.}\mathsf{labels}{}[l]` is of the form :math:`{t^\ast}`.




The instruction :math:`(\mathsf{br\_table}~{l^\ast}~{l'})` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~{t^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


   * For all :math:`l` in :math:`{l^\ast}`:

      * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

      * The result type :math:`{t^\ast}` :ref:`matches <match>` the result type :math:`C{.}\mathsf{labels}{}[l]`.

   * The result type :math:`C{.}\mathsf{labels}{}[{l'}]` exists.

   * The result type :math:`{t^\ast}` :ref:`matches <match>` the result type :math:`C{.}\mathsf{labels}{}[{l'}]`.




The instruction :math:`(\mathsf{call}~x)` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`(\mathsf{call\_indirect}~x~y)` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{lim}}~\mathsf{funcref})`.

   * The function type :math:`C{.}\mathsf{types}{}[y]` exists.

   * The function type :math:`C{.}\mathsf{types}{}[y]` is of the form :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`\mathsf{return}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


   * The result type :math:`C{.}\mathsf{return}` is of the form :math:`{t^\ast}`.




The instruction :math:`({\mathit{nt}}{.}\mathsf{const}~c_{\mathit{nt}})` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}}~{.}~{\mathit{unop}}_{\mathit{nt}})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{nt}}~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}}~{.}~{\mathit{binop}}_{\mathit{nt}})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{nt}}~{\mathit{nt}}~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}}~{.}~{\mathit{testop}}_{\mathit{nt}})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{nt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{nt}}~{.}~{\mathit{relop}}_{\mathit{nt}})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{nt}}~{\mathit{nt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({{\mathit{nt}}_1~{.}~{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_2})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1` if:


   * Either:

      * :math:`{\mathit{cvtop}}` is of the form :math:`\mathsf{reinterpret}`.

      * :math:`{|{\mathit{nt}}_1|}` is of the form :math:`{|{\mathit{nt}}_2|}`.

   * Or:




The instruction :math:`(\mathsf{ref{.}null}~{\mathit{rt}})` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~{\mathit{rt}}`.




The instruction :math:`(\mathsf{ref{.}func}~x)` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\mathsf{funcref}` if:


   * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.




The instruction :math:`\mathsf{ref{.}is\_null}` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{rt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}~{.}~{\mathit{vvunop}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}~{.}~{\mathit{vvbinop}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}~{.}~{\mathit{vvternop}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}~{.}~{\mathit{vvtestop}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}}~{.}~{\mathit{vunop}}_{\mathit{sh}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}~{.}~{\mathit{vbinop}}_{\mathit{sh}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}~{.}~{\mathit{vtestop}}_{\mathit{sh}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}}~{.}~{\mathit{vrelop}}_{\mathit{sh}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}~{.}~{\mathit{vshiftop}}_{\mathit{sh}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{bitmask})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{swizzle})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{shuffle}~{i^\ast})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * For all :math:`i` in :math:`{i^\ast}`:

      * The lane index :math:`i` is less than :math:`2 \cdot {\mathrm{dim}}({\mathit{sh}})`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{splat})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{numtype}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The number type :math:`{\mathit{numtype}}` is :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`({{\mathit{sh}}{.}\mathsf{extract\_lane}}{{{\mathit{sx}}^?}}~i)` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~{\mathit{numtype}}` if:


   * The lane index :math:`i` is less than :math:`{\mathrm{dim}}({\mathit{sh}})`.

   * The number type :math:`{\mathit{numtype}}` is :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{replace\_lane}~i)` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~{\mathit{numtype}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The lane index :math:`i` is less than :math:`{\mathrm{dim}}({\mathit{sh}})`.

   * The number type :math:`{\mathit{numtype}}` is :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`(\mathsf{vextunop}~{\mathit{sh}}_1~{\mathit{sh}}_2~{\mathit{vextunop}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{vextbinop}~{\mathit{sh}}_1~{\mathit{sh}}_2~{\mathit{vextbinop}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({{\mathit{sh}}_1{.}\mathsf{narrow}}{\mathsf{\_}}{{\mathit{sh}}_2}{\mathsf{\_}}{{\mathit{sx}}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({{\mathit{sh}}_1~{.}~{\mathit{vcvtop}}}{\mathsf{\_}}{{\mathit{sh}}_2})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{local{.}get}~x)` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~t` if:


   * The value type :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The value type :math:`C{.}\mathsf{locals}{}[x]` is of the form :math:`t`.




The instruction :math:`(\mathsf{local{.}set}~x)` is :ref:`valid <valid-val>` with the function type :math:`t~\rightarrow~\epsilon` if:


   * The value type :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The value type :math:`C{.}\mathsf{locals}{}[x]` is of the form :math:`t`.




The instruction :math:`(\mathsf{local{.}tee}~x)` is :ref:`valid <valid-val>` with the function type :math:`t~\rightarrow~t` if:


   * The value type :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The value type :math:`C{.}\mathsf{locals}{}[x]` is of the form :math:`t`.




The instruction :math:`(\mathsf{global{.}get}~x)` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~t` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`({\mathit{mut}}~t)`.




The instruction :math:`(\mathsf{global{.}set}~x)` is :ref:`valid <valid-val>` with the function type :math:`t~\rightarrow~\epsilon` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`(\mathsf{mut}~t)`.




The instruction :math:`(\mathsf{table{.}get}~x)` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathit{rt}}` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}set}~x)` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathit{rt}}~\rightarrow~\epsilon` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}size}~x)` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}grow}~x)` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{rt}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}fill}~x)` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathit{rt}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}copy}~x_1~x_2)` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x_1]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x_1]` is of the form :math:`({\mathit{lim}}_1~{\mathit{rt}})`.

   * The table type :math:`C{.}\mathsf{tables}{}[x_2]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x_2]` is of the form :math:`({\mathit{lim}}_2~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}init}~x_1~x_2)` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x_1]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x_1]` is of the form :math:`({\mathit{lim}}~{\mathit{rt}})`.

   * The element type :math:`C{.}\mathsf{elems}{}[x_2]` exists.

   * The reference type :math:`C{.}\mathsf{elems}{}[x_2]` is of the form :math:`{\mathit{rt}}`.




The instruction :math:`(\mathsf{elem{.}drop}~x)` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\epsilon` if:


   * The element type :math:`C{.}\mathsf{elems}{}[x]` exists.




The instruction :math:`\mathsf{memory{.}size}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`\mathsf{memory{.}grow}` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`\mathsf{memory{.}fill}` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon`.




The instruction :math:`\mathsf{memory{.}copy}` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon`.




The instruction :math:`(\mathsf{memory{.}init}~x)` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The data type :math:`C{.}\mathsf{datas}{}[x]` exists.

   * The data type :math:`C{.}\mathsf{datas}{}[x]` is of the form :math:`\mathsf{ok}`.




The instruction :math:`(\mathsf{data{.}drop}~x)` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\epsilon` if:


   * The data type :math:`C{.}\mathsf{datas}{}[x]` exists.

   * The data type :math:`C{.}\mathsf{datas}{}[x]` is of the form :math:`\mathsf{ok}`.




The instruction :math:`({{\mathit{nt}}{.}\mathsf{load}}{{{\mathit{loadop}}^?}}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathit{valtype}}` if:


   * Either:

      * :math:`{{\mathit{loadop}}^?}` is absent.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathit{nt}}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

   * Or:

      * The number type :math:`{\mathit{nt}}` is of the form :math:`{\mathsf{i}}{n}`.

      * :math:`{{\mathit{loadop}}^?}` is of the form :math:`{M}{\mathsf{\_}}{{\mathit{sx}}}`.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathsf{i}}{n}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({{\mathit{nt}}{.}\mathsf{store}}{{{\mathit{sz}}^?}}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathit{valtype}}~\rightarrow~\epsilon` if:


   * Either:

      * The pack size :math:`{{\mathit{sz}}^?}` is absent.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathit{nt}}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

   * Or:

      * The number type :math:`{\mathit{nt}}` is of the form :math:`{\mathsf{i}}{n}`.

      * The pack size :math:`{{\mathit{sz}}^?}` is of the form :math:`M`.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathsf{i}}{n}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~{\mathit{vloadop}}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * Either:

      * :math:`{\mathit{vloadop}}` is of the form :math:`({M}{\mathsf{x}}{N}{\mathsf{\_}}{{\mathit{sx}}})`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8 \cdot N`.

   * Or:

      * :math:`{\mathit{vloadop}}` is of the form :math:`({n}{\mathsf{\_}}{\mathsf{splat}})`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.
   * Or:

      * :math:`{\mathit{vloadop}}` is of the form :math:`({n}{\mathsf{\_}}{\mathsf{zero}})`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.




The instruction :math:`(\mathsf{vload\_lane}~\mathsf{v{\scriptstyle 128}}~n~{\mathit{memarg}}~{\mathit{laneidx}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.

   * :math:`{\mathit{laneidx}}` is less than :math:`128 / n`.




The instruction :math:`(\mathsf{vstore}~\mathsf{v{\scriptstyle 128}}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\epsilon` if:


   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|\mathsf{v{\scriptstyle 128}}|} / 8`.




The instruction :math:`(\mathsf{vstore\_lane}~\mathsf{v{\scriptstyle 128}}~n~{\mathit{memarg}}~{\mathit{laneidx}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\epsilon` if:


   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.

   * :math:`{\mathit{laneidx}}` is less than :math:`128 / n`.




The instruction :math:`(\mathsf{select}~t)` is :ref:`valid <valid-val>` with the function type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t`.




The instruction :math:`(\mathsf{select})` is :ref:`valid <valid-val>` with the function type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


   * The value type :math:`t` :ref:`matches <match>` the value type :math:`{t'}`.

   * The value type :math:`{t'}` is of the form :math:`{\mathit{numtype}}` or :math:`{t'}` is of the form :math:`{\mathit{vectype}}`.




The instruction :math:`({{\mathit{nt}}_1~{.}~\mathsf{reinterpret}}{\mathsf{\_}}{{\mathit{nt}}_2})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1` if:


   * :math:`{|{\mathit{nt}}_1|}` is of the form :math:`{|{\mathit{nt}}_2|}`.




The instruction :math:`({{\mathit{nt}}_1~{.}~{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_2})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1`.




The instruction :math:`(\mathsf{load}~{\mathit{nt}}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathit{nt}}` if:


   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.




The instruction :math:`({{\mathsf{i}}{n}{.}\mathsf{load}}{{M}{\mathsf{\_}}{{\mathit{sx}}}}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathsf{i}}{n}` if:


   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`(\mathsf{store}~{\mathit{nt}}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathit{nt}}~\rightarrow~\epsilon` if:


   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.




The instruction :math:`({{\mathsf{i}}{n}{.}\mathsf{store}}{M}~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathsf{i}}{n}~\rightarrow~\epsilon` if:


   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~({M}{\mathsf{x}}{N}{\mathsf{\_}}{{\mathit{sx}}})~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8 \cdot N`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~({n}{\mathsf{\_}}{\mathsf{splat}})~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~({n}{\mathsf{\_}}{\mathsf{zero}})~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{{\mathit{valtype}}^\ast}~\rightarrow~{{\mathit{valtype}'}^\ast}` if:


   * Either:

      * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is empty.

      * The value type sequence :math:`{{\mathit{valtype}}^\ast}` is empty.

      * The value type sequence :math:`{{\mathit{valtype}'}^\ast}` is empty.

   * Or:

      * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is of the form :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}`.

      * The instruction :math:`{\mathit{instr}}_1` is :ref:`valid <valid-val>` with the function type :math:`{{\mathit{valtype}}^\ast}~\rightarrow~{t_2^\ast}`.

      * The instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_2^\ast}~\rightarrow~{{\mathit{valtype}'}^\ast}`.
   * Or:

      * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

      * The result type :math:`{{\mathit{valtype}}^\ast}` :ref:`matches <match>` the result type :math:`{t_1^\ast}`.

      * The result type :math:`{t_2^\ast}` :ref:`matches <match>` the result type :math:`{{\mathit{valtype}'}^\ast}`.
   * Or:

      * The value type sequence :math:`{{\mathit{valtype}}^\ast}` is of the form :math:`{t^\ast}~{t_1^\ast}`.

      * The value type sequence :math:`{{\mathit{valtype}'}^\ast}` is of the form :math:`{t^\ast}~{t_2^\ast}`.

      * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction sequence :math:`\epsilon` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction sequence :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_3^\ast}` if:


   * The instruction :math:`{\mathit{instr}}_1` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * The instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_2^\ast}~\rightarrow~{t_3^\ast}`.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{{t'}_1^\ast}~\rightarrow~{{t'}_2^\ast}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * The result type :math:`{{t'}_1^\ast}` :ref:`matches <match>` the result type :math:`{t_1^\ast}`.

   * The result type :math:`{t_2^\ast}` :ref:`matches <match>` the result type :math:`{{t'}_2^\ast}`.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t^\ast}~{t_1^\ast}~\rightarrow~{t^\ast}~{t_2^\ast}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The expression :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the result type :math:`{t^\ast}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the function type :math:`\epsilon~\rightarrow~{t^\ast}`.




:math:`{\mathit{val}}` is constant if:


   * Either:

      * The value :math:`{\mathit{val}}` is of the form :math:`({\mathit{nt}}{.}\mathsf{const}~c)`.

   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`({\mathit{vt}}{.}\mathsf{const}~{\mathit{vc}})`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{ref{.}null}~{\mathit{rt}})`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{ref{.}func}~x)`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{global{.}get}~x)`.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`(\epsilon~t)`.




:math:`({\mathit{nt}}{.}\mathsf{const}~c)` is constant.




:math:`({\mathit{vt}}{.}\mathsf{const}~{\mathit{vc}})` is constant.




:math:`(\mathsf{ref{.}null}~{\mathit{rt}})` is constant.




:math:`(\mathsf{ref{.}func}~x)` is constant.




:math:`(\mathsf{global{.}get}~x)` is constant if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`(\epsilon~t)`.




:math:`{{\mathit{instr}}^\ast}` is constant if:


   * For all :math:`{\mathit{instr}}` in :math:`{{\mathit{instr}}^\ast}`:

      * :math:`{\mathit{instr}}` is constant.




The type :math:`(\mathsf{type}~{\mathit{ft}})` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{ft}}` if:


   * The function type :math:`{\mathit{ft}}` is :ref:`valid <valid-val>`.




The function :math:`(\mathsf{func}~x~{(\mathsf{local}~t)^\ast}~{\mathit{expr}})` is :ref:`valid <valid-val>` with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The function type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{types}{}[x]` is of the form :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * For all :math:`t` in :math:`{t^\ast}`:

      * The value type :math:`t` is not of the form :math:`\mathsf{bot}`.

   * Under the context :math:`C` with the field :math:`\mathsf{locals}` appended by :math:`{t_1^\ast}~{t^\ast}` and the field :math:`\mathsf{labels}` appended by :math:`{t_2^\ast}` and the field :math:`\mathsf{return}` appended by :math:`{t_2^\ast}`, the expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the result type :math:`{t_2^\ast}`.




The global :math:`(\mathsf{global}~{\mathit{gt}}~{\mathit{expr}})` is :ref:`valid <valid-val>` with the global type :math:`{\mathit{gt}}` if:


   * The global type :math:`{\mathit{gt}}` is :ref:`valid <valid-val>`.

   * The global type :math:`{\mathit{gt}}` is of the form :math:`({\mathit{mut}}~t)`.

   * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`t`.

   * :math:`{\mathit{expr}}` is constant.




The table :math:`(\mathsf{table}~{\mathit{tt}})` is :ref:`valid <valid-val>` with the table type :math:`{\mathit{tt}}` if:


   * The table type :math:`{\mathit{tt}}` is :ref:`valid <valid-val>`.




The memory :math:`(\mathsf{memory}~{\mathit{mt}})` is :ref:`valid <valid-val>` with the memory type :math:`{\mathit{mt}}` if:


   * The memory type :math:`{\mathit{mt}}` is :ref:`valid <valid-val>`.




:math:`{\mathit{elemmode}}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}}` if:


   * Either:

      * :math:`{\mathit{elemmode}}` is of the form :math:`(\mathsf{active}~x~{\mathit{expr}})`.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{lim}}~{\mathit{rt}})`.

      * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`\mathsf{i{\scriptstyle 32}}`.

      * :math:`{\mathit{expr}}` is constant.

   * Or:

      * :math:`{\mathit{elemmode}}` is of the form :math:`\mathsf{passive}`.
   * Or:

      * :math:`{\mathit{elemmode}}` is of the form :math:`\mathsf{declare}`.




:math:`(\mathsf{active}~x~{\mathit{expr}})` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}}` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{lim}}~{\mathit{rt}})`.

   * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`\mathsf{i{\scriptstyle 32}}`.

   * :math:`{\mathit{expr}}` is constant.




:math:`\mathsf{passive}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}}`.




:math:`\mathsf{declare}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}}`.




The table segment :math:`(\mathsf{elem}~{\mathit{rt}}~{{\mathit{expr}}^\ast}~{\mathit{elemmode}})` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}}` if:


   * For all :math:`{\mathit{expr}}` in :math:`{{\mathit{expr}}^\ast}`:

      * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{rt}}`.

      * :math:`{\mathit{expr}}` is constant.

   * :math:`{\mathit{elemmode}}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}}`.




:math:`{\mathit{datamode}}` is :ref:`valid <valid-val>` if:


   * Either:

      * :math:`{\mathit{datamode}}` is of the form :math:`(\mathsf{active}~0~{\mathit{expr}})`.

      * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`\mathsf{i{\scriptstyle 32}}`.

      * :math:`{\mathit{expr}}` is constant.

   * Or:

      * :math:`{\mathit{datamode}}` is of the form :math:`\mathsf{passive}`.




:math:`(\mathsf{active}~0~{\mathit{expr}})` is :ref:`valid <valid-val>` if:


   * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`\mathsf{i{\scriptstyle 32}}`.

   * :math:`{\mathit{expr}}` is constant.




:math:`\mathsf{passive}` is always :ref:`valid <valid-val>`.




The memory segment :math:`(\mathsf{data}~{b^\ast}~{\mathit{datamode}})` is :ref:`valid <valid-val>` if:


   * :math:`{\mathit{datamode}}` is :ref:`valid <valid-val>`.




The start function :math:`(\mathsf{start}~x)` is :ref:`valid <valid-val>` if:


   * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`\epsilon~\rightarrow~\epsilon`.




The import :math:`(\mathsf{import}~{\mathit{name}}_1~{\mathit{name}}_2~{\mathit{xt}})` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}` if:


   * The external type :math:`{\mathit{xt}}` is :ref:`valid <valid-val>`.




The external index :math:`{\mathit{externidx}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{externtype}}` if:


   * Either:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{func}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{func}~{\mathit{ft}})`.

      * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

      * The function type :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`{\mathit{ft}}`.

   * Or:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{global}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{global}~{\mathit{gt}})`.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`{\mathit{gt}}`.
   * Or:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{table}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{table}~{\mathit{tt}})`.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`{\mathit{tt}}`.
   * Or:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{mem}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{mem}~{\mathit{mt}})`.

      * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

      * The memory type :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`{\mathit{mt}}`.




The external index :math:`(\mathsf{func}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{func}~{\mathit{ft}})` if:


   * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`{\mathit{ft}}`.




The external index :math:`(\mathsf{global}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{global}~{\mathit{gt}})` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`{\mathit{gt}}`.




The external index :math:`(\mathsf{table}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{table}~{\mathit{tt}})` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`{\mathit{tt}}`.




The external index :math:`(\mathsf{mem}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{mem}~{\mathit{mt}})` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`{\mathit{mt}}`.




The export :math:`(\mathsf{export}~{\mathit{name}}~{\mathit{externidx}})` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}` if:


   * The external index :math:`{\mathit{externidx}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}`.




The module :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^{n}}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` is :ref:`valid <valid-val>` if:


   * For all :math:`{\mathit{type}}` in :math:`{{\mathit{type}}^\ast}`:

      * The type :math:`{\mathit{type}}` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{ft}'}`.

   * :math:`{{\mathit{ft}'}^\ast}` is the concatenation of all such :math:`{\mathit{ft}'}`.

   * For all :math:`{\mathit{import}}` in :math:`{{\mathit{import}}^\ast}`:

      * Under the context :math:`\{ \mathsf{types}~{{\mathit{ft}'}^\ast},\;\allowbreak \mathsf{return}~\epsilon \}`, the import :math:`{\mathit{import}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{ixt}}`.

   * :math:`{{\mathit{ixt}}^\ast}` is the concatenation of all such :math:`{\mathit{ixt}}`.

   * For all :math:`{\mathit{global}}` in :math:`{{\mathit{global}}^\ast}`:

      * Under the context :math:`{C'}`, the global :math:`{\mathit{global}}` is :ref:`valid <valid-val>` with the global type :math:`{\mathit{gt}}`.

   * :math:`{{\mathit{gt}}^\ast}` is the concatenation of all such :math:`{\mathit{gt}}`.

   * For all :math:`{\mathit{table}}` in :math:`{{\mathit{table}}^\ast}`:

      * Under the context :math:`{C'}`, the table :math:`{\mathit{table}}` is :ref:`valid <valid-val>` with the table type :math:`{\mathit{tt}}`.

   * :math:`{{\mathit{tt}}^\ast}` is the concatenation of all such :math:`{\mathit{tt}}`.

   * For all :math:`{\mathit{mem}}` in :math:`{{\mathit{mem}}^\ast}`:

      * Under the context :math:`{C'}`, the memory :math:`{\mathit{mem}}` is :ref:`valid <valid-val>` with the memory type :math:`{\mathit{mt}}`.

   * :math:`{{\mathit{mt}}^\ast}` is the concatenation of all such :math:`{\mathit{mt}}`.

   * For all :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}`:

      * Under the context :math:`{C'}`, the table segment :math:`{\mathit{elem}}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}}`.

   * :math:`{{\mathit{rt}}^\ast}` is the concatenation of all such :math:`{\mathit{rt}}`.

   * For all :math:`{\mathit{data}}` in :math:`{{\mathit{data}}^\ast}`:

      * Under the context :math:`{C'}`, the memory segment :math:`{\mathit{data}}` is :ref:`valid <valid-val>`.

   * For all :math:`{\mathit{func}}` in :math:`{{\mathit{func}}^\ast}`:

      * The function :math:`{\mathit{func}}` is :ref:`valid <valid-val>` with the function type :math:`{\mathit{ft}}`.

   * :math:`{{\mathit{ft}}^\ast}` is the concatenation of all such :math:`{\mathit{ft}}`.

   * If :math:`{\mathit{start}}` is defined, then:

      * The start function :math:`{\mathit{start}}` is :ref:`valid <valid-val>`.

   * For all :math:`{\mathit{export}}` in :math:`{{\mathit{export}}^\ast}`:

      * The export :math:`{\mathit{export}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}`.

   * The length of :math:`{{\mathit{mt}}^\ast}` is less than or equal to :math:`1`.

   * The context :math:`{C'}` is of the form :math:`\{ \mathsf{types}~{{\mathit{ft}'}^\ast},\;\allowbreak \mathsf{funcs}~{{\mathit{ift}}^\ast}~{{\mathit{ft}}^\ast},\;\allowbreak \mathsf{globals}~{{\mathit{igt}}^\ast},\;\allowbreak \mathsf{tables}~{{\mathit{itt}}^\ast}~{{\mathit{tt}}^\ast},\;\allowbreak \mathsf{mems}~{{\mathit{imt}}^\ast}~{{\mathit{mt}}^\ast},\;\allowbreak \mathsf{return}~\epsilon \}`.

   * The function type sequence :math:`{{\mathit{ift}}^\ast}` is of the form :math:`{\mathrm{funcs}}({{\mathit{ixt}}^\ast})`.

   * The global type sequence :math:`{{\mathit{igt}}^\ast}` is of the form :math:`{\mathrm{globals}}({{\mathit{ixt}}^\ast})`.

   * The table type sequence :math:`{{\mathit{itt}}^\ast}` is of the form :math:`{\mathrm{tables}}({{\mathit{ixt}}^\ast})`.

   * The memory type sequence :math:`{{\mathit{imt}}^\ast}` is of the form :math:`{\mathrm{mems}}({{\mathit{ixt}}^\ast})`.


:math:`\mathsf{table{.}copy}~x~y`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{tables}{}[y]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.


:math:`\mathsf{table{.}init}~x~y`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.


:math:`\mathsf{load}~{\mathit{nt}}~{\mathit{ao}}`
.................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}}|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathit{nt}}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}}|} / 8]`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}{.}\mathsf{load}}{{n}{\mathsf{\_}}{{\mathit{sx}}}}~{\mathit{ao}}`
........................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8]`.

#. Push the value :math:`({\mathsf{i}}{n}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{n, {|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{(c)})` to the stack.


:math:`\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~({M}{\mathsf{x}}{N}{\mathsf{\_}}{{\mathit{sx}}})~{\mathit{ao}}`
...................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + M \cdot N / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`{j^{N}}` be the result for which :math:`{({{\mathrm{bytes}}}_{{\mathsf{i}}{M}}({j^{N}}) = z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} + k \cdot M / 8 : M / 8])^{k<N}}`.

#. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`M \cdot 2`.

#. Let :math:`c` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{{{{\mathrm{extend}}}_{M, {|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{(j)}^{N}})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~({N}{\mathsf{\_}}{\mathsf{splat}})~{\mathit{ao}}`
.....................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`M` be :math:`128 / N`.

#. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`N`.

#. Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

#. Let :math:`c` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({j^{M}})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~({N}{\mathsf{\_}}{\mathsf{zero}})~{\mathit{ao}}`
....................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

#. Let :math:`c` be :math:`{{{{\mathrm{extend}}}_{N, 128}^{\mathsf{u}}}}{(j)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{memory{.}copy}`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.


:math:`\mathsf{memory{.}init}~x`
................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{datas}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.


:math:`\mathsf{store}~{\mathit{nt}}~{\mathit{ao}}`
..................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}}|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathit{nt}}}(c)`.

#. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}}|} / 8] = {b^\ast}]`.


:math:`{{\mathsf{i}}{n}{.}\mathsf{store}}{n}~{\mathit{ao}}`
...........................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`{\mathsf{i}}{n}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}({{\mathrm{wrap}}}_{{|{\mathsf{i}}{n}|}, n}(c))`.

#. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8] = {b^\ast}]`.


:math:`\mathsf{unreachable}`
............................


1. Trap.


:math:`\mathsf{nop}`
....................


1. Do nothing.


:math:`\mathsf{drop}`
.....................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.


:math:`\mathsf{select}~{({t^\ast})^?}`
......................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_2` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_1` from the stack.

#. If :math:`c \neq 0`, then:

   a. Push the value :math:`{\mathit{val}}_1` to the stack.

#. Else:

   a. Push the value :math:`{\mathit{val}}_2` to the stack.


:math:`\mathsf{if}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast}~{{\mathit{instr}}_2^\ast}`
.....................................................................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

   a. Execute the instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast})`.

#. Else:

   a. Execute the instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}_2^\ast})`.


:math:`\mathsf{label}`
......................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

#. Pop the :math:`\mathsf{label}` from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.


:math:`\mathsf{br}~{n'}`
........................


1. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

#. Let :math:`L` be the topmost :math:`\mathsf{label}`.

#. Let :math:`n` be the arity of :math:`L`

#. If :math:`{n'} = 0`, then:

   a. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

   #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

   #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{label}` from the stack.

   #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

   #. Jump to the continuation of :math:`L`.

#. Else:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Let :math:`l` be the label index :math:`{n'} - 1`.

   #. Pop the :math:`\mathsf{label}` from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{br\_if}~l`
.........................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

   a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

   a. Do nothing.


:math:`\mathsf{br\_table}~{l^\ast}~{l'}`
........................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i < {|{l^\ast}|}`, then:

   a. Execute the instruction :math:`(\mathsf{br}~{l^\ast}{}[i])`.

#. Else:

   a. Execute the instruction :math:`(\mathsf{br}~{l'})`.


:math:`\mathsf{frame}`
......................


1. Let :math:`f` be the topmost :math:`\mathsf{frame}`.

#. Let :math:`n` be the arity of :math:`f`

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{frame}`.

#. Pop the :math:`\mathsf{frame}` from the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.


:math:`\mathsf{return}`
.......................


1. If the first non-value entry of the stack is a :math:`\mathsf{frame}`, then:

   a. Let :math:`f` be the topmost :math:`\mathsf{frame}`.

   #. Let :math:`n` be the arity of :math:`f`

   #. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

   #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

   #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{frame}` from the stack.

   #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Else:

   a. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

   #. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{label}` from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`\mathsf{return}`.


:math:`{\mathit{nt}}~{.}~{\mathit{unop}}`
.........................................


1. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{unop}}}{{}_{{\mathit{nt}}}}{(c_1)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{unop}}}{{}_{{\mathit{nt}}}}{(c_1)}`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}}~{.}~{\mathit{binop}}`
..........................................


1. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a number is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{binop}}}{{}_{{\mathit{nt}}}}{(c_1, c_2)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{binop}}}{{}_{{\mathit{nt}}}}{(c_1, c_2)}`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}}~{.}~{\mathit{testop}}`
...........................................


1. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{testop}}}{{}_{{\mathit{nt}}}}{(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}}~{.}~{\mathit{relop}}`
..........................................


1. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a number is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{relop}}}{{}_{{\mathit{nt}}}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathit{nt}}_2~{.}~{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_1}`
............................................................................


1. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}_1` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{cvtop}}}{{}_{{\mathit{nt}}_1, {\mathit{nt}}_2}}{(c_1)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{cvtop}}}{{}_{{\mathit{nt}}_1, {\mathit{nt}}_2}}{(c_1)}`.

#. Push the value :math:`({\mathit{nt}}_2{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{ref{.}is\_null}`
...............................


1. Assert: Due to validation, a reference is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. If :math:`{\mathit{ref}}` is some :math:`\mathsf{ref{.}null}~{\mathit{reftype}}`, then:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}}~{.}~{\mathit{vvunop}}`
..........................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vvunop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}}~{.}~{\mathit{vvbinop}}`
...........................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vvbinop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}}~{.}~{\mathit{vvternop}}`
............................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_3)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vvternop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2, c_3)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}}~{.}~\mathsf{any\_true}`
...........................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{ine}}}_{{|\mathsf{v{\scriptstyle 128}}|}}(c_1, 0)`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}~{.}~{\mathit{vunop}}`
..........................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{vunop}}}{{}_{{\mathit{sh}}}}{(c_1)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vunop}}}{{}_{{\mathit{sh}}}}{(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}~{.}~{\mathit{vbinop}}`
...........................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{vbinop}}}{{}_{{\mathit{sh}}}}{(c_1, c_2)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vbinop}}}{{}_{{\mathit{sh}}}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}~{.}~\mathsf{all\_true}`
...............................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c)`.

#. If :math:`{({\mathit{ci}}_1 \neq 0)^\ast}`, then:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`{\mathit{sh}}~{.}~{\mathit{vrelop}}`
...........................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vrelop}}}{{}_{{\mathit{sh}}}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}~{.}~{\mathit{vshiftop}}`
................................................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`{{c'}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c_1)`.

#. Let :math:`c` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{{{\mathit{vshiftop}}}{\mathsf{\_}}~{{\mathsf{i}}{n}}{\mathsf{x}}{N}}{({c'}, n)}^\ast})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}{.}\mathsf{bitmask}`
...........................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c)`.

#. Let :math:`{\mathit{ci}}` be the result for which :math:`{{\mathrm{bits}}}_{{\mathsf{i}}{32}}({\mathit{ci}})` :math:`=` :math:`{{{{{\mathrm{ilt}}}_{{|{\mathsf{i}}{n}|}}^{\mathsf{s}}}}{({\mathit{ci}}_1, 0)}^\ast}~{0^{32 - N}}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{\mathrm{irev}}}_{32}({\mathit{ci}}))` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{M}{.}\mathsf{swizzle}`
...........................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`{{c'}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c_1)~{0^{256 - M}}`.

#. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c_2)`.

#. Assert: Due to validation, :math:`{({{\mathit{ci}}^\ast}{}[k] < {|{{c'}^\ast}|})^{k<M}}`.

#. Assert: Due to validation, :math:`{(k < {|{{\mathit{ci}}^\ast}|})^{k<M}}`.

#. Let :math:`c` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{c'}^\ast}{}[{{\mathit{ci}}^\ast}{}[k]]^{k<M}})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}{.}\mathsf{shuffle}~{i^\ast}`
....................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{(k < {|{i^\ast}|})^{k<N}}`.

#. Let :math:`{{c'}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c_1)~{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c_2)`.

#. Assert: Due to validation, :math:`{({i^\ast}{}[k] < {|{{c'}^\ast}|})^{k<N}}`.

#. Let :math:`c` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{{c'}^\ast}{}[{i^\ast}{}[k]]^{k<N}})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}{.}\mathsf{splat}`
.........................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0 = {\mathrm{unpack}}({\mathsf{i}}{n})`.

#. Let :math:`c` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{{\mathrm{pack}}}_{{\mathsf{i}}{n}}(c_1)^{N}})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{{\mathit{lanetype}}}{\mathsf{x}}{N}{.}\mathsf{extract\_lane}}{{{\mathit{sx}'}^?}}~i`
.............................................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{sx}'}^?}` is not defined, then:

   a. Assert: Due to validation, :math:`{\mathit{lanetype}}` is number type.

   #. Assert: Due to validation, :math:`i < {|{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{N}}(c_1)|}`.

   #. Let :math:`c_2` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{N}}(c_1){}[i]`.

   #. Push the value :math:`({\mathit{lanetype}}{.}\mathsf{const}~c_2)` to the stack.

#. Else:

   a. Assert: Due to validation, :math:`{\mathit{lanetype}}` is packed type.

   #. Let :math:`{\mathit{sx}}` be :math:`{{\mathit{sx}'}^?}`.

   #. Assert: Due to validation, :math:`i < {|{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{N}}(c_1)|}`.

   #. Let :math:`c_2` be :math:`{{{{\mathrm{extend}}}_{{|{\mathit{lanetype}}|}, 32}^{{\mathit{sx}}}}}{({{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{N}}(c_1){}[i])}`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c_2)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}{.}\mathsf{replace\_lane}~i`
...................................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0 = {\mathrm{unpack}}({\mathsf{i}}{n})`.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c_1){}[{}[i] = {{\mathrm{pack}}}_{{\mathsf{i}}{n}}(c_2)])`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{vextunop}~{\mathit{sh}}_1~{\mathit{sh}}_2~{\mathit{vextunop}}`
.............................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{vextunop}}}_{{\mathit{sh}}_1, {\mathit{sh}}_2}({\mathit{vextunop}}, c_1)`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{vextbinop}~{\mathit{sh}}_1~{\mathit{sh}}_2~{\mathit{vextbinop}}`
...............................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{vextbinop}}}_{{\mathit{sh}}_1, {\mathit{sh}}_2}({\mathit{vextbinop}}, c_1, c_2)`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{N_2}{.}\mathsf{narrow}}{\mathsf{\_}}{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{N_1}}{\mathsf{\_}}{{\mathit{sx}}}`
...................................................................................................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{N_1}}(c_1)`.

#. Let :math:`{{\mathit{ci}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{N_1}}(c_2)`.

#. Let :math:`{{\mathit{cj}}_1^\ast}` be :math:`\epsilon`.

#. For each :math:`{\mathit{ci}}_1` in :math:`{{\mathit{ci}}_1^\ast}`, do:

   a. Let :math:`{\mathit{cj}}_1` be :math:`{{{{\mathrm{narrow}}}_{{|{{\mathsf{i}}{n}}_1|}, {|{{\mathsf{i}}{n}}_2|}}^{{\mathit{sx}}}}}{{\mathit{ci}}_1}`.

   #. Append :math:`{\mathit{cj}}_1` to :math:`{{\mathit{cj}}_1^\ast}`.

#. Let :math:`{{\mathit{cj}}_2^\ast}` be :math:`\epsilon`.

#. For each :math:`{\mathit{ci}}_2` in :math:`{{\mathit{ci}}_2^\ast}`, do:

   a. Let :math:`{\mathit{cj}}_2` be :math:`{{{{\mathrm{narrow}}}_{{|{{\mathsf{i}}{n}}_1|}, {|{{\mathsf{i}}{n}}_2|}}^{{\mathit{sx}}}}}{{\mathit{ci}}_2}`.

   #. Append :math:`{\mathit{cj}}_2` to :math:`{{\mathit{cj}}_2^\ast}`.

#. Let :math:`c` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{N_2}}({{\mathit{cj}}_1^\ast}~{{\mathit{cj}}_2^\ast})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M}~{.}~{\mathit{vcvtop}}}{\mathsf{\_}}{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{{M'}}}`
..........................................................................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{\mathrm{halfop}}({\mathit{vcvtop}})` is defined, then:

   a. Let :math:`{\mathit{half}}` be :math:`{\mathrm{halfop}}({\mathit{vcvtop}})`.

   #. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{{M'}}}(c_1){}[{\mathrm{half}}({\mathit{half}}, 0, M) : M]`.

   #. Let :math:`{{{\mathit{cj}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{vcvtop}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{{M'}}, {{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M}}({\mathit{vcvtop}}, {\mathit{ci}})^\ast}`.

   #. If :math:`{|{{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M}}({{\mathit{cj}}^\ast})^\ast}|} > 0`, then:

      1) Let :math:`c` be an element of :math:`{{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M}}({{\mathit{cj}}^\ast})^\ast}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. Else if :math:`{\mathrm{zeroop}}({\mathit{vcvtop}})` is not defined and :math:`M = {M'}`, then:

   a. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{{M'}}}(c_1)`.

   #. Let :math:`{{{\mathit{cj}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{vcvtop}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{{M'}}, {{{\mathsf{i}}{n}}_2}{\mathsf{x}}{{M'}}}({\mathit{vcvtop}}, {\mathit{ci}})^\ast}`.

   #. If :math:`{|{{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{{M'}}}({{\mathit{cj}}^\ast})^\ast}|} > 0`, then:

      1) Let :math:`c` be an element of :math:`{{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{{M'}}}({{\mathit{cj}}^\ast})^\ast}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. If :math:`{\mathrm{zeroop}}({\mathit{vcvtop}}) = \mathsf{zero}` and :math:`{{\mathsf{i}}{n}}_1` is number type and :math:`{{\mathsf{i}}{n}}_2` is number type, then:

   a. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{{M'}}}(c_1)`.

   #. Let :math:`{{{\mathit{cj}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{vcvtop}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{{M'}}, {{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M}}({\mathit{vcvtop}}, {\mathit{ci}})^\ast}~{{\mathrm{zero}}({{\mathsf{i}}{n}}_2)^{{M'}}}`.

   #. If :math:`{|{{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M}}({{\mathit{cj}}^\ast})^\ast}|} > 0`, then:

      1) Let :math:`c` be an element of :math:`{{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M}}({{\mathit{cj}}^\ast})^\ast}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{local{.}tee}~x`
..............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Execute the instruction :math:`(\mathsf{local{.}set}~x)`.


:math:`\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}^\ast}`
............................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{k}}~\rightarrow~{t_2^{n}}` be the destructuring of :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`k` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Let :math:`L` be the :math:`\mathsf{label}` whose arity is :math:`n` and whose continuation is the end of the block.

#. Enter the block :math:`{{\mathit{val}}^{k}}~{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` :math:`L`.


:math:`\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast}`
...........................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{k}}~\rightarrow~{t_2^{n}}` be the destructuring of :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`k` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Let :math:`L` be the :math:`\mathsf{label}` whose arity is :math:`k` and whose continuation is the start of the block.

#. Enter the block :math:`{{\mathit{val}}^{k}}~{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` :math:`L`.


:math:`\mathsf{call}~x`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Execute the instruction :math:`(\mathsf{call}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x])`.


:math:`\mathsf{call\_indirect}~x~y`
...................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i]` is not some :math:`\mathsf{ref{.}func\_addr}~{\mathit{funcaddr}}`, then:

   a. Trap.

#. Let :math:`(\mathsf{ref{.}func\_addr}~a)` be the destructuring of :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i]`.

#. If :math:`a \geq {|z{.}\mathsf{funcs}|}`, then:

   a. Trap.

#. If :math:`z{.}\mathsf{types}{}[y] \neq z{.}\mathsf{funcs}{}[a]{.}\mathsf{type}`, then:

   a. Trap.

#. Execute the instruction :math:`(\mathsf{call}~a)`.


:math:`\mathsf{call}~a`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`a < {|z{.}\mathsf{funcs}|}`.

#. Let :math:`\{ \mathsf{type}~{t_1^{k}}~\rightarrow~{t_2^{n}},\;\allowbreak \mathsf{module}~{\mathit{mm}},\;\allowbreak \mathsf{code}~{\mathit{func}} \}` be the destructuring of :math:`z{.}\mathsf{funcs}{}[a]`.

#. Let :math:`(\mathsf{func}~x~{{\mathit{local}}_0^\ast}~{{\mathit{instr}}^\ast})` be the destructuring of :math:`{\mathit{func}}`.

#. Let :math:`{t^\ast}` be the value type sequence :math:`\epsilon`.

#. For each :math:`{\mathit{local}}_0` in :math:`{{\mathit{local}}_0^\ast}`, do:

   a. Let :math:`(\mathsf{local}~t)` be the destructuring of :math:`{\mathit{local}}_0`.

   #. Append :math:`t` to :math:`{t^\ast}`.

#. Assert: Due to validation, there are at least :math:`k` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Let :math:`f` be the frame :math:`\{ \mathsf{locals}~{{\mathit{val}}^{k}}~{{{\mathrm{default}}}_{t}^\ast},\;\allowbreak \mathsf{module}~{\mathit{mm}} \}`.

#. Let :math:`{f'}` be the :math:`\mathsf{frame}` :math:`f` whose arity is :math:`n`.

#. Push the :math:`\mathsf{frame}` :math:`{f'}`.

#. Let :math:`L` be the :math:`\mathsf{label}` whose arity is :math:`n` and whose continuation is the end of the block.

#. Enter the block :math:`{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` :math:`L`.


:math:`\mathsf{ref{.}func}~x`
.............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Push the value :math:`(\mathsf{ref{.}func}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x])` to the stack.


:math:`\mathsf{local{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Push the value :math:`z{.}\mathsf{locals}{}[x]` to the stack.


:math:`\mathsf{global{.}get}~x`
...............................


1. Let :math:`z` be the current state.

#. Push the value :math:`z{.}\mathsf{globals}{}[x]{.}\mathsf{value}` to the stack.


:math:`\mathsf{table{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. Push the value :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i]` to the stack.


:math:`\mathsf{table{.}size}~x`
...............................


1. Let :math:`z` be the current state.

#. Let :math:`n` be the length of :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{table{.}fill}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}fill}~x)`.


:math:`\mathsf{table{.}copy}~x~y`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{tables}{}[y]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. If :math:`j \leq i`, then:

      1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

      #) Execute the instruction :math:`(\mathsf{table{.}get}~y)`.

      #) Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Else:

      1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + n - 1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + n - 1)` to the stack.

      #) Execute the instruction :math:`(\mathsf{table{.}get}~y)`.

      #) Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}copy}~x~y)`.


:math:`\mathsf{table{.}init}~x~y`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. Assert: Due to validation, :math:`i < {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

   #. Push the value :math:`z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[i]` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}init}~x~y)`.


:math:`{{\mathit{nt}}{.}\mathsf{load}}{{{\mathit{loadop}}^?}}~{\mathit{ao}}`
............................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`{{\mathit{loadop}}^?}` is not defined, then:

   a. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}}|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathit{nt}}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}}|} / 8]`.

   #. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.

#. Else:

   a. Assert: Due to validation, :math:`{\mathit{nt}}` is :math:`{\mathsf{i}}{n}`.

   #. Let :math:`{\mathit{loadop}}_0` be :math:`{{\mathit{loadop}}^?}`.

   #. Let :math:`{n}{\mathsf{\_}}{{\mathit{sx}}}` be the destructuring of :math:`{\mathit{loadop}}_0`.

   #. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8]`.

   #. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{n, {|{\mathit{nt}}|}}^{{\mathit{sx}}}}}{(c)})` to the stack.


:math:`\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~{{\mathit{vloadop}}^?}~{\mathit{ao}}`
.........................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`{{\mathit{vloadop}}^?}` is not defined, then:

   a. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|\mathsf{v{\scriptstyle 128}}|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{\mathsf{v{\scriptstyle 128}}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|\mathsf{v{\scriptstyle 128}}|} / 8]`.

   #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. Else:

   a. Let :math:`{\mathit{vloadop}}_0` be :math:`{{\mathit{vloadop}}^?}`.

   #. If :math:`{\mathit{vloadop}}_0` is some :math:`{\mathbb{N}}{\mathsf{x}}{\mathbb{N}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({M}{\mathsf{x}}{N}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vloadop}}_0`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + M \cdot N / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) Let :math:`{j^{N}}` be the result for which :math:`{({{\mathrm{bytes}}}_{{\mathsf{i}}{M}}({j^{N}}) = z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} + k \cdot M / 8 : M / 8])^{k<N}}`.

      #) Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`M \cdot 2`.

      #) Let :math:`c` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{{{{\mathrm{extend}}}_{M, {|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{(j)}^{N}})`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

   #. If :math:`{\mathit{vloadop}}_0` is some :math:`{\mathbb{N}}{\mathsf{\_}}{\mathsf{splat}}`, then:

      1) Let :math:`({N}{\mathsf{\_}}{\mathsf{splat}})` be the destructuring of :math:`{\mathit{vloadop}}_0`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) Let :math:`M` be :math:`128 / N`.

      #) Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`N`.

      #) Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

      #) Let :math:`c` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({j^{M}})`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

   #. If :math:`{\mathit{vloadop}}_0` is some :math:`{\mathbb{N}}{\mathsf{\_}}{\mathsf{zero}}`, then:

      1) Let :math:`({N}{\mathsf{\_}}{\mathsf{zero}})` be the destructuring of :math:`{\mathit{vloadop}}_0`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

      #) Let :math:`c` be :math:`{{{{\mathrm{extend}}}_{N, 128}^{\mathsf{u}}}}{(j)}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{vload\_lane}~\mathsf{v{\scriptstyle 128}}~N~{\mathit{ao}}~j`
...........................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`M` be :math:`128 / N`.

#. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`N`.

#. Let :math:`k` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(k)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

#. Let :math:`c` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c_1){}[{}[j] = k])`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{memory{.}size}`
..............................


1. Let :math:`z` be the current state.

#. Let :math:`n \cdot 64 \cdot {\mathrm{Ki}}` be the length of :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{memory{.}fill}`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8})`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`\mathsf{memory{.}fill}`.


:math:`\mathsf{memory{.}copy}`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. If :math:`j \leq i`, then:

      1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{load}}{{8}{\mathsf{\_}}{\mathsf{u}}})`.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8})`.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Else:

      1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + n - 1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + n - 1)` to the stack.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{load}}{{8}{\mathsf{\_}}{\mathsf{u}}})`.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8})`.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`\mathsf{memory{.}copy}`.


:math:`\mathsf{memory{.}init}~x`
................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{datas}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. Assert: Due to validation, :math:`i < {|z{.}\mathsf{datas}{}[x]{.}\mathsf{bytes}|}`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~z{.}\mathsf{datas}{}[x]{.}\mathsf{bytes}{}[i])` to the stack.

   #. Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8})`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{memory{.}init}~x)`.


:math:`\mathsf{local{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{locals}{}[x] = {\mathit{val}}]`.


:math:`\mathsf{global{.}set}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = {\mathit{val}}]`.


:math:`\mathsf{table{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a reference is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. Perform :math:`z{}[{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i] = {\mathit{ref}}]`.


:math:`\mathsf{table{.}grow}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a reference is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Either:

   a. Let :math:`{\mathit{ti}}` be the table instance :math:`{\mathrm{growtable}}(z{.}\mathsf{tables}{}[x], n, {\mathit{ref}})`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|})` to the stack.

   #. Perform :math:`z{}[{.}\mathsf{tables}{}[x] = {\mathit{ti}}]`.

#. Or:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{32}^{{-1}}}}{({-1})})` to the stack.


:math:`\mathsf{elem{.}drop}~x`
..............................


1. Let :math:`z` be the current state.

#. Perform :math:`z{}[{.}\mathsf{elems}{}[x]{.}\mathsf{refs} = \epsilon]`.


:math:`{{\mathit{nt}}{.}\mathsf{store}}{{{\mathit{sz}}^?}}~{\mathit{ao}}`
.........................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number is on the top of the stack.

#. Pop the value :math:`({\mathit{nt}'}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{nt}} = {\mathit{nt}'}`.

#. If :math:`{{\mathit{sz}}^?}` is not defined, then:

   a. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}'}|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathit{nt}'}}(c)`.

   #. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}'}|} / 8] = {b^\ast}]`.

#. Else:

   a. Assert: Due to validation, :math:`{\mathit{nt}'}` is :math:`{\mathsf{i}}{n}`.

   #. Let :math:`n` be :math:`{{\mathit{sz}}^?}`.

   #. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}({{\mathrm{wrap}}}_{{|{\mathit{nt}'}|}, n}(c))`.

   #. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8] = {b^\ast}]`.


:math:`\mathsf{vstore}~\mathsf{v{\scriptstyle 128}}~{\mathit{ao}}`
..................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|\mathsf{v{\scriptstyle 128}}|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{\mathsf{v{\scriptstyle 128}}}(c)`.

#. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|\mathsf{v{\scriptstyle 128}}|} / 8] = {b^\ast}]`.


:math:`\mathsf{vstore\_lane}~\mathsf{v{\scriptstyle 128}}~N~{\mathit{ao}}~j`
............................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`M` be :math:`128 / N`.

#. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`N`.

#. Assert: Due to validation, :math:`j < {|{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c)|}`.

#. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}({{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c){}[j])`.

#. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8] = {b^\ast}]`.


:math:`\mathsf{memory{.}grow}`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Either:

   a. Let :math:`{\mathit{mi}}` be the memory instance :math:`{\mathrm{growmemory}}(z{.}\mathsf{mems}{}[0], n)`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|} / (64 \, {\mathrm{Ki}}))` to the stack.

   #. Perform :math:`z{}[{.}\mathsf{mems}{}[0] = {\mathit{mi}}]`.

#. Or:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{32}^{{-1}}}}{({-1})})` to the stack.


:math:`\mathsf{data{.}drop}~x`
..............................


1. Let :math:`z` be the current state.

#. Perform :math:`z{}[{.}\mathsf{datas}{}[x]{.}\mathsf{bytes} = \epsilon]`.


:math:`{\mathrm{Ki}}`
.....................


1. Return :math:`1024`.


:math:`{\mathrm{min}}(i, j)`
............................


1. If :math:`i \leq j`, then:

   a. Return :math:`i`.

#. Return :math:`j`.


:math:`{\mathrm{sum}}({{n''}^\ast})`
....................................


1. If :math:`{{n''}^\ast} = \epsilon`, then:

   a. Return :math:`0`.

#. Let :math:`n~{{n'}^\ast}` be :math:`{{n''}^\ast}`.

#. Return :math:`n + {\mathrm{sum}}({{n'}^\ast})`.


:math:`{X^\ast}`
................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. If :math:`{|{X^\ast}|} = 1`, then:

   a. Let :math:`w` be :math:`{X^\ast}`.

   #. Return :math:`w`.

#. Fail.


:math:`{X^?}`
.............


1. If :math:`{X^?}` is not defined, then:

   a. Return :math:`\epsilon`.

#. Let :math:`w` be :math:`{X^?}`.

#. Return :math:`w`.


:math:`{\mathrm{concat}}({X^\ast})`
...................................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{w^\ast}~{{{w'}^\ast}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`{w^\ast}~{\mathrm{concat}}({{{w'}^\ast}^\ast})`.


:math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{X}(w_1, {X^\ast})`
.............................................................................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{{w'}^\ast}~{{w^\ast}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`w_1~{{w'}^\ast}~{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{X}(w_1, {{w^\ast}^\ast})`.


:math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{X}({X^\ast}, {{w^\ast}^\ast})`
.........................................................................................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`w_1~{{w'}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{X}(w_1, {{w^\ast}^\ast})~{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{X}({{w'}^\ast}, {{w^\ast}^\ast})`.


:math:`{\Large\times}~{X^\ast}`
...............................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{w_1^\ast}~{{w^\ast}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{X}({w_1^\ast}, {\Large\times}~{{w^\ast}^\ast})`.


:math:`{\mathrm{signif}}(N)`
............................


1. If :math:`N = 32`, then:

   a. Return :math:`23`.

#. If :math:`N = 64`, then:

   a. Return :math:`52`.

#. Fail.


:math:`{\mathrm{expon}}(N)`
...........................


1. If :math:`N = 32`, then:

   a. Return :math:`8`.

#. If :math:`N = 64`, then:

   a. Return :math:`11`.

#. Fail.


:math:`M`
.........


1. Return :math:`{\mathrm{signif}}(N)`.


:math:`E`
.........


1. Return :math:`{\mathrm{expon}}(N)`.


:math:`{+0}`
............


1. Return :math:`({+((0 + 0 \cdot {2^{{-M}}}) \cdot {2^{e}})})`.


:math:`{+1}`
............


1. Return :math:`({+((1 + 1 \cdot {2^{{-M}}}) \cdot {2^{0}})})`.


:math:`{{\mathrm{canon}}}_{N}`
..............................


1. Return :math:`{2^{{\mathrm{signif}}(N) - 1}}`.


:math:`{\mathrm{lanetype}}({{\mathsf{i}}{n}}{\mathsf{x}}{N})`
.............................................................


1. Return :math:`{\mathsf{i}}{n}`.


:math:`{|{\mathit{valtype}}|}`
..............................


1. If :math:`{\mathit{valtype}} = \mathsf{i{\scriptstyle 32}}`, then:

   a. Return :math:`32`.

#. If :math:`{\mathit{valtype}} = \mathsf{i{\scriptstyle 64}}`, then:

   a. Return :math:`64`.

#. If :math:`{\mathit{valtype}} = \mathsf{f{\scriptstyle 32}}`, then:

   a. Return :math:`32`.

#. If :math:`{\mathit{valtype}} = \mathsf{f{\scriptstyle 64}}`, then:

   a. Return :math:`64`.

#. If :math:`{\mathit{valtype}} = \mathsf{v{\scriptstyle 128}}`, then:

   a. Return :math:`128`.

#. Fail.


:math:`{|{\mathit{packtype}}|}`
...............................


1. If :math:`{\mathit{packtype}} = \mathsf{i{\scriptstyle 8}}`, then:

   a. Return :math:`8`.

#. Assert: Due to validation, :math:`{\mathit{packtype}} = \mathsf{i{\scriptstyle 16}}`.

#. Return :math:`16`.


:math:`{|{\mathit{lanetype}}|}`
...............................


1. If :math:`{\mathit{lanetype}}` is number type, then:

   a. Return :math:`{|{\mathit{lanetype}}|}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is packed type.

#. Return :math:`{|{\mathit{lanetype}}|}`.


:math:`{|{\mathsf{i}}{n}|}`
...........................


1. Return :math:`{|{\mathsf{i}}{n}|}`.


:math:`{|{\mathsf{i}}{n}|}`
...........................


1. Return :math:`{|{\mathsf{i}}{n}|}`.


:math:`{|{\mathsf{f}}{n}|}`
...........................


1. Return :math:`{|{\mathsf{f}}{n}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N_1`
...........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N_2`
...........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`N_1`
...........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`N_2`
...........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`{\mathrm{inv}}_{\mathit{isize}}(n)`
..........................................


1. If :math:`n = 32`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 32}}`.

#. If :math:`n = 64`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 64}}`.

#. Fail.


:math:`{\mathrm{inv}}_{\mathit{jsize}}(n)`
..........................................


1. If :math:`n = 8`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 8}}`.

#. If :math:`n = 16`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 16}}`.

#. If :math:`n = 32`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 32}}`.

#. If :math:`n = 64`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 64}}`.

#. Fail.


:math:`{\mathrm{inv}}_{\mathit{fsize}}(n)`
..........................................


1. If :math:`n = 32`, then:

   a. Return :math:`\mathsf{f{\scriptstyle 32}}`.

#. If :math:`n = 64`, then:

   a. Return :math:`\mathsf{f{\scriptstyle 64}}`.

#. Fail.


:math:`{\mathrm{zero}}({\mathit{numtype}})`
...........................................


1. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{n}`, then:

   a. Return :math:`0`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{n}`.

#. Return :math:`{+0}`.


:math:`{\mathrm{dim}}({{\mathsf{i}}{n}}{\mathsf{x}}{N})`
........................................................


1. Return :math:`N`.


:math:`{|{{\mathsf{i}}{n}}{\mathsf{x}}{N}|}`
............................................


1. Return :math:`{|{\mathsf{i}}{n}|} \cdot N`.


:math:`{\mathrm{concat}}({{\mathit{byte}}^\ast})`
.................................................


1. If :math:`{{\mathit{byte}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{b^\ast}~{{{b'}^\ast}^\ast}` be :math:`{{\mathit{byte}}^\ast}`.

#. Return :math:`{b^\ast}~{\mathrm{concat}}({{{b'}^\ast}^\ast})`.


:math:`{\mathrm{unpack}}({\mathit{lanetype}})`
..............................................


1. If :math:`{\mathit{lanetype}}` is number type, then:

   a. Return :math:`{\mathit{lanetype}}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is packed type.

#. Return :math:`\mathsf{i{\scriptstyle 32}}`.


:math:`{\mathrm{unpack}}({{\mathsf{i}}{n}}{\mathsf{x}}{N})`
...........................................................


1. Return :math:`{\mathrm{unpack}}({\mathsf{i}}{n})`.


:math:`{\mathrm{funcs}}({{\mathit{externtype}'}^\ast})`
.......................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{func}~{\mathit{functype}}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{ft}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{ft}}~{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externtype}'}^\ast})`
.........................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{global}~{\mathit{globaltype}}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{gt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{gt}}~{\mathrm{globals}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externtype}'}^\ast})`
........................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{table}~{\mathit{tabletype}}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{tt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{tt}}~{\mathrm{tables}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externtype}'}^\ast})`
......................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{mem}~{\mathit{memtype}}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{mt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{mt}}~{\mathrm{mems}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{dataidx}}({\mathit{instr}})`
............................................


1. If :math:`{\mathit{instr}}` is some :math:`\mathsf{memory{.}init}~{\mathit{dataidx}}`, then:

   a. Let :math:`(\mathsf{memory{.}init}~x)` be the destructuring of :math:`{\mathit{instr}}`.

   #. Return :math:`x`.

#. If :math:`{\mathit{instr}}` is some :math:`\mathsf{data{.}drop}~{\mathit{dataidx}}`, then:

   a. Let :math:`(\mathsf{data{.}drop}~x)` be the destructuring of :math:`{\mathit{instr}}`.

   #. Return :math:`x`.

#. Return :math:`\epsilon`.


:math:`{\mathrm{dataidx}}({{\mathit{instr}''}^\ast})`
.....................................................


1. If :math:`{{\mathit{instr}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{instr}}~{{\mathit{instr}'}^\ast}` be :math:`{{\mathit{instr}''}^\ast}`.

#. Return :math:`{\mathrm{dataidx}}({\mathit{instr}})~{\mathrm{dataidx}}({{\mathit{instr}'}^\ast})`.


:math:`{\mathrm{dataidx}}({{\mathit{in}}^\ast})`
................................................


1. Return :math:`{\mathrm{dataidx}}({{\mathit{in}}^\ast})`.


:math:`{\mathrm{dataidx}}(\mathsf{func}~x~{{\mathit{loc}}^\ast}~e)`
...................................................................


1. Return :math:`{\mathrm{dataidx}}(e)`.


:math:`{\mathrm{dataidx}}({{\mathit{func}''}^\ast})`
....................................................


1. If :math:`{{\mathit{func}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{func}}~{{\mathit{func}'}^\ast}` be :math:`{{\mathit{func}''}^\ast}`.

#. Return :math:`{\mathrm{dataidx}}({\mathit{func}})~{\mathrm{dataidx}}({{\mathit{func}'}^\ast})`.






1. Return :math:`\{ \mathsf{align}~0,\;\allowbreak \mathsf{offset}~0 \}`.


:math:`\mathbb{B}(b)`
.....................


1. If :math:`b` is false, then:

   a. Return :math:`0`.

#. Assert: Due to validation, :math:`b` is true.

#. Return :math:`1`.


:math:`{{\mathrm{signed}}}_{N}(i)`
..................................


1. If :math:`i < {2^{N - 1}}`, then:

   a. Return :math:`i`.

#. Assert: Due to validation, :math:`{2^{N - 1}} \leq i`.

#. Assert: Due to validation, :math:`i < {2^{N}}`.

#. Return :math:`i - {2^{N}}`.


:math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{(i)}`
...............................................


1. If :math:`0 \leq i` and :math:`i < {2^{N - 1}}`, then:

   a. Return :math:`i`.

#. Assert: Due to validation, :math:`{-{2^{N - 1}}} \leq i`.

#. Assert: Due to validation, :math:`i < 0`.

#. Return :math:`i + {2^{N}}`.


:math:`{{\mathrm{sat\_u}}}_{N}(i)`
..................................


1. If :math:`i < 0`, then:

   a. Return :math:`0`.

#. If :math:`i > {2^{N}} - 1`, then:

   a. Return :math:`{2^{N}} - 1`.

#. Return :math:`i`.


:math:`{{\mathrm{sat\_s}}}_{N}(i)`
..................................


1. If :math:`i < {-{2^{N - 1}}}`, then:

   a. Return :math:`{-{2^{N - 1}}}`.

#. If :math:`i > {2^{N - 1}} - 1`, then:

   a. Return :math:`{2^{N - 1}} - 1`.

#. Return :math:`i`.


:math:`{{\mathit{unop}}}{{}_{{\mathit{numtype}}}}{({\mathit{iN}})}`
...................................................................


1. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{unop}} = \mathsf{clz}`, then:

      1) Return :math:`{{\mathrm{iclz}}}_{N}({\mathit{iN}})`.

   #. If :math:`{\mathit{unop}} = \mathsf{ctz}`, then:

      1) Return :math:`{{\mathrm{ictz}}}_{N}({\mathit{iN}})`.

   #. If :math:`{\mathit{unop}} = \mathsf{popcnt}`, then:

      1) Return :math:`{{\mathrm{ipopcnt}}}_{N}({\mathit{iN}})`.

   #. Assert: Due to validation, :math:`{\mathit{unop}}` is some :math:`\mathsf{extend}~n`.

   #. Let :math:`(\mathsf{extend}~M)` be the destructuring of :math:`{\mathit{unop}}`.

   #. Return :math:`{{{{\mathrm{extend}}}_{M, N}^{\mathsf{s}}}}{({{\mathrm{wrap}}}_{N, M}({\mathit{iN}}))}`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{unop}} = \mathsf{abs}`, then:

   a. Return :math:`{{\mathrm{fabs}}}_{N}({\mathit{iN}})`.

#. If :math:`{\mathit{unop}} = \mathsf{neg}`, then:

   a. Return :math:`{{\mathrm{fneg}}}_{N}({\mathit{iN}})`.

#. If :math:`{\mathit{unop}} = \mathsf{sqrt}`, then:

   a. Return :math:`{{\mathrm{fsqrt}}}_{N}({\mathit{iN}})`.

#. If :math:`{\mathit{unop}} = \mathsf{ceil}`, then:

   a. Return :math:`{{\mathrm{fceil}}}_{N}({\mathit{iN}})`.

#. If :math:`{\mathit{unop}} = \mathsf{floor}`, then:

   a. Return :math:`{{\mathrm{ffloor}}}_{N}({\mathit{iN}})`.

#. If :math:`{\mathit{unop}} = \mathsf{trunc}`, then:

   a. Return :math:`{{\mathrm{ftrunc}}}_{N}({\mathit{iN}})`.

#. Assert: Due to validation, :math:`{\mathit{unop}} = \mathsf{nearest}`.

#. Return :math:`{{\mathrm{fnearest}}}_{N}({\mathit{iN}})`.


:math:`{{\mathrm{iadd}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`(i_1 + i_2) \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{{{\mathrm{idiv}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
.............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. If :math:`i_2 = 0`, then:

      1) Return :math:`\epsilon`.

   #. Return :math:`{\mathrm{truncz}}(i_1 / i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. If :math:`i_2 = 0`, then:

   a. Return :math:`\epsilon`.

#. If :math:`{{\mathrm{signed}}}_{N}(i_1) / {{\mathrm{signed}}}_{N}(i_2) = {2^{N - 1}}`, then:

   a. Return :math:`\epsilon`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({\mathrm{truncz}}({{\mathrm{signed}}}_{N}(i_1) / {{\mathrm{signed}}}_{N}(i_2)))}`.


:math:`{{\mathrm{imul}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`i_1 \cdot i_2 \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{{{\mathrm{irem}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
.............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. If :math:`i_2 = 0`, then:

      1) Return :math:`\epsilon`.

   #. Return :math:`i_1 - i_2 \cdot {\mathrm{truncz}}(i_1 / i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. If :math:`i_2 = 0`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`j_1` be :math:`{{\mathrm{signed}}}_{N}(i_1)`.

#. Let :math:`j_2` be :math:`{{\mathrm{signed}}}_{N}(i_2)`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{(j_1 - j_2 \cdot {\mathrm{truncz}}(j_1 / j_2))}`.


:math:`{{\mathrm{isub}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`({2^{N}} + i_1 - i_2) \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{\mathit{binop}}}{{}_{{\mathit{numtype}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`
.......................................................................................


1. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{binop}} = \mathsf{add}`, then:

      1) Return :math:`{{\mathrm{iadd}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}} = \mathsf{sub}`, then:

      1) Return :math:`{{\mathrm{isub}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}} = \mathsf{mul}`, then:

      1) Return :math:`{{\mathrm{imul}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}}` is some :math:`{\mathsf{div}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{div}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{binop}}`.

      #) Return :math:`{{{{\mathrm{idiv}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{binop}}` is some :math:`{\mathsf{rem}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{rem}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{binop}}`.

      #) Return :math:`{{{{\mathrm{irem}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{binop}} = \mathsf{and}`, then:

      1) Return :math:`{{\mathrm{iand}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}} = \mathsf{or}`, then:

      1) Return :math:`{{\mathrm{ior}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}} = \mathsf{xor}`, then:

      1) Return :math:`{{\mathrm{ixor}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}} = \mathsf{shl}`, then:

      1) Return :math:`{{\mathrm{ishl}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}}` is some :math:`{\mathsf{shr}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{shr}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{binop}}`.

      #) Return :math:`{{{{\mathrm{ishr}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{binop}} = \mathsf{rotl}`, then:

      1) Return :math:`{{\mathrm{irotl}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}} = \mathsf{rotr}`, then:

      1) Return :math:`{{\mathrm{irotr}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{binop}} = \mathsf{add}`, then:

   a. Return :math:`{{\mathrm{fadd}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop}} = \mathsf{sub}`, then:

   a. Return :math:`{{\mathrm{fsub}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop}} = \mathsf{mul}`, then:

   a. Return :math:`{{\mathrm{fmul}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop}} = \mathsf{div}`, then:

   a. Return :math:`{{\mathrm{fdiv}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop}} = \mathsf{min}`, then:

   a. Return :math:`{{\mathrm{fmin}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop}} = \mathsf{max}`, then:

   a. Return :math:`{{\mathrm{fmax}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{binop}} = \mathsf{copysign}`.

#. Return :math:`{{\mathrm{fcopysign}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.


:math:`{{\mathrm{ieqz}}}_{N}(i_1)`
..................................


1. Return :math:`\mathbb{B}(i_1 = 0)`.


:math:`{\mathsf{eqz}}{{}_{{\mathsf{i}}{n}}}{({\mathit{iN}})}`
.............................................................


1. Return :math:`{{\mathrm{ieqz}}}_{N}({\mathit{iN}})`.


:math:`{{\mathrm{ieq}}}_{N}(i_1, i_2)`
......................................


1. Return :math:`\mathbb{B}(i_1 = i_2)`.


:math:`{{{{\mathrm{ige}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 \geq i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) \geq {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{{{\mathrm{igt}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 > i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) > {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{{{\mathrm{ile}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 \leq i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) \leq {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{{{\mathrm{ilt}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 < i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) < {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{\mathrm{ine}}}_{N}(i_1, i_2)`
......................................


1. Return :math:`\mathbb{B}(i_1 \neq i_2)`.


:math:`{{\mathit{relop}}}{{}_{{\mathit{numtype}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`
.......................................................................................


1. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{relop}} = \mathsf{eq}`, then:

      1) Return :math:`{{\mathrm{ieq}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{relop}} = \mathsf{ne}`, then:

      1) Return :math:`{{\mathrm{ine}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{relop}}` is some :math:`{\mathsf{lt}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{lt}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{{{\mathrm{ilt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{relop}}` is some :math:`{\mathsf{gt}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{gt}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{{{\mathrm{igt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{relop}}` is some :math:`{\mathsf{le}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{le}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{{{\mathrm{ile}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{relop}}` is some :math:`{\mathsf{ge}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{ge}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{{{\mathrm{ige}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{relop}} = \mathsf{eq}`, then:

   a. Return :math:`{{\mathrm{feq}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{relop}} = \mathsf{ne}`, then:

   a. Return :math:`{{\mathrm{fne}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{relop}} = \mathsf{lt}`, then:

   a. Return :math:`{{\mathrm{flt}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{relop}} = \mathsf{gt}`, then:

   a. Return :math:`{{\mathrm{fgt}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{relop}} = \mathsf{le}`, then:

   a. Return :math:`{{\mathrm{fle}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{relop}} = \mathsf{ge}`.

#. Return :math:`{{\mathrm{fge}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.


:math:`{{\mathit{cvtop}}}{{}_{{\mathit{numtype}}, {\mathit{numtype}'}}}{({\mathit{iN}}_1)}`
...........................................................................................


1. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{n}` and :math:`{\mathit{numtype}'}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{cvtop}}` is some :math:`\mathsf{extend}~{\mathit{sx}}`, then:

      1) Let :math:`(\mathsf{extend}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{cvtop}}`.

      #) Return :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

   #. If :math:`{\mathit{cvtop}} = \mathsf{wrap}`, then:

      1) Return :math:`{{\mathrm{wrap}}}_{N_1, N_2}({\mathit{iN}}_1)`.

#. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{n}` and :math:`{\mathit{numtype}'}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{cvtop}}` is some :math:`\mathsf{trunc}~{\mathit{sx}}`, then:

      1) Let :math:`(\mathsf{trunc}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{cvtop}}`.

      #) Return :math:`{{{{\mathrm{trunc}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

   #. If :math:`{\mathit{cvtop}}` is some :math:`\mathsf{trunc\_sat}~{\mathit{sx}}`, then:

      1) Let :math:`(\mathsf{trunc\_sat}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{cvtop}}`.

      #) Return :math:`{{{{\mathrm{trunc\_sat}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

#. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{n}` and :math:`{\mathit{numtype}'}` is :math:`{\mathsf{f}}{n}` and :math:`{\mathit{cvtop}}` is some :math:`\mathsf{convert}~{\mathit{sx}}`, then:

   a. Let :math:`(\mathsf{convert}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{cvtop}}`.

   #. Return :math:`{{{{\mathrm{convert}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

#. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{n}` and :math:`{\mathit{numtype}'}` is :math:`{\mathsf{f}}{n}`, then:

   a. If :math:`{\mathit{cvtop}} = \mathsf{promote}`, then:

      1) Return :math:`{{\mathrm{promote}}}_{N_1, N_2}({\mathit{iN}}_1)`.

   #. If :math:`{\mathit{cvtop}} = \mathsf{demote}`, then:

      1) Return :math:`{{\mathrm{demote}}}_{N_1, N_2}({\mathit{iN}}_1)`.

#. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{n}` and :math:`{\mathit{numtype}'}` is :math:`{\mathsf{f}}{n}` and :math:`{\mathit{cvtop}} = \mathsf{reinterpret}` and :math:`{|{\mathit{numtype}}|} = {|{\mathit{numtype}'}|}`, then:

   a. Return :math:`{{\mathrm{reinterpret}}}_{{\mathit{numtype}}, {\mathit{numtype}'}}({\mathit{iN}}_1)`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{n}`.

#. Assert: Due to validation, :math:`{\mathit{numtype}'}` is :math:`{\mathsf{i}}{n}`.

#. Assert: Due to validation, :math:`{\mathit{cvtop}} = \mathsf{reinterpret}`.

#. Assert: Due to validation, :math:`{|{\mathit{numtype}}|} = {|{\mathit{numtype}'}|}`.

#. Return :math:`{{\mathrm{reinterpret}}}_{{\mathit{numtype}}, {\mathit{numtype}'}}({\mathit{iN}}_1)`.


:math:`{{\mathrm{inez}}}_{N}(i_1)`
..................................


1. Return :math:`\mathbb{B}(i_1 \neq 0)`.


:math:`{{\mathrm{ineg}}}_{N}(i_1)`
..................................


1. Return :math:`({2^{N}} - i_1) \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{\mathrm{iabs}}}_{N}(i_1)`
..................................


1. If :math:`{{\mathrm{signed}}}_{N}(i_1) \geq 0`, then:

   a. Return :math:`i_1`.

#. Return :math:`{{\mathrm{ineg}}}_{N}(i_1)`.


:math:`{{\mathrm{imin}}}_{N}({\mathit{sx}}, i_1, i_2)`
......................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. If :math:`i_1 \leq i_2`, then:

      1) Return :math:`i_1`.

   #. Return :math:`i_2`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. If :math:`{{\mathrm{signed}}}_{N}(i_1) \leq {{\mathrm{signed}}}_{N}(i_2)`, then:

   a. Return :math:`i_1`.

#. Return :math:`i_2`.


:math:`{{\mathrm{imax}}}_{N}({\mathit{sx}}, i_1, i_2)`
......................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. If :math:`i_1 \geq i_2`, then:

      1) Return :math:`i_1`.

   #. Return :math:`i_2`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. If :math:`{{\mathrm{signed}}}_{N}(i_1) \geq {{\mathrm{signed}}}_{N}(i_2)`, then:

   a. Return :math:`i_1`.

#. Return :math:`i_2`.


:math:`{{{{\mathrm{iadd\_sat}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
..................................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`{{\mathrm{sat\_u}}}_{N}(i_1 + i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({{\mathrm{sat\_s}}}_{N}({{\mathrm{signed}}}_{N}(i_1) + {{\mathrm{signed}}}_{N}(i_2)))}`.


:math:`{{{{\mathrm{isub\_sat}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`
..................................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`{{\mathrm{sat\_u}}}_{N}(i_1 - i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({{\mathrm{sat\_s}}}_{N}({{\mathrm{signed}}}_{N}(i_1) - {{\mathrm{signed}}}_{N}(i_2)))}`.


:math:`{{\mathrm{pack}}}_{{\mathit{lanetype}}}(c)`
..................................................


1. If :math:`{\mathit{lanetype}}` is number type, then:

   a. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is packed type.

#. Return :math:`{{\mathrm{wrap}}}_{{|{\mathrm{unpack}}({\mathit{lanetype}})|}, {|{\mathit{lanetype}}|}}(c)`.


:math:`{{\mathrm{unpack}}}_{{\mathit{lanetype}}}(c)`
....................................................


1. If :math:`{\mathit{lanetype}}` is number type, then:

   a. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is packed type.

#. Return :math:`{{{{\mathrm{extend}}}_{{|{\mathit{lanetype}}|}, {|{\mathrm{unpack}}({\mathit{lanetype}})|}}^{\mathsf{u}}}}{(c)}`.


:math:`{\mathrm{zeroop}}({\mathit{vcvtop}})`
............................................


1. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{extend}~{\mathit{half}}~{\mathit{sx}}`, then:

   a. Return :math:`\epsilon`.

#. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{convert}~{{\mathit{half}}^?}~{\mathit{sx}}`, then:

   a. Return :math:`\epsilon`.

#. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{trunc\_sat}~{\mathit{sx}}~{{\mathit{zero}}^?}`, then:

   a. Let :math:`(\mathsf{trunc\_sat}~{\mathit{sx}}~{{\mathit{zero}}^?})` be the destructuring of :math:`{\mathit{vcvtop}}`.

   #. Return :math:`{{\mathit{zero}}^?}`.

#. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{demote}~{\mathit{zero}}`, then:

   a. Let :math:`(\mathsf{demote}~{\mathit{zero}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

   #. Return :math:`{\mathit{zero}}`.

#. Assert: Due to validation, :math:`{\mathit{vcvtop}} = `.

#. Return :math:`\epsilon`.


:math:`{\mathrm{halfop}}({\mathit{vcvtop}})`
............................................


1. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{extend}~{\mathit{half}}~{\mathit{sx}}`, then:

   a. Let :math:`(\mathsf{extend}~{\mathit{half}}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

   #. Return :math:`{\mathit{half}}`.

#. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{convert}~{{\mathit{half}}^?}~{\mathit{sx}}`, then:

   a. Let :math:`(\mathsf{convert}~{{\mathit{half}}^?}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

   #. Return :math:`{{\mathit{half}}^?}`.

#. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{trunc\_sat}~{\mathit{sx}}~{{\mathit{zero}}^?}`, then:

   a. Return :math:`\epsilon`.

#. If :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{demote}~{\mathit{zero}}`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{\mathit{vcvtop}} = `.

#. Return :math:`\mathsf{low}`.


:math:`{\mathrm{half}}({\mathit{half}}, i, j)`
..............................................


1. If :math:`{\mathit{half}} = \mathsf{low}`, then:

   a. Return :math:`i`.

#. Assert: Due to validation, :math:`{\mathit{half}} = \mathsf{high}`.

#. Return :math:`j`.


:math:`{\mathsf{not}}{{}_{\mathsf{v{\scriptstyle 128}}}({\mathit{v{\kern-0.1em\scriptstyle 128}}})}`
....................................................................................................


1. Return :math:`{{\mathrm{inot}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}})`.


:math:`{{\mathit{vvbinop}}}{{}_{\mathsf{v{\scriptstyle 128}}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)}`
.........................................................................................................................................................


1. If :math:`{\mathit{vvbinop}} = \mathsf{and}`, then:

   a. Return :math:`{{\mathrm{iand}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. If :math:`{\mathit{vvbinop}} = \mathsf{andnot}`, then:

   a. Return :math:`{{\mathrm{iandnot}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. If :math:`{\mathit{vvbinop}} = \mathsf{or}`, then:

   a. Return :math:`{{\mathrm{ior}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{vvbinop}} = \mathsf{xor}`.

#. Return :math:`{{\mathrm{ixor}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.


:math:`{\mathsf{bitselect}}{{}_{\mathsf{v{\scriptstyle 128}}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_3)}`
......................................................................................................................................................................................................


1. Return :math:`{{\mathrm{ibitselect}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_3)`.


:math:`{{\mathit{vunop}}}{{}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}}{({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)}`
....................................................................................................................


1. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{vunop}} = \mathsf{abs}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{\mathrm{iabs}}}_{N}({\mathit{lane}}_1)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vunop}} = \mathsf{neg}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{\mathrm{ineg}}}_{N}({\mathit{lane}}_1)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vunop}} = \mathsf{popcnt}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{\mathrm{ipopcnt}}}_{N}({\mathit{lane}}_1)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{vunop}} = \mathsf{abs}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fabs}}}_{N}({\mathit{lane}}_1)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`\epsilon`.

   #. For each :math:`{{\mathit{lane}}^\ast}` in :math:`{{{\mathit{lane}}^\ast}^\ast}`, do:

      1) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})`.

      #) Append :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` to :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop}} = \mathsf{neg}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fneg}}}_{N}({\mathit{lane}}_1)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`\epsilon`.

   #. For each :math:`{{\mathit{lane}}^\ast}` in :math:`{{{\mathit{lane}}^\ast}^\ast}`, do:

      1) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})`.

      #) Append :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` to :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop}} = \mathsf{sqrt}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fsqrt}}}_{N}({\mathit{lane}}_1)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`\epsilon`.

   #. For each :math:`{{\mathit{lane}}^\ast}` in :math:`{{{\mathit{lane}}^\ast}^\ast}`, do:

      1) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})`.

      #) Append :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` to :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop}} = \mathsf{ceil}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fceil}}}_{N}({\mathit{lane}}_1)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`\epsilon`.

   #. For each :math:`{{\mathit{lane}}^\ast}` in :math:`{{{\mathit{lane}}^\ast}^\ast}`, do:

      1) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})`.

      #) Append :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` to :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop}} = \mathsf{floor}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{ffloor}}}_{N}({\mathit{lane}}_1)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`\epsilon`.

   #. For each :math:`{{\mathit{lane}}^\ast}` in :math:`{{{\mathit{lane}}^\ast}^\ast}`, do:

      1) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})`.

      #) Append :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` to :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop}} = \mathsf{trunc}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{ftrunc}}}_{N}({\mathit{lane}}_1)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`\epsilon`.

   #. For each :math:`{{\mathit{lane}}^\ast}` in :math:`{{{\mathit{lane}}^\ast}^\ast}`, do:

      1) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})`.

      #) Append :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` to :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{vunop}} = \mathsf{nearest}`.

#. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

#. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fnearest}}}_{N}({\mathit{lane}}_1)^\ast}`.

#. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`\epsilon`.

#. For each :math:`{{\mathit{lane}}^\ast}` in :math:`{{{\mathit{lane}}^\ast}^\ast}`, do:

   a. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})`.

   #. Append :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` to :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.


:math:`{{\mathit{vbinop}}}{{}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}}{({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)}`
..................................................................................................................................................................


1. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{vbinop}} = \mathsf{add}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{\mathrm{iadd}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}} = \mathsf{sub}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{\mathrm{isub}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}}` is some :math:`{\mathsf{min}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{min}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vbinop}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{\mathrm{imin}}}_{N}({\mathit{sx}}, {\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}}` is some :math:`{\mathsf{max}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{max}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vbinop}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{\mathrm{imax}}}_{N}({\mathit{sx}}, {\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}}` is some :math:`{\mathsf{add\_sat}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{add\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vbinop}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{{{\mathrm{iadd\_sat}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)}^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}}` is some :math:`{\mathsf{sub\_sat}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{sub\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vbinop}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{{{\mathrm{isub\_sat}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)}^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}} = \mathsf{mul}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{\mathrm{imul}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}} = `, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{{{\mathrm{iavgr}}}_{N}^{\mathsf{u}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)}^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}} = `, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{{{{\mathrm{iq{\kern-0.1em\scriptstyle 15\kern-0.1em}mulr\_sat}}}_{N}^{\mathsf{s}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)}^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{vbinop}} = \mathsf{add}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fadd}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`\epsilon`.

   #. For each :math:`{{\mathit{lane}}^\ast}` in :math:`{{{\mathit{lane}}^\ast}^\ast}`, do:

      1) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})`.

      #) Append :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` to :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}} = \mathsf{sub}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fsub}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`\epsilon`.

   #. For each :math:`{{\mathit{lane}}^\ast}` in :math:`{{{\mathit{lane}}^\ast}^\ast}`, do:

      1) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})`.

      #) Append :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` to :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}} = \mathsf{mul}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fmul}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`\epsilon`.

   #. For each :math:`{{\mathit{lane}}^\ast}` in :math:`{{{\mathit{lane}}^\ast}^\ast}`, do:

      1) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})`.

      #) Append :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` to :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}} = \mathsf{div}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fdiv}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`\epsilon`.

   #. For each :math:`{{\mathit{lane}}^\ast}` in :math:`{{{\mathit{lane}}^\ast}^\ast}`, do:

      1) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})`.

      #) Append :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` to :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}} = \mathsf{min}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fmin}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`\epsilon`.

   #. For each :math:`{{\mathit{lane}}^\ast}` in :math:`{{{\mathit{lane}}^\ast}^\ast}`, do:

      1) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})`.

      #) Append :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` to :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}} = \mathsf{max}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fmax}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`\epsilon`.

   #. For each :math:`{{\mathit{lane}}^\ast}` in :math:`{{{\mathit{lane}}^\ast}^\ast}`, do:

      1) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})`.

      #) Append :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` to :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}} = \mathsf{pmin}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fpmin}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`\epsilon`.

   #. For each :math:`{{\mathit{lane}}^\ast}` in :math:`{{{\mathit{lane}}^\ast}^\ast}`, do:

      1) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})`.

      #) Append :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` to :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{vbinop}} = \mathsf{pmax}`.

#. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

#. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{fpmax}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

#. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`\epsilon`.

#. For each :math:`{{\mathit{lane}}^\ast}` in :math:`{{{\mathit{lane}}^\ast}^\ast}`, do:

   a. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})`.

   #. Append :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` to :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.


:math:`{{\mathit{vrelop}}}{{}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}}{({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)}`
..................................................................................................................................................................


1. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{vrelop}} = \mathsf{eq}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`\epsilon`.

      #) For each :math:`{\mathit{lane}}_1` in :math:`{{\mathit{lane}}_1^\ast}` and :math:`{\mathit{lane}}_2` in :math:`{{\mathit{lane}}_2^\ast}`, do:

         a) Let :math:`{\mathit{lane}}_3` be :math:`{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{ieq}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}`.

         #) Append :math:`{\mathit{lane}}_3` to :math:`{{\mathit{lane}}_3^\ast}`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vrelop}} = \mathsf{ne}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`\epsilon`.

      #) For each :math:`{\mathit{lane}}_1` in :math:`{{\mathit{lane}}_1^\ast}` and :math:`{\mathit{lane}}_2` in :math:`{{\mathit{lane}}_2^\ast}`, do:

         a) Let :math:`{\mathit{lane}}_3` be :math:`{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{ine}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}`.

         #) Append :math:`{\mathit{lane}}_3` to :math:`{{\mathit{lane}}_3^\ast}`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vrelop}}` is some :math:`\mathsf{lt}~{\mathit{sx}}`, then:

      1) Let :math:`(\mathsf{lt}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{vrelop}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`\epsilon`.

      #) For each :math:`{\mathit{lane}}_1` in :math:`{{\mathit{lane}}_1^\ast}` and :math:`{\mathit{lane}}_2` in :math:`{{\mathit{lane}}_2^\ast}`, do:

         a) Let :math:`{\mathit{lane}}_3` be :math:`{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{{{\mathrm{ilt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)})}`.

         #) Append :math:`{\mathit{lane}}_3` to :math:`{{\mathit{lane}}_3^\ast}`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vrelop}}` is some :math:`\mathsf{gt}~{\mathit{sx}}`, then:

      1) Let :math:`(\mathsf{gt}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{vrelop}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`\epsilon`.

      #) For each :math:`{\mathit{lane}}_1` in :math:`{{\mathit{lane}}_1^\ast}` and :math:`{\mathit{lane}}_2` in :math:`{{\mathit{lane}}_2^\ast}`, do:

         a) Let :math:`{\mathit{lane}}_3` be :math:`{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{{{\mathrm{igt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)})}`.

         #) Append :math:`{\mathit{lane}}_3` to :math:`{{\mathit{lane}}_3^\ast}`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vrelop}}` is some :math:`\mathsf{le}~{\mathit{sx}}`, then:

      1) Let :math:`(\mathsf{le}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{vrelop}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`\epsilon`.

      #) For each :math:`{\mathit{lane}}_1` in :math:`{{\mathit{lane}}_1^\ast}` and :math:`{\mathit{lane}}_2` in :math:`{{\mathit{lane}}_2^\ast}`, do:

         a) Let :math:`{\mathit{lane}}_3` be :math:`{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{{{\mathrm{ile}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)})}`.

         #) Append :math:`{\mathit{lane}}_3` to :math:`{{\mathit{lane}}_3^\ast}`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vrelop}}` is some :math:`\mathsf{ge}~{\mathit{sx}}`, then:

      1) Let :math:`(\mathsf{ge}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{vrelop}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`\epsilon`.

      #) For each :math:`{\mathit{lane}}_1` in :math:`{{\mathit{lane}}_1^\ast}` and :math:`{\mathit{lane}}_2` in :math:`{{\mathit{lane}}_2^\ast}`, do:

         a) Let :math:`{\mathit{lane}}_3` be :math:`{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{{{\mathrm{ige}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)})}`.

         #) Append :math:`{\mathit{lane}}_3` to :math:`{{\mathit{lane}}_3^\ast}`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{vrelop}} = \mathsf{eq}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathit{lanetype}}|}`.

   #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`\epsilon`.

   #. For each :math:`{\mathit{lane}}_1` in :math:`{{\mathit{lane}}_1^\ast}` and :math:`{\mathit{lane}}_2` in :math:`{{\mathit{lane}}_2^\ast}`, do:

      1) Let :math:`{\mathit{lane}}_3` be :math:`{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{feq}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}`.

      #) Append :math:`{\mathit{lane}}_3` to :math:`{{\mathit{lane}}_3^\ast}`.

   #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

   #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop}} = \mathsf{ne}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathit{lanetype}}|}`.

   #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`\epsilon`.

   #. For each :math:`{\mathit{lane}}_1` in :math:`{{\mathit{lane}}_1^\ast}` and :math:`{\mathit{lane}}_2` in :math:`{{\mathit{lane}}_2^\ast}`, do:

      1) Let :math:`{\mathit{lane}}_3` be :math:`{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{fne}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}`.

      #) Append :math:`{\mathit{lane}}_3` to :math:`{{\mathit{lane}}_3^\ast}`.

   #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

   #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop}} = \mathsf{lt}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathit{lanetype}}|}`.

   #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`\epsilon`.

   #. For each :math:`{\mathit{lane}}_1` in :math:`{{\mathit{lane}}_1^\ast}` and :math:`{\mathit{lane}}_2` in :math:`{{\mathit{lane}}_2^\ast}`, do:

      1) Let :math:`{\mathit{lane}}_3` be :math:`{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{flt}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}`.

      #) Append :math:`{\mathit{lane}}_3` to :math:`{{\mathit{lane}}_3^\ast}`.

   #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

   #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop}} = \mathsf{gt}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathit{lanetype}}|}`.

   #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`\epsilon`.

   #. For each :math:`{\mathit{lane}}_1` in :math:`{{\mathit{lane}}_1^\ast}` and :math:`{\mathit{lane}}_2` in :math:`{{\mathit{lane}}_2^\ast}`, do:

      1) Let :math:`{\mathit{lane}}_3` be :math:`{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{fgt}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}`.

      #) Append :math:`{\mathit{lane}}_3` to :math:`{{\mathit{lane}}_3^\ast}`.

   #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

   #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop}} = \mathsf{le}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathit{lanetype}}|}`.

   #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`\epsilon`.

   #. For each :math:`{\mathit{lane}}_1` in :math:`{{\mathit{lane}}_1^\ast}` and :math:`{\mathit{lane}}_2` in :math:`{{\mathit{lane}}_2^\ast}`, do:

      1) Let :math:`{\mathit{lane}}_3` be :math:`{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{fle}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}`.

      #) Append :math:`{\mathit{lane}}_3` to :math:`{{\mathit{lane}}_3^\ast}`.

   #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

   #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. Assert: Due to validation, :math:`{\mathit{vrelop}} = \mathsf{ge}`.

#. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

#. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathit{lanetype}}|}`.

#. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`\epsilon`.

#. For each :math:`{\mathit{lane}}_1` in :math:`{{\mathit{lane}}_1^\ast}` and :math:`{\mathit{lane}}_2` in :math:`{{\mathit{lane}}_2^\ast}`, do:

   a. Let :math:`{\mathit{lane}}_3` be :math:`{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{fge}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}`.

   #. Append :math:`{\mathit{lane}}_3` to :math:`{{\mathit{lane}}_3^\ast}`.

#. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

#. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.


:math:`{{\mathrm{vcvtop}}}_{{{\mathit{lanetype}'}}{\mathsf{x}}{M_1}, {{\mathit{lanetype}}}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}, {\mathit{iN}}_1)`
.................................................................................................................................................


1. If :math:`{\mathit{lanetype}'}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{n}` and :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{extend}~{\mathit{half}}~{\mathit{sx}}`, then:

      1) Let :math:`(\mathsf{extend}~{\mathit{half}}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

      #) Let :math:`{\mathit{iN}}_2` be :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

      #) Return :math:`{\mathit{iN}}_2`.

   #. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{n}` and :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{convert}~{{\mathit{half}}^?}~{\mathit{sx}}`, then:

      1) Let :math:`(\mathsf{convert}~{{\mathit{half}}^?}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

      #) Let :math:`{\mathit{fN}}_2` be :math:`{{{{\mathrm{convert}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

      #) Return :math:`{\mathit{fN}}_2`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}'}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{n}` and :math:`{\mathit{vcvtop}}` is some :math:`\mathsf{trunc\_sat}~{\mathit{sx}}~{{\mathit{zero}}^?}`, then:

   a. Let :math:`(\mathsf{trunc\_sat}~{\mathit{sx}}~{{\mathit{zero}}^?})` be the destructuring of :math:`{\mathit{vcvtop}}`.

   #. Let :math:`{{\mathit{iN}}_2^?}` be :math:`{{{{\mathrm{trunc\_sat}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

   #. Return :math:`{{\mathit{iN}}_2^?}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{n}`.

#. If :math:`{\mathit{vcvtop}} = (\mathsf{demote}~\mathsf{zero})`, then:

   a. Let :math:`{{\mathit{fN}}_2^\ast}` be :math:`{{\mathrm{demote}}}_{N_1, N_2}({\mathit{iN}}_1)`.

   #. Return :math:`{{\mathit{fN}}_2^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{vcvtop}} = `.

#. Let :math:`{{\mathit{fN}}_2^\ast}` be :math:`{{\mathrm{promote}}}_{N_1, N_2}({\mathit{iN}}_1)`.

#. Return :math:`{{\mathit{fN}}_2^\ast}`.


:math:`{{\mathrm{vextunop}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(\mathsf{extadd\_pairwise}~{\mathit{sx}}, c_1)`
............................................................................................................................................................


1. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_1)`.

#. Let :math:`{{\mathit{cj}}_1~{\mathit{cj}}_2^\ast}` be the result for which the :ref:`concatenation <notation-concat>` of :math:`{{\mathit{cj}}_1~{\mathit{cj}}_2^\ast}` is :math:`{{{{{\mathrm{extend}}}_{N_2, N_1}^{{\mathit{sx}}}}}{({\mathit{ci}})}^\ast}`.

#. Let :math:`c` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}}({{{\mathrm{iadd}}}_{N_1}({\mathit{cj}}_1, {\mathit{cj}}_2)^\ast})`.

#. Return :math:`c`.


:math:`{{\mathrm{vextbinop}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}({\mathit{vextbinop}}, c_1, c_2)`
...............................................................................................................................................


1. If :math:`{\mathit{vextbinop}}` is some :math:`{\mathsf{extmul}}{\mathsf{\_}}{{\mathit{half}}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

   a. Let :math:`({\mathsf{extmul}}{\mathsf{\_}}{{\mathit{half}}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vextbinop}}`.

   #. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_1){}[{\mathrm{half}}({\mathit{half}}, 0, M_1) : M_1]`.

   #. Let :math:`{{\mathit{ci}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_2){}[{\mathrm{half}}({\mathit{half}}, 0, M_1) : M_1]`.

   #. Let :math:`c` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}}({{{\mathrm{imul}}}_{N_1}({{{{\mathrm{extend}}}_{N_2, N_1}^{{\mathit{sx}}}}}{({\mathit{ci}}_1)}, {{{{\mathrm{extend}}}_{N_2, N_1}^{{\mathit{sx}}}}}{({\mathit{ci}}_2)})^\ast})`.

   #. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{vextbinop}} = `.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_1)`.

#. Let :math:`{{\mathit{ci}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_2)`.

#. Let :math:`{{\mathit{cj}}_1~{\mathit{cj}}_2^\ast}` be the result for which the :ref:`concatenation <notation-concat>` of :math:`{{\mathit{cj}}_1~{\mathit{cj}}_2^\ast}` is :math:`{{{\mathrm{imul}}}_{N_1}({{{{\mathrm{extend}}}_{N_2, N_1}^{\mathsf{s}}}}{({\mathit{ci}}_1)}, {{{{\mathrm{extend}}}_{N_2, N_1}^{\mathsf{s}}}}{({\mathit{ci}}_2)})^\ast}`.

#. Let :math:`c` be :math:`{{\mathrm{inv}}_{{\mathit{lanes}}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}}({{{\mathrm{iadd}}}_{N_1}({\mathit{cj}}_1, {\mathit{cj}}_2)^\ast})`.

#. Return :math:`c`.


:math:`{{{\mathit{vshiftop}}}{\mathsf{\_}}~{{\mathsf{i}}{n}}{\mathsf{x}}{M}}{({\mathit{lane}}, n)}`
...................................................................................................


1. If :math:`{\mathit{vshiftop}} = \mathsf{shl}`, then:

   a. Return :math:`{{\mathrm{ishl}}}_{N}({\mathit{lane}}, n)`.

#. Assert: Due to validation, :math:`{\mathit{vshiftop}}` is some :math:`\mathsf{shr}~{\mathit{sx}}`.

#. Let :math:`(\mathsf{shr}~{\mathit{sx}})` be the destructuring of :math:`{\mathit{vshiftop}}`.

#. Return :math:`{{{{\mathrm{ishr}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}, n)}`.


:math:`{{\mathrm{default}}}_{{\mathit{valtype}}}`
.................................................


1. If :math:`{\mathit{valtype}} = \mathsf{i{\scriptstyle 32}}`, then:

   a. Return :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)`.

#. If :math:`{\mathit{valtype}} = \mathsf{i{\scriptstyle 64}}`, then:

   a. Return :math:`(\mathsf{i{\scriptstyle 64}}{.}\mathsf{const}~0)`.

#. If :math:`{\mathit{valtype}} = \mathsf{f{\scriptstyle 32}}`, then:

   a. Return :math:`(\mathsf{f{\scriptstyle 32}}{.}\mathsf{const}~{+0})`.

#. If :math:`{\mathit{valtype}} = \mathsf{f{\scriptstyle 64}}`, then:

   a. Return :math:`(\mathsf{f{\scriptstyle 64}}{.}\mathsf{const}~{+0})`.

#. If :math:`{\mathit{valtype}} = \mathsf{v{\scriptstyle 128}}`, then:

   a. Return :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~0)`.

#. If :math:`{\mathit{valtype}} = \mathsf{funcref}`, then:

   a. Return :math:`(\mathsf{ref{.}null}~\mathsf{funcref})`.

#. Assert: Due to validation, :math:`{\mathit{valtype}} = \mathsf{externref}`.

#. Return :math:`(\mathsf{ref{.}null}~\mathsf{externref})`.


:math:`{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`
.......................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{func}~{\mathit{funcaddr}}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{fa}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{fa}}~{\mathrm{funcs}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`
.........................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{global}~{\mathit{globaladdr}}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{ga}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ga}}~{\mathrm{globals}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`
........................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{table}~{\mathit{tableaddr}}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{ta}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ta}}~{\mathrm{tables}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`
......................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{mem}~{\mathit{memaddr}}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{ma}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ma}}~{\mathrm{mems}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xv}}^\ast})`.


:math:`(s, f){.}\mathsf{store}`
...............................


1. Return.


:math:`(s, f){.}\mathsf{frame}`
...............................


1. Return :math:`f`.


:math:`(s, f){.}\mathsf{module}{.}\mathsf{funcs}`
.................................................


1. Return :math:`f{.}\mathsf{module}{.}\mathsf{funcs}`.


:math:`(s, f){.}\mathsf{funcs}`
...............................


1. Return :math:`s{.}\mathsf{funcs}`.


:math:`(s, f){.}\mathsf{globals}`
.................................


1. Return :math:`s{.}\mathsf{globals}`.


:math:`(s, f){.}\mathsf{tables}`
................................


1. Return :math:`s{.}\mathsf{tables}`.


:math:`(s, f){.}\mathsf{mems}`
..............................


1. Return :math:`s{.}\mathsf{mems}`.


:math:`(s, f){.}\mathsf{elems}`
...............................


1. Return :math:`s{.}\mathsf{elems}`.


:math:`(s, f){.}\mathsf{datas}`
...............................


1. Return :math:`s{.}\mathsf{datas}`.


:math:`(s, f){.}\mathsf{module}`
................................


1. Return :math:`f{.}\mathsf{module}`.


:math:`(s, f){.}\mathsf{types}{}[x]`
....................................


1. Return :math:`f{.}\mathsf{module}{.}\mathsf{types}{}[x]`.


:math:`(s, f){.}\mathsf{funcs}{}[x]`
....................................


1. Return :math:`s{.}\mathsf{funcs}{}[f{.}\mathsf{module}{.}\mathsf{funcs}{}[x]]`.


:math:`(s, f){.}\mathsf{globals}{}[x]`
......................................


1. Return :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]`.


:math:`(s, f){.}\mathsf{tables}{}[x]`
.....................................


1. Return :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]`.


:math:`(s, f){.}\mathsf{mems}{}[x]`
...................................


1. Return :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]`.


:math:`(s, f){.}\mathsf{elems}{}[x]`
....................................


1. Return :math:`s{.}\mathsf{elems}{}[f{.}\mathsf{module}{.}\mathsf{elems}{}[x]]`.


:math:`(s, f){.}\mathsf{datas}{}[x]`
....................................


1. Return :math:`s{.}\mathsf{datas}{}[f{.}\mathsf{module}{.}\mathsf{datas}{}[x]]`.


:math:`(s, f){.}\mathsf{locals}{}[x]`
.....................................


1. Return :math:`f{.}\mathsf{locals}{}[x]`.


:math:`(s, f){}[{.}\mathsf{locals}{}[x] = v]`
.............................................


1. Replace :math:`f{.}\mathsf{locals}{}[x]` with :math:`v`.


:math:`(s, f){}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = v]`
...............................................................


1. Replace :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]{.}\mathsf{value}` with :math:`v`.


:math:`(s, f){}[{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i] = r]`
..................................................................


1. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]{.}\mathsf{refs}{}[i]` with :math:`r`.


:math:`(s, f){}[{.}\mathsf{tables}{}[x] = {\mathit{ti}}]`
.........................................................


1. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]` with :math:`{\mathit{ti}}`.


:math:`(s, f){}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i : j] = {b^\ast}]`
............................................................................


1. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]{.}\mathsf{bytes}{}[i : j]` with :math:`{b^\ast}`.


:math:`(s, f){}[{.}\mathsf{mems}{}[x] = {\mathit{mi}}]`
.......................................................


1. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]` with :math:`{\mathit{mi}}`.


:math:`(s, f){}[{.}\mathsf{elems}{}[x]{.}\mathsf{refs} = {r^\ast}]`
...................................................................


1. Replace :math:`s{.}\mathsf{elems}{}[f{.}\mathsf{module}{.}\mathsf{elems}{}[x]]{.}\mathsf{refs}` with :math:`{r^\ast}`.


:math:`(s, f){}[{.}\mathsf{datas}{}[x]{.}\mathsf{bytes} = {b^\ast}]`
....................................................................


1. Replace :math:`s{.}\mathsf{datas}{}[f{.}\mathsf{module}{.}\mathsf{datas}{}[x]]{.}\mathsf{bytes}` with :math:`{b^\ast}`.


:math:`{\mathrm{growtable}}({\mathit{ti}}, n, r)`
.................................................


1. Let :math:`\{ \mathsf{type}~({}[ i .. {j^?} ]~{\mathit{rt}}),\;\allowbreak \mathsf{refs}~{{r'}^\ast} \}` be the destructuring of :math:`{\mathit{ti}}`.

#. Let :math:`{i'}` be :math:`{|{{r'}^\ast}|} + n`.

#. If :math:`{({i'} \leq j)^?}`, then:

   a. Let :math:`{\mathit{ti}'}` be the table instance :math:`\{ \mathsf{type}~({}[ {i'} .. {j^?} ]~{\mathit{rt}}),\;\allowbreak \mathsf{refs}~{{r'}^\ast}~{r^{n}} \}`.

   #. Return :math:`{\mathit{ti}'}`.

#. Fail.


:math:`{\mathrm{growmemory}}({\mathit{mi}}, n)`
...............................................


1. Let :math:`\{ \mathsf{type}~{}[ i .. {j^?} ]~\mathsf{page},\;\allowbreak \mathsf{bytes}~{b^\ast} \}` be the destructuring of :math:`{\mathit{mi}}`.

#. Let :math:`{i'}` be :math:`{|{b^\ast}|} / (64 \, {\mathrm{Ki}}) + n`.

#. If :math:`{({i'} \leq j)^?}`, then:

   a. Let :math:`{\mathit{mi}'}` be the memory instance :math:`\{ \mathsf{type}~{}[ {i'} .. {j^?} ]~\mathsf{page},\;\allowbreak \mathsf{bytes}~{b^\ast}~{\mathtt{0x00}^{n \cdot 64 \, {\mathrm{Ki}}}} \}`.

   #. Return :math:`{\mathit{mi}'}`.

#. Fail.


:math:`{{\mathrm{blocktype}}}_{z}({\mathit{blocktype}})`
........................................................


1. If :math:`{\mathit{blocktype}} = ()`, then:

   a. Return :math:`\epsilon~\rightarrow~\epsilon`.

#. If :math:`{\mathit{blocktype}}` is some :math:`{{\mathit{valtype}}^?}`, then:

   a. Let :math:`{{\mathit{valtype}}_0^?}` be the block type :math:`{\mathit{blocktype}}`.

   #. If :math:`{{\mathit{valtype}}_0^?}` is defined, then:

      1) Let :math:`t` be :math:`{{\mathit{valtype}}_0^?}`.

      #) Return :math:`\epsilon~\rightarrow~t`.

#. Assert: Due to validation, :math:`{\mathit{blocktype}}` is some :math:`{\mathit{funcidx}}`.

#. Let :math:`x` be the block type :math:`{\mathit{blocktype}}`.

#. Return :math:`z{.}\mathsf{types}{}[x]`.


:math:`{\mathrm{funcs}}({{\mathit{externaddr}''}^\ast})`
........................................................


1. If :math:`{{\mathit{externaddr}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{func}~{\mathit{funcaddr}}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{fa}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{fa}}~{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externaddr}''}^\ast})`
..........................................................


1. If :math:`{{\mathit{externaddr}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{global}~{\mathit{globaladdr}}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{ga}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ga}}~{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externaddr}''}^\ast})`
.........................................................


1. If :math:`{{\mathit{externaddr}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{table}~{\mathit{tableaddr}}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{ta}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ta}}~{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externaddr}''}^\ast})`
.......................................................


1. If :math:`{{\mathit{externaddr}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{mem}~{\mathit{memaddr}}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{ma}})` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ma}}~{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}''}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{allocfunc}}(s, {\mathit{moduleinst}}, {\mathit{func}})`
.......................................................................


1. Let :math:`(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}})` be the destructuring of :math:`{\mathit{func}}`.

#. Let :math:`{\mathit{fi}}` be the function instance :math:`\{ \mathsf{type}~{\mathit{moduleinst}}{.}\mathsf{types}{}[x],\;\allowbreak \mathsf{module}~{\mathit{moduleinst}},\;\allowbreak \mathsf{code}~{\mathit{func}} \}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{funcs}`.

#. Append :math:`{\mathit{fi}}` to :math:`s{.}\mathsf{funcs}`.

#. Return :math:`a`.


:math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}''}^\ast})`
.................................................................................


1. If :math:`{{\mathit{func}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{func}}~{{\mathit{func}'}^\ast}` be :math:`{{\mathit{func}''}^\ast}`.

#. Let :math:`{\mathit{fa}}` be :math:`{\mathrm{allocfunc}}(s, {\mathit{moduleinst}}, {\mathit{func}})`.

#. Let :math:`{{\mathit{fa}'}^\ast}` be :math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}'}^\ast})`.

#. Return :math:`{\mathit{fa}}~{{\mathit{fa}'}^\ast}`.


:math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`
........................................................................


1. Let :math:`{\mathit{gi}}` be the global instance :math:`\{ \mathsf{type}~{\mathit{globaltype}},\;\allowbreak \mathsf{value}~{\mathit{val}} \}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{globals}`.

#. Append :math:`{\mathit{gi}}` to :math:`s{.}\mathsf{globals}`.

#. Return :math:`a`.


:math:`{\mathrm{allocglobals}}(s, {{\mathit{globaltype}''}^\ast}, {{\mathit{val}''}^\ast})`
...........................................................................................


1. If :math:`{{\mathit{globaltype}''}^\ast} = \epsilon`, then:

   a. Assert: :math:`{{\mathit{val}''}^\ast} = \epsilon`.

   #. Return :math:`\epsilon`.

#. Else:

   a. Let :math:`{\mathit{globaltype}}~{{\mathit{globaltype}'}^\ast}` be :math:`{{\mathit{globaltype}''}^\ast}`.

   #. Assert: :math:`{|{{\mathit{val}''}^\ast}|} \geq 1`.

   #. Let :math:`{\mathit{val}}~{{\mathit{val}'}^\ast}` be :math:`{{\mathit{val}''}^\ast}`.

   #. Let :math:`{\mathit{ga}}` be :math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`.

   #. Let :math:`{{\mathit{ga}'}^\ast}` be :math:`{\mathrm{allocglobals}}(s, {{\mathit{globaltype}'}^\ast}, {{\mathit{val}'}^\ast})`.

   #. Return :math:`{\mathit{ga}}~{{\mathit{ga}'}^\ast}`.


:math:`{\mathrm{alloctable}}(s, {}[ i .. {j^?} ]~{\mathit{rt}})`
................................................................


1. Let :math:`{\mathit{ti}}` be the table instance :math:`\{ \mathsf{type}~({}[ i .. {j^?} ]~{\mathit{rt}}),\;\allowbreak \mathsf{refs}~{(\mathsf{ref{.}null}~{\mathit{rt}})^{i}} \}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{tables}`.

#. Append :math:`{\mathit{ti}}` to :math:`s{.}\mathsf{tables}`.

#. Return :math:`a`.


:math:`{\mathrm{alloctables}}(s, {{\mathit{tabletype}''}^\ast})`
................................................................


1. If :math:`{{\mathit{tabletype}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{tabletype}}~{{\mathit{tabletype}'}^\ast}` be :math:`{{\mathit{tabletype}''}^\ast}`.

#. Let :math:`{\mathit{ta}}` be :math:`{\mathrm{alloctable}}(s, {\mathit{tabletype}})`.

#. Let :math:`{{\mathit{ta}'}^\ast}` be :math:`{\mathrm{alloctables}}(s, {{\mathit{tabletype}'}^\ast})`.

#. Return :math:`{\mathit{ta}}~{{\mathit{ta}'}^\ast}`.


:math:`{\mathrm{allocmem}}(s, {}[ i .. {j^?} ]~\mathsf{page})`
..............................................................


1. Let :math:`{\mathit{mi}}` be the memory instance :math:`\{ \mathsf{type}~{}[ i .. {j^?} ]~\mathsf{page},\;\allowbreak \mathsf{bytes}~{\mathtt{0x00}^{i \cdot 64 \, {\mathrm{Ki}}}} \}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{mems}`.

#. Append :math:`{\mathit{mi}}` to :math:`s{.}\mathsf{mems}`.

#. Return :math:`a`.


:math:`{\mathrm{allocmems}}(s, {{\mathit{memtype}''}^\ast})`
............................................................


1. If :math:`{{\mathit{memtype}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{memtype}}~{{\mathit{memtype}'}^\ast}` be :math:`{{\mathit{memtype}''}^\ast}`.

#. Let :math:`{\mathit{ma}}` be :math:`{\mathrm{allocmem}}(s, {\mathit{memtype}})`.

#. Let :math:`{{\mathit{ma}'}^\ast}` be :math:`{\mathrm{allocmems}}(s, {{\mathit{memtype}'}^\ast})`.

#. Return :math:`{\mathit{ma}}~{{\mathit{ma}'}^\ast}`.


:math:`{\mathrm{allocelem}}(s, {\mathit{rt}}, {{\mathit{ref}}^\ast})`
.....................................................................


1. Let :math:`{\mathit{ei}}` be the element instance :math:`\{ \mathsf{type}~{\mathit{rt}},\;\allowbreak \mathsf{refs}~{{\mathit{ref}}^\ast} \}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{elems}`.

#. Append :math:`{\mathit{ei}}` to :math:`s{.}\mathsf{elems}`.

#. Return :math:`a`.


:math:`{\mathrm{allocelems}}(s, {{\mathit{reftype}}^\ast}, {{\mathit{ref}''}^\ast})`
....................................................................................


1. If :math:`{{\mathit{ref}''}^\ast} = \epsilon`, then:

   a. Assert: :math:`{{\mathit{reftype}}^\ast} = \epsilon`.

   #. Return :math:`\epsilon`.

#. Else:

   a. Let :math:`{{\mathit{ref}}^\ast}~{{{\mathit{ref}'}^\ast}^\ast}` be :math:`{{\mathit{ref}''}^\ast}`.

   #. Assert: :math:`{|{{\mathit{reftype}}^\ast}|} \geq 1`.

   #. Let :math:`{\mathit{rt}}~{{\mathit{rt}'}^\ast}` be :math:`{{\mathit{reftype}}^\ast}`.

   #. Let :math:`{\mathit{ea}}` be :math:`{\mathrm{allocelem}}(s, {\mathit{rt}}, {{\mathit{ref}}^\ast})`.

   #. Let :math:`{{\mathit{ea}'}^\ast}` be :math:`{\mathrm{allocelems}}(s, {{\mathit{rt}'}^\ast}, {{{\mathit{ref}'}^\ast}^\ast})`.

   #. Return :math:`{\mathit{ea}}~{{\mathit{ea}'}^\ast}`.


:math:`{\mathrm{allocdata}}(s, {{\mathit{byte}}^\ast})`
.......................................................


1. Let :math:`{\mathit{di}}` be the data instance :math:`\{ \mathsf{bytes}~{{\mathit{byte}}^\ast} \}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{datas}`.

#. Append :math:`{\mathit{di}}` to :math:`s{.}\mathsf{datas}`.

#. Return :math:`a`.


:math:`{\mathrm{allocdatas}}(s, {{\mathit{byte}''}^\ast})`
..........................................................


1. If :math:`{{\mathit{byte}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{{\mathit{byte}}^\ast}~{{{\mathit{byte}'}^\ast}^\ast}` be :math:`{{\mathit{byte}''}^\ast}`.

#. Let :math:`{\mathit{da}}` be :math:`{\mathrm{allocdata}}(s, {{\mathit{byte}}^\ast})`.

#. Let :math:`{{\mathit{da}'}^\ast}` be :math:`{\mathrm{allocdatas}}(s, {{{\mathit{byte}'}^\ast}^\ast})`.

#. Return :math:`{\mathit{da}}~{{\mathit{da}'}^\ast}`.


:math:`{\mathrm{instexport}}({{\mathit{fa}}^\ast}, {{\mathit{ga}}^\ast}, {{\mathit{ta}}^\ast}, {{\mathit{ma}}^\ast}, \mathsf{export}~{\mathit{name}}~{\mathit{externidx}})`
...........................................................................................................................................................................


1. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{func}~{\mathit{funcidx}}`, then:

   a. Let :math:`(\mathsf{func}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`\{ \mathsf{name}~{\mathit{name}},\;\allowbreak \mathsf{addr}~(\mathsf{func}~{{\mathit{fa}}^\ast}{}[x]) \}`.

#. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{global}~{\mathit{globalidx}}`, then:

   a. Let :math:`(\mathsf{global}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`\{ \mathsf{name}~{\mathit{name}},\;\allowbreak \mathsf{addr}~(\mathsf{global}~{{\mathit{ga}}^\ast}{}[x]) \}`.

#. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{table}~{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`\{ \mathsf{name}~{\mathit{name}},\;\allowbreak \mathsf{addr}~(\mathsf{table}~{{\mathit{ta}}^\ast}{}[x]) \}`.

#. Assert: :math:`{\mathit{externidx}}` is some :math:`\mathsf{mem}~{\mathit{memidx}}`.

#. Let :math:`(\mathsf{mem}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

#. Return :math:`\{ \mathsf{name}~{\mathit{name}},\;\allowbreak \mathsf{addr}~(\mathsf{mem}~{{\mathit{ma}}^\ast}{}[x]) \}`.


:math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}^\ast}, {{{\mathit{ref}}^\ast}^\ast})`
.......................................................................................................................................


1. Let :math:`(\mathsf{module}~{{\mathit{type}}_0^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^{n_{\mathit{func}}}}~{{\mathit{global}}_1^\ast}~{{\mathit{table}}_2^\ast}~{{\mathit{mem}}_3^\ast}~{{\mathit{elem}}_4^\ast}~{{\mathit{data}}_5^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be the destructuring of :math:`{\mathit{module}}`.

#. Let :math:`{(\mathsf{data}~{{\mathit{byte}}^\ast}~{\mathit{datamode}})^{n_{\mathit{data}}}}` be :math:`{{\mathit{data}}_5^\ast}`.

#. Let :math:`{(\mathsf{elem}~{\mathit{rt}}~{{\mathit{expr}}_2^\ast}~{\mathit{elemmode}})^{n_{\mathit{elem}}}}` be :math:`{{\mathit{elem}}_4^\ast}`.

#. Let :math:`{(\mathsf{memory}~{\mathit{memtype}})^{n_{\mathit{mem}}}}` be :math:`{{\mathit{mem}}_3^\ast}`.

#. Let :math:`{(\mathsf{table}~{\mathit{tabletype}})^{n_{\mathit{table}}}}` be :math:`{{\mathit{table}}_2^\ast}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_1)^{n_{\mathit{global}}}}` be :math:`{{\mathit{global}}_1^\ast}`.

#. Let :math:`{{\mathit{ft}}^\ast}` be the function type sequence :math:`\epsilon`.

#. For each :math:`{\mathit{type}}_0` in :math:`{{\mathit{type}}_0^\ast}`, do:

   a. Let :math:`(\mathsf{type}~{\mathit{ft}})` be the destructuring of :math:`{\mathit{type}}_0`.

   #. Append :math:`{\mathit{ft}}` to :math:`{{\mathit{ft}}^\ast}`.

#. Let :math:`{{\mathit{fa}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ga}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{globals}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ma}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{mems}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ta}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{tables}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{fa}}^\ast}` be :math:`{|s{.}\mathsf{funcs}|} + i_{\mathit{func}}` for all :math:`i_{\mathit{func}}` from :math:`0` to :math:`n_{\mathit{func}} - 1`.

#. Let :math:`{{\mathit{ga}}^\ast}` be :math:`{|s{.}\mathsf{globals}|} + i_{\mathit{global}}` for all :math:`i_{\mathit{global}}` from :math:`0` to :math:`n_{\mathit{global}} - 1`.

#. Let :math:`{{\mathit{ta}}^\ast}` be :math:`{|s{.}\mathsf{tables}|} + i_{\mathit{table}}` for all :math:`i_{\mathit{table}}` from :math:`0` to :math:`n_{\mathit{table}} - 1`.

#. Let :math:`{{\mathit{ma}}^\ast}` be :math:`{|s{.}\mathsf{mems}|} + i_{\mathit{mem}}` for all :math:`i_{\mathit{mem}}` from :math:`0` to :math:`n_{\mathit{mem}} - 1`.

#. Let :math:`{{\mathit{ea}}^\ast}` be :math:`{|s{.}\mathsf{elems}|} + i_{\mathit{elem}}` for all :math:`i_{\mathit{elem}}` from :math:`0` to :math:`n_{\mathit{elem}} - 1`.

#. Let :math:`{{\mathit{da}}^\ast}` be :math:`{|s{.}\mathsf{datas}|} + i_{\mathit{data}}` for all :math:`i_{\mathit{data}}` from :math:`0` to :math:`n_{\mathit{data}} - 1`.

#. Let :math:`{{\mathit{xi}}^\ast}` be the export instance sequence :math:`\epsilon`.

#. For each :math:`{\mathit{export}}` in :math:`{{\mathit{export}}^\ast}`, do:

   a. Let :math:`{\mathit{xi}}` be the export instance :math:`{\mathrm{instexport}}({{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast}, {{\mathit{ga}}_{\mathit{ex}}^\ast}~{{\mathit{ga}}^\ast}, {{\mathit{ta}}_{\mathit{ex}}^\ast}~{{\mathit{ta}}^\ast}, {{\mathit{ma}}_{\mathit{ex}}^\ast}~{{\mathit{ma}}^\ast}, {\mathit{export}})`.

   #. Append :math:`{\mathit{xi}}` to :math:`{{\mathit{xi}}^\ast}`.

#. Let :math:`{\mathit{moduleinst}}` be the module instance :math:`\{ \mathsf{types}~{{\mathit{ft}}^\ast},\;\allowbreak \mathsf{funcs}~{{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast},\;\allowbreak \mathsf{globals}~{{\mathit{ga}}_{\mathit{ex}}^\ast}~{{\mathit{ga}}^\ast},\;\allowbreak \mathsf{tables}~{{\mathit{ta}}_{\mathit{ex}}^\ast}~{{\mathit{ta}}^\ast},\;\allowbreak \mathsf{mems}~{{\mathit{ma}}_{\mathit{ex}}^\ast}~{{\mathit{ma}}^\ast},\;\allowbreak \mathsf{elems}~{{\mathit{ea}}^\ast},\;\allowbreak \mathsf{datas}~{{\mathit{da}}^\ast},\;\allowbreak \mathsf{exports}~{{\mathit{xi}}^\ast} \}`.

#. Let :math:`{{\mathit{funcaddr}}_0^\ast}` be :math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}}^{n_{\mathit{func}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{funcaddr}}_0^\ast} = {{\mathit{fa}}^\ast}`.

#. Let :math:`{{\mathit{globaladdr}}_0^\ast}` be :math:`{\mathrm{allocglobals}}(s, {{\mathit{globaltype}}^{n_{\mathit{global}}}}, {{\mathit{val}}^\ast})`.

#. Assert: Due to validation, :math:`{{\mathit{globaladdr}}_0^\ast} = {{\mathit{ga}}^\ast}`.

#. Let :math:`{{\mathit{tableaddr}}_0^\ast}` be :math:`{\mathrm{alloctables}}(s, {{\mathit{tabletype}}^{n_{\mathit{table}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{tableaddr}}_0^\ast} = {{\mathit{ta}}^\ast}`.

#. Let :math:`{{\mathit{memaddr}}_0^\ast}` be :math:`{\mathrm{allocmems}}(s, {{\mathit{memtype}}^{n_{\mathit{mem}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{memaddr}}_0^\ast} = {{\mathit{ma}}^\ast}`.

#. Let :math:`{{\mathit{elemaddr}}_0^\ast}` be :math:`{\mathrm{allocelems}}(s, {{\mathit{rt}}^{n_{\mathit{elem}}}}, {{{\mathit{ref}}^\ast}^\ast})`.

#. Assert: Due to validation, :math:`{{\mathit{elemaddr}}_0^\ast} = {{\mathit{ea}}^\ast}`.

#. Let :math:`{{\mathit{dataaddr}}_0^\ast}` be :math:`{\mathrm{allocdatas}}(s, {({{\mathit{byte}}^\ast})^{n_{\mathit{data}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{dataaddr}}_0^\ast} = {{\mathit{da}}^\ast}`.

#. Return :math:`{\mathit{moduleinst}}`.


:math:`{\mathrm{runelem}}(\mathsf{elem}~{\mathit{reftype}}~{{\mathit{expr}}^\ast}~{\mathit{elemmode}}, i)`
..........................................................................................................


1. If :math:`{\mathit{elemmode}} = \mathsf{passive}`, then:

   a. Return :math:`\epsilon`.

#. If :math:`{\mathit{elemmode}} = \mathsf{declare}`, then:

   a. Return :math:`(\mathsf{elem{.}drop}~i)`.

#. Assert: :math:`{\mathit{elemmode}}` is some :math:`\mathsf{active}~{\mathit{tableidx}}~{\mathit{expr}}`.

#. Let :math:`(\mathsf{active}~x~{{\mathit{instr}}^\ast})` be the destructuring of :math:`{\mathit{elemmode}}`.

#. Let :math:`n` be the length of :math:`{{\mathit{expr}}^\ast}`.

#. Return :math:`{{\mathit{instr}}^\ast}~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)~(\mathsf{table{.}init}~x~i)~(\mathsf{elem{.}drop}~i)`.


:math:`{\mathrm{rundata}}(\mathsf{data}~{{\mathit{byte}}^\ast}~{\mathit{datamode}}, i)`
.......................................................................................


1. If :math:`{\mathit{datamode}} = \mathsf{passive}`, then:

   a. Return :math:`\epsilon`.

#. Assert: :math:`{\mathit{datamode}}` is some :math:`\mathsf{active}~{\mathit{memidx}}~{\mathit{expr}}`.

#. Let :math:`(\mathsf{active}~{\mathit{memidx}}_0~{{\mathit{instr}}^\ast})` be the destructuring of :math:`{\mathit{datamode}}`.

#. Assert: Due to validation, :math:`{\mathit{memidx}}_0 = 0`.

#. Let :math:`n` be the length of :math:`{{\mathit{byte}}^\ast}`.

#. Return :math:`{{\mathit{instr}}^\ast}~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)~(\mathsf{memory{.}init}~i)~(\mathsf{data{.}drop}~i)`.


:math:`{\mathrm{instantiate}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast})`
..................................................................................


1. Let :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be the destructuring of :math:`{\mathit{module}}`.

#. Let :math:`{{\mathit{functype}}^\ast}` be the function type sequence :math:`\epsilon`.

#. For each :math:`{\mathit{type}}` in :math:`{{\mathit{type}}^\ast}`, do:

   a. Let :math:`(\mathsf{type}~{\mathit{functype}})` be the destructuring of :math:`{\mathit{type}}`.

   #. Append :math:`{\mathit{functype}}` to :math:`{{\mathit{functype}}^\ast}`.

#. Let :math:`n_{\mathsf{d}}` be the length of :math:`{{\mathit{data}}^\ast}`.

#. Let :math:`n_{\mathsf{e}}` be the length of :math:`{{\mathit{elem}}^\ast}`.

#. Let :math:`n_{\mathsf{f}}` be the length of :math:`{{\mathit{func}}^\ast}`.

#. Let :math:`{{\mathit{expr}}_{\mathsf{g}}^\ast}` be the expression sequence :math:`\epsilon`.

#. For each :math:`{\mathit{global}}` in :math:`{{\mathit{global}}^\ast}`, do:

   a. Let :math:`(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_{\mathsf{g}})` be the destructuring of :math:`{\mathit{global}}`.

   #. Append :math:`{\mathit{expr}}_{\mathsf{g}}` to :math:`{{\mathit{expr}}_{\mathsf{g}}^\ast}`.

#. Let :math:`{{{\mathit{expr}}_{\mathsf{e}}^\ast}^\ast}` be the expression sequence sequence :math:`\epsilon`.

#. For each :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}`, do:

   a. Let :math:`(\mathsf{elem}~{\mathit{reftype}}~{{\mathit{expr}}_{\mathsf{e}}^\ast}~{\mathit{elemmode}})` be the destructuring of :math:`{\mathit{elem}}`.

   #. Append :math:`{{\mathit{expr}}_{\mathsf{e}}^\ast}` to :math:`{{{\mathit{expr}}_{\mathsf{e}}^\ast}^\ast}`.

#. Let :math:`{{\mathit{instr}}_{\mathsf{d}}^\ast}` be the :ref:`concatenation <notation-concat>` of :math:`{{\mathrm{rundata}}({{\mathit{data}}^\ast}{}[j], j)^{j<n_{\mathsf{d}}}}`.

#. Let :math:`{{\mathit{instr}}_{\mathsf{e}}^\ast}` be the :ref:`concatenation <notation-concat>` of :math:`{{\mathrm{runelem}}({{\mathit{elem}}^\ast}{}[i], i)^{i<n_{\mathsf{e}}}}`.

#. Let :math:`{\mathit{moduleinst}}_{\mathit{init}}` be the module instance :math:`\{ \mathsf{types}~{{\mathit{functype}}^\ast},\;\allowbreak \mathsf{funcs}~{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})~{({|s{.}\mathsf{funcs}|} + i_{\mathsf{f}})^{i_{\mathsf{f}}<n_{\mathsf{f}}}},\;\allowbreak \mathsf{globals}~{\mathrm{globals}}({{\mathit{externaddr}}^\ast}) \}`.

#. Let :math:`f_{\mathit{init}}` be the frame :math:`\{ \mathsf{module}~{\mathit{moduleinst}}_{\mathit{init}} \}`.

#. Let :math:`z` be the state :math:`(s, f_{\mathit{init}})`.

#. Let :math:`F` be the :math:`\mathsf{frame}` :math:`z{.}\mathsf{frame}`.

#. Push the :math:`\mathsf{frame}` :math:`F`.

#. Let :math:`{{\mathit{val}}^\ast}` be the value sequence :math:`\epsilon`.

#. For each :math:`{\mathit{expr}}_{\mathsf{g}}` in :math:`{{\mathit{expr}}_{\mathsf{g}}^\ast}`, do:

   a. Let :math:`{\mathit{val}}` be the result of :ref:`evaluating <exec-expr>` :math:`{\mathit{expr}}_{\mathsf{g}}` with state :math:`z`.

   #. Append :math:`{\mathit{val}}` to :math:`{{\mathit{val}}^\ast}`.

#. Let :math:`{{{\mathit{ref}}^\ast}^\ast}` be the reference sequence sequence :math:`\epsilon`.

#. For each :math:`{{\mathit{expr}}_{\mathsf{e}}^\ast}` in :math:`{{{\mathit{expr}}_{\mathsf{e}}^\ast}^\ast}`, do:

   a. Let :math:`{{\mathit{ref}}^\ast}` be the reference sequence :math:`\epsilon`.

   #. For each :math:`{\mathit{expr}}_{\mathsf{e}}` in :math:`{{\mathit{expr}}_{\mathsf{e}}^\ast}`, do:

      1) Let :math:`{\mathit{ref}}` be the result of :ref:`evaluating <exec-expr>` :math:`{\mathit{expr}}_{\mathsf{e}}` with state :math:`z`.

      #) Append :math:`{\mathit{ref}}` to :math:`{{\mathit{ref}}^\ast}`.

   #. Append :math:`{{\mathit{ref}}^\ast}` to :math:`{{{\mathit{ref}}^\ast}^\ast}`.

#. Pop the :math:`\mathsf{frame}` from the stack.

#. Let :math:`{\mathit{moduleinst}}` be :math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}^\ast}, {{{\mathit{ref}}^\ast}^\ast})`.

#. Let :math:`f` be the frame :math:`\{ \mathsf{module}~{\mathit{moduleinst}} \}`.

#. Let :math:`{f'}` be the :math:`\mathsf{frame}` :math:`f`.

#. Push the :math:`\mathsf{frame}` :math:`{f'}`.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{e}}^\ast}`.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{d}}^\ast}`.

#. If :math:`{{\mathit{start}}^?}` is defined, then:

   a. Let :math:`(\mathsf{start}~x)` be :math:`{{\mathit{start}}^?}`.

   #. Let :math:`{\mathit{instr}}_0` be the administrative instruction :math:`(\mathsf{call}~x)`.

   #. Execute the instruction :math:`{\mathit{instr}}_0`.

#. Pop the :math:`\mathsf{frame}` from the stack.

#. Return :math:`f{.}\mathsf{module}`.


:math:`{\mathrm{invoke}}(s, {\mathit{fa}}, {{\mathit{val}}^{n}})`
.................................................................


1. Let :math:`f` be the frame :math:`\{ \mathsf{module}~\{  \} \}`.

#. Let :math:`F` be the :math:`\mathsf{frame}` :math:`(s, f)`.

#. Push the :math:`\mathsf{frame}` :math:`F`.

#. Let :math:`{t_1^{n}}~\rightarrow~{t_2^\ast}` be the destructuring of :math:`(s, f){.}\mathsf{funcs}{}[{\mathit{fa}}]{.}\mathsf{type}`.

#. Pop the :math:`\mathsf{frame}` from the stack.

#. Let :math:`k` be the length of :math:`{t_2^\ast}`.

#. Let :math:`{f'}` be the :math:`\mathsf{frame}` :math:`f` whose arity is :math:`k`.

#. Push the :math:`\mathsf{frame}` :math:`{f'}`.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{call}~{\mathit{fa}})`.

#. Pop the values :math:`{{\mathit{val}'}^{k}}` from the stack.

#. Pop the :math:`\mathsf{frame}` from the stack.

#. Return :math:`{{\mathit{val}'}^{k}}`.


:math:`\mathsf{eval\_expr}~{{\mathit{instr}}^\ast}`
...................................................


1. Execute the sequence :math:`{{\mathit{instr}}^\ast}`.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Return :math:`{\mathit{val}}`.


== Complete.
spectec 0.5 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...
Limits_ok
- the limits ([ n .. m? ]) is valid with k if:
  - n is less than or equal to k.
  - If m is defined, then:
    - n is less than or equal to m.
    - m is less than or equal to k.

Functype_ok
- the function type t_1* -> t_2* is always valid.

Globaltype_ok
- the global type (MUT? t) is always valid.

Tabletype_ok
- the table type (limits reftype) is valid if:
  - the limits limits is valid with ((2 ^ 32) - 1).

Memtype_ok
- the memory type limits PAGE is valid if:
  - the limits limits is valid with (2 ^ 16).

Externtype_ok
- the external type externtype is valid if:
  - Either:
    - externtype is (FUNC functype).
    - the function type functype is valid.
  - Or:
    - externtype is (GLOBAL globaltype).
    - the global type globaltype is valid.
  - Or:
    - externtype is (TABLE tabletype).
    - the table type tabletype is valid.
  - Or:
    - externtype is (MEM memtype).
    - the memory type memtype is valid.

Externtype_ok/func
- the external type (FUNC functype) is valid if:
  - the function type functype is valid.

Externtype_ok/global
- the external type (GLOBAL globaltype) is valid if:
  - the global type globaltype is valid.

Externtype_ok/table
- the external type (TABLE tabletype) is valid if:
  - the table type tabletype is valid.

Externtype_ok/mem
- the external type (MEM memtype) is valid if:
  - the memory type memtype is valid.

Valtype_sub
- the value type t_2 matches the value type t_1 if:
  - Either:
    - t_2 is t_1.
  - Or:
    - t_2 is BOT.

Valtype_sub/refl
- the value type t matches only itself.

Valtype_sub/bot
- the value type BOT matches t.

Resulttype_sub
- the result type t_1* matches the result type t_2* if:
  - For all t_1 in t_1*, and corresponding t_2 in t_2*:
    - the value type t_1 matches the value type t_2.

Limits_sub
- the limits ([ n_11 .. ?(n_12) ]) matches the limits ([ n_21 .. ?(n_22) ]) if:
  - n_11 is greater than or equal to n_21.
  - n_12 is less than or equal to n_22.

Functype_sub
- the function type ft matches only itself.

Globaltype_sub
- the global type gt matches only itself.

Tabletype_sub
- the table type (lim_1 rt) matches the table type (lim_2 rt) if:
  - the limits lim_1 matches the limits lim_2.

Memtype_sub
- the memory type lim_1 PAGE matches the memory type lim_2 PAGE if:
  - the limits lim_1 matches the limits lim_2.

Externtype_sub
- the external type externtype_1 matches the external type externtype_2 if:
  - Either:
    - externtype_1 is (FUNC ft_1).
    - externtype_2 is (FUNC ft_2).
    - the function type ft_1 matches the function type ft_2.
  - Or:
    - externtype_1 is (GLOBAL gt_1).
    - externtype_2 is (GLOBAL gt_2).
    - the global type gt_1 matches the global type gt_2.
  - Or:
    - externtype_1 is (TABLE tt_1).
    - externtype_2 is (TABLE tt_2).
    - the table type tt_1 matches the table type tt_2.
  - Or:
    - externtype_1 is (MEM mt_1).
    - externtype_2 is (MEM mt_2).
    - the memory type mt_1 matches the memory type mt_2.

Externtype_sub/func
- the external type (FUNC ft_1) matches the external type (FUNC ft_2) if:
  - the function type ft_1 matches the function type ft_2.

Externtype_sub/global
- the external type (GLOBAL gt_1) matches the external type (GLOBAL gt_2) if:
  - the global type gt_1 matches the global type gt_2.

Externtype_sub/table
- the external type (TABLE tt_1) matches the external type (TABLE tt_2) if:
  - the table type tt_1 matches the table type tt_2.

Externtype_sub/mem
- the external type (MEM mt_1) matches the external type (MEM mt_2) if:
  - the memory type mt_1 matches the memory type mt_2.

Blocktype_ok
- the block type blocktype is valid with the function type valtype* -> valtype'* if:
  - Either:
    - blocktype is (_RESULT valtype''?).
    - the value type sequence valtype* is [].
    - the value type sequence valtype'* is valtype''?.
  - Or:
    - blocktype is (_IDX typeidx).
    - the function type C.TYPES[typeidx] exists.
    - C.TYPES[typeidx] is valtype* -> valtype'*.

Blocktype_ok/valtype
- the block type (_RESULT valtype?) is valid with the function type [] -> valtype?.

Blocktype_ok/typeidx
- the block type (_IDX typeidx) is valid with the function type t_1* -> t_2* if:
  - the function type C.TYPES[typeidx] exists.
  - C.TYPES[typeidx] is t_1* -> t_2*.

Instr_ok/nop
- the instruction NOP is valid with the function type [] -> [].

Instr_ok/unreachable
- the instruction UNREACHABLE is valid with t_1* -> t_2*.

Instr_ok/drop
- the instruction DROP is valid with the function type [t] -> [].

Instr_ok/select
- the instruction (SELECT valtype?) is valid with the function type [t, t, I32] -> [t] if:
  - Either:
    - the value type sequence valtype? is ?([t]).
  - Or:
    - valtype? is ?().
    - the value type t matches the value type t'.
    - t' is numtype or t' is vectype.

Instr_ok/block
- the instruction (BLOCK bt instr*) is valid with the function type t_1* -> t_2* if:
  - the block type bt is valid with t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr* is valid with t_1* -> t_2*.

Instr_ok/loop
- the instruction (LOOP bt instr*) is valid with the function type t_1* -> t_2* if:
  - the block type bt is valid with t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_1*].
  - Under the context C', the instruction sequence instr* is valid with t_1* -> t_2*.

Instr_ok/if
- the instruction (IF bt instr_1* ELSE instr_2*) is valid with the function type t_1* :: [I32] -> t_2* if:
  - the block type bt is valid with the function type t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr_1* is valid with t_1* -> t_2*.
  - Under the context C', the instruction sequence instr_2* is valid with t_1* -> t_2*.

Instr_ok/br
- the instruction (BR l) is valid with the function type t_1* :: t* -> t_2* if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t*.

Instr_ok/br_if
- the instruction (BR_IF l) is valid with the function type t* :: [I32] -> t* if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t*.

Instr_ok/br_table
- the instruction (BR_TABLE l* l') is valid with the function type t_1* :: t* :: [I32] -> t_2* if:
  - For all l in l*:
    - the result type C.LABELS[l] exists.
    - the result type t* matches C.LABELS[l].
  - the result type C.LABELS[l'] exists.
  - t* matches C.LABELS[l'].

Instr_ok/call
- the instruction (CALL x) is valid with the function type t_1* -> t_2* if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is t_1* -> t_2*.

Instr_ok/call_indirect
- the instruction (CALL_INDIRECT x y) is valid with the function type t_1* :: [I32] -> t_2* if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim FUNCREF).
  - the function type C.TYPES[y] exists.
  - C.TYPES[y] is t_1* -> t_2*.

Instr_ok/return
- the instruction RETURN is valid with the function type t_1* :: t* -> t_2* if:
  - the result type C.RETURN is ?(t*).

Instr_ok/const
- the instruction (nt.CONST c_nt) is valid with the function type [] -> [nt].

Instr_ok/unop
- the instruction (UNOP nt unop_nt) is valid with the function type [nt] -> [nt].

Instr_ok/binop
- the instruction (BINOP nt binop_nt) is valid with the function type [nt, nt] -> [nt].

Instr_ok/testop
- the instruction (TESTOP nt testop_nt) is valid with the function type [nt] -> [I32].

Instr_ok/relop
- the instruction (RELOP nt relop_nt) is valid with the function type [nt, nt] -> [I32].

Instr_ok/cvtop
- the instruction (CVTOP nt_1 nt_2 cvtop) is valid with the function type [nt_2] -> [nt_1] if:
  - Either:
    - cvtop is REINTERPRET.
    - $size(nt_1) is $size(nt_2).
  - Or:


Instr_ok/ref.null
- the instruction (REF.NULL rt) is valid with the function type [] -> [rt].

Instr_ok/ref.func
- the instruction (REF.FUNC x) is valid with the function type [] -> [FUNCREF] if:
  - the function type C.FUNCS[x] exists.

Instr_ok/ref.is_null
- the instruction REF.IS_NULL is valid with the function type [rt] -> [I32].

Instr_ok/vconst
- the instruction (V128.CONST c) is valid with the function type [] -> [V128].

Instr_ok/vvunop
- the instruction (VVUNOP V128 vvunop) is valid with the function type [V128] -> [V128].

Instr_ok/vvbinop
- the instruction (VVBINOP V128 vvbinop) is valid with the function type [V128, V128] -> [V128].

Instr_ok/vvternop
- the instruction (VVTERNOP V128 vvternop) is valid with the function type [V128, V128, V128] -> [V128].

Instr_ok/vvtestop
- the instruction (VVTESTOP V128 vvtestop) is valid with the function type [V128] -> [I32].

Instr_ok/vunop
- the instruction (VUNOP sh vunop_sh) is valid with [V128] -> [V128].

Instr_ok/vbinop
- the instruction (VBINOP sh vbinop_sh) is valid with [V128, V128] -> [V128].

Instr_ok/vtestop
- the instruction (VTESTOP sh vtestop_sh) is valid with [V128] -> [I32].

Instr_ok/vrelop
- the instruction (VRELOP sh vrelop_sh) is valid with [V128, V128] -> [V128].

Instr_ok/vshiftop
- the instruction (VSHIFTOP sh vshiftop_sh) is valid with the function type [V128, I32] -> [V128].

Instr_ok/vbitmask
- the instruction (VBITMASK sh) is valid with [V128] -> [I32].

Instr_ok/vswizzle
- the instruction (VSWIZZLE sh) is valid with [V128, V128] -> [V128].

Instr_ok/vshuffle
- the instruction (VSHUFFLE sh i*) is valid with the function type [V128, V128] -> [V128] if:
  - For all i in i*:
    - the lane index i is less than (2 * $dim(sh)).

Instr_ok/vsplat
- the instruction (VSPLAT sh) is valid with the function type [numtype] -> [V128] if:
  - the number type numtype is $shunpack(sh).

Instr_ok/vextract_lane
- the instruction (VEXTRACT_LANE sh sx? i) is valid with the function type [V128] -> [numtype] if:
  - the lane index i is less than $dim(sh).
  - the number type numtype is $shunpack(sh).

Instr_ok/vreplace_lane
- the instruction (VREPLACE_LANE sh i) is valid with the function type [V128, numtype] -> [V128] if:
  - the lane index i is less than $dim(sh).
  - the number type numtype is $shunpack(sh).

Instr_ok/vextunop
- the instruction (VEXTUNOP sh_1 sh_2 vextunop) is valid with the function type [V128] -> [V128].

Instr_ok/vextbinop
- the instruction (VEXTBINOP sh_1 sh_2 vextbinop) is valid with the function type [V128, V128] -> [V128].

Instr_ok/vnarrow
- the instruction (VNARROW sh_1 sh_2 sx) is valid with [V128, V128] -> [V128].

Instr_ok/vcvtop
- the instruction (VCVTOP sh_1 sh_2 vcvtop) is valid with [V128] -> [V128].

Instr_ok/local.get
- the instruction (LOCAL.GET x) is valid with the function type [] -> [t] if:
  - the value type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/local.set
- the instruction (LOCAL.SET x) is valid with the function type [t] -> [] if:
  - the value type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/local.tee
- the instruction (LOCAL.TEE x) is valid with the function type [t] -> [t] if:
  - the value type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/global.get
- the instruction (GLOBAL.GET x) is valid with the function type [] -> [t] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (mut t).

Instr_ok/global.set
- the instruction (GLOBAL.SET x) is valid with the function type [t] -> [] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?(MUT) t).

Instr_ok/table.get
- the instruction (TABLE.GET x) is valid with the function type [I32] -> [rt] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.set
- the instruction (TABLE.SET x) is valid with the function type [I32, rt] -> [] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.size
- the instruction (TABLE.SIZE x) is valid with the function type [] -> [I32] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.grow
- the instruction (TABLE.GROW x) is valid with the function type [rt, I32] -> [I32] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.fill
- the instruction (TABLE.FILL x) is valid with the function type [I32, rt, I32] -> [] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.copy
- the instruction (TABLE.COPY x_1 x_2) is valid with the function type [I32, I32, I32] -> [] if:
  - the table type C.TABLES[x_1] exists.
  - C.TABLES[x_1] is (lim_1 rt).
  - the table type C.TABLES[x_2] exists.
  - C.TABLES[x_2] is (lim_2 rt).

Instr_ok/table.init
- the instruction (TABLE.INIT x_1 x_2) is valid with the function type [I32, I32, I32] -> [] if:
  - the table type C.TABLES[x_1] exists.
  - C.TABLES[x_1] is (lim rt).
  - the element type C.ELEMS[x_2] exists.
  - C.ELEMS[x_2] is rt.

Instr_ok/elem.drop
- the instruction (ELEM.DROP x) is valid with the function type [] -> [] if:
  - the element type C.ELEMS[x] exists.

Instr_ok/memory.size
- the instruction MEMORY.SIZE is valid with the function type [] -> [I32].

Instr_ok/memory.grow
- the instruction MEMORY.GROW is valid with the function type [I32] -> [I32].

Instr_ok/memory.fill
- the instruction MEMORY.FILL is valid with the function type [I32, I32, I32] -> [].

Instr_ok/memory.copy
- the instruction MEMORY.COPY is valid with [I32, I32, I32] -> [].

Instr_ok/memory.init
- the instruction (MEMORY.INIT x) is valid with the function type [I32, I32, I32] -> [] if:
  - the data type C.DATAS[x] exists.
  - C.DATAS[x] is OK.

Instr_ok/data.drop
- the instruction (DATA.DROP x) is valid with the function type [] -> [] if:
  - the data type C.DATAS[x] exists.
  - C.DATAS[x] is OK.

Instr_ok/load
- the instruction (LOAD nt loadop_? memarg) is valid with the function type [I32] -> [valtype] if:
  - Either:
    - loadop_? is ?().
    - the value type valtype is nt.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - Or:
    - the number type nt is Inn.
    - loadop_? is ?(M _ sx).
    - valtype is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store
- the instruction (STORE nt sz? memarg) is valid with the function type [I32, valtype] -> [] if:
  - Either:
    - the pack size sz? is ?().
    - the value type valtype is nt.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - Or:
    - the number type nt is Inn.
    - sz? is ?(M).
    - valtype is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/vload
- the instruction (VLOAD V128 ?(vloadop) memarg) is valid with the function type [I32] -> [V128] if:
  - Either:
    - vloadop is (SHAPE M X N _ sx).
    - (2 ^ memarg.ALIGN) is less than or equal to ((M / 8) * N).
  - Or:
    - vloadop is (SPLAT n).
    - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).
  - Or:
    - vloadop is (ZERO n).
    - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).

Instr_ok/vload_lane
- the instruction (VLOAD_LANE V128 n memarg laneidx) is valid with the function type [I32, V128] -> [V128] if:
  - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).
  - laneidx is less than (128 / n).

Instr_ok/vstore
- the instruction (VSTORE V128 memarg) is valid with the function type [I32, V128] -> [] if:
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(V128) / 8).

Instr_ok/vstore_lane
- the instruction (VSTORE_LANE V128 n memarg laneidx) is valid with the function type [I32, V128] -> [] if:
  - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).
  - laneidx is less than (128 / n).

Instr_ok/select-expl
- the instruction (SELECT ?([t])) is valid with the function type [t, t, I32] -> [t].

Instr_ok/select-impl
- the instruction (SELECT ?()) is valid with the function type [t, t, I32] -> [t] if:
  - the value type t matches the value type t'.
  - t' is numtype or t' is vectype.

Instr_ok/cvtop-reinterpret
- the instruction (CVTOP nt_1 nt_2 REINTERPRET) is valid with the function type [nt_2] -> [nt_1] if:
  - $size(nt_1) is $size(nt_2).

Instr_ok/cvtop-convert
- the instruction (CVTOP nt_1 nt_2 cvtop) is valid with [nt_2] -> [nt_1].

Instr_ok/load-val
- the instruction (LOAD nt ?() memarg) is valid with the function type [I32] -> [nt] if:
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).

Instr_ok/load-pack
- the instruction (LOAD Inn ?(M _ sx) memarg) is valid with the function type [I32] -> [Inn] if:
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store-val
- the instruction (STORE nt ?() memarg) is valid with the function type [I32, nt] -> [] if:
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).

Instr_ok/store-pack
- the instruction (STORE Inn ?(M) memarg) is valid with the function type [I32, Inn] -> [] if:
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/vload
- the instruction (VLOAD V128 ?((SHAPE M X N _ sx)) memarg) is valid with the function type [I32] -> [V128] if:
  - (2 ^ memarg.ALIGN) is less than or equal to ((M / 8) * N).

Instr_ok/vload-splat
- the instruction (VLOAD V128 ?((SPLAT n)) memarg) is valid with the function type [I32] -> [V128] if:
  - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).

Instr_ok/vload-zero
- the instruction (VLOAD V128 ?((ZERO n)) memarg) is valid with the function type [I32] -> [V128] if:
  - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).

Instrs_ok
- the instruction sequence instr* is valid with the function type valtype* -> valtype'* if:
  - Either:
    - instr* is [].
    - the value type sequence valtype* is [].
    - the value type sequence valtype'* is [].
  - Or:
    - instr* is [instr_1] :: instr_2*.
    - the instruction instr_1 is valid with the function type valtype* -> t_2*.
    - the instruction sequence instr_2* is valid with the function type t_2* -> valtype'*.
  - Or:
    - instr* is valid with the function type t_1* -> t_2*.
    - valtype* matches the result type t_1*.
    - the result type t_2* matches valtype'*.
  - Or:
    - valtype* is t* :: t_1*.
    - valtype'* is t* :: t_2*.
    - instr* is valid with t_1* -> t_2*.

Instrs_ok/empty
- the instruction sequence [] is valid with the function type [] -> [].

Instrs_ok/seq
- the instruction sequence [instr_1] :: instr_2* is valid with the function type t_1* -> t_3* if:
  - the instruction instr_1 is valid with the function type t_1* -> t_2*.
  - the instruction sequence instr_2* is valid with the function type t_2* -> t_3*.

Instrs_ok/sub
- the instruction sequence instr* is valid with the function type t'_1* -> t'_2* if:
  - instr* is valid with the function type t_1* -> t_2*.
  - the result type t'_1* matches the result type t_1*.
  - the result type t_2* matches the result type t'_2*.

Instrs_ok/frame
- the instruction sequence instr* is valid with the function type t* :: t_1* -> t* :: t_2* if:
  - instr* is valid with the function type t_1* -> t_2*.

Expr_ok
- the expression instr* is valid with the result type t* if:
  - instr* is valid with the function type [] -> t*.

Instr_const
- the value val is constant if:
  - Either:
    - val is (nt.CONST c).
  - Or:
    - val is (vt.CONST vc).
  - Or:
    - val is (REF.NULL rt).
  - Or:
    - val is (REF.FUNC x).
  - Or:
    - val is (GLOBAL.GET x).
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is (?() t).

Instr_const/const
- the instruction (nt.CONST c) is constant.

Instr_const/vconst
- the instruction (vt.CONST vc) is constant.

Instr_const/ref.null
- the instruction (REF.NULL rt) is constant.

Instr_const/ref.func
- the instruction (REF.FUNC x) is constant.

Instr_const/global.get
- the instruction (GLOBAL.GET x) is constant if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?() t).

Expr_const
- the expression instr* is constant if:
  - For all instr in instr*:
    - the instruction instr is constant.

Type_ok
- the type (TYPE ft) is valid with the function type ft if:
  - ft is valid.

Func_ok
- the function (FUNC x (LOCAL t)* expr) is valid with the function type t_1* -> t_2* if:
  - the function type C.TYPES[x] exists.
  - C.TYPES[x] is t_1* -> t_2*.
  - For all t in t*:
    - the value type t is not BOT.
  - Under the context C with .LOCALS appended by t_1* :: t* and .LABELS appended by [t_2*] and .RETURN appended by ?(t_2*), the expression expr is valid with the result type t_2*.

Global_ok
- the global (GLOBAL gt expr) is valid with the global type gt if:
  - gt is valid.
  - gt is (mut t).
  - the expression expr is valid with the value type t.
  - expr is constant.

Table_ok
- the table (TABLE tt) is valid with the table type tt if:
  - tt is valid.

Mem_ok
- the memory (MEMORY mt) is valid with the memory type mt if:
  - mt is valid.

Elemmode_ok
- elemmode is valid with the reference type rt if:
  - Either:
    - elemmode is (ACTIVE x expr).
    - the table type C.TABLES[x] exists.
    - C.TABLES[x] is (lim rt).
    - the expression expr is valid with the value type I32.
    - expr is constant.
  - Or:
    - elemmode is PASSIVE.
  - Or:
    - elemmode is DECLARE.

Elemmode_ok/active
- (ACTIVE x expr) is valid with the reference type rt if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim rt).
  - the expression expr is valid with the value type I32.
  - expr is constant.

Elemmode_ok/passive
- PASSIVE is valid with rt.

Elemmode_ok/declare
- DECLARE is valid with rt.

Elem_ok
- the table segment (ELEM rt expr* elemmode) is valid with the reference type rt if:
  - For all expr in expr*:
    - the expression expr is valid with rt.
    - expr is constant.
  - elemmode is valid with rt.

Datamode_ok
- datamode is valid if:
  - Either:
    - datamode is (ACTIVE 0 expr).
    - the expression expr is valid with the value type I32.
    - expr is constant.
  - Or:
    - datamode is PASSIVE.

Datamode_ok/active
- (ACTIVE 0 expr) is valid if:
  - the expression expr is valid with the value type I32.
  - expr is constant.

Datamode_ok/passive
- PASSIVE is always valid.

Data_ok
- the memory segment (DATA b* datamode) is valid if:
  - datamode is valid.

Start_ok
- the start function (START x) is valid if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is [] -> [].

Import_ok
- the import (IMPORT name_1 name_2 xt) is valid with the external type xt if:
  - xt is valid.

Externidx_ok
- the external index externidx is valid with the external type externtype if:
  - Either:
    - externidx is (FUNC x).
    - externtype is (FUNC ft).
    - the function type C.FUNCS[x] exists.
    - C.FUNCS[x] is ft.
  - Or:
    - externidx is (GLOBAL x).
    - externtype is (GLOBAL gt).
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is gt.
  - Or:
    - externidx is (TABLE x).
    - externtype is (TABLE tt).
    - the table type C.TABLES[x] exists.
    - C.TABLES[x] is tt.
  - Or:
    - externidx is (MEM x).
    - externtype is (MEM mt).
    - the memory type C.MEMS[x] exists.
    - C.MEMS[x] is mt.

Externidx_ok/func
- the external index (FUNC x) is valid with the external type (FUNC ft) if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is ft.

Externidx_ok/global
- the external index (GLOBAL x) is valid with the external type (GLOBAL gt) if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is gt.

Externidx_ok/table
- the external index (TABLE x) is valid with the external type (TABLE tt) if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is tt.

Externidx_ok/mem
- the external index (MEM x) is valid with the external type (MEM mt) if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is mt.

Export_ok
- the export (EXPORT name externidx) is valid with the external type xt if:
  - the external index externidx is valid with xt.

Module_ok
- the module (MODULE type* import* func* global* table* mem* elem* data^n start? export*) is valid if:
  - For all type in type*:
    - the type type is valid with the function type ft'.
  - ft'* is the concatenation of all such ft'.
  - For all import in import*:
    - Under the context { TYPES: ft'*; RETURN: ?() }, the import import is valid with the external type ixt.
  - ixt* is the concatenation of all such ixt.
  - For all global in global*:
    - Under the context C', the global global is valid with the global type gt.
  - gt* is the concatenation of all such gt.
  - For all table in table*:
    - Under the context C', the table table is valid with the table type tt.
  - tt* is the concatenation of all such tt.
  - For all mem in mem*:
    - Under the context C', the memory mem is valid with the memory type mt.
  - mt* is the concatenation of all such mt.
  - For all elem in elem*:
    - Under the context C', the table segment elem is valid with the reference type rt.
  - rt* is the concatenation of all such rt.
  - For all data in data*:
    - Under the context C', the memory segment data is valid.
  - For all func in func*:
    - the function func is valid with the function type ft.
  - ft* is the concatenation of all such ft.
  - If start is defined, then:
    - the start function start is valid.
  - For all export in export*:
    - the export export is valid with the external type xt.
  - |mt*| is less than or equal to 1.
  - the context C' is { TYPES: ft'*; FUNCS: ift* :: ft*; GLOBALS: igt*; TABLES: itt* :: tt*; MEMS: imt* :: mt*; RETURN: ?() }.
  - the function type sequence ift* is $funcsxt(ixt*).
  - the global type sequence igt* is $globalsxt(ixt*).
  - the table type sequence itt* is $tablesxt(ixt*).
  - the memory type sequence imt* is $memsxt(ixt*).

Step_read/table.copy-trap-* x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$table(z, y).REFS|), then:
  a. Trap.
9. If ((j + n) > |$table(z, x).REFS|), then:
  a. Trap.

Step_read/table.init-trap-* x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$elem(z, y).REFS|), then:
  a. Trap.
9. If ((j + n) > |$table(z, x).REFS|), then:
  a. Trap.

Step_read/load-num-* nt ?() ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (((i + ao.OFFSET) + ($size(nt) / 8)) > |$mem(z, 0).BYTES|), then:
  a. Trap.
5. Let c be $nbytes__1^-1(nt, $mem(z, 0).BYTES[(i + ao.OFFSET) : ($size(nt) / 8)]).
6. Push the value (nt.CONST c) to the stack.

Step_read/load-pack-* Inn ?(n _ sx) ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
  a. Trap.
5. Let c be $ibytes__1^-1(n, $mem(z, 0).BYTES[(i + ao.OFFSET) : (n / 8)]).
6. Push the value (Inn.CONST $extend__(n, $size(Inn), sx, c)) to the stack.

Step_read/vload-shape-* V128 ?((SHAPE M X N _ sx)) ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (((i + ao.OFFSET) + ((M * N) / 8)) > |$mem(z, 0).BYTES|), then:
  a. Trap.
5. Let j^N be $ibytes__1^-1(M, $mem(z, 0).BYTES[((i + ao.OFFSET) + ((k * M) / 8)) : (M / 8)])^(k<N).
6. Let Jnn be $jsize^-1((M * 2)).
7. Let c be $inv_lanes_(Jnn X N, $extend__(M, $jsize(Jnn), sx, j)^N).
8. Push the value (V128.CONST c) to the stack.

Step_read/vload-splat-* V128 ?((SPLAT N)) ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, 0).BYTES|), then:
  a. Trap.
5. Let M be (128 / N).
6. Let Jnn be $jsize^-1(N).
7. Let j be $ibytes__1^-1(N, $mem(z, 0).BYTES[(i + ao.OFFSET) : (N / 8)]).
8. Let c be $inv_lanes_(Jnn X M, j^M).
9. Push the value (V128.CONST c) to the stack.

Step_read/vload-zero-* V128 ?((ZERO N)) ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, 0).BYTES|), then:
  a. Trap.
5. Let j be $ibytes__1^-1(N, $mem(z, 0).BYTES[(i + ao.OFFSET) : (N / 8)]).
6. Let c be $extend__(N, 128, U, j).
7. Push the value (V128.CONST c) to the stack.

Step_read/memory.copy-trap-*
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.
9. If ((j + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.

Step_read/memory.init-trap-* x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$data(z, x).BYTES|), then:
  a. Trap.
9. If ((j + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.

Step/store-num-* nt ?() ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type nt is on the top of the stack.
3. Pop the value (numtype_0.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + ($size(nt) / 8)) > |$mem(z, 0).BYTES|), then:
  a. Trap.
7. Let b* be $nbytes_(nt, c).
8. Perform $with_mem(z, 0, (i + ao.OFFSET), ($size(nt) / 8), b*).

Step/store-pack-* Inn ?(n) ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type Inn is on the top of the stack.
3. Pop the value (numtype_0.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
  a. Trap.
7. Let b* be $ibytes_(n, $wrap__($size(Inn), n, c)).
8. Perform $with_mem(z, 0, (i + ao.OFFSET), (n / 8), b*).

Step_pure/unreachable
1. Trap.

Step_pure/nop
1. Do nothing.

Step_pure/drop
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.

Step_pure/select t*?
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. Assert: Due to validation, a value is on the top of the stack.
4. Pop the value val_2 from the stack.
5. Assert: Due to validation, a value is on the top of the stack.
6. Pop the value val_1 from the stack.
7. If (c =/= 0), then:
  a. Push the value val_1 to the stack.
8. Else:
  a. Push the value val_2 to the stack.

Step_pure/if bt instr_1* instr_2*
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BLOCK bt instr_1*).
4. Else:
  a. Execute the instruction (BLOCK bt instr_2*).

Step_pure/label
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
3. Pop the label (LABEL_ _ { _ }) from the stack.
4. Push the values val* to the stack.

Step_pure/br n'
1. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
2. Let (LABEL_ n { instr'* }) be the topmost LABEL_.
3. If (n' = 0), then:
  a. Assert: Due to validation, there are at least n values on the top of the stack.
  b. Pop the values val^n from the stack.
  c. Pop all values val'* from the top of the stack.
  d. Pop the label (LABEL_ _ { _ }) from the stack.
  e. Push the values val^n to the stack.
  f. Execute the sequence instr'*.
4. Else:
  a. Pop all values val* from the top of the stack.
  b. Let l be (n' - 1).
  c. Pop the label (LABEL_ _ { _ }) from the stack.
  d. Push the values val* to the stack.
  e. Execute the instruction (BR l).

Step_pure/br_if l
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BR l).
4. Else:
  a. Do nothing.

Step_pure/br_table l* l'
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. If (i < |l*|), then:
  a. Execute the instruction (BR l*[i]).
4. Else:
  a. Execute the instruction (BR l').

Step_pure/frame
1. Let (FRAME_ n { f }) be the topmost FRAME_.
2. Assert: Due to validation, there are at least n values on the top of the stack.
3. Assert: Due to validation, there are at least n values on the top of the stack.
4. Pop the values val^n from the stack.
5. Assert: Due to validation, the first non-value entry of the stack is a FRAME_.
6. Pop the frame (FRAME_ _ { _ }) from the stack.
7. Push the values val^n to the stack.

Step_pure/return
1. If the first non-value entry of the stack is a FRAME_, then:
  a. Let (FRAME_ n { f }) be the topmost FRAME_.
  b. Assert: Due to validation, there are at least n values on the top of the stack.
  c. Pop the values val^n from the stack.
  d. Pop all values val'* from the top of the stack.
  e. Pop the frame (FRAME_ _ { _ }) from the stack.
  f. Push the values val^n to the stack.
2. Else:
  a. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
  b. Pop all values val* from the top of the stack.
  c. Pop the label (LABEL_ _ { _ }) from the stack.
  d. Push the values val* to the stack.
  e. Execute the instruction RETURN.

Step_pure/unop nt unop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. If (|$unop_(nt, unop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $unop_(nt, unop, c_1).
5. Push the value (nt.CONST c) to the stack.

Step_pure/binop nt binop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type num is on the top of the stack.
4. Pop the value (numtype_0.CONST c_1) from the stack.
5. If (|$binop_(nt, binop, c_1, c_2)| <= 0), then:
  a. Trap.
6. Let c be an element of $binop_(nt, binop, c_1, c_2).
7. Push the value (nt.CONST c) to the stack.

Step_pure/testop nt testop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. Let c be $testop_(nt, testop, c_1).
4. Push the value (I32.CONST c) to the stack.

Step_pure/relop nt relop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type num is on the top of the stack.
4. Pop the value (numtype_0.CONST c_1) from the stack.
5. Let c be $relop_(nt, relop, c_1, c_2).
6. Push the value (I32.CONST c) to the stack.

Step_pure/cvtop nt_2 nt_1 cvtop
1. Assert: Due to validation, a value of value type nt_1 is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. If (|$cvtop__(nt_1, nt_2, cvtop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $cvtop__(nt_1, nt_2, cvtop, c_1).
5. Push the value (nt_2.CONST c) to the stack.

Step_pure/ref.is_null
1. Assert: Due to validation, a value of value type ref is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is some REF.NULL, then:
  a. Push the value (I32.CONST 1) to the stack.
4. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_pure/vvunop V128 vvunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vvunop_(V128, vvunop, c_1).
4. Push the value (V128.CONST c) to the stack.

Step_pure/vvbinop V128 vvbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vvbinop_(V128, vvbinop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vvternop V128 vvternop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_3) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_2) from the stack.
5. Assert: Due to validation, a value of value type V128 is on the top of the stack.
6. Pop the value (V128.CONST c_1) from the stack.
7. Let c be $vvternop_(V128, vvternop, c_1, c_2, c_3).
8. Push the value (V128.CONST c) to the stack.

Step_pure/vvtestop V128 ANY_TRUE
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $ine_($size(V128), c_1, 0).
4. Push the value (I32.CONST c) to the stack.

Step_pure/vunop sh vunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (|$vunop_(sh, vunop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $vunop_(sh, vunop, c_1).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vbinop sh vbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. If (|$vbinop_(sh, vbinop, c_1, c_2)| <= 0), then:
  a. Trap.
6. Let c be an element of $vbinop_(sh, vbinop, c_1, c_2).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vtestop Jnn X N ALL_TRUE
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c) from the stack.
3. Let ci_1* be $lanes_(Jnn X N, c).
4. If (ci_1 =/= 0)*, then:
  a. Push the value (I32.CONST 1) to the stack.
5. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_pure/vrelop sh vrelop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vrelop_(sh, vrelop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vshiftop Jnn X N vshiftop
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST n) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c'* be $lanes_(Jnn X N, c_1).
6. Let c be $inv_lanes_(Jnn X N, $vshiftop_(Jnn X N, vshiftop, c', n)*).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vbitmask Jnn X N
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c) from the stack.
3. Let ci_1* be $lanes_(Jnn X N, c).
4. Let ci be $ibits__1^-1(32, $ilt_($lsize(Jnn), S, ci_1, 0)* :: 0^(32 - N)).
5. Push the value (I32.CONST $irev_(32, ci)) to the stack.

Step_pure/vswizzle Pnn X M
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c'* be $lanes_(Pnn X M, c_1) :: 0^(256 - M).
6. Let ci* be $lanes_(Pnn X M, c_2).
7. Assert: Due to validation, (ci*[k] < |c'*|)^(k<M).
8. Assert: Due to validation, (k < |ci*|)^(k<M).
9. Let c be $inv_lanes_(Pnn X M, c'*[ci*[k]]^(k<M)).
10. Push the value (V128.CONST c) to the stack.

Step_pure/vshuffle Pnn X N i*
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Assert: Due to validation, (k < |i*|)^(k<N).
6. Let c'* be $lanes_(Pnn X N, c_1) :: $lanes_(Pnn X N, c_2).
7. Assert: Due to validation, (i*[k] < |c'*|)^(k<N).
8. Let c be $inv_lanes_(Pnn X N, c'*[i*[k]]^(k<N)).
9. Push the value (V128.CONST c) to the stack.

Step_pure/vsplat Lnn X N
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. Assert: Due to validation, (numtype_0 = $unpack(Lnn)).
4. Let c be $inv_lanes_(Lnn X N, $packnum_(Lnn, c_1)^N).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vextract_lane lanetype X N sx'? i
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If sx'? is not defined, then:
  a. Assert: Due to validation, lanetype is numtype.
  b. Assert: Due to validation, (i < |$lanes_(lanetype X N, c_1)|).
  c. Let c_2 be $lanes_(lanetype X N, c_1)[i].
  d. Push the value (lanetype.CONST c_2) to the stack.
4. Else:
  a. Assert: Due to validation, lanetype is packtype.
  b. Let ?(sx) be sx'?.
  c. Assert: Due to validation, (i < |$lanes_(lanetype X N, c_1)|).
  d. Let c_2 be $extend__($psize(lanetype), 32, sx, $lanes_(lanetype X N, c_1)[i]).
  e. Push the value (I32.CONST c_2) to the stack.

Step_pure/vreplace_lane Lnn X N i
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, (numtype_0 = $unpack(Lnn)).
4. Assert: Due to validation, a value of value type V128 is on the top of the stack.
5. Pop the value (V128.CONST c_1) from the stack.
6. Let c be $inv_lanes_(Lnn X N, $lanes_(Lnn X N, c_1) with [i] replaced by $packnum_(Lnn, c_2)).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vextunop sh_1 sh_2 vextunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vextunop__(sh_1, sh_2, vextunop, c_1).
4. Push the value (V128.CONST c) to the stack.

Step_pure/vextbinop sh_1 sh_2 vextbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vextbinop__(sh_1, sh_2, vextbinop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vnarrow Jnn_2 X N_2 Jnn_1 X N_1 sx
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let ci_1* be $lanes_(Jnn_1 X N_1, c_1).
6. Let ci_2* be $lanes_(Jnn_1 X N_1, c_2).
7. Let cj_1* be [].
8. For each ci_1 in ci_1*, do:
  a. Let cj_1 be $narrow__($lsize(Jnn_1), $lsize(Jnn_2), sx, ci_1).
  b. Append cj_1 to the cj_1*.
9. Let cj_2* be [].
10. For each ci_2 in ci_2*, do:
  a. Let cj_2 be $narrow__($lsize(Jnn_1), $lsize(Jnn_2), sx, ci_2).
  b. Append cj_2 to the cj_2*.
11. Let c be $inv_lanes_(Jnn_2 X N_2, cj_1* :: cj_2*).
12. Push the value (V128.CONST c) to the stack.

Step_pure/vcvtop Lnn_2 X M Lnn_1 X M' vcvtop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If $halfop(vcvtop) is defined, then:
  a. Let ?(half) be $halfop(vcvtop).
  b. Let ci* be $lanes_(Lnn_1 X M', c_1)[$half(half, 0, M) : M].
  c. Let cj** be $setproduct_(`lane_(Lnn_2), $vcvtop__(Lnn_1 X M', Lnn_2 X M, vcvtop, ci)*).
  d. If (|$inv_lanes_(Lnn_2 X M, cj*)*| > 0), then:
    1) Let c be an element of $inv_lanes_(Lnn_2 X M, cj*)*.
    2) Push the value (V128.CONST c) to the stack.
4. Else if ($zeroop(vcvtop) is not defined /\ (M = M')), then:
  a. Let ci* be $lanes_(Lnn_1 X M', c_1).
  b. Let cj** be $setproduct_(`lane_(Lnn_2), $vcvtop__(Lnn_1 X M', Lnn_2 X M', vcvtop, ci)*).
  c. If (|$inv_lanes_(Lnn_2 X M', cj*)*| > 0), then:
    1) Let c be an element of $inv_lanes_(Lnn_2 X M', cj*)*.
    2) Push the value (V128.CONST c) to the stack.
5. If (($zeroop(vcvtop) = ?(ZERO)) /\ (Lnn_1 is numtype /\ Lnn_2 is numtype)), then:
  a. Let ci* be $lanes_(Lnn_1 X M', c_1).
  b. Let cj** be $setproduct_(`lane_((nt_2 : numtype <: lanetype)), $vcvtop__(Lnn_1 X M', Lnn_2 X M, vcvtop, ci)* :: [$zero(Lnn_2)]^M').
  c. If (|$inv_lanes_(Lnn_2 X M, cj*)*| > 0), then:
    1) Let c be an element of $inv_lanes_(Lnn_2 X M, cj*)*.
    2) Push the value (V128.CONST c) to the stack.

Step_pure/local.tee x
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Push the value val to the stack.
4. Push the value val to the stack.
5. Execute the instruction (LOCAL.SET x).

Step_read/block bt instr*
1. Let z be the current state.
2. Let t_1^k -> t_2^n be $blocktype(z, bt).
3. Assert: Due to validation, there are at least k values on the top of the stack.
4. Pop the values val^k from the stack.
5. Enter val^k :: instr* with label (LABEL_ n { [] }).

Step_read/loop bt instr*
1. Let z be the current state.
2. Let t_1^k -> t_2^n be $blocktype(z, bt).
3. Assert: Due to validation, there are at least k values on the top of the stack.
4. Pop the values val^k from the stack.
5. Enter val^k :: instr* with label (LABEL_ k { [(LOOP bt instr*)] }).

Step_read/call x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$funcaddr(z)|).
3. Execute the instruction (CALL_ADDR $funcaddr(z)[x]).

Step_read/call_indirect x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (i >= |$table(z, x).REFS|), then:
  a. Trap.
5. If $table(z, x).REFS[i] is not REF.FUNC_ADDR, then:
  a. Trap.
6. Let (REF.FUNC_ADDR a) be $table(z, x).REFS[i].
7. If (a >= |$funcinst(z)|), then:
  a. Trap.
8. If ($type(z, y) =/= $funcinst(z)[a].TYPE), then:
  a. Trap.
9. Execute the instruction (CALL_ADDR a).

Step_read/call_addr a
1. Let z be the current state.
2. Assert: Due to validation, (a < |$funcinst(z)|).
3. Let { TYPE: t_1^k -> t_2^n; MODULE: mm; CODE: func } be $funcinst(z)[a].
4. Let (FUNC x local_0* instr*) be func.
5. Let t* be [].
6. For each local_0 in local_0*, do:
  a. Let (LOCAL t) be local_0.
  b. Append t to the t*.
7. Assert: Due to validation, there are at least k values on the top of the stack.
8. Pop the values val^k from the stack.
9. Let f be { LOCALS: val^k :: $default_(t)*; MODULE: mm }.
10. Push the frame (FRAME_ n { f }) to the stack.
11. Enter instr* with label (LABEL_ n { [] }).

Step_read/ref.func x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$funcaddr(z)|).
3. Push the value (REF.FUNC_ADDR $funcaddr(z)[x]) to the stack.

Step_read/local.get x
1. Let z be the current state.
2. Push the value $local(z, x) to the stack.

Step_read/global.get x
1. Let z be the current state.
2. Push the value $global(z, x).VALUE to the stack.

Step_read/table.get x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (i >= |$table(z, x).REFS|), then:
  a. Trap.
5. Push the value $table(z, x).REFS[i] to the stack.

Step_read/table.size x
1. Let z be the current state.
2. Let n be |$table(z, x).REFS|.
3. Push the value (I32.CONST n) to the stack.

Step_read/table.fill x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. If ((i + n) > |$table(z, x).REFS|), then:
  a. Trap.
9. If (n = 0), then:
  a. Do nothing.
10. Else:
  a. Push the value (I32.CONST i) to the stack.
  b. Push the value val to the stack.
  c. Execute the instruction (TABLE.SET x).
  d. Push the value (I32.CONST (i + 1)) to the stack.
  e. Push the value val to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (TABLE.FILL x).

Step_read/table.copy x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$table(z, y).REFS|), then:
  a. Trap.
9. If ((j + n) > |$table(z, x).REFS|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else:
  a. If (j <= i), then:
    1) Push the value (I32.CONST j) to the stack.
    2) Push the value (I32.CONST i) to the stack.
    3) Execute the instruction (TABLE.GET y).
    4) Execute the instruction (TABLE.SET x).
    5) Push the value (I32.CONST (j + 1)) to the stack.
    6) Push the value (I32.CONST (i + 1)) to the stack.
  b. Else:
    1) Push the value (I32.CONST ((j + n) - 1)) to the stack.
    2) Push the value (I32.CONST ((i + n) - 1)) to the stack.
    3) Execute the instruction (TABLE.GET y).
    4) Execute the instruction (TABLE.SET x).
    5) Push the value (I32.CONST j) to the stack.
    6) Push the value (I32.CONST i) to the stack.
  c. Push the value (I32.CONST (n - 1)) to the stack.
  d. Execute the instruction (TABLE.COPY x y).

Step_read/table.init x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$elem(z, y).REFS|), then:
  a. Trap.
9. If ((j + n) > |$table(z, x).REFS|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else:
  a. Assert: Due to validation, (i < |$elem(z, y).REFS|).
  b. Push the value (I32.CONST j) to the stack.
  c. Push the value $elem(z, y).REFS[i] to the stack.
  d. Execute the instruction (TABLE.SET x).
  e. Push the value (I32.CONST (j + 1)) to the stack.
  f. Push the value (I32.CONST (i + 1)) to the stack.
  g. Push the value (I32.CONST (n - 1)) to the stack.
  h. Execute the instruction (TABLE.INIT x y).

Step_read/load nt loadop_? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If loadop_? is not defined, then:
  a. If (((i + ao.OFFSET) + ($size(nt) / 8)) > |$mem(z, 0).BYTES|), then:
    1) Trap.
  b. Let c be $nbytes__1^-1(nt, $mem(z, 0).BYTES[(i + ao.OFFSET) : ($size(nt) / 8)]).
  c. Push the value (nt.CONST c) to the stack.
5. Else:
  a. Assert: Due to validation, nt is Inn.
  b. Let ?(loadop_0) be loadop_?.
  c. Let n _ sx be loadop_0.
  d. If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
    1) Trap.
  e. Let c be $ibytes__1^-1(n, $mem(z, 0).BYTES[(i + ao.OFFSET) : (n / 8)]).
  f. Push the value (nt.CONST $extend__(n, $size(nt), sx, c)) to the stack.

Step_read/vload V128 vloadop? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If vloadop? is not defined, then:
  a. If (((i + ao.OFFSET) + ($size(V128) / 8)) > |$mem(z, 0).BYTES|), then:
    1) Trap.
  b. Let c be $vbytes__1^-1(V128, $mem(z, 0).BYTES[(i + ao.OFFSET) : ($size(V128) / 8)]).
  c. Push the value (V128.CONST c) to the stack.
5. Else:
  a. Let ?(vloadop_0) be vloadop?.
  b. If vloadop_0 is some SHAPE, then:
    1) Let (SHAPE M X N _ sx) be vloadop_0.
    2) If (((i + ao.OFFSET) + ((M * N) / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
    3) Let j^N be $ibytes__1^-1(M, $mem(z, 0).BYTES[((i + ao.OFFSET) + ((k * M) / 8)) : (M / 8)])^(k<N).
    4) Let Jnn be $jsize^-1((M * 2)).
    5) Let c be $inv_lanes_(Jnn X N, $extend__(M, $jsize(Jnn), sx, j)^N).
    6) Push the value (V128.CONST c) to the stack.
  c. If vloadop_0 is some SPLAT, then:
    1) Let (SPLAT N) be vloadop_0.
    2) If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
    3) Let M be (128 / N).
    4) Let Jnn be $jsize^-1(N).
    5) Let j be $ibytes__1^-1(N, $mem(z, 0).BYTES[(i + ao.OFFSET) : (N / 8)]).
    6) Let c be $inv_lanes_(Jnn X M, j^M).
    7) Push the value (V128.CONST c) to the stack.
  d. If vloadop_0 is some ZERO, then:
    1) Let (ZERO N) be vloadop_0.
    2) If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
    3) Let j be $ibytes__1^-1(N, $mem(z, 0).BYTES[(i + ao.OFFSET) : (N / 8)]).
    4) Let c be $extend__(N, 128, U, j).
    5) Push the value (V128.CONST c) to the stack.

Step_read/vload_lane V128 N ao j
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c_1) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, 0).BYTES|), then:
  a. Trap.
7. Let M be (128 / N).
8. Let Jnn be $jsize^-1(N).
9. Let k be $ibytes__1^-1(N, $mem(z, 0).BYTES[(i + ao.OFFSET) : (N / 8)]).
10. Let c be $inv_lanes_(Jnn X M, $lanes_(Jnn X M, c_1) with [j] replaced by k).
11. Push the value (V128.CONST c) to the stack.

Step_read/memory.size
1. Let z be the current state.
2. Let ((n * 64) * $Ki()) be |$mem(z, 0).BYTES|.
3. Push the value (I32.CONST n) to the stack.

Step_read/memory.fill
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. If ((i + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.
9. If (n = 0), then:
  a. Do nothing.
10. Else:
  a. Push the value (I32.CONST i) to the stack.
  b. Push the value val to the stack.
  c. Execute the instruction (STORE I32 ?(8) $memarg0()).
  d. Push the value (I32.CONST (i + 1)) to the stack.
  e. Push the value val to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction MEMORY.FILL.

Step_read/memory.copy
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.
9. If ((j + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else:
  a. If (j <= i), then:
    1) Push the value (I32.CONST j) to the stack.
    2) Push the value (I32.CONST i) to the stack.
    3) Execute the instruction (LOAD I32 ?(8 _ U) $memarg0()).
    4) Execute the instruction (STORE I32 ?(8) $memarg0()).
    5) Push the value (I32.CONST (j + 1)) to the stack.
    6) Push the value (I32.CONST (i + 1)) to the stack.
  b. Else:
    1) Push the value (I32.CONST ((j + n) - 1)) to the stack.
    2) Push the value (I32.CONST ((i + n) - 1)) to the stack.
    3) Execute the instruction (LOAD I32 ?(8 _ U) $memarg0()).
    4) Execute the instruction (STORE I32 ?(8) $memarg0()).
    5) Push the value (I32.CONST j) to the stack.
    6) Push the value (I32.CONST i) to the stack.
  c. Push the value (I32.CONST (n - 1)) to the stack.
  d. Execute the instruction MEMORY.COPY.

Step_read/memory.init x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$data(z, x).BYTES|), then:
  a. Trap.
9. If ((j + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else:
  a. Assert: Due to validation, (i < |$data(z, x).BYTES|).
  b. Push the value (I32.CONST j) to the stack.
  c. Push the value (I32.CONST $data(z, x).BYTES[i]) to the stack.
  d. Execute the instruction (STORE I32 ?(8) $memarg0()).
  e. Push the value (I32.CONST (j + 1)) to the stack.
  f. Push the value (I32.CONST (i + 1)) to the stack.
  g. Push the value (I32.CONST (n - 1)) to the stack.
  h. Execute the instruction (MEMORY.INIT x).

Step/local.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_local(z, x, val).

Step/global.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_global(z, x, val).

Step/table.set x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (i >= |$table(z, x).REFS|), then:
  a. Trap.
7. Perform $with_table(z, x, i, ref).

Step/table.grow x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type ref is on the top of the stack.
5. Pop the value ref from the stack.
6. Either:
  a. Let ti be $growtable($table(z, x), n, ref).
  b. Push the value (I32.CONST |$table(z, x).REFS|) to the stack.
  c. Perform $with_tableinst(z, x, ti).
7. Or:
  a. Push the value (I32.CONST $inv_signed_(32, (- 1))) to the stack.

Step/elem.drop x
1. Let z be the current state.
2. Perform $with_elem(z, x, []).

Step/store nt sz? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (nt'.CONST c) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, (nt = nt').
7. If sz? is not defined, then:
  a. If (((i + ao.OFFSET) + ($size(nt') / 8)) > |$mem(z, 0).BYTES|), then:
    1) Trap.
  b. Let b* be $nbytes_(nt', c).
  c. Perform $with_mem(z, 0, (i + ao.OFFSET), ($size(nt') / 8), b*).
8. Else:
  a. Assert: Due to validation, nt' is Inn.
  b. Let ?(n) be sz?.
  c. If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
    1) Trap.
  d. Let b* be $ibytes_(n, $wrap__($size(nt'), n, c)).
  e. Perform $with_mem(z, 0, (i + ao.OFFSET), (n / 8), b*).

Step/vstore V128 ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + ($size(V128) / 8)) > |$mem(z, 0).BYTES|), then:
  a. Trap.
7. Let b* be $vbytes_(V128, c).
8. Perform $with_mem(z, 0, (i + ao.OFFSET), ($size(V128) / 8), b*).

Step/vstore_lane V128 N ao j
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + N) > |$mem(z, 0).BYTES|), then:
  a. Trap.
7. Let M be (128 / N).
8. Let Jnn be $jsize^-1(N).
9. Assert: Due to validation, (j < |$lanes_(Jnn X M, c)|).
10. Let b* be $ibytes_(N, $lanes_(Jnn X M, c)[j]).
11. Perform $with_mem(z, 0, (i + ao.OFFSET), (N / 8), b*).

Step/memory.grow
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Either:
  a. Let mi be $growmemory($mem(z, 0), n).
  b. Push the value (I32.CONST (|$mem(z, 0).BYTES| / (64 * $Ki()))) to the stack.
  c. Perform $with_meminst(z, 0, mi).
5. Or:
  a. Push the value (I32.CONST $inv_signed_(32, (- 1))) to the stack.

Step/data.drop x
1. Let z be the current state.
2. Perform $with_data(z, x, []).

Ki
1. Return 1024.

min i j
1. If (i <= j), then:
  a. Return i.
2. Return j.

sum n''*
1. If (n''* = []), then:
  a. Return 0.
2. Let [n] :: n'* be n''*.
3. Return (n + $sum(n'*)).

opt_ `X X*
1. If (X* = []), then:
  a. Return ?().
2. If (|X*| = 1), then:
  a. Let [w] be X*.
  b. Return ?(w).
3. Fail.

list_ `X X?
1. If X? is not defined, then:
  a. Return [].
2. Let ?(w) be X?.
3. Return [w].

concat_ `X X*
1. If (X* = []), then:
  a. Return [].
2. Let [w*] :: w'** be X*.
3. Return w* :: $concat_(`X, w'**).

setproduct2_ `X w_1 X*
1. If (X* = []), then:
  a. Return [].
2. Let [w'*] :: w** be X*.
3. Return [[w_1] :: w'*] :: $setproduct2_(`X, w_1, w**).

setproduct1_ `X X* w**
1. If (X* = []), then:
  a. Return [].
2. Let [w_1] :: w'* be X*.
3. Return $setproduct2_(`X, w_1, w**) :: $setproduct1_(`X, w'*, w**).

setproduct_ `X X*
1. If (X* = []), then:
  a. Return [[]].
2. Let [w_1*] :: w** be X*.
3. Return $setproduct1_(`X, w_1*, $setproduct_(`X, w**)).

signif N
1. If (N = 32), then:
  a. Return 23.
2. If (N = 64), then:
  a. Return 52.
3. Fail.

expon N
1. If (N = 32), then:
  a. Return 8.
2. If (N = 64), then:
  a. Return 11.
3. Fail.

M N
1. Return $signif(N).

E N
1. Return $expon(N).

fzero N
1. Return (POS (SUBNORM 0)).

fone N
1. Return (POS (NORM 1 0)).

canon_ N
1. Return (2 ^ ($signif(N) - 1)).

lanetype Lnn X N
1. Return Lnn.

size valtype
1. If (valtype = I32), then:
  a. Return 32.
2. If (valtype = I64), then:
  a. Return 64.
3. If (valtype = F32), then:
  a. Return 32.
4. If (valtype = F64), then:
  a. Return 64.
5. If (valtype = V128), then:
  a. Return 128.
6. Fail.

psize packtype
1. If (packtype = I8), then:
  a. Return 8.
2. Assert: Due to validation, (packtype = I16).
3. Return 16.

lsize lanetype
1. If lanetype is numtype, then:
  a. Return $size(lanetype).
2. Assert: Due to validation, lanetype is packtype.
3. Return $psize(lanetype).

isize Inn
1. Return $size(Inn).

jsize Jnn
1. Return $lsize(Jnn).

fsize Fnn
1. Return $size(Fnn).

sizenn nt
1. Return $size(nt).

sizenn1 nt
1. Return $size(nt).

sizenn2 nt
1. Return $size(nt).

lsizenn lt
1. Return $lsize(lt).

lsizenn1 lt
1. Return $lsize(lt).

lsizenn2 lt
1. Return $lsize(lt).

inv_isize n
1. If (n = 32), then:
  a. Return I32.
2. If (n = 64), then:
  a. Return I64.
3. Fail.

inv_jsize n
1. If (n = 8), then:
  a. Return I8.
2. If (n = 16), then:
  a. Return I16.
3. If (n = 32), then:
  a. Return I32.
4. If (n = 64), then:
  a. Return I64.
5. Fail.

inv_fsize n
1. If (n = 32), then:
  a. Return F32.
2. If (n = 64), then:
  a. Return F64.
3. Fail.

zero numtype
1. If numtype is Inn, then:
  a. Return 0.
2. Assert: Due to validation, numtype is Fnn.
3. Return $fzero($size(numtype)).

dim Lnn X N
1. Return N.

shsize Lnn X N
1. Return ($lsize(Lnn) * N).

concat_bytes byte*
1. If (byte* = []), then:
  a. Return [].
2. Let [b*] :: b'** be byte*.
3. Return b* :: $concat_bytes(b'**).

unpack lanetype
1. If lanetype is numtype, then:
  a. Return lanetype.
2. Assert: Due to validation, lanetype is packtype.
3. Return I32.

shunpack Lnn X N
1. Return $unpack(Lnn).

funcsxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some FUNC, then:
  a. Let (FUNC ft) be externtype_0.
  b. Return [ft] :: $funcsxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $funcsxt(xt*).

globalsxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some GLOBAL, then:
  a. Let (GLOBAL gt) be externtype_0.
  b. Return [gt] :: $globalsxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $globalsxt(xt*).

tablesxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some TABLE, then:
  a. Let (TABLE tt) be externtype_0.
  b. Return [tt] :: $tablesxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $tablesxt(xt*).

memsxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some MEM, then:
  a. Let (MEM mt) be externtype_0.
  b. Return [mt] :: $memsxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $memsxt(xt*).

dataidx_instr instr
1. If instr is some MEMORY.INIT, then:
  a. Let (MEMORY.INIT x) be instr.
  b. Return [x].
2. If instr is some DATA.DROP, then:
  a. Let (DATA.DROP x) be instr.
  b. Return [x].
3. Return [].

dataidx_instrs instr''*
1. If (instr''* = []), then:
  a. Return [].
2. Let [instr] :: instr'* be instr''*.
3. Return $dataidx_instr(instr) :: $dataidx_instrs(instr'*).

dataidx_expr in*
1. Return $dataidx_instrs(in*).

dataidx_func (FUNC x loc* e)
1. Return $dataidx_expr(e).

dataidx_funcs func''*
1. If (func''* = []), then:
  a. Return [].
2. Let [func] :: func'* be func''*.
3. Return $dataidx_func(func) :: $dataidx_funcs(func'*).

memarg0
1. Return { ALIGN: 0; OFFSET: 0 }.

bool b
1. If (b = false), then:
  a. Return 0.
2. Assert: Due to validation, (b = true).
3. Return 1.

signed_ N i
1. If (i < (2 ^ (N - 1))), then:
  a. Return i.
2. Assert: Due to validation, ((2 ^ (N - 1)) <= i).
3. Assert: Due to validation, (i < (2 ^ N)).
4. Return (i - (2 ^ N)).

inv_signed_ N i
1. If ((0 <= i) /\ (i < (2 ^ (N - 1)))), then:
  a. Return i.
2. Assert: Due to validation, ((- (2 ^ (N - 1))) <= i).
3. Assert: Due to validation, (i < 0).
4. Return (i + (2 ^ N)).

sat_u_ N i
1. If (i < 0), then:
  a. Return 0.
2. If (i > ((2 ^ N) - 1)), then:
  a. Return ((2 ^ N) - 1).
3. Return i.

sat_s_ N i
1. If (i < (- (2 ^ (N - 1)))), then:
  a. Return (- (2 ^ (N - 1))).
2. If (i > ((2 ^ (N - 1)) - 1)), then:
  a. Return ((2 ^ (N - 1)) - 1).
3. Return i.

unop_ numtype unop_ iN
1. If numtype is Inn, then:
  a. If (unop_ = CLZ), then:
    1) Return [$iclz_($sizenn(numtype), iN)].
  b. If (unop_ = CTZ), then:
    1) Return [$ictz_($sizenn(numtype), iN)].
  c. If (unop_ = POPCNT), then:
    1) Return [$ipopcnt_($sizenn(numtype), iN)].
  d. Assert: Due to validation, unop_ is some EXTEND.
  e. Let (EXTEND M) be unop_.
  f. Return [$extend__(M, $sizenn(numtype), S, $wrap__($sizenn(numtype), M, iN))].
2. Assert: Due to validation, numtype is Fnn.
3. If (unop_ = ABS), then:
  a. Return $fabs_($sizenn(numtype), iN).
4. If (unop_ = NEG), then:
  a. Return $fneg_($sizenn(numtype), iN).
5. If (unop_ = SQRT), then:
  a. Return $fsqrt_($sizenn(numtype), iN).
6. If (unop_ = CEIL), then:
  a. Return $fceil_($sizenn(numtype), iN).
7. If (unop_ = FLOOR), then:
  a. Return $ffloor_($sizenn(numtype), iN).
8. If (unop_ = TRUNC), then:
  a. Return $ftrunc_($sizenn(numtype), iN).
9. Assert: Due to validation, (unop_ = NEAREST).
10. Return $fnearest_($sizenn(numtype), iN).

iadd_ N i_1 i_2
1. Return ((i_1 + i_2) \ (2 ^ N)).

idiv_ N sx i_1 i_2
1. If (sx = U), then:
  a. If (i_2 = 0), then:
    1) Return ?().
  b. Return ?($truncz((i_1 / i_2))).
2. Assert: Due to validation, (sx = S).
3. If (i_2 = 0), then:
  a. Return ?().
4. If (($signed_(N, i_1) / $signed_(N, i_2)) = (2 ^ (N - 1))), then:
  a. Return ?().
5. Return ?($inv_signed_(N, $truncz(($signed_(N, i_1) / $signed_(N, i_2))))).

imul_ N i_1 i_2
1. Return ((i_1 * i_2) \ (2 ^ N)).

irem_ N sx i_1 i_2
1. If (sx = U), then:
  a. If (i_2 = 0), then:
    1) Return ?().
  b. Return ?((i_1 - (i_2 * $truncz((i_1 / i_2))))).
2. Assert: Due to validation, (sx = S).
3. If (i_2 = 0), then:
  a. Return ?().
4. Let j_1 be $signed_(N, i_1).
5. Let j_2 be $signed_(N, i_2).
6. Return ?($inv_signed_(N, (j_1 - (j_2 * $truncz((j_1 / j_2)))))).

isub_ N i_1 i_2
1. Return ((((2 ^ N) + i_1) - i_2) \ (2 ^ N)).

binop_ numtype binop_ iN_1 iN_2
1. If numtype is Inn, then:
  a. If (binop_ = ADD), then:
    1) Return [$iadd_($sizenn(numtype), iN_1, iN_2)].
  b. If (binop_ = SUB), then:
    1) Return [$isub_($sizenn(numtype), iN_1, iN_2)].
  c. If (binop_ = MUL), then:
    1) Return [$imul_($sizenn(numtype), iN_1, iN_2)].
  d. If binop_ is some DIV, then:
    1) Let (DIV sx) be binop_.
    2) Return $list_(`num_((Inn : Inn <: numtype)), $idiv_($sizenn(numtype), sx, iN_1, iN_2)).
  e. If binop_ is some REM, then:
    1) Let (REM sx) be binop_.
    2) Return $list_(`num_((Inn : Inn <: numtype)), $irem_($sizenn(numtype), sx, iN_1, iN_2)).
  f. If (binop_ = AND), then:
    1) Return [$iand_($sizenn(numtype), iN_1, iN_2)].
  g. If (binop_ = OR), then:
    1) Return [$ior_($sizenn(numtype), iN_1, iN_2)].
  h. If (binop_ = XOR), then:
    1) Return [$ixor_($sizenn(numtype), iN_1, iN_2)].
  i. If (binop_ = SHL), then:
    1) Return [$ishl_($sizenn(numtype), iN_1, iN_2)].
  j. If binop_ is some SHR, then:
    1) Let (SHR sx) be binop_.
    2) Return [$ishr_($sizenn(numtype), sx, iN_1, iN_2)].
  k. If (binop_ = ROTL), then:
    1) Return [$irotl_($sizenn(numtype), iN_1, iN_2)].
  l. If (binop_ = ROTR), then:
    1) Return [$irotr_($sizenn(numtype), iN_1, iN_2)].
2. Assert: Due to validation, numtype is Fnn.
3. If (binop_ = ADD), then:
  a. Return $fadd_($sizenn(numtype), iN_1, iN_2).
4. If (binop_ = SUB), then:
  a. Return $fsub_($sizenn(numtype), iN_1, iN_2).
5. If (binop_ = MUL), then:
  a. Return $fmul_($sizenn(numtype), iN_1, iN_2).
6. If (binop_ = DIV), then:
  a. Return $fdiv_($sizenn(numtype), iN_1, iN_2).
7. If (binop_ = MIN), then:
  a. Return $fmin_($sizenn(numtype), iN_1, iN_2).
8. If (binop_ = MAX), then:
  a. Return $fmax_($sizenn(numtype), iN_1, iN_2).
9. Assert: Due to validation, (binop_ = COPYSIGN).
10. Return $fcopysign_($sizenn(numtype), iN_1, iN_2).

ieqz_ N i_1
1. Return $bool((i_1 = 0)).

testop_ Inn EQZ iN
1. Return $ieqz_($sizenn(Inn), iN).

ieq_ N i_1 i_2
1. Return $bool((i_1 = i_2)).

ige_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 >= i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) >= $signed_(N, i_2))).

igt_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 > i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) > $signed_(N, i_2))).

ile_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 <= i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) <= $signed_(N, i_2))).

ilt_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 < i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) < $signed_(N, i_2))).

ine_ N i_1 i_2
1. Return $bool((i_1 =/= i_2)).

relop_ numtype relop_ iN_1 iN_2
1. If numtype is Inn, then:
  a. If (relop_ = EQ), then:
    1) Return $ieq_($sizenn(numtype), iN_1, iN_2).
  b. If (relop_ = NE), then:
    1) Return $ine_($sizenn(numtype), iN_1, iN_2).
  c. If relop_ is some LT, then:
    1) Let (LT sx) be relop_.
    2) Return $ilt_($sizenn(numtype), sx, iN_1, iN_2).
  d. If relop_ is some GT, then:
    1) Let (GT sx) be relop_.
    2) Return $igt_($sizenn(numtype), sx, iN_1, iN_2).
  e. If relop_ is some LE, then:
    1) Let (LE sx) be relop_.
    2) Return $ile_($sizenn(numtype), sx, iN_1, iN_2).
  f. If relop_ is some GE, then:
    1) Let (GE sx) be relop_.
    2) Return $ige_($sizenn(numtype), sx, iN_1, iN_2).
2. Assert: Due to validation, numtype is Fnn.
3. If (relop_ = EQ), then:
  a. Return $feq_($sizenn(numtype), iN_1, iN_2).
4. If (relop_ = NE), then:
  a. Return $fne_($sizenn(numtype), iN_1, iN_2).
5. If (relop_ = LT), then:
  a. Return $flt_($sizenn(numtype), iN_1, iN_2).
6. If (relop_ = GT), then:
  a. Return $fgt_($sizenn(numtype), iN_1, iN_2).
7. If (relop_ = LE), then:
  a. Return $fle_($sizenn(numtype), iN_1, iN_2).
8. Assert: Due to validation, (relop_ = GE).
9. Return $fge_($sizenn(numtype), iN_1, iN_2).

cvtop__ numtype numtype' cvtop iN_1
1. If (numtype is Inn /\ numtype' is Inn), then:
  a. If cvtop is some EXTEND, then:
    1) Let (EXTEND sx) be cvtop.
    2) Return [$extend__($sizenn1(numtype), $sizenn2(numtype'), sx, iN_1)].
  b. If (cvtop = WRAP), then:
    1) Return [$wrap__($sizenn1(numtype), $sizenn2(numtype'), iN_1)].
2. If (numtype is Fnn /\ numtype' is Inn), then:
  a. If cvtop is some TRUNC, then:
    1) Let (TRUNC sx) be cvtop.
    2) Return $list_(`num_((Inn_2 : Inn <: numtype)), $trunc__($sizenn1(numtype), $sizenn2(numtype'), sx, iN_1)).
  b. If cvtop is some TRUNC_SAT, then:
    1) Let (TRUNC_SAT sx) be cvtop.
    2) Return $list_(`num_((Inn_2 : Inn <: numtype)), $trunc_sat__($sizenn1(numtype), $sizenn2(numtype'), sx, iN_1)).
3. If (numtype is Inn /\ (numtype' is Fnn /\ cvtop is some CONVERT)), then:
  a. Let (CONVERT sx) be cvtop.
  b. Return [$convert__($sizenn1(numtype), $sizenn2(numtype'), sx, iN_1)].
4. If (numtype is Fnn /\ numtype' is Fnn), then:
  a. If (cvtop = PROMOTE), then:
    1) Return $promote__($sizenn1(numtype), $sizenn2(numtype'), iN_1).
  b. If (cvtop = DEMOTE), then:
    1) Return $demote__($sizenn1(numtype), $sizenn2(numtype'), iN_1).
5. If (numtype is Inn /\ (numtype' is Fnn /\ ((cvtop = REINTERPRET) /\ ($size(numtype) = $size(numtype'))))), then:
  a. Return [$reinterpret__(numtype, numtype', iN_1)].
6. Assert: Due to validation, numtype is Fnn.
7. Assert: Due to validation, numtype' is Inn.
8. Assert: Due to validation, (cvtop = REINTERPRET).
9. Assert: Due to validation, ($size(numtype) = $size(numtype')).
10. Return [$reinterpret__(numtype, numtype', iN_1)].

inez_ N i_1
1. Return $bool((i_1 =/= 0)).

ineg_ N i_1
1. Return (((2 ^ N) - i_1) \ (2 ^ N)).

iabs_ N i_1
1. If ($signed_(N, i_1) >= 0), then:
  a. Return i_1.
2. Return $ineg_(N, i_1).

imin_ N sx i_1 i_2
1. If (sx = U), then:
  a. If (i_1 <= i_2), then:
    1) Return i_1.
  b. Return i_2.
2. Assert: Due to validation, (sx = S).
3. If ($signed_(N, i_1) <= $signed_(N, i_2)), then:
  a. Return i_1.
4. Return i_2.

imax_ N sx i_1 i_2
1. If (sx = U), then:
  a. If (i_1 >= i_2), then:
    1) Return i_1.
  b. Return i_2.
2. Assert: Due to validation, (sx = S).
3. If ($signed_(N, i_1) >= $signed_(N, i_2)), then:
  a. Return i_1.
4. Return i_2.

iadd_sat_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $sat_u_(N, (i_1 + i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $inv_signed_(N, $sat_s_(N, ($signed_(N, i_1) + $signed_(N, i_2)))).

isub_sat_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $sat_u_(N, (i_1 - i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $inv_signed_(N, $sat_s_(N, ($signed_(N, i_1) - $signed_(N, i_2)))).

packnum_ lanetype c
1. If lanetype is numtype, then:
  a. Return c.
2. Assert: Due to validation, lanetype is packtype.
3. Return $wrap__($size($unpack(lanetype)), $psize(lanetype), c).

unpacknum_ lanetype c
1. If lanetype is numtype, then:
  a. Return c.
2. Assert: Due to validation, lanetype is packtype.
3. Return $extend__($psize(lanetype), $size($unpack(lanetype)), U, c).

zeroop vcvtop
1. If vcvtop is some EXTEND, then:
  a. Return ?().
2. If vcvtop is some CONVERT, then:
  a. Return ?().
3. If vcvtop is some TRUNC_SAT, then:
  a. Let (TRUNC_SAT sx zero?) be vcvtop.
  b. Return zero?.
4. If vcvtop is some DEMOTE, then:
  a. Let (DEMOTE zero) be vcvtop.
  b. Return ?(zero).
5. Assert: Due to validation, (vcvtop = PROMOTELOW).
6. Return ?().

halfop vcvtop
1. If vcvtop is some EXTEND, then:
  a. Let (EXTEND half sx) be vcvtop.
  b. Return ?(half).
2. If vcvtop is some CONVERT, then:
  a. Let (CONVERT half? sx) be vcvtop.
  b. Return half?.
3. If vcvtop is some TRUNC_SAT, then:
  a. Return ?().
4. If vcvtop is some DEMOTE, then:
  a. Return ?().
5. Assert: Due to validation, (vcvtop = PROMOTELOW).
6. Return ?(LOW).

half half i j
1. If (half = LOW), then:
  a. Return i.
2. Assert: Due to validation, (half = HIGH).
3. Return j.

vvunop_ V128 NOT v128
1. Return $inot_($size(V128), v128).

vvbinop_ V128 vvbinop v128_1 v128_2
1. If (vvbinop = AND), then:
  a. Return $iand_($size(V128), v128_1, v128_2).
2. If (vvbinop = ANDNOT), then:
  a. Return $iandnot_($size(V128), v128_1, v128_2).
3. If (vvbinop = OR), then:
  a. Return $ior_($size(V128), v128_1, v128_2).
4. Assert: Due to validation, (vvbinop = XOR).
5. Return $ixor_($size(V128), v128_1, v128_2).

vvternop_ V128 BITSELECT v128_1 v128_2 v128_3
1. Return $ibitselect_($size(V128), v128_1, v128_2, v128_3).

vunop_ lanetype X M vunop_ v128_1
1. If lanetype is Jnn, then:
  a. If (vunop_ = ABS), then:
    1) Let lane_1* be $lanes_(lanetype X M, v128_1).
    2) Let v128 be $inv_lanes_(lanetype X M, $iabs_($lsizenn(lanetype), lane_1)*).
    3) Return [v128].
  b. If (vunop_ = NEG), then:
    1) Let lane_1* be $lanes_(lanetype X M, v128_1).
    2) Let v128 be $inv_lanes_(lanetype X M, $ineg_($lsizenn(lanetype), lane_1)*).
    3) Return [v128].
  c. If (vunop_ = POPCNT), then:
    1) Let lane_1* be $lanes_(lanetype X M, v128_1).
    2) Let v128 be $inv_lanes_(lanetype X M, $ipopcnt_($lsizenn(lanetype), lane_1)*).
    3) Return [v128].
2. Assert: Due to validation, lanetype is Fnn.
3. If (vunop_ = ABS), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fabs_($sizenn(lanetype), lane_1)*).
  c. Let v128* be [].
  d. For each lane* in lane**, do:
    1) Let v128 be $inv_lanes_(lanetype X M, lane*).
    2) Append v128 to the v128*.
  e. Return v128*.
4. If (vunop_ = NEG), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fneg_($sizenn(lanetype), lane_1)*).
  c. Let v128* be [].
  d. For each lane* in lane**, do:
    1) Let v128 be $inv_lanes_(lanetype X M, lane*).
    2) Append v128 to the v128*.
  e. Return v128*.
5. If (vunop_ = SQRT), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fsqrt_($sizenn(lanetype), lane_1)*).
  c. Let v128* be [].
  d. For each lane* in lane**, do:
    1) Let v128 be $inv_lanes_(lanetype X M, lane*).
    2) Append v128 to the v128*.
  e. Return v128*.
6. If (vunop_ = CEIL), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fceil_($sizenn(lanetype), lane_1)*).
  c. Let v128* be [].
  d. For each lane* in lane**, do:
    1) Let v128 be $inv_lanes_(lanetype X M, lane*).
    2) Append v128 to the v128*.
  e. Return v128*.
7. If (vunop_ = FLOOR), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $ffloor_($sizenn(lanetype), lane_1)*).
  c. Let v128* be [].
  d. For each lane* in lane**, do:
    1) Let v128 be $inv_lanes_(lanetype X M, lane*).
    2) Append v128 to the v128*.
  e. Return v128*.
8. If (vunop_ = TRUNC), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $ftrunc_($sizenn(lanetype), lane_1)*).
  c. Let v128* be [].
  d. For each lane* in lane**, do:
    1) Let v128 be $inv_lanes_(lanetype X M, lane*).
    2) Append v128 to the v128*.
  e. Return v128*.
9. Assert: Due to validation, (vunop_ = NEAREST).
10. Let lane_1* be $lanes_(lanetype X M, v128_1).
11. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fnearest_($sizenn(lanetype), lane_1)*).
12. Let v128* be [].
13. For each lane* in lane**, do:
  a. Let v128 be $inv_lanes_(lanetype X M, lane*).
  b. Append v128 to the v128*.
14. Return v128*.

vbinop_ lanetype X M vbinop_ v128_1 v128_2
1. If lanetype is Jnn, then:
  a. If (vbinop_ = ADD), then:
    1) Let lane_1* be $lanes_(lanetype X M, v128_1).
    2) Let lane_2* be $lanes_(lanetype X M, v128_2).
    3) Let v128 be $inv_lanes_(lanetype X M, $iadd_($lsizenn(lanetype), lane_1, lane_2)*).
    4) Return [v128].
  b. If (vbinop_ = SUB), then:
    1) Let lane_1* be $lanes_(lanetype X M, v128_1).
    2) Let lane_2* be $lanes_(lanetype X M, v128_2).
    3) Let v128 be $inv_lanes_(lanetype X M, $isub_($lsizenn(lanetype), lane_1, lane_2)*).
    4) Return [v128].
  c. If vbinop_ is some MIN, then:
    1) Let (MIN sx) be vbinop_.
    2) Let lane_1* be $lanes_(lanetype X M, v128_1).
    3) Let lane_2* be $lanes_(lanetype X M, v128_2).
    4) Let v128 be $inv_lanes_(lanetype X M, $imin_($lsizenn(lanetype), sx, lane_1, lane_2)*).
    5) Return [v128].
  d. If vbinop_ is some MAX, then:
    1) Let (MAX sx) be vbinop_.
    2) Let lane_1* be $lanes_(lanetype X M, v128_1).
    3) Let lane_2* be $lanes_(lanetype X M, v128_2).
    4) Let v128 be $inv_lanes_(lanetype X M, $imax_($lsizenn(lanetype), sx, lane_1, lane_2)*).
    5) Return [v128].
  e. If vbinop_ is some ADD_SAT, then:
    1) Let (ADD_SAT sx) be vbinop_.
    2) Let lane_1* be $lanes_(lanetype X M, v128_1).
    3) Let lane_2* be $lanes_(lanetype X M, v128_2).
    4) Let v128 be $inv_lanes_(lanetype X M, $iadd_sat_($lsizenn(lanetype), sx, lane_1, lane_2)*).
    5) Return [v128].
  f. If vbinop_ is some SUB_SAT, then:
    1) Let (SUB_SAT sx) be vbinop_.
    2) Let lane_1* be $lanes_(lanetype X M, v128_1).
    3) Let lane_2* be $lanes_(lanetype X M, v128_2).
    4) Let v128 be $inv_lanes_(lanetype X M, $isub_sat_($lsizenn(lanetype), sx, lane_1, lane_2)*).
    5) Return [v128].
  g. If (vbinop_ = MUL), then:
    1) Let lane_1* be $lanes_(lanetype X M, v128_1).
    2) Let lane_2* be $lanes_(lanetype X M, v128_2).
    3) Let v128 be $inv_lanes_(lanetype X M, $imul_($lsizenn(lanetype), lane_1, lane_2)*).
    4) Return [v128].
  h. If (vbinop_ = AVGRU), then:
    1) Let lane_1* be $lanes_(lanetype X M, v128_1).
    2) Let lane_2* be $lanes_(lanetype X M, v128_2).
    3) Let v128 be $inv_lanes_(lanetype X M, $iavgr_($lsizenn(lanetype), U, lane_1, lane_2)*).
    4) Return [v128].
  i. If (vbinop_ = Q15MULR_SATS), then:
    1) Let lane_1* be $lanes_(lanetype X M, v128_1).
    2) Let lane_2* be $lanes_(lanetype X M, v128_2).
    3) Let v128 be $inv_lanes_(lanetype X M, $iq15mulr_sat_($lsizenn(lanetype), S, lane_1, lane_2)*).
    4) Return [v128].
2. Assert: Due to validation, lanetype is Fnn.
3. If (vbinop_ = ADD), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fadd_($sizenn(lanetype), lane_1, lane_2)*).
  d. Let v128* be [].
  e. For each lane* in lane**, do:
    1) Let v128 be $inv_lanes_(lanetype X M, lane*).
    2) Append v128 to the v128*.
  f. Return v128*.
4. If (vbinop_ = SUB), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fsub_($sizenn(lanetype), lane_1, lane_2)*).
  d. Let v128* be [].
  e. For each lane* in lane**, do:
    1) Let v128 be $inv_lanes_(lanetype X M, lane*).
    2) Append v128 to the v128*.
  f. Return v128*.
5. If (vbinop_ = MUL), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fmul_($sizenn(lanetype), lane_1, lane_2)*).
  d. Let v128* be [].
  e. For each lane* in lane**, do:
    1) Let v128 be $inv_lanes_(lanetype X M, lane*).
    2) Append v128 to the v128*.
  f. Return v128*.
6. If (vbinop_ = DIV), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fdiv_($sizenn(lanetype), lane_1, lane_2)*).
  d. Let v128* be [].
  e. For each lane* in lane**, do:
    1) Let v128 be $inv_lanes_(lanetype X M, lane*).
    2) Append v128 to the v128*.
  f. Return v128*.
7. If (vbinop_ = MIN), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fmin_($sizenn(lanetype), lane_1, lane_2)*).
  d. Let v128* be [].
  e. For each lane* in lane**, do:
    1) Let v128 be $inv_lanes_(lanetype X M, lane*).
    2) Append v128 to the v128*.
  f. Return v128*.
8. If (vbinop_ = MAX), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fmax_($sizenn(lanetype), lane_1, lane_2)*).
  d. Let v128* be [].
  e. For each lane* in lane**, do:
    1) Let v128 be $inv_lanes_(lanetype X M, lane*).
    2) Append v128 to the v128*.
  f. Return v128*.
9. If (vbinop_ = PMIN), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fpmin_($sizenn(lanetype), lane_1, lane_2)*).
  d. Let v128* be [].
  e. For each lane* in lane**, do:
    1) Let v128 be $inv_lanes_(lanetype X M, lane*).
    2) Append v128 to the v128*.
  f. Return v128*.
10. Assert: Due to validation, (vbinop_ = PMAX).
11. Let lane_1* be $lanes_(lanetype X M, v128_1).
12. Let lane_2* be $lanes_(lanetype X M, v128_2).
13. Let lane** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $fpmax_($sizenn(lanetype), lane_1, lane_2)*).
14. Let v128* be [].
15. For each lane* in lane**, do:
  a. Let v128 be $inv_lanes_(lanetype X M, lane*).
  b. Append v128 to the v128*.
16. Return v128*.

vrelop_ lanetype X M vrelop_ v128_1 v128_2
1. If lanetype is Jnn, then:
  a. If (vrelop_ = EQ), then:
    1) Let lane_1* be $lanes_(lanetype X M, v128_1).
    2) Let lane_2* be $lanes_(lanetype X M, v128_2).
    3) Let lane_3* be [].
    4) For each lane_1 in lane_1* and lane_2 in lane_2*, do:
      a) Let lane_3 be $extend__(1, $lsizenn(lanetype), S, $ieq_($lsizenn(lanetype), lane_1, lane_2)).
      b) Append lane_3 to the lane_3*.
    5) Let v128 be $inv_lanes_(lanetype X M, lane_3*).
    6) Return v128.
  b. If (vrelop_ = NE), then:
    1) Let lane_1* be $lanes_(lanetype X M, v128_1).
    2) Let lane_2* be $lanes_(lanetype X M, v128_2).
    3) Let lane_3* be [].
    4) For each lane_1 in lane_1* and lane_2 in lane_2*, do:
      a) Let lane_3 be $extend__(1, $lsizenn(lanetype), S, $ine_($lsizenn(lanetype), lane_1, lane_2)).
      b) Append lane_3 to the lane_3*.
    5) Let v128 be $inv_lanes_(lanetype X M, lane_3*).
    6) Return v128.
  c. If vrelop_ is some LT, then:
    1) Let (LT sx) be vrelop_.
    2) Let lane_1* be $lanes_(lanetype X M, v128_1).
    3) Let lane_2* be $lanes_(lanetype X M, v128_2).
    4) Let lane_3* be [].
    5) For each lane_1 in lane_1* and lane_2 in lane_2*, do:
      a) Let lane_3 be $extend__(1, $lsizenn(lanetype), S, $ilt_($lsizenn(lanetype), sx, lane_1, lane_2)).
      b) Append lane_3 to the lane_3*.
    6) Let v128 be $inv_lanes_(lanetype X M, lane_3*).
    7) Return v128.
  d. If vrelop_ is some GT, then:
    1) Let (GT sx) be vrelop_.
    2) Let lane_1* be $lanes_(lanetype X M, v128_1).
    3) Let lane_2* be $lanes_(lanetype X M, v128_2).
    4) Let lane_3* be [].
    5) For each lane_1 in lane_1* and lane_2 in lane_2*, do:
      a) Let lane_3 be $extend__(1, $lsizenn(lanetype), S, $igt_($lsizenn(lanetype), sx, lane_1, lane_2)).
      b) Append lane_3 to the lane_3*.
    6) Let v128 be $inv_lanes_(lanetype X M, lane_3*).
    7) Return v128.
  e. If vrelop_ is some LE, then:
    1) Let (LE sx) be vrelop_.
    2) Let lane_1* be $lanes_(lanetype X M, v128_1).
    3) Let lane_2* be $lanes_(lanetype X M, v128_2).
    4) Let lane_3* be [].
    5) For each lane_1 in lane_1* and lane_2 in lane_2*, do:
      a) Let lane_3 be $extend__(1, $lsizenn(lanetype), S, $ile_($lsizenn(lanetype), sx, lane_1, lane_2)).
      b) Append lane_3 to the lane_3*.
    6) Let v128 be $inv_lanes_(lanetype X M, lane_3*).
    7) Return v128.
  f. If vrelop_ is some GE, then:
    1) Let (GE sx) be vrelop_.
    2) Let lane_1* be $lanes_(lanetype X M, v128_1).
    3) Let lane_2* be $lanes_(lanetype X M, v128_2).
    4) Let lane_3* be [].
    5) For each lane_1 in lane_1* and lane_2 in lane_2*, do:
      a) Let lane_3 be $extend__(1, $lsizenn(lanetype), S, $ige_($lsizenn(lanetype), sx, lane_1, lane_2)).
      b) Append lane_3 to the lane_3*.
    6) Let v128 be $inv_lanes_(lanetype X M, lane_3*).
    7) Return v128.
2. Assert: Due to validation, lanetype is Fnn.
3. If (vrelop_ = EQ), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let Inn be $isize^-1($size(lanetype)).
  d. Let lane_3* be [].
  e. For each lane_1 in lane_1* and lane_2 in lane_2*, do:
    1) Let lane_3 be $extend__(1, $sizenn(lanetype), S, $feq_($sizenn(lanetype), lane_1, lane_2)).
    2) Append lane_3 to the lane_3*.
  f. Let v128 be $inv_lanes_(Inn X M, lane_3*).
  g. Return v128.
4. If (vrelop_ = NE), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let Inn be $isize^-1($size(lanetype)).
  d. Let lane_3* be [].
  e. For each lane_1 in lane_1* and lane_2 in lane_2*, do:
    1) Let lane_3 be $extend__(1, $sizenn(lanetype), S, $fne_($sizenn(lanetype), lane_1, lane_2)).
    2) Append lane_3 to the lane_3*.
  f. Let v128 be $inv_lanes_(Inn X M, lane_3*).
  g. Return v128.
5. If (vrelop_ = LT), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let Inn be $isize^-1($size(lanetype)).
  d. Let lane_3* be [].
  e. For each lane_1 in lane_1* and lane_2 in lane_2*, do:
    1) Let lane_3 be $extend__(1, $sizenn(lanetype), S, $flt_($sizenn(lanetype), lane_1, lane_2)).
    2) Append lane_3 to the lane_3*.
  f. Let v128 be $inv_lanes_(Inn X M, lane_3*).
  g. Return v128.
6. If (vrelop_ = GT), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let Inn be $isize^-1($size(lanetype)).
  d. Let lane_3* be [].
  e. For each lane_1 in lane_1* and lane_2 in lane_2*, do:
    1) Let lane_3 be $extend__(1, $sizenn(lanetype), S, $fgt_($sizenn(lanetype), lane_1, lane_2)).
    2) Append lane_3 to the lane_3*.
  f. Let v128 be $inv_lanes_(Inn X M, lane_3*).
  g. Return v128.
7. If (vrelop_ = LE), then:
  a. Let lane_1* be $lanes_(lanetype X M, v128_1).
  b. Let lane_2* be $lanes_(lanetype X M, v128_2).
  c. Let Inn be $isize^-1($size(lanetype)).
  d. Let lane_3* be [].
  e. For each lane_1 in lane_1* and lane_2 in lane_2*, do:
    1) Let lane_3 be $extend__(1, $sizenn(lanetype), S, $fle_($sizenn(lanetype), lane_1, lane_2)).
    2) Append lane_3 to the lane_3*.
  f. Let v128 be $inv_lanes_(Inn X M, lane_3*).
  g. Return v128.
8. Assert: Due to validation, (vrelop_ = GE).
9. Let lane_1* be $lanes_(lanetype X M, v128_1).
10. Let lane_2* be $lanes_(lanetype X M, v128_2).
11. Let Inn be $isize^-1($size(lanetype)).
12. Let lane_3* be [].
13. For each lane_1 in lane_1* and lane_2 in lane_2*, do:
  a. Let lane_3 be $extend__(1, $sizenn(lanetype), S, $fge_($sizenn(lanetype), lane_1, lane_2)).
  b. Append lane_3 to the lane_3*.
14. Let v128 be $inv_lanes_(Inn X M, lane_3*).
15. Return v128.

vcvtop__ lanetype' X M_1 lanetype X M_2 vcvtop iN_1
1. If lanetype' is Jnn, then:
  a. If (lanetype is Jnn /\ vcvtop is some EXTEND), then:
    1) Let (EXTEND half sx) be vcvtop.
    2) Let iN_2 be $extend__($lsizenn1(lanetype'), $lsizenn2(lanetype), sx, iN_1).
    3) Return [iN_2].
  b. If (lanetype is Fnn /\ vcvtop is some CONVERT), then:
    1) Let (CONVERT half? sx) be vcvtop.
    2) Let fN_2 be $convert__($lsizenn1(lanetype'), $lsizenn2(lanetype), sx, iN_1).
    3) Return [fN_2].
2. Assert: Due to validation, lanetype' is Fnn.
3. If (lanetype is Inn /\ vcvtop is some TRUNC_SAT), then:
  a. Let (TRUNC_SAT sx zero?) be vcvtop.
  b. Let iN_2? be $trunc_sat__($lsizenn1(lanetype'), $lsizenn2(lanetype), sx, iN_1).
  c. Return $list_(`lane_((Inn_2 : Inn <: lanetype)), iN_2?).
4. Assert: Due to validation, lanetype is Fnn.
5. If (vcvtop = (DEMOTE ZERO)), then:
  a. Let fN_2* be $demote__($lsizenn1(lanetype'), $lsizenn2(lanetype), iN_1).
  b. Return fN_2*.
6. Assert: Due to validation, (vcvtop = PROMOTELOW).
7. Let fN_2* be $promote__($lsizenn1(lanetype'), $lsizenn2(lanetype), iN_1).
8. Return fN_2*.

vextunop__ Inn_1 X M_1 Inn_2 X M_2 (EXTADD_PAIRWISE sx) c_1
1. Let ci* be $lanes_(Inn_2 X M_2, c_1).
2. Let [cj_1, cj_2]* be $concat__1^-1(`iN($lsizenn1((Inn_1 : Inn <: lanetype))), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), sx, ci)*).
3. Let c be $inv_lanes_(Inn_1 X M_1, $iadd_($lsizenn1(Inn_1), cj_1, cj_2)*).
4. Return c.

vextbinop__ Inn_1 X M_1 Inn_2 X M_2 vextbinop_ c_1 c_2
1. If vextbinop_ is some EXTMUL, then:
  a. Let (EXTMUL half sx) be vextbinop_.
  b. Let ci_1* be $lanes_(Inn_2 X M_2, c_1)[$half(half, 0, M_1) : M_1].
  c. Let ci_2* be $lanes_(Inn_2 X M_2, c_2)[$half(half, 0, M_1) : M_1].
  d. Let c be $inv_lanes_(Inn_1 X M_1, $imul_($lsizenn1(Inn_1), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), sx, ci_1), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), sx, ci_2))*).
  e. Return c.
2. Assert: Due to validation, (vextbinop_ = DOTS).
3. Let ci_1* be $lanes_(Inn_2 X M_2, c_1).
4. Let ci_2* be $lanes_(Inn_2 X M_2, c_2).
5. Let [cj_1, cj_2]* be $concat__1^-1(`iN($lsizenn1((Inn_1 : Inn <: lanetype))), $imul_($lsizenn1(Inn_1), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), S, ci_1), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), S, ci_2))*).
6. Let c be $inv_lanes_(Inn_1 X M_1, $iadd_($lsizenn1(Inn_1), cj_1, cj_2)*).
7. Return c.

vshiftop_ Jnn X M vshiftop_ lane n
1. If (vshiftop_ = SHL), then:
  a. Return $ishl_($lsizenn(Jnn), lane, n).
2. Assert: Due to validation, vshiftop_ is some SHR.
3. Let (SHR sx) be vshiftop_.
4. Return $ishr_($lsizenn(Jnn), sx, lane, n).

default_ valtype
1. If (valtype = I32), then:
  a. Return (I32.CONST 0).
2. If (valtype = I64), then:
  a. Return (I64.CONST 0).
3. If (valtype = F32), then:
  a. Return (F32.CONST $fzero(32)).
4. If (valtype = F64), then:
  a. Return (F64.CONST $fzero(64)).
5. If (valtype = V128), then:
  a. Return (V128.CONST 0).
6. If (valtype = FUNCREF), then:
  a. Return (REF.NULL FUNCREF).
7. Assert: Due to validation, (valtype = EXTERNREF).
8. Return (REF.NULL EXTERNREF).

funcsxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr'*.
3. If externaddr_0 is some FUNC, then:
  a. Let (FUNC fa) be externaddr_0.
  b. Return [fa] :: $funcsxa(xv*).
4. Let [externaddr] :: xv* be externaddr'*.
5. Return $funcsxa(xv*).

globalsxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr'*.
3. If externaddr_0 is some GLOBAL, then:
  a. Let (GLOBAL ga) be externaddr_0.
  b. Return [ga] :: $globalsxa(xv*).
4. Let [externaddr] :: xv* be externaddr'*.
5. Return $globalsxa(xv*).

tablesxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr'*.
3. If externaddr_0 is some TABLE, then:
  a. Let (TABLE ta) be externaddr_0.
  b. Return [ta] :: $tablesxa(xv*).
4. Let [externaddr] :: xv* be externaddr'*.
5. Return $tablesxa(xv*).

memsxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr'*.
3. If externaddr_0 is some MEM, then:
  a. Let (MEM ma) be externaddr_0.
  b. Return [ma] :: $memsxa(xv*).
4. Let [externaddr] :: xv* be externaddr'*.
5. Return $memsxa(xv*).

store (s, f)
1. Return.

frame (s, f)
1. Return f.

funcaddr (s, f)
1. Return f.MODULE.FUNCS.

funcinst (s, f)
1. Return s.FUNCS.

globalinst (s, f)
1. Return s.GLOBALS.

tableinst (s, f)
1. Return s.TABLES.

meminst (s, f)
1. Return s.MEMS.

eleminst (s, f)
1. Return s.ELEMS.

datainst (s, f)
1. Return s.DATAS.

moduleinst (s, f)
1. Return f.MODULE.

type (s, f) x
1. Return f.MODULE.TYPES[x].

func (s, f) x
1. Return s.FUNCS[f.MODULE.FUNCS[x]].

global (s, f) x
1. Return s.GLOBALS[f.MODULE.GLOBALS[x]].

table (s, f) x
1. Return s.TABLES[f.MODULE.TABLES[x]].

mem (s, f) x
1. Return s.MEMS[f.MODULE.MEMS[x]].

elem (s, f) x
1. Return s.ELEMS[f.MODULE.ELEMS[x]].

data (s, f) x
1. Return s.DATAS[f.MODULE.DATAS[x]].

local (s, f) x
1. Return f.LOCALS[x].

with_local (s, f) x v
1. Replace f.LOCALS[x] with v.

with_global (s, f) x v
1. Replace s.GLOBALS[f.MODULE.GLOBALS[x]].VALUE with v.

with_table (s, f) x i r
1. Replace s.TABLES[f.MODULE.TABLES[x]].REFS[i] with r.

with_tableinst (s, f) x ti
1. Replace s.TABLES[f.MODULE.TABLES[x]] with ti.

with_mem (s, f) x i j b*
1. Replace s.MEMS[f.MODULE.MEMS[x]].BYTES[i : j] with b*.

with_meminst (s, f) x mi
1. Replace s.MEMS[f.MODULE.MEMS[x]] with mi.

with_elem (s, f) x r*
1. Replace s.ELEMS[f.MODULE.ELEMS[x]].REFS with r*.

with_data (s, f) x b*
1. Replace s.DATAS[f.MODULE.DATAS[x]].BYTES with b*.

growtable ti n r
1. Let { TYPE: (([ i .. j? ]) rt); REFS: r'* } be ti.
2. Let i' be (|r'*| + n).
3. If (i' <= j)?, then:
  a. Let ti' be { TYPE: (([ i' .. j? ]) rt); REFS: r'* :: r^n }.
  b. Return ti'.
4. Fail.

growmemory mi n
1. Let { TYPE: ([ i .. j? ]) PAGE; BYTES: b* } be mi.
2. Let i' be ((|b*| / (64 * $Ki())) + n).
3. If (i' <= j)?, then:
  a. Let mi' be { TYPE: ([ i' .. j? ]) PAGE; BYTES: b* :: 0^(n * (64 * $Ki())) }.
  b. Return mi'.
4. Fail.

blocktype z blocktype
1. If (blocktype = (_RESULT ?())), then:
  a. Return [] -> [].
2. If blocktype is some _RESULT, then:
  a. Let (_RESULT valtype_0?) be blocktype.
  b. If valtype_0? is defined, then:
    1) Let ?(t) be valtype_0?.
    2) Return [] -> [t].
3. Assert: Due to validation, blocktype is some _IDX.
4. Let (_IDX x) be blocktype.
5. Return $type(z, x).

funcs externaddr''*
1. If (externaddr''* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr''*.
3. If externaddr_0 is some FUNC, then:
  a. Let (FUNC fa) be externaddr_0.
  b. Return [fa] :: $funcs(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr''*.
5. Return $funcs(externaddr'*).

globals externaddr''*
1. If (externaddr''* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr''*.
3. If externaddr_0 is some GLOBAL, then:
  a. Let (GLOBAL ga) be externaddr_0.
  b. Return [ga] :: $globals(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr''*.
5. Return $globals(externaddr'*).

tables externaddr''*
1. If (externaddr''* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr''*.
3. If externaddr_0 is some TABLE, then:
  a. Let (TABLE ta) be externaddr_0.
  b. Return [ta] :: $tables(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr''*.
5. Return $tables(externaddr'*).

mems externaddr''*
1. If (externaddr''* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr''*.
3. If externaddr_0 is some MEM, then:
  a. Let (MEM ma) be externaddr_0.
  b. Return [ma] :: $mems(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr''*.
5. Return $mems(externaddr'*).

allocfunc s moduleinst func
1. Let (FUNC x local* expr) be func.
2. Let fi be { TYPE: moduleinst.TYPES[x]; MODULE: moduleinst; CODE: func }.
3. Let a be |s.FUNCS|.
4. Append fi to the s.FUNCS.
5. Return a.

allocfuncs s moduleinst func''*
1. If (func''* = []), then:
  a. Return [].
2. Let [func] :: func'* be func''*.
3. Let fa be $allocfunc(s, moduleinst, func).
4. Let fa'* be $allocfuncs(s, moduleinst, func'*).
5. Return [fa] :: fa'*.

allocglobal s globaltype val
1. Let gi be { TYPE: globaltype; VALUE: val }.
2. Let a be |s.GLOBALS|.
3. Append gi to the s.GLOBALS.
4. Return a.

allocglobals s globaltype''* val''*
1. If (globaltype''* = []), then:
  a. Assert: Due to validation, (val''* = []).
  b. Return [].
2. Else:
  a. Let [globaltype] :: globaltype'* be globaltype''*.
  b. Assert: Due to validation, (|val''*| >= 1).
  c. Let [val] :: val'* be val''*.
  d. Let ga be $allocglobal(s, globaltype, val).
  e. Let ga'* be $allocglobals(s, globaltype'*, val'*).
  f. Return [ga] :: ga'*.

alloctable s (([ i .. j? ]) rt)
1. Let ti be { TYPE: (([ i .. j? ]) rt); REFS: (REF.NULL rt)^i }.
2. Let a be |s.TABLES|.
3. Append ti to the s.TABLES.
4. Return a.

alloctables s tabletype''*
1. If (tabletype''* = []), then:
  a. Return [].
2. Let [tabletype] :: tabletype'* be tabletype''*.
3. Let ta be $alloctable(s, tabletype).
4. Let ta'* be $alloctables(s, tabletype'*).
5. Return [ta] :: ta'*.

allocmem s ([ i .. j? ]) PAGE
1. Let mi be { TYPE: ([ i .. j? ]) PAGE; BYTES: 0^(i * (64 * $Ki())) }.
2. Let a be |s.MEMS|.
3. Append mi to the s.MEMS.
4. Return a.

allocmems s memtype''*
1. If (memtype''* = []), then:
  a. Return [].
2. Let [memtype] :: memtype'* be memtype''*.
3. Let ma be $allocmem(s, memtype).
4. Let ma'* be $allocmems(s, memtype'*).
5. Return [ma] :: ma'*.

allocelem s rt ref*
1. Let ei be { TYPE: rt; REFS: ref* }.
2. Let a be |s.ELEMS|.
3. Append ei to the s.ELEMS.
4. Return a.

allocelems s reftype* ref''*
1. If (ref''* = []), then:
  a. Assert: Due to validation, (reftype* = []).
  b. Return [].
2. Else:
  a. Let [ref*] :: ref'** be ref''*.
  b. Assert: Due to validation, (|reftype*| >= 1).
  c. Let [rt] :: rt'* be reftype*.
  d. Let ea be $allocelem(s, rt, ref*).
  e. Let ea'* be $allocelems(s, rt'*, ref'**).
  f. Return [ea] :: ea'*.

allocdata s byte*
1. Let di be { BYTES: byte* }.
2. Let a be |s.DATAS|.
3. Append di to the s.DATAS.
4. Return a.

allocdatas s byte''*
1. If (byte''* = []), then:
  a. Return [].
2. Let [byte*] :: byte'** be byte''*.
3. Let da be $allocdata(s, byte*).
4. Let da'* be $allocdatas(s, byte'**).
5. Return [da] :: da'*.

instexport fa* ga* ta* ma* (EXPORT name externidx)
1. If externidx is some FUNC, then:
  a. Let (FUNC x) be externidx.
  b. Return { NAME: name; ADDR: (FUNC fa*[x]) }.
2. If externidx is some GLOBAL, then:
  a. Let (GLOBAL x) be externidx.
  b. Return { NAME: name; ADDR: (GLOBAL ga*[x]) }.
3. If externidx is some TABLE, then:
  a. Let (TABLE x) be externidx.
  b. Return { NAME: name; ADDR: (TABLE ta*[x]) }.
4. Assert: Due to validation, externidx is some MEM.
5. Let (MEM x) be externidx.
6. Return { NAME: name; ADDR: (MEM ma*[x]) }.

allocmodule s module externaddr* val* ref**
1. Let (MODULE type_0* import* func^n_func global_1* table_2* mem_3* elem_4* data_5* start? export*) be module.
2. Let (DATA byte* datamode)^n_data be data_5*.
3. Let (ELEM rt expr_2* elemmode)^n_elem be elem_4*.
4. Let (MEMORY memtype)^n_mem be mem_3*.
5. Let (TABLE tabletype)^n_table be table_2*.
6. Let (GLOBAL globaltype expr_1)^n_global be global_1*.
7. Let ft* be [].
8. For each type_0 in type_0*, do:
  a. Let (TYPE ft) be type_0.
  b. Append ft to the ft*.
9. Let fa_ex* be $funcs(externaddr*).
10. Let ga_ex* be $globals(externaddr*).
11. Let ma_ex* be $mems(externaddr*).
12. Let ta_ex* be $tables(externaddr*).
13. Let fa* be (|s.FUNCS| + i_func)^(i_func<n_func).
14. Let ga* be (|s.GLOBALS| + i_global)^(i_global<n_global).
15. Let ta* be (|s.TABLES| + i_table)^(i_table<n_table).
16. Let ma* be (|s.MEMS| + i_mem)^(i_mem<n_mem).
17. Let ea* be (|s.ELEMS| + i_elem)^(i_elem<n_elem).
18. Let da* be (|s.DATAS| + i_data)^(i_data<n_data).
19. Let xi* be [].
20. For each export in export*, do:
  a. Let xi be $instexport(fa_ex* :: fa*, ga_ex* :: ga*, ta_ex* :: ta*, ma_ex* :: ma*, export).
  b. Append xi to the xi*.
21. Let moduleinst be { TYPES: ft*; FUNCS: fa_ex* :: fa*; GLOBALS: ga_ex* :: ga*; TABLES: ta_ex* :: ta*; MEMS: ma_ex* :: ma*; ELEMS: ea*; DATAS: da*; EXPORTS: xi* }.
22. Let funcaddr_0* be $allocfuncs(s, moduleinst, func^n_func).
23. Assert: Due to validation, (funcaddr_0* = fa*).
24. Let globaladdr_0* be $allocglobals(s, globaltype^n_global, val*).
25. Assert: Due to validation, (globaladdr_0* = ga*).
26. Let tableaddr_0* be $alloctables(s, tabletype^n_table).
27. Assert: Due to validation, (tableaddr_0* = ta*).
28. Let memaddr_0* be $allocmems(s, memtype^n_mem).
29. Assert: Due to validation, (memaddr_0* = ma*).
30. Let elemaddr_0* be $allocelems(s, rt^n_elem, ref**).
31. Assert: Due to validation, (elemaddr_0* = ea*).
32. Let dataaddr_0* be $allocdatas(s, byte*^n_data).
33. Assert: Due to validation, (dataaddr_0* = da*).
34. Return moduleinst.

runelem (ELEM reftype expr* elemmode) i
1. If (elemmode = PASSIVE), then:
  a. Return [].
2. If (elemmode = DECLARE), then:
  a. Return [(ELEM.DROP i)].
3. Assert: Due to validation, elemmode is some ACTIVE.
4. Let (ACTIVE x instr*) be elemmode.
5. Let n be |expr*|.
6. Return instr* :: [(I32.CONST 0), (I32.CONST n), (TABLE.INIT x i), (ELEM.DROP i)].

rundata (DATA byte* datamode) i
1. If (datamode = PASSIVE), then:
  a. Return [].
2. Assert: Due to validation, datamode is some ACTIVE.
3. Let (ACTIVE memidx_0 instr*) be datamode.
4. Assert: Due to validation, (memidx_0 = 0).
5. Let n be |byte*|.
6. Return instr* :: [(I32.CONST 0), (I32.CONST n), (MEMORY.INIT i), (DATA.DROP i)].

instantiate s module externaddr*
1. Let (MODULE type* import* func* global* table* mem* elem* data* start? export*) be module.
2. Let functype* be [].
3. For each type in type*, do:
  a. Let (TYPE functype) be type.
  b. Append functype to the functype*.
4. Let n_D be |data*|.
5. Let n_E be |elem*|.
6. Let n_F be |func*|.
7. Let expr_G* be [].
8. For each global in global*, do:
  a. Let (GLOBAL globaltype expr_G) be global.
  b. Append expr_G to the expr_G*.
9. Let expr_E** be [].
10. For each elem in elem*, do:
  a. Let (ELEM reftype expr_E* elemmode) be elem.
  b. Append expr_E* to the expr_E**.
11. Let instr_D* be $concat_(`instr, $rundata(data*[j], j)^(j<n_D)).
12. Let instr_E* be $concat_(`instr, $runelem(elem*[i], i)^(i<n_E)).
13. Let moduleinst_init be { TYPES: functype*; FUNCS: $funcs(externaddr*) :: (|s.FUNCS| + i_F)^(i_F<n_F); GLOBALS: $globals(externaddr*) }.
14. Let f_init be { MODULE: moduleinst_init }.
15. Let z be (s, f_init).
16. Push the frame (FRAME_ 0 { $frame(z) }) to the stack.
17. Let val* be [].
18. For each expr_G in expr_G*, do:
  a. Let [val] be $Eval_expr(z, expr_G).
  b. Append val to the val*.
19. Let ref** be [].
20. For each expr_E* in expr_E**, do:
  a. Let ref* be [].
  b. For each expr_E in expr_E*, do:
    1) Let [ref] be $Eval_expr(z, expr_E).
    2) Append ref to the ref*.
  c. Append ref* to the ref**.
21. Pop the frame (FRAME_ 0 { $frame(z) }) from the stack.
22. Let moduleinst be $allocmodule(s, module, externaddr*, val*, ref**).
23. Let f be { MODULE: moduleinst }.
24. Push the frame (FRAME_ 0 { f }) to the stack.
25. Execute the sequence instr_E*.
26. Execute the sequence instr_D*.
27. If start? is defined, then:
  a. Let ?((START x)) be start?.
  b. Let instr_0 be (CALL x).
  c. Execute the instruction instr_0.
28. Pop the frame (FRAME_ 0 { f }) from the stack.
29. Return f.MODULE.

invoke s fa val^n
1. Let f be { MODULE: {} }.
2. Push the frame (FRAME_ 0 { (s, f) }) to the stack.
3. Let t_1^n -> t_2* be $funcinst((s, f))[fa].TYPE.
4. Pop the frame (FRAME_ 0 { _f }) from the stack.
5. Let k be |t_2*|.
6. Push the frame (FRAME_ k { f }) to the stack.
7. Push the values val^n to the stack.
8. Execute the instruction (CALL_ADDR fa).
9. Pop the values val'^k from the stack.
10. Pop the frame (FRAME_ k { f }) from the stack.
11. Return val'^k.

Eval_expr instr*
1. Execute the sequence instr*.
2. Pop the value val from the stack.
3. Return [val].

== Complete.
Generating prose for Wasm 3.0...
spectec 0.5 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...
Untranslated relation Expand: `%~~%`(deftype, comptype)
Untranslated relation Expand_use: `%~~_%%`(typeuse, context, comptype)



The number type :math:`{\mathit{numtype}}` is always :ref:`valid <valid-val>`.




The vector type :math:`{\mathit{vectype}}` is always :ref:`valid <valid-val>`.




The packed type :math:`{\mathit{packtype}}` is always :ref:`valid <valid-val>`.




The packed type :math:`{\mathit{packtype}}` :ref:`matches <match>` only itself.




The number type :math:`{\mathit{numtype}}` :ref:`matches <match>` only itself.




The vector type :math:`{\mathit{vectype}}` :ref:`matches <match>` only itself.




The heap type :math:`{\mathit{heaptype}}` is :ref:`valid <valid-val>` if:


   * Either:

      * The heap type :math:`{\mathit{heaptype}}` is of the form :math:`{\mathit{absheaptype}}`.

   * Or:

      * The heap type :math:`{\mathit{heaptype}}` is of the form :math:`{\mathit{typeuse}}`.

      * The type use :math:`{\mathit{typeuse}}` is :ref:`valid <valid-val>`.




The heap type :math:`{\mathit{absheaptype}}` is always :ref:`valid <valid-val>`.




The heap type :math:`{\mathit{typeuse}}` is :ref:`valid <valid-val>` if:


   * The type use :math:`{\mathit{typeuse}}` is :ref:`valid <valid-val>`.




The reference type :math:`(\mathsf{ref}~{\mathsf{null}^?}~{\mathit{heaptype}})` is :ref:`valid <valid-val>` if:


   * The heap type :math:`{\mathit{heaptype}}` is :ref:`valid <valid-val>`.




The value type :math:`{\mathit{valtype}}` is :ref:`valid <valid-val>` if:


   * Either:

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathit{numtype}}`.

      * The number type :math:`{\mathit{numtype}}` is :ref:`valid <valid-val>`.

   * Or:

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathit{vectype}}`.

      * The vector type :math:`{\mathit{vectype}}` is :ref:`valid <valid-val>`.
   * Or:

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathit{reftype}}`.

      * The reference type :math:`{\mathit{reftype}}` is :ref:`valid <valid-val>`.
   * Or:

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`\mathsf{bot}`.




The value type :math:`{\mathit{numtype}}` is :ref:`valid <valid-val>` if:


   * The number type :math:`{\mathit{numtype}}` is :ref:`valid <valid-val>`.




The value type :math:`{\mathit{vectype}}` is :ref:`valid <valid-val>` if:


   * The vector type :math:`{\mathit{vectype}}` is :ref:`valid <valid-val>`.




The value type :math:`{\mathit{reftype}}` is :ref:`valid <valid-val>` if:


   * The reference type :math:`{\mathit{reftype}}` is :ref:`valid <valid-val>`.




The value type :math:`\mathsf{bot}` is always :ref:`valid <valid-val>`.




The type use :math:`{\mathit{typeuse}}` is :ref:`valid <valid-val>` if:


   * Either:

      * The type use :math:`{\mathit{typeuse}}` is of the form :math:`{\mathit{typeidx}}`.

      * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

   * Or:

      * The type use :math:`{\mathit{typeuse}}` is of the form :math:`(\mathsf{rec}~{.}~{.})`.

      * The recursive type :math:`C{.}\mathsf{recs}{}[i]` exists.
   * Or:

      * The type use :math:`{\mathit{typeuse}}` is of the form :math:`{\mathit{deftype}}`.

      * The defined type :math:`{\mathit{deftype}}` is :ref:`valid <valid-val>`.




The type use :math:`{\mathit{typeidx}}` is :ref:`valid <valid-val>` if:


   * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.




The type use :math:`(\mathsf{rec}~{.}~{.})` is :ref:`valid <valid-val>` if:


   * The recursive type :math:`C{.}\mathsf{recs}{}[i]` exists.




The type use :math:`{\mathit{deftype}}` is :ref:`valid <valid-val>` if:


   * The defined type :math:`{\mathit{deftype}}` is :ref:`valid <valid-val>`.




The result type :math:`{t^\ast}` is :ref:`valid <valid-val>` if:


   * For all :math:`t` in :math:`{t^\ast}`:

      * The value type :math:`t` is :ref:`valid <valid-val>`.




The field type :math:`({\mathsf{mut}^?}~{\mathit{storagetype}})` is :ref:`valid <valid-val>` if:


   * The storage type :math:`{\mathit{storagetype}}` is :ref:`valid <valid-val>`.




The storage type :math:`{\mathit{storagetype}}` is :ref:`valid <valid-val>` if:


   * Either:

      * The storage type :math:`{\mathit{storagetype}}` is of the form :math:`{\mathit{valtype}}`.

      * The value type :math:`{\mathit{valtype}}` is :ref:`valid <valid-val>`.

   * Or:

      * The storage type :math:`{\mathit{storagetype}}` is of the form :math:`{\mathit{packtype}}`.

      * The packed type :math:`{\mathit{packtype}}` is :ref:`valid <valid-val>`.




The storage type :math:`{\mathit{valtype}}` is :ref:`valid <valid-val>` if:


   * The value type :math:`{\mathit{valtype}}` is :ref:`valid <valid-val>`.




The storage type :math:`{\mathit{packtype}}` is :ref:`valid <valid-val>` if:


   * The packed type :math:`{\mathit{packtype}}` is :ref:`valid <valid-val>`.




The composite type :math:`{\mathit{comptype}}` is :ref:`valid <valid-val>` if:


   * Either:

      * The composite type :math:`{\mathit{comptype}}` is of the form :math:`(\mathsf{struct}~{{\mathit{fieldtype}}^\ast})`.

      * For all :math:`{\mathit{fieldtype}}` in :math:`{{\mathit{fieldtype}}^\ast}`:

         * The field type :math:`{\mathit{fieldtype}}` is :ref:`valid <valid-val>`.

   * Or:

      * The composite type :math:`{\mathit{comptype}}` is of the form :math:`(\mathsf{array}~{\mathit{fieldtype}})`.

      * The field type :math:`{\mathit{fieldtype}}` is :ref:`valid <valid-val>`.
   * Or:

      * The composite type :math:`{\mathit{comptype}}` is of the form :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.

      * The result type :math:`{t_1^\ast}` is :ref:`valid <valid-val>`.

      * The result type :math:`{t_2^\ast}` is :ref:`valid <valid-val>`.




The composite type :math:`(\mathsf{struct}~{{\mathit{fieldtype}}^\ast})` is :ref:`valid <valid-val>` if:


   * For all :math:`{\mathit{fieldtype}}` in :math:`{{\mathit{fieldtype}}^\ast}`:

      * The field type :math:`{\mathit{fieldtype}}` is :ref:`valid <valid-val>`.




The composite type :math:`(\mathsf{array}~{\mathit{fieldtype}})` is :ref:`valid <valid-val>` if:


   * The field type :math:`{\mathit{fieldtype}}` is :ref:`valid <valid-val>`.




The composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})` is :ref:`valid <valid-val>` if:


   * The result type :math:`{t_1^\ast}` is :ref:`valid <valid-val>`.

   * The result type :math:`{t_2^\ast}` is :ref:`valid <valid-val>`.




The sub type :math:`(\mathsf{sub}~{\mathsf{final}^?}~{x^\ast}~{\mathit{comptype}})` is :ref:`valid <valid-val>` for the type index :math:`x_0` if:


   * The length of :math:`{x^\ast}` is less than or equal to :math:`1`.

   * For all :math:`x` in :math:`{x^\ast}`:

      * The index :math:`x` is less than :math:`x_0`.

      * The type :math:`C{.}\mathsf{types}{}[x]` exists.

      * The sub type :math:`{\mathrm{unroll}}(C{.}\mathsf{types}{}[x])` is of the form :math:`(\mathsf{sub}~{{x'}^\ast}~{\mathit{comptype}'})`.

   * :math:`{{\mathit{comptype}'}^\ast}` is the concatenation of all such :math:`{\mathit{comptype}'}`.

   * The composite type :math:`{\mathit{comptype}}` is :ref:`valid <valid-val>`.

   * For all :math:`{\mathit{comptype}'}` in :math:`{{\mathit{comptype}'}^\ast}`:

      * The composite type :math:`{\mathit{comptype}}` :ref:`matches <match>` the composite type :math:`{\mathit{comptype}'}`.




The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is :ref:`valid <valid-val>` for the type index :math:`x` if:


   * Either:

      * The sub type sequence :math:`{{\mathit{subtype}}^\ast}` is empty.

   * Or:

      * The sub type sequence :math:`{{\mathit{subtype}}^\ast}` is of the form :math:`{\mathit{subtype}}_1~{{\mathit{subtype}'}^\ast}`.

      * The sub type :math:`{\mathit{subtype}}_1` is :ref:`valid <valid-val>` for the type index :math:`x`.

      * The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}'}^\ast})` is :ref:`valid <valid-val>` for the type index :math:`x + 1`.




The recursive type :math:`(\mathsf{rec})` is :ref:`valid <valid-val>` for the type index :math:`x`.




The recursive type :math:`(\mathsf{rec}~{\mathit{subtype}}_1~{{\mathit{subtype}}^\ast})` is :ref:`valid <valid-val>` for the type index :math:`x` if:


   * The sub type :math:`{\mathit{subtype}}_1` is :ref:`valid <valid-val>` for the type index :math:`x`.

   * The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is :ref:`valid <valid-val>` for the type index :math:`x + 1`.




The sub type :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{compttype}})` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x, i)})` if:


   * The length of :math:`{{\mathit{typeuse}}^\ast}` is less than or equal to :math:`1`.

   * For all :math:`{\mathit{typeuse}}` in :math:`{{\mathit{typeuse}}^\ast}`:

      * :math:`{\mathit{typeuse}} \prec x, i` is true.

      * The sub type :math:`{{\mathrm{unroll}}}_{C}({\mathit{typeuse}})` is of the form :math:`(\mathsf{sub}~{{\mathit{typeuse}'}^\ast}~{\mathit{comptype}'})`.

   * :math:`{{\mathit{comptype}'}^\ast}` is the concatenation of all such :math:`{\mathit{comptype}'}`.

   * The composite type :math:`{\mathit{comptype}}` is :ref:`valid <valid-val>`.

   * For all :math:`{\mathit{comptype}'}` in :math:`{{\mathit{comptype}'}^\ast}`:

      * The composite type :math:`{\mathit{comptype}}` :ref:`matches <match>` the composite type :math:`{\mathit{comptype}'}`.




The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x, i)})` if:


   * Either:

      * The sub type sequence :math:`{{\mathit{subtype}}^\ast}` is empty.

   * Or:

      * The sub type sequence :math:`{{\mathit{subtype}}^\ast}` is of the form :math:`{\mathit{subtype}}_1~{{\mathit{subtype}'}^\ast}`.

      * The sub type :math:`{\mathit{subtype}}_1` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x, i)})`.

      * The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}'}^\ast})` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x + 1, i + 1)})`.




The recursive type :math:`(\mathsf{rec})` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x, i)})`.




The recursive type :math:`(\mathsf{rec}~{\mathit{subtype}}_1~{{\mathit{subtype}}^\ast})` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x, i)})` if:


   * The sub type :math:`{\mathit{subtype}}_1` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x, i)})`.

   * The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is :ref:`valid <valid-val>` for :math:`({\mathsf{ok}}{(x + 1, i + 1)})`.




The defined type :math:`({\mathit{rectype}}~{.}~i)` is :ref:`valid <valid-val>` if:


   * The recursive type :math:`{\mathit{rectype}}` is :ref:`valid <valid-val>` for the type index :math:`x`.

   * The recursive type :math:`{\mathit{rectype}}` is of the form :math:`(\mathsf{rec}~{{\mathit{subtype}}^{n}})`.

   * :math:`i` is less than :math:`n`.




The composite type :math:`{\mathit{comptype}}_1` :ref:`matches <match>` the composite type :math:`{\mathit{comptype}}_2` if:


   * Either:

      * The composite type :math:`{\mathit{comptype}}_1` is of the form :math:`(\mathsf{struct}~{{\mathit{ft}}_1^\ast}~{{\mathit{ft}'}_1^\ast})`.

      * The composite type :math:`{\mathit{comptype}}_2` is of the form :math:`(\mathsf{struct}~{{\mathit{ft}}_2^\ast})`.

      * For all :math:`{\mathit{ft}}_1` in :math:`{{\mathit{ft}}_1^\ast}`, and corresponding :math:`{\mathit{ft}}_2` in :math:`{{\mathit{ft}}_2^\ast}`:

         * The field type :math:`{\mathit{ft}}_1` :ref:`matches <match>` the field type :math:`{\mathit{ft}}_2`.

   * Or:

      * The composite type :math:`{\mathit{comptype}}_1` is of the form :math:`(\mathsf{array}~{\mathit{ft}}_1)`.

      * The composite type :math:`{\mathit{comptype}}_2` is of the form :math:`(\mathsf{array}~{\mathit{ft}}_2)`.

      * The field type :math:`{\mathit{ft}}_1` :ref:`matches <match>` the field type :math:`{\mathit{ft}}_2`.
   * Or:

      * The composite type :math:`{\mathit{comptype}}_1` is of the form :math:`(\mathsf{func}~{t_{11}^\ast}~\rightarrow~{t_{12}^\ast})`.

      * The composite type :math:`{\mathit{comptype}}_2` is of the form :math:`(\mathsf{func}~{t_{21}^\ast}~\rightarrow~{t_{22}^\ast})`.

      * The result type :math:`{t_{21}^\ast}` :ref:`matches <match>` the result type :math:`{t_{11}^\ast}`.

      * The result type :math:`{t_{12}^\ast}` :ref:`matches <match>` the result type :math:`{t_{22}^\ast}`.




The composite type :math:`(\mathsf{struct}~{{\mathit{ft}}_1^\ast}~{{\mathit{ft}'}_1^\ast})` :ref:`matches <match>` the composite type :math:`(\mathsf{struct}~{{\mathit{ft}}_2^\ast})` if:


   * For all :math:`{\mathit{ft}}_1` in :math:`{{\mathit{ft}}_1^\ast}`, and corresponding :math:`{\mathit{ft}}_2` in :math:`{{\mathit{ft}}_2^\ast}`:

      * The field type :math:`{\mathit{ft}}_1` :ref:`matches <match>` the field type :math:`{\mathit{ft}}_2`.




The composite type :math:`(\mathsf{array}~{\mathit{ft}}_1)` :ref:`matches <match>` the composite type :math:`(\mathsf{array}~{\mathit{ft}}_2)` if:


   * The field type :math:`{\mathit{ft}}_1` :ref:`matches <match>` the field type :math:`{\mathit{ft}}_2`.




The composite type :math:`(\mathsf{func}~{t_{11}^\ast}~\rightarrow~{t_{12}^\ast})` :ref:`matches <match>` the composite type :math:`(\mathsf{func}~{t_{21}^\ast}~\rightarrow~{t_{22}^\ast})` if:


   * The result type :math:`{t_{21}^\ast}` :ref:`matches <match>` the result type :math:`{t_{11}^\ast}`.

   * The result type :math:`{t_{12}^\ast}` :ref:`matches <match>` the result type :math:`{t_{22}^\ast}`.




The defined type :math:`{\mathit{deftype}}_1` :ref:`matches <match>` the defined type :math:`{\mathit{deftype}}_2` if:


   * Either:

      * The defined type :math:`{{\mathrm{clos}}}_{C}({\mathit{deftype}}_1)` is of the form :math:`{{\mathrm{clos}}}_{C}({\mathit{deftype}}_2)`.

   * Or:

      * The sub type :math:`{\mathrm{unroll}}({\mathit{deftype}}_1)` is of the form :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{ct}})`.

      * The length of :math:`{{\mathit{typeuse}}^\ast}` is greater than :math:`i`.

      * The type use :math:`{{\mathit{typeuse}}^\ast}{}[i]` :ref:`matches <match>` the heap type :math:`{\mathit{deftype}}_2`.




The defined type :math:`{\mathit{deftype}}_1` :ref:`matches <match>` the defined type :math:`{\mathit{deftype}}_2` if:


   * The defined type :math:`{{\mathrm{clos}}}_{C}({\mathit{deftype}}_1)` is of the form :math:`{{\mathrm{clos}}}_{C}({\mathit{deftype}}_2)`.




The defined type :math:`{\mathit{deftype}}_1` :ref:`matches <match>` the defined type :math:`{\mathit{deftype}}_2` if:


   * The sub type :math:`{\mathrm{unroll}}({\mathit{deftype}}_1)` is of the form :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{ct}})`.

   * The length of :math:`{{\mathit{typeuse}}^\ast}` is greater than :math:`i`.

   * The type use :math:`{{\mathit{typeuse}}^\ast}{}[i]` :ref:`matches <match>` the heap type :math:`{\mathit{deftype}}_2`.




The heap type :math:`{\mathit{heaptype}}_1` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}_2` if:


   * Either:

      * The heap type :math:`{\mathit{heaptype}}_2` is of the form :math:`{\mathit{heaptype}}_1`.

   * Or:

      * The heap type :math:`{\mathit{heaptype}'}` is :ref:`valid <valid-val>`.

      * The heap type :math:`{\mathit{heaptype}}_1` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}'}`.

      * The heap type :math:`{\mathit{heaptype}'}` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}_2`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}}_1` is of the form :math:`\mathsf{eq}`.

      * The heap type :math:`{\mathit{heaptype}}_2` is of the form :math:`\mathsf{any}`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}}_1` is of the form :math:`\mathsf{i{\scriptstyle 31}}`.

      * The heap type :math:`{\mathit{heaptype}}_2` is of the form :math:`\mathsf{eq}`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}}_1` is of the form :math:`\mathsf{struct}`.

      * The heap type :math:`{\mathit{heaptype}}_2` is of the form :math:`\mathsf{eq}`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}}_1` is of the form :math:`\mathsf{array}`.

      * The heap type :math:`{\mathit{heaptype}}_2` is of the form :math:`\mathsf{eq}`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}}_1` is of the form :math:`{\mathit{deftype}}`.

      * The heap type :math:`{\mathit{heaptype}}_2` is of the form :math:`\mathsf{struct}`.

      * The :ref:`expansion <aux-expand-deftype>` of :math:`{\mathit{deftype}}` is :math:`(\mathsf{struct}~{{\mathit{fieldtype}}^\ast})`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}}_1` is of the form :math:`{\mathit{deftype}}`.

      * The heap type :math:`{\mathit{heaptype}}_2` is of the form :math:`\mathsf{array}`.

      * The :ref:`expansion <aux-expand-deftype>` of :math:`{\mathit{deftype}}` is :math:`(\mathsf{array}~{\mathit{fieldtype}})`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}}_1` is of the form :math:`{\mathit{deftype}}`.

      * The heap type :math:`{\mathit{heaptype}}_2` is of the form :math:`\mathsf{func}`.

      * The :ref:`expansion <aux-expand-deftype>` of :math:`{\mathit{deftype}}` is :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}}_1` is of the form :math:`{\mathit{deftype}}_1`.

      * The heap type :math:`{\mathit{heaptype}}_2` is of the form :math:`{\mathit{deftype}}_2`.

      * The defined type :math:`{\mathit{deftype}}_1` :ref:`matches <match>` the defined type :math:`{\mathit{deftype}}_2`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}}_1` is of the form :math:`{\mathit{typeidx}}`.

      * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

      * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}_2`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}}_2` is of the form :math:`{\mathit{typeidx}}`.

      * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

      * The heap type :math:`{\mathit{heaptype}}_1` :ref:`matches <match>` the type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}}_1` is of the form :math:`(\mathsf{rec}~{.}~{.})`.

      * The length of :math:`{{\mathit{typeuse}}^\ast}` is greater than :math:`j`.

      * The heap type :math:`{\mathit{heaptype}}_2` is of the form :math:`{{\mathit{typeuse}}^\ast}{}[j]`.

      * The recursive type :math:`C{.}\mathsf{recs}{}[i]` exists.

      * The recursive type :math:`C{.}\mathsf{recs}{}[i]` is of the form :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{ct}})`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}}_1` is of the form :math:`\mathsf{none}`.

      * The heap type :math:`{\mathit{heaptype}}_2` :ref:`matches <match>` the heap type :math:`\mathsf{any}`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}}_1` is of the form :math:`\mathsf{nofunc}`.

      * The heap type :math:`{\mathit{heaptype}}_2` :ref:`matches <match>` the heap type :math:`\mathsf{func}`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}}_1` is of the form :math:`\mathsf{noexn}`.

      * The heap type :math:`{\mathit{heaptype}}_2` :ref:`matches <match>` the heap type :math:`\mathsf{exn}`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}}_1` is of the form :math:`\mathsf{noextern}`.

      * The heap type :math:`{\mathit{heaptype}}_2` :ref:`matches <match>` the heap type :math:`\mathsf{extern}`.
   * Or:

      * The heap type :math:`{\mathit{heaptype}}_1` is of the form :math:`\mathsf{bot}`.




The heap type :math:`{\mathit{heaptype}}` :ref:`matches <match>` only itself.




The heap type :math:`{\mathit{heaptype}}_1` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}_2` if:


   * The heap type :math:`{\mathit{heaptype}'}` is :ref:`valid <valid-val>`.

   * The heap type :math:`{\mathit{heaptype}}_1` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}'}`.

   * The heap type :math:`{\mathit{heaptype}'}` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}_2`.




The heap type :math:`\mathsf{eq}` :ref:`matches <match>` the heap type :math:`\mathsf{any}`.




The heap type :math:`\mathsf{i{\scriptstyle 31}}` :ref:`matches <match>` the heap type :math:`\mathsf{eq}`.




The heap type :math:`\mathsf{struct}` :ref:`matches <match>` the heap type :math:`\mathsf{eq}`.




The heap type :math:`\mathsf{array}` :ref:`matches <match>` the heap type :math:`\mathsf{eq}`.




The heap type :math:`{\mathit{deftype}}` :ref:`matches <match>` the heap type :math:`\mathsf{struct}` if:


   * The :ref:`expansion <aux-expand-deftype>` of :math:`{\mathit{deftype}}` is :math:`(\mathsf{struct}~{{\mathit{fieldtype}}^\ast})`.




The heap type :math:`{\mathit{deftype}}` :ref:`matches <match>` the heap type :math:`\mathsf{array}` if:


   * The :ref:`expansion <aux-expand-deftype>` of :math:`{\mathit{deftype}}` is :math:`(\mathsf{array}~{\mathit{fieldtype}})`.




The heap type :math:`{\mathit{deftype}}` :ref:`matches <match>` the heap type :math:`\mathsf{func}` if:


   * The :ref:`expansion <aux-expand-deftype>` of :math:`{\mathit{deftype}}` is :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The heap type :math:`{\mathit{deftype}}_1` :ref:`matches <match>` the heap type :math:`{\mathit{deftype}}_2` if:


   * The defined type :math:`{\mathit{deftype}}_1` :ref:`matches <match>` the defined type :math:`{\mathit{deftype}}_2`.




The heap type :math:`{\mathit{typeidx}}` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}` if:


   * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

   * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}`.




The heap type :math:`{\mathit{heaptype}}` :ref:`matches <match>` the heap type :math:`{\mathit{typeidx}}` if:


   * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

   * The heap type :math:`{\mathit{heaptype}}` :ref:`matches <match>` the type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]`.




The heap type :math:`(\mathsf{rec}~{.}~{.})` :ref:`matches <match>` the type use :math:`{{\mathit{typeuse}}^\ast}{}[j]` if:


   * The length of :math:`{{\mathit{typeuse}}^\ast}` is greater than :math:`j`.

   * The recursive type :math:`C{.}\mathsf{recs}{}[i]` exists.

   * The recursive type :math:`C{.}\mathsf{recs}{}[i]` is of the form :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{ct}})`.




The heap type :math:`\mathsf{none}` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}` if:


   * The heap type :math:`{\mathit{heaptype}}` :ref:`matches <match>` the heap type :math:`\mathsf{any}`.




The heap type :math:`\mathsf{nofunc}` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}` if:


   * The heap type :math:`{\mathit{heaptype}}` :ref:`matches <match>` the heap type :math:`\mathsf{func}`.




The heap type :math:`\mathsf{noexn}` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}` if:


   * The heap type :math:`{\mathit{heaptype}}` :ref:`matches <match>` the heap type :math:`\mathsf{exn}`.




The heap type :math:`\mathsf{noextern}` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}` if:


   * The heap type :math:`{\mathit{heaptype}}` :ref:`matches <match>` the heap type :math:`\mathsf{extern}`.




The heap type :math:`\mathsf{bot}` :ref:`matches <match>` the heap type :math:`{\mathit{heaptype}}`.




The reference type :math:`(\mathsf{ref}~{{\mathsf{null}}_1^?}~{\mathit{ht}}_1)` :ref:`matches <match>` the reference type :math:`(\mathsf{ref}~{{\mathsf{null}}_2^?}~{\mathit{ht}}_2)` if:


   * The heap type :math:`{\mathit{ht}}_1` :ref:`matches <match>` the heap type :math:`{\mathit{ht}}_2`.

   * Either:

      * :math:`{{\mathsf{null}}_1^?}` is absent.

      * :math:`{{\mathsf{null}}_2^?}` is absent.

   * Or:

      * :math:`{{\mathsf{null}}_1^?}` is of the form :math:`{\mathsf{null}^?}`.

      * :math:`{{\mathsf{null}}_2^?}` is of the form :math:`\mathsf{null}`.




The reference type :math:`(\mathsf{ref}~{\mathit{ht}}_1)` :ref:`matches <match>` the reference type :math:`(\mathsf{ref}~{\mathit{ht}}_2)` if:


   * The heap type :math:`{\mathit{ht}}_1` :ref:`matches <match>` the heap type :math:`{\mathit{ht}}_2`.




The reference type :math:`(\mathsf{ref}~{\mathsf{null}^?}~{\mathit{ht}}_1)` :ref:`matches <match>` the reference type :math:`(\mathsf{ref}~\mathsf{null}~{\mathit{ht}}_2)` if:


   * The heap type :math:`{\mathit{ht}}_1` :ref:`matches <match>` the heap type :math:`{\mathit{ht}}_2`.




The value type :math:`{\mathit{valtype}}_1` :ref:`matches <match>` the value type :math:`{\mathit{valtype}}_2` if:


   * Either:

      * The value type :math:`{\mathit{valtype}}_1` is of the form :math:`{\mathit{numtype}}_1`.

      * The value type :math:`{\mathit{valtype}}_2` is of the form :math:`{\mathit{numtype}}_2`.

      * The number type :math:`{\mathit{numtype}}_1` :ref:`matches <match>` the number type :math:`{\mathit{numtype}}_2`.

   * Or:

      * The value type :math:`{\mathit{valtype}}_1` is of the form :math:`{\mathit{vectype}}_1`.

      * The value type :math:`{\mathit{valtype}}_2` is of the form :math:`{\mathit{vectype}}_2`.

      * The vector type :math:`{\mathit{vectype}}_1` :ref:`matches <match>` the vector type :math:`{\mathit{vectype}}_2`.
   * Or:

      * The value type :math:`{\mathit{valtype}}_1` is of the form :math:`{\mathit{reftype}}_1`.

      * The value type :math:`{\mathit{valtype}}_2` is of the form :math:`{\mathit{reftype}}_2`.

      * The reference type :math:`{\mathit{reftype}}_1` :ref:`matches <match>` the reference type :math:`{\mathit{reftype}}_2`.
   * Or:

      * The value type :math:`{\mathit{valtype}}_1` is of the form :math:`\mathsf{bot}`.




The value type :math:`{\mathit{numtype}}_1` :ref:`matches <match>` the value type :math:`{\mathit{numtype}}_2` if:


   * The number type :math:`{\mathit{numtype}}_1` :ref:`matches <match>` the number type :math:`{\mathit{numtype}}_2`.




The value type :math:`{\mathit{vectype}}_1` :ref:`matches <match>` the value type :math:`{\mathit{vectype}}_2` if:


   * The vector type :math:`{\mathit{vectype}}_1` :ref:`matches <match>` the vector type :math:`{\mathit{vectype}}_2`.




The value type :math:`{\mathit{reftype}}_1` :ref:`matches <match>` the value type :math:`{\mathit{reftype}}_2` if:


   * The reference type :math:`{\mathit{reftype}}_1` :ref:`matches <match>` the reference type :math:`{\mathit{reftype}}_2`.




The value type :math:`\mathsf{bot}` :ref:`matches <match>` the value type :math:`{\mathit{valtype}}`.




The result type :math:`{t_1^\ast}` :ref:`matches <match>` the result type :math:`{t_2^\ast}` if:


   * For all :math:`t_1` in :math:`{t_1^\ast}`, and corresponding :math:`t_2` in :math:`{t_2^\ast}`:

      * The value type :math:`t_1` :ref:`matches <match>` the value type :math:`t_2`.




The storage type :math:`{\mathit{storagetype}}_1` :ref:`matches <match>` the storage type :math:`{\mathit{storagetype}}_2` if:


   * Either:

      * The storage type :math:`{\mathit{storagetype}}_1` is of the form :math:`{\mathit{valtype}}_1`.

      * The storage type :math:`{\mathit{storagetype}}_2` is of the form :math:`{\mathit{valtype}}_2`.

      * The value type :math:`{\mathit{valtype}}_1` :ref:`matches <match>` the value type :math:`{\mathit{valtype}}_2`.

   * Or:

      * The storage type :math:`{\mathit{storagetype}}_1` is of the form :math:`{\mathit{packtype}}_1`.

      * The storage type :math:`{\mathit{storagetype}}_2` is of the form :math:`{\mathit{packtype}}_2`.

      * The packed type :math:`{\mathit{packtype}}_1` :ref:`matches <match>` the packed type :math:`{\mathit{packtype}}_2`.




The storage type :math:`{\mathit{valtype}}_1` :ref:`matches <match>` the storage type :math:`{\mathit{valtype}}_2` if:


   * The value type :math:`{\mathit{valtype}}_1` :ref:`matches <match>` the value type :math:`{\mathit{valtype}}_2`.




The storage type :math:`{\mathit{packtype}}_1` :ref:`matches <match>` the storage type :math:`{\mathit{packtype}}_2` if:


   * The packed type :math:`{\mathit{packtype}}_1` :ref:`matches <match>` the packed type :math:`{\mathit{packtype}}_2`.




The field type :math:`({{\mathsf{mut}}_1^?}~{\mathit{zt}}_1)` :ref:`matches <match>` the field type :math:`({{\mathsf{mut}}_2^?}~{\mathit{zt}}_2)` if:


   * The storage type :math:`{\mathit{zt}}_1` :ref:`matches <match>` the storage type :math:`{\mathit{zt}}_2`.

   * Either:

      * :math:`{{\mathsf{mut}}_1^?}` is absent.

      * :math:`{{\mathsf{mut}}_2^?}` is absent.

   * Or:

      * :math:`{{\mathsf{mut}}_1^?}` is of the form :math:`\mathsf{mut}`.

      * :math:`{{\mathsf{mut}}_2^?}` is of the form :math:`\mathsf{mut}`.

      * The storage type :math:`{\mathit{zt}}_2` :ref:`matches <match>` the storage type :math:`{\mathit{zt}}_1`.




The field type :math:`(\epsilon~{\mathit{zt}}_1)` :ref:`matches <match>` the field type :math:`(\epsilon~{\mathit{zt}}_2)` if:


   * The storage type :math:`{\mathit{zt}}_1` :ref:`matches <match>` the storage type :math:`{\mathit{zt}}_2`.




The field type :math:`(\mathsf{mut}~{\mathit{zt}}_1)` :ref:`matches <match>` the field type :math:`(\mathsf{mut}~{\mathit{zt}}_2)` if:


   * The storage type :math:`{\mathit{zt}}_1` :ref:`matches <match>` the storage type :math:`{\mathit{zt}}_2`.

   * The storage type :math:`{\mathit{zt}}_2` :ref:`matches <match>` the storage type :math:`{\mathit{zt}}_1`.




The instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}` is :ref:`valid <valid-val>` if:


   * The result type :math:`{t_1^\ast}` is :ref:`valid <valid-val>`.

   * The result type :math:`{t_2^\ast}` is :ref:`valid <valid-val>`.

   * For all :math:`x` in :math:`{x^\ast}`:

      * The local :math:`C{.}\mathsf{locals}{}[x]` exists.




The limits range :math:`{}[ n .. {m^?} ]` is :ref:`valid <valid-val>` within :math:`k` if:


   * :math:`n` is less than or equal to :math:`k`.

   * If :math:`m` is defined, then:

      * :math:`n` is less than or equal to :math:`m`.

      * :math:`m` is less than or equal to :math:`k`.




The tag type :math:`{\mathit{typeuse}}` is :ref:`valid <valid-val>` if:


   * The type use :math:`{\mathit{typeuse}}` is :ref:`valid <valid-val>`.

   * The :ref:`expansion <aux-expand-typeuse>` of :math:`C` is :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The global type :math:`({\mathsf{mut}^?}~t)` is :ref:`valid <valid-val>` if:


   * The value type :math:`t` is :ref:`valid <valid-val>`.




The memory type :math:`({\mathit{addrtype}}~{\mathit{limits}}~\mathsf{page})` is :ref:`valid <valid-val>` if:


   * The limits range :math:`{\mathit{limits}}` is :ref:`valid <valid-val>` within :math:`{2^{16}}`.




The table type :math:`({\mathit{addrtype}}~{\mathit{limits}}~{\mathit{reftype}})` is :ref:`valid <valid-val>` if:


   * The limits range :math:`{\mathit{limits}}` is :ref:`valid <valid-val>` within :math:`{2^{32}} - 1`.

   * The reference type :math:`{\mathit{reftype}}` is :ref:`valid <valid-val>`.




The external type :math:`{\mathit{externtype}}` is :ref:`valid <valid-val>` if:


   * Either:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{tag}~{\mathit{tagtype}})`.

      * The tag type :math:`{\mathit{tagtype}}` is :ref:`valid <valid-val>`.

   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{global}~{\mathit{globaltype}})`.

      * The global type :math:`{\mathit{globaltype}}` is :ref:`valid <valid-val>`.
   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{mem}~{\mathit{memtype}})`.

      * The memory type :math:`{\mathit{memtype}}` is :ref:`valid <valid-val>`.
   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{table}~{\mathit{tabletype}})`.

      * The table type :math:`{\mathit{tabletype}}` is :ref:`valid <valid-val>`.
   * Or:

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{func}~{\mathit{typeuse}})`.

      * The type use :math:`{\mathit{typeuse}}` is :ref:`valid <valid-val>`.

      * The :ref:`expansion <aux-expand-typeuse>` of :math:`C` is :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The external type :math:`(\mathsf{tag}~{\mathit{tagtype}})` is :ref:`valid <valid-val>` if:


   * The tag type :math:`{\mathit{tagtype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{global}~{\mathit{globaltype}})` is :ref:`valid <valid-val>` if:


   * The global type :math:`{\mathit{globaltype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{mem}~{\mathit{memtype}})` is :ref:`valid <valid-val>` if:


   * The memory type :math:`{\mathit{memtype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{table}~{\mathit{tabletype}})` is :ref:`valid <valid-val>` if:


   * The table type :math:`{\mathit{tabletype}}` is :ref:`valid <valid-val>`.




The external type :math:`(\mathsf{func}~{\mathit{typeuse}})` is :ref:`valid <valid-val>` if:


   * The type use :math:`{\mathit{typeuse}}` is :ref:`valid <valid-val>`.

   * The :ref:`expansion <aux-expand-typeuse>` of :math:`C` is :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The instruction type :math:`{t_{11}^\ast}~{\rightarrow}_{{x_1^\ast}}\,{t_{12}^\ast}` :ref:`matches <match>` the instruction type :math:`{t_{21}^\ast}~{\rightarrow}_{{x_2^\ast}}\,{t_{22}^\ast}` if:


   * The result type :math:`{t_{21}^\ast}` :ref:`matches <match>` the result type :math:`{t_{11}^\ast}`.

   * The result type :math:`{t_{12}^\ast}` :ref:`matches <match>` the result type :math:`{t_{22}^\ast}`.

   * The local index sequence :math:`{x^\ast}` is of the form :math:`{x_2^\ast} \setminus {x_1^\ast}`.

   * For all :math:`x` in :math:`{x^\ast}`:

      * The local :math:`C{.}\mathsf{locals}{}[x]` exists.

      * The local :math:`C{.}\mathsf{locals}{}[x]` is of the form :math:`(\mathsf{set}~t)`.




The limits range :math:`{}[ n_1 .. m_1 ]` :ref:`matches <match>` the limits range :math:`{}[ n_2 .. m_2 ]` if:


   * :math:`n_1` is greater than or equal to :math:`n_2`.

   * :math:`m_1` is less than or equal to :math:`m_2`.




The tag type :math:`{\mathit{deftype}}_1` :ref:`matches <match>` the tag type :math:`{\mathit{deftype}}_2` if:


   * The defined type :math:`{\mathit{deftype}}_1` :ref:`matches <match>` the defined type :math:`{\mathit{deftype}}_2`.

   * The defined type :math:`{\mathit{deftype}}_2` :ref:`matches <match>` the defined type :math:`{\mathit{deftype}}_1`.




The global type :math:`({{\mathsf{mut}}_1^?}~{\mathit{valtype}}_1)` :ref:`matches <match>` the global type :math:`({{\mathsf{mut}}_2^?}~{\mathit{valtype}}_2)` if:


   * The value type :math:`{\mathit{valtype}}_1` :ref:`matches <match>` the value type :math:`{\mathit{valtype}}_2`.

   * Either:

      * :math:`{{\mathsf{mut}}_1^?}` is absent.

      * :math:`{{\mathsf{mut}}_2^?}` is absent.

   * Or:

      * :math:`{{\mathsf{mut}}_1^?}` is of the form :math:`\mathsf{mut}`.

      * :math:`{{\mathsf{mut}}_2^?}` is of the form :math:`\mathsf{mut}`.

      * The value type :math:`{\mathit{valtype}}_2` :ref:`matches <match>` the value type :math:`{\mathit{valtype}}_1`.




The global type :math:`(\epsilon~{\mathit{valtype}}_1)` :ref:`matches <match>` the global type :math:`(\epsilon~{\mathit{valtype}}_2)` if:


   * The value type :math:`{\mathit{valtype}}_1` :ref:`matches <match>` the value type :math:`{\mathit{valtype}}_2`.




The global type :math:`(\mathsf{mut}~{\mathit{valtype}}_1)` :ref:`matches <match>` the global type :math:`(\mathsf{mut}~{\mathit{valtype}}_2)` if:


   * The value type :math:`{\mathit{valtype}}_1` :ref:`matches <match>` the value type :math:`{\mathit{valtype}}_2`.

   * The value type :math:`{\mathit{valtype}}_2` :ref:`matches <match>` the value type :math:`{\mathit{valtype}}_1`.




The memory type :math:`({\mathit{addrtype}}~{\mathit{limits}}_1~\mathsf{page})` :ref:`matches <match>` the memory type :math:`({\mathit{addrtype}}~{\mathit{limits}}_2~\mathsf{page})` if:


   * The limits range :math:`{\mathit{limits}}_1` :ref:`matches <match>` the limits range :math:`{\mathit{limits}}_2`.




The table type :math:`({\mathit{addrtype}}~{\mathit{limits}}_1~{\mathit{reftype}}_1)` :ref:`matches <match>` the table type :math:`({\mathit{addrtype}}~{\mathit{limits}}_2~{\mathit{reftype}}_2)` if:


   * The limits range :math:`{\mathit{limits}}_1` :ref:`matches <match>` the limits range :math:`{\mathit{limits}}_2`.

   * The reference type :math:`{\mathit{reftype}}_1` :ref:`matches <match>` the reference type :math:`{\mathit{reftype}}_2`.

   * The reference type :math:`{\mathit{reftype}}_2` :ref:`matches <match>` the reference type :math:`{\mathit{reftype}}_1`.




The external type :math:`{\mathit{externtype}}_1` :ref:`matches <match>` the external type :math:`{\mathit{externtype}}_2` if:


   * Either:

      * The external type :math:`{\mathit{externtype}}_1` is of the form :math:`(\mathsf{tag}~{\mathit{tagtype}}_1)`.

      * The external type :math:`{\mathit{externtype}}_2` is of the form :math:`(\mathsf{tag}~{\mathit{tagtype}}_2)`.

      * The tag type :math:`{\mathit{tagtype}}_1` :ref:`matches <match>` the tag type :math:`{\mathit{tagtype}}_2`.

   * Or:

      * The external type :math:`{\mathit{externtype}}_1` is of the form :math:`(\mathsf{global}~{\mathit{globaltype}}_1)`.

      * The external type :math:`{\mathit{externtype}}_2` is of the form :math:`(\mathsf{global}~{\mathit{globaltype}}_2)`.

      * The global type :math:`{\mathit{globaltype}}_1` :ref:`matches <match>` the global type :math:`{\mathit{globaltype}}_2`.
   * Or:

      * The external type :math:`{\mathit{externtype}}_1` is of the form :math:`(\mathsf{mem}~{\mathit{memtype}}_1)`.

      * The external type :math:`{\mathit{externtype}}_2` is of the form :math:`(\mathsf{mem}~{\mathit{memtype}}_2)`.

      * The memory type :math:`{\mathit{memtype}}_1` :ref:`matches <match>` the memory type :math:`{\mathit{memtype}}_2`.
   * Or:

      * The external type :math:`{\mathit{externtype}}_1` is of the form :math:`(\mathsf{table}~{\mathit{tabletype}}_1)`.

      * The external type :math:`{\mathit{externtype}}_2` is of the form :math:`(\mathsf{table}~{\mathit{tabletype}}_2)`.

      * The table type :math:`{\mathit{tabletype}}_1` :ref:`matches <match>` the table type :math:`{\mathit{tabletype}}_2`.
   * Or:

      * The external type :math:`{\mathit{externtype}}_1` is of the form :math:`(\mathsf{func}~{\mathit{deftype}}_1)`.

      * The external type :math:`{\mathit{externtype}}_2` is of the form :math:`(\mathsf{func}~{\mathit{deftype}}_2)`.

      * The defined type :math:`{\mathit{deftype}}_1` :ref:`matches <match>` the defined type :math:`{\mathit{deftype}}_2`.




The external type :math:`(\mathsf{tag}~{\mathit{tagtype}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{tag}~{\mathit{tagtype}}_2)` if:


   * The tag type :math:`{\mathit{tagtype}}_1` :ref:`matches <match>` the tag type :math:`{\mathit{tagtype}}_2`.




The external type :math:`(\mathsf{global}~{\mathit{globaltype}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{global}~{\mathit{globaltype}}_2)` if:


   * The global type :math:`{\mathit{globaltype}}_1` :ref:`matches <match>` the global type :math:`{\mathit{globaltype}}_2`.




The external type :math:`(\mathsf{mem}~{\mathit{memtype}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{mem}~{\mathit{memtype}}_2)` if:


   * The memory type :math:`{\mathit{memtype}}_1` :ref:`matches <match>` the memory type :math:`{\mathit{memtype}}_2`.




The external type :math:`(\mathsf{table}~{\mathit{tabletype}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{table}~{\mathit{tabletype}}_2)` if:


   * The table type :math:`{\mathit{tabletype}}_1` :ref:`matches <match>` the table type :math:`{\mathit{tabletype}}_2`.




The external type :math:`(\mathsf{func}~{\mathit{deftype}}_1)` :ref:`matches <match>` the external type :math:`(\mathsf{func}~{\mathit{deftype}}_2)` if:


   * The defined type :math:`{\mathit{deftype}}_1` :ref:`matches <match>` the defined type :math:`{\mathit{deftype}}_2`.




The block type :math:`{\mathit{blocktype}}` is :ref:`valid <valid-val>` as the instruction type :math:`{{\mathit{valtype}}^\ast}~\rightarrow~{{\mathit{valtype}'}^\ast}` if:


   * Either:

      * The block type :math:`{\mathit{blocktype}}` is of the form :math:`{{\mathit{valtype}''}^?}`.

      * The value type sequence :math:`{{\mathit{valtype}}^\ast}` is empty.

      * The value type sequence :math:`{{\mathit{valtype}'}^\ast}` is of the form :math:`{{\mathit{valtype}''}^?}`.

      * If :math:`{\mathit{valtype}''}` is defined, then:

         * The value type :math:`{\mathit{valtype}''}` is :ref:`valid <valid-val>`.

   * Or:

      * The block type :math:`{\mathit{blocktype}}` is of the form :math:`{\mathit{typeidx}}`.

      * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

      * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is :math:`(\mathsf{func}~{{\mathit{valtype}}^\ast}~\rightarrow~{{\mathit{valtype}'}^\ast})`.




The block type :math:`{{\mathit{valtype}}^?}` is :ref:`valid <valid-val>` as the instruction type :math:`\epsilon~\rightarrow~{{\mathit{valtype}}^?}` if:


   * If :math:`{\mathit{valtype}}` is defined, then:

      * The value type :math:`{\mathit{valtype}}` is :ref:`valid <valid-val>`.




The block type :math:`{\mathit{typeidx}}` is :ref:`valid <valid-val>` as the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The catch clause :math:`{\mathit{catch}}` is :ref:`valid <valid-val>` if:


   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * Either:

      * The catch clause :math:`{\mathit{catch}}` is of the form :math:`(\mathsf{catch}~x~l)`.

      * The tag :math:`C{.}\mathsf{tags}{}[x]` exists.

      * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{tags}{}[x]` is :math:`(\mathsf{func}~{t^\ast}~\rightarrow)`.

      * The result type :math:`{t^\ast}` :ref:`matches <match>` the label :math:`C{.}\mathsf{labels}{}[l]`.

   * Or:

      * The catch clause :math:`{\mathit{catch}}` is of the form :math:`(\mathsf{catch\_ref}~x~l)`.

      * The tag :math:`C{.}\mathsf{tags}{}[x]` exists.

      * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{tags}{}[x]` is :math:`(\mathsf{func}~{t^\ast}~\rightarrow)`.

      * The result type :math:`{t^\ast}~(\mathsf{ref}~\mathsf{exn})` :ref:`matches <match>` the label :math:`C{.}\mathsf{labels}{}[l]`.
   * Or:

      * The catch clause :math:`{\mathit{catch}}` is of the form :math:`(\mathsf{catch\_all}~l)`.

      * The result type :math:`\epsilon` :ref:`matches <match>` the label :math:`C{.}\mathsf{labels}{}[l]`.
   * Or:

      * The catch clause :math:`{\mathit{catch}}` is of the form :math:`(\mathsf{catch\_all\_ref}~l)`.

      * The result type :math:`(\mathsf{ref}~\mathsf{exn})` :ref:`matches <match>` the label :math:`C{.}\mathsf{labels}{}[l]`.




The catch clause :math:`(\mathsf{catch}~x~l)` is :ref:`valid <valid-val>` if:


   * The tag :math:`C{.}\mathsf{tags}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{tags}{}[x]` is :math:`(\mathsf{func}~{t^\ast}~\rightarrow)`.

   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The result type :math:`{t^\ast}` :ref:`matches <match>` the label :math:`C{.}\mathsf{labels}{}[l]`.




The catch clause :math:`(\mathsf{catch\_ref}~x~l)` is :ref:`valid <valid-val>` if:


   * The tag :math:`C{.}\mathsf{tags}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{tags}{}[x]` is :math:`(\mathsf{func}~{t^\ast}~\rightarrow)`.

   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The result type :math:`{t^\ast}~(\mathsf{ref}~\mathsf{exn})` :ref:`matches <match>` the label :math:`C{.}\mathsf{labels}{}[l]`.




The catch clause :math:`(\mathsf{catch\_all}~l)` is :ref:`valid <valid-val>` if:


   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The result type :math:`\epsilon` :ref:`matches <match>` the label :math:`C{.}\mathsf{labels}{}[l]`.




The catch clause :math:`(\mathsf{catch\_all\_ref}~l)` is :ref:`valid <valid-val>` if:


   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The result type :math:`(\mathsf{ref}~\mathsf{exn})` :ref:`matches <match>` the label :math:`C{.}\mathsf{labels}{}[l]`.




The value type :math:`t` is defaultable if:


   * The value :math:`{{\mathrm{default}}}_{t}` is not absent.




The instruction :math:`\mathsf{nop}` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction :math:`\mathsf{unreachable}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is :ref:`valid <valid-val>`.




The instruction :math:`\mathsf{drop}` is :ref:`valid <valid-val>` with the instruction type :math:`t~\rightarrow~\epsilon` if:


   * The value type :math:`t` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{select}~{{\mathit{valtype}}^?})` is :ref:`valid <valid-val>` with the instruction type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


   * The value type :math:`t` is :ref:`valid <valid-val>`.

   * Either:

      * The value type sequence :math:`{{\mathit{valtype}}^?}` is of the form :math:`t`.

   * Or:

      * The value type sequence :math:`{{\mathit{valtype}}^?}` is absent.

      * The value type :math:`t` :ref:`matches <match>` the value type :math:`{t'}`.

      * The value type :math:`{t'}` is of the form :math:`{\mathit{numtype}}` or :math:`{t'}` is of the form :math:`{\mathit{vectype}}`.




The instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}^\ast})` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{bt}}` is :ref:`valid <valid-val>` as the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.




The instruction :math:`(\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast})` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{bt}}` is :ref:`valid <valid-val>` as the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_1^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.




The instruction :math:`(\mathsf{if}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast})` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{bt}}` is :ref:`valid <valid-val>` as the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_1^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}}\,{t_2^\ast}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_2^\ast}}\,{t_2^\ast}`.




The instruction :math:`(\mathsf{br}~l)` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The label :math:`C{.}\mathsf{labels}{}[l]` is of the form :math:`{t^\ast}`.

   * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{br\_if}~l)` is :ref:`valid <valid-val>` with the instruction type :math:`{t^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t^\ast}` if:


   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The label :math:`C{.}\mathsf{labels}{}[l]` is of the form :math:`{t^\ast}`.




The instruction :math:`(\mathsf{br\_table}~{l^\ast}~{l'})` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{t^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


   * For all :math:`l` in :math:`{l^\ast}`:

      * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

      * The result type :math:`{t^\ast}` :ref:`matches <match>` the label :math:`C{.}\mathsf{labels}{}[l]`.

   * The label :math:`C{.}\mathsf{labels}{}[{l'}]` exists.

   * The result type :math:`{t^\ast}` :ref:`matches <match>` the label :math:`C{.}\mathsf{labels}{}[{l'}]`.

   * The instruction type :math:`{t_1^\ast}~{t^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{br\_on\_null}~l)` is :ref:`valid <valid-val>` with the instruction type :math:`{t^\ast}~(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})~\rightarrow~{t^\ast}~(\mathsf{ref}~{\mathit{ht}})` if:


   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The label :math:`C{.}\mathsf{labels}{}[l]` is of the form :math:`{t^\ast}`.

   * The heap type :math:`{\mathit{ht}}` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{br\_on\_non\_null}~l)` is :ref:`valid <valid-val>` with the instruction type :math:`{t^\ast}~(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})~\rightarrow~{t^\ast}` if:


   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The label :math:`C{.}\mathsf{labels}{}[l]` is of the form :math:`{t^\ast}~(\mathsf{ref}~{\mathsf{null}^?}~{\mathit{ht}})`.




The instruction :math:`(\mathsf{br\_on\_cast}~l~{\mathit{rt}}_1~{\mathit{rt}}_2)` is :ref:`valid <valid-val>` with the instruction type :math:`{t^\ast}~{\mathit{rt}}_1~\rightarrow~{t^\ast}~{\mathit{reftype}}` if:


   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The label :math:`C{.}\mathsf{labels}{}[l]` is of the form :math:`{t^\ast}~{\mathit{rt}}`.

   * The reference type :math:`{\mathit{rt}}_1` is :ref:`valid <valid-val>`.

   * The reference type :math:`{\mathit{rt}}_2` is :ref:`valid <valid-val>`.

   * The reference type :math:`{\mathit{rt}}_2` :ref:`matches <match>` the reference type :math:`{\mathit{rt}}_1`.

   * The reference type :math:`{\mathit{rt}}_2` :ref:`matches <match>` the reference type :math:`{\mathit{rt}}`.

   * The reference type :math:`{\mathit{reftype}}` is :math:`{\mathit{rt}}_1 \setminus {\mathit{rt}}_2`.




The instruction :math:`(\mathsf{br\_on\_cast\_fail}~l~{\mathit{rt}}_1~{\mathit{rt}}_2)` is :ref:`valid <valid-val>` with the instruction type :math:`{t^\ast}~{\mathit{rt}}_1~\rightarrow~{t^\ast}~{\mathit{rt}}_2` if:


   * The label :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The label :math:`C{.}\mathsf{labels}{}[l]` is of the form :math:`{t^\ast}~{\mathit{rt}}`.

   * The reference type :math:`{\mathit{rt}}_1` is :ref:`valid <valid-val>`.

   * The reference type :math:`{\mathit{rt}}_2` is :ref:`valid <valid-val>`.

   * The reference type :math:`{\mathit{rt}}_2` :ref:`matches <match>` the reference type :math:`{\mathit{rt}}_1`.

   * The reference type :math:`{\mathit{rt}}_1 \setminus {\mathit{rt}}_2` :ref:`matches <match>` the reference type :math:`{\mathit{rt}}`.




The instruction :math:`(\mathsf{call}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The function :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{funcs}{}[x]` is :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The instruction :math:`(\mathsf{call\_ref}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~(\mathsf{ref}~\mathsf{null}~x)~\rightarrow~{t_2^\ast}` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The instruction :math:`(\mathsf{call\_indirect}~x~y)` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\mathit{at}}~\rightarrow~{t_2^\ast}` if:


   * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.

   * The reference type :math:`{\mathit{rt}}` :ref:`matches <match>` the reference type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{func})`.

   * The type :math:`C{.}\mathsf{types}{}[y]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[y]` is :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The instruction :math:`\mathsf{return}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


   * The result type :math:`C{.}\mathsf{return}` is of the form :math:`{t^\ast}`.

   * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{return\_call}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{t_3^\ast}~{t_1^\ast}~\rightarrow~{t_4^\ast}` if:


   * The function :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{funcs}{}[x]` is :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.

   * The result type :math:`C{.}\mathsf{return}` is of the form :math:`{{t'}_2^\ast}`.

   * The result type :math:`{t_2^\ast}` :ref:`matches <match>` the result type :math:`{{t'}_2^\ast}`.

   * The instruction type :math:`{t_3^\ast}~\rightarrow~{t_4^\ast}` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{return\_call\_ref}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{t_3^\ast}~{t_1^\ast}~(\mathsf{ref}~\mathsf{null}~x)~\rightarrow~{t_4^\ast}` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.

   * The result type :math:`C{.}\mathsf{return}` is of the form :math:`{{t'}_2^\ast}`.

   * The result type :math:`{t_2^\ast}` :ref:`matches <match>` the result type :math:`{{t'}_2^\ast}`.

   * The instruction type :math:`{t_3^\ast}~\rightarrow~{t_4^\ast}` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{return\_call\_indirect}~x~y)` is :ref:`valid <valid-val>` with the instruction type :math:`{t_3^\ast}~{t_1^\ast}~{\mathit{at}}~\rightarrow~{t_4^\ast}` if:


   * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.

   * The reference type :math:`{\mathit{rt}}` :ref:`matches <match>` the reference type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{func})`.

   * The type :math:`C{.}\mathsf{types}{}[y]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[y]` is :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.

   * The result type :math:`C{.}\mathsf{return}` is of the form :math:`{{t'}_2^\ast}`.

   * The result type :math:`{t_2^\ast}` :ref:`matches <match>` the result type :math:`{{t'}_2^\ast}`.

   * The instruction type :math:`{t_3^\ast}~\rightarrow~{t_4^\ast}` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{throw}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


   * The tag :math:`C{.}\mathsf{tags}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{tags}{}[x]` is :math:`(\mathsf{func}~{t^\ast}~\rightarrow)`.

   * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is :ref:`valid <valid-val>`.




The instruction :math:`\mathsf{throw\_ref}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~(\mathsf{ref}~\mathsf{null}~\mathsf{exn})~\rightarrow~{t_2^\ast}` if:


   * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{try\_table}~{\mathit{bt}}~{{\mathit{catch}}^\ast}~{{\mathit{instr}}^\ast})` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{bt}}` is :ref:`valid <valid-val>` as the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.

   * For all :math:`{\mathit{catch}}` in :math:`{{\mathit{catch}}^\ast}`:

      * The catch clause :math:`{\mathit{catch}}` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{ref{.}null}~{\mathit{ht}})` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})` if:


   * The heap type :math:`{\mathit{ht}}` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{ref{.}func}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~(\mathsf{ref}~{\mathit{dt}})` if:


   * The function :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`{\mathit{dt}}`.

   * :math:`x` is contained in :math:`C{.}\mathsf{refs}`.




The instruction :math:`\mathsf{ref{.}i{\scriptstyle 31}}` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~\mathsf{i{\scriptstyle 31}})`.




The instruction :math:`\mathsf{ref{.}is\_null}` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The heap type :math:`{\mathit{ht}}` is :ref:`valid <valid-val>`.




The instruction :math:`\mathsf{ref{.}as\_non\_null}` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})~\rightarrow~(\mathsf{ref}~{\mathit{ht}})` if:


   * The heap type :math:`{\mathit{ht}}` is :ref:`valid <valid-val>`.




The instruction :math:`\mathsf{ref{.}eq}` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{eq})~(\mathsf{ref}~\mathsf{null}~\mathsf{eq})~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`(\mathsf{ref{.}test}~{\mathit{rt}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{rt}'}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The reference type :math:`{\mathit{rt}}` is :ref:`valid <valid-val>`.

   * The reference type :math:`{\mathit{rt}'}` is :ref:`valid <valid-val>`.

   * The reference type :math:`{\mathit{rt}}` :ref:`matches <match>` the reference type :math:`{\mathit{rt}'}`.




The instruction :math:`(\mathsf{ref{.}cast}~{\mathit{rt}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{rt}'}~\rightarrow~{\mathit{rt}}` if:


   * The reference type :math:`{\mathit{rt}}` is :ref:`valid <valid-val>`.

   * The reference type :math:`{\mathit{rt}'}` is :ref:`valid <valid-val>`.

   * The reference type :math:`{\mathit{rt}}` :ref:`matches <match>` the reference type :math:`{\mathit{rt}'}`.




The instruction :math:`({\mathsf{i{\scriptstyle 31}{.}get}}{\mathsf{\_}}{{\mathit{sx}}})` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{i{\scriptstyle 31}})~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`(\mathsf{struct{.}new}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{t^\ast}~\rightarrow~(\mathsf{ref}~x)` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{struct}~{({\mathsf{mut}^?}~{\mathit{zt}})^\ast})`.

   * The value type sequence :math:`{t^\ast}` is :math:`{{\mathrm{unpack}}({\mathit{zt}})^\ast}`.




The instruction :math:`(\mathsf{struct{.}new\_default}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~(\mathsf{ref}~x)` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{struct}~{({\mathsf{mut}^?}~{\mathit{zt}})^\ast})`.

   * For all :math:`{\mathit{zt}}` in :math:`{{\mathit{zt}}^\ast}`:

      * A :ref:`default value <aux-default>` for :math:`{\mathrm{unpack}}({\mathit{zt}})` is defined.




The instruction :math:`({\mathsf{struct{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x~i)` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\rightarrow~t` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{struct}~{{\mathit{ft}}^\ast})`.

   * The length of :math:`{{\mathit{ft}}^\ast}` is greater than :math:`i`.

   * The field type :math:`{{\mathit{ft}}^\ast}{}[i]` is of the form :math:`({\mathsf{mut}^?}~{\mathit{zt}})`.

   * The signedness :math:`{{\mathit{sx}}^?}` is absent if and only if :math:`{\mathit{zt}}` is a packed type.

   * The value type :math:`t` is :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{struct{.}set}~x~i)` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~t~\rightarrow~\epsilon` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{struct}~{{\mathit{ft}}^\ast})`.

   * The length of :math:`{{\mathit{ft}}^\ast}` is greater than :math:`i`.

   * The field type :math:`{{\mathit{ft}}^\ast}{}[i]` is of the form :math:`(\mathsf{mut}~{\mathit{zt}})`.

   * The value type :math:`t` is :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{array{.}new}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`t~\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~x)` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}))`.

   * The value type :math:`t` is :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{array{.}new\_default}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~x)` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}))`.

   * A :ref:`default value <aux-default>` for :math:`{\mathrm{unpack}}({\mathit{zt}})` is defined.




The instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)` is :ref:`valid <valid-val>` with the instruction type :math:`{t^{n}}~\rightarrow~(\mathsf{ref}~x)` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}))`.

   * The value type :math:`t` is :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{array{.}new\_elem}~x~y)` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~x)` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{rt}}))`.

   * The element segment :math:`C{.}\mathsf{elems}{}[y]` exists.

   * The element segment :math:`C{.}\mathsf{elems}{}[y]` :ref:`matches <match>` the reference type :math:`{\mathit{rt}}`.




The instruction :math:`(\mathsf{array{.}new\_data}~x~y)` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~x)` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}))`.

   * The value type :math:`{\mathrm{unpack}}({\mathit{zt}})` is of the form :math:`{\mathit{numtype}}` or :math:`{\mathrm{unpack}}({\mathit{zt}})` is of the form :math:`{\mathit{vectype}}`.

   * The data segment :math:`C{.}\mathsf{datas}{}[y]` exists.

   * The data segment :math:`C{.}\mathsf{datas}{}[y]` is of the form :math:`\mathsf{ok}`.




The instruction :math:`({\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}))`.

   * The signedness :math:`{{\mathit{sx}}^?}` is absent if and only if :math:`{\mathit{zt}}` is a packed type.

   * The value type :math:`t` is :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{array{.}set}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~t~\rightarrow~\epsilon` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{array}~(\mathsf{mut}~{\mathit{zt}}))`.

   * The value type :math:`t` is :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`\mathsf{array{.}len}` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{array})~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`(\mathsf{array{.}fill}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{array}~(\mathsf{mut}~{\mathit{zt}}))`.

   * The value type :math:`t` is :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{array{.}copy}~x_1~x_2)` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x_1)~\mathsf{i{\scriptstyle 32}}~(\mathsf{ref}~\mathsf{null}~x_2)~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The type :math:`C{.}\mathsf{types}{}[x_1]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x_1]` is :math:`(\mathsf{array}~(\mathsf{mut}~{\mathit{zt}}_1))`.

   * The type :math:`C{.}\mathsf{types}{}[x_2]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x_2]` is :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}_2))`.

   * The storage type :math:`{\mathit{zt}}_2` :ref:`matches <match>` the storage type :math:`{\mathit{zt}}_1`.




The instruction :math:`(\mathsf{array{.}init\_elem}~x~y)` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{array}~(\mathsf{mut}~{\mathit{zt}}))`.

   * The element segment :math:`C{.}\mathsf{elems}{}[y]` exists.

   * The element segment :math:`C{.}\mathsf{elems}{}[y]` :ref:`matches <match>` the storage type :math:`{\mathit{zt}}`.




The instruction :math:`(\mathsf{array{.}init\_data}~x~y)` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{array}~(\mathsf{mut}~{\mathit{zt}}))`.

   * The value type :math:`{\mathrm{unpack}}({\mathit{zt}})` is of the form :math:`{\mathit{numtype}}` or :math:`{\mathrm{unpack}}({\mathit{zt}})` is of the form :math:`{\mathit{vectype}}`.

   * The data segment :math:`C{.}\mathsf{datas}{}[y]` exists.

   * The data segment :math:`C{.}\mathsf{datas}{}[y]` is of the form :math:`\mathsf{ok}`.




The instruction :math:`\mathsf{extern{.}convert\_any}` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~{{\mathsf{null}}_1^?}~\mathsf{any})~\rightarrow~(\mathsf{ref}~{{\mathsf{null}}_2^?}~\mathsf{extern})` if:


   * :math:`{{\mathsf{null}}_1^?}` is of the form :math:`{{\mathsf{null}}_2^?}`.




The instruction :math:`\mathsf{any{.}convert\_extern}` is :ref:`valid <valid-val>` with the instruction type :math:`(\mathsf{ref}~{{\mathsf{null}}_1^?}~\mathsf{extern})~\rightarrow~(\mathsf{ref}~{{\mathsf{null}}_2^?}~\mathsf{any})` if:


   * :math:`{{\mathsf{null}}_1^?}` is of the form :math:`{{\mathsf{null}}_2^?}`.




The instruction :math:`(\mathsf{local{.}get}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~t` if:


   * The local :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The local :math:`C{.}\mathsf{locals}{}[x]` is of the form :math:`(\mathsf{set}~t)`.




The instruction :math:`(\mathsf{local{.}set}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`t~{\rightarrow}_{x}\,\epsilon` if:


   * The local :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The local :math:`C{.}\mathsf{locals}{}[x]` is of the form :math:`({\mathit{init}}~t)`.




The instruction :math:`(\mathsf{local{.}tee}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`t~{\rightarrow}_{x}\,t` if:


   * The local :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The local :math:`C{.}\mathsf{locals}{}[x]` is of the form :math:`({\mathit{init}}~t)`.




The instruction :math:`(\mathsf{global{.}get}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~t` if:


   * The global :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`({\mathsf{mut}^?}~t)`.




The instruction :math:`(\mathsf{global{.}set}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`t~\rightarrow~\epsilon` if:


   * The global :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`(\mathsf{mut}~t)`.




The instruction :math:`(\mathsf{table{.}get}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\rightarrow~{\mathit{rt}}` if:


   * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}set}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~{\mathit{rt}}~\rightarrow~\epsilon` if:


   * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}size}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~{\mathit{at}}` if:


   * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}grow}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{rt}}~{\mathit{at}}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}fill}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~{\mathit{rt}}~{\mathit{at}}~\rightarrow~\epsilon` if:


   * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}copy}~x_1~x_2)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}_1~{\mathit{at}}_2~{\mathit{addrtype}}~\rightarrow~\epsilon` if:


   * The table :math:`C{.}\mathsf{tables}{}[x_1]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x_1]` is of the form :math:`({\mathit{at}}_1~{\mathit{lim}}_1~{\mathit{rt}}_1)`.

   * The table :math:`C{.}\mathsf{tables}{}[x_2]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x_2]` is of the form :math:`({\mathit{at}}_2~{\mathit{lim}}_2~{\mathit{rt}}_2)`.

   * The reference type :math:`{\mathit{rt}}_2` :ref:`matches <match>` the reference type :math:`{\mathit{rt}}_1`.

   * The address type :math:`{\mathit{addrtype}}` is :math:`{\mathrm{min}}({\mathit{at}}_1, {\mathit{at}}_2)`.




The instruction :math:`(\mathsf{table{.}init}~x~y)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}}_1)`.

   * The element segment :math:`C{.}\mathsf{elems}{}[y]` exists.

   * The element segment :math:`C{.}\mathsf{elems}{}[y]` is of the form :math:`{\mathit{rt}}_2`.

   * The reference type :math:`{\mathit{rt}}_2` :ref:`matches <match>` the reference type :math:`{\mathit{rt}}_1`.




The instruction :math:`(\mathsf{elem{.}drop}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~\epsilon` if:


   * The element segment :math:`C{.}\mathsf{elems}{}[x]` exists.




The instruction :math:`(\mathsf{memory{.}size}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~{\mathit{at}}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.




The instruction :math:`(\mathsf{memory{.}grow}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\rightarrow~{\mathit{at}}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.




The instruction :math:`(\mathsf{memory{.}fill}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\mathsf{i{\scriptstyle 32}}~{\mathit{at}}~\rightarrow~\epsilon` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.




The instruction :math:`(\mathsf{memory{.}copy}~x_1~x_2)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}_1~{\mathit{at}}_2~{\mathit{addrtype}}~\rightarrow~\epsilon` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x_1]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x_1]` is of the form :math:`({\mathit{at}}_1~{\mathit{lim}}_1~\mathsf{page})`.

   * The memory :math:`C{.}\mathsf{mems}{}[x_2]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x_2]` is of the form :math:`({\mathit{at}}_2~{\mathit{lim}}_2~\mathsf{page})`.

   * The address type :math:`{\mathit{addrtype}}` is :math:`{\mathrm{min}}({\mathit{at}}_1, {\mathit{at}}_2)`.




The instruction :math:`(\mathsf{memory{.}init}~x~y)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * The data segment :math:`C{.}\mathsf{datas}{}[y]` exists.

   * The data segment :math:`C{.}\mathsf{datas}{}[y]` is of the form :math:`\mathsf{ok}`.




The instruction :math:`(\mathsf{data{.}drop}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~\epsilon` if:


   * The data segment :math:`C{.}\mathsf{datas}{}[x]` exists.

   * The data segment :math:`C{.}\mathsf{datas}{}[x]` is of the form :math:`\mathsf{ok}`.




The instruction :math:`({{\mathit{nt}}{.}\mathsf{load}}{{{\mathit{loadop}}^?}}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\rightarrow~{\mathit{valtype}}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * Either:

      * :math:`{{\mathit{loadop}}^?}` is absent.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathit{nt}}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

   * Or:

      * The number type :math:`{\mathit{nt}}` is of the form :math:`{\mathsf{i}}{N}`.

      * :math:`{{\mathit{loadop}}^?}` is of the form :math:`{M}{\mathsf{\_}}{{\mathit{sx}}}`.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathsf{i}}{N}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({{\mathit{nt}}{.}\mathsf{store}}{{{\mathit{storeop}}^?}}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~{\mathit{valtype}}~\rightarrow~\epsilon` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * Either:

      * :math:`{{\mathit{storeop}}^?}` is absent.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathit{nt}}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

   * Or:

      * The number type :math:`{\mathit{nt}}` is of the form :math:`{\mathsf{i}}{N}`.

      * :math:`{{\mathit{storeop}}^?}` is of the form :math:`M`.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathsf{i}}{N}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{{\mathit{vloadop}}^?}}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * Either:

      * :math:`{{\mathit{vloadop}}^?}` is absent.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|\mathsf{v{\scriptstyle 128}}|} / 8`.

   * Or:

      * :math:`{{\mathit{vloadop}}^?}` is of the form :math:`({M}{\mathsf{x}}{N}{\mathsf{\_}}{{\mathit{sx}}})`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8 \cdot N`.
   * Or:

      * :math:`{{\mathit{vloadop}}^?}` is of the form :math:`({N}{\mathsf{\_}}{\mathsf{splat}})`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.
   * Or:

      * :math:`{{\mathit{vloadop}}^?}` is of the form :math:`({N}{\mathsf{\_}}{\mathsf{zero}})`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{N}{\mathsf{\_}}{\mathsf{lane}}~x~{\mathit{memarg}}~i)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.

   * :math:`i` is less than :math:`128 / N`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{store}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\epsilon` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|\mathsf{v{\scriptstyle 128}}|} / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{store}}{N}{\mathsf{\_}}{\mathsf{lane}}~x~{\mathit{memarg}}~i)` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\epsilon` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.

   * :math:`i` is less than :math:`128 / N`.




The instruction :math:`({\mathit{nt}}{.}\mathsf{const}~c_{\mathit{nt}})` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}}~{.}~{\mathit{unop}}_{\mathit{nt}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{nt}}~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}}~{.}~{\mathit{binop}}_{\mathit{nt}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{nt}}~{\mathit{nt}}~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}}~{.}~{\mathit{testop}}_{\mathit{nt}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{nt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{nt}}~{.}~{\mathit{relop}}_{\mathit{nt}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{nt}}~{\mathit{nt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({{\mathit{nt}}_1~{.}~{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_2})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}~{.}~{\mathit{vvunop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}~{.}~{\mathit{vvbinop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}~{.}~{\mathit{vvternop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}~{.}~{\mathit{vvtestop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}}~{.}~{\mathit{vunop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}~{.}~{\mathit{vbinop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}~{.}~{\mathit{vternop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}~{.}~{\mathit{vtestop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}}~{.}~{\mathit{vrelop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}~{.}~{\mathit{vshiftop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{bitmask})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}}~{.}~{\mathit{vswizzlop}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{shuffle}~{i^\ast})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * For all :math:`i` in :math:`{i^\ast}`:

      * The lane index :math:`i` is less than :math:`2 \cdot {\mathrm{dim}}({\mathit{sh}})`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{splat})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{numtype}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The number type :math:`{\mathit{numtype}}` is :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`({{\mathit{sh}}{.}\mathsf{extract\_lane}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~i)` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~{\mathit{numtype}}` if:


   * The lane index :math:`i` is less than :math:`{\mathrm{dim}}({\mathit{sh}})`.

   * The number type :math:`{\mathit{numtype}}` is :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{replace\_lane}~i)` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~{\mathit{numtype}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The lane index :math:`i` is less than :math:`{\mathrm{dim}}({\mathit{sh}})`.

   * The number type :math:`{\mathit{numtype}}` is :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`({{\mathit{sh}}_1~{.}~{\mathit{vextunop}}}{\mathsf{\_}}{{\mathit{sh}}_2})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({{\mathit{sh}}_1~{.}~{\mathit{vextbinop}}}{\mathsf{\_}}{{\mathit{sh}}_2})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({{\mathit{sh}}_1~{.}~{\mathit{vextternop}}}{\mathsf{\_}}{{\mathit{sh}}_2})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({{\mathit{sh}}_1{.}\mathsf{narrow}}{\mathsf{\_}}{{\mathit{sh}}_2}{\mathsf{\_}}{{\mathit{sx}}})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({{\mathit{sh}}_1~{.}~{\mathit{vcvtop}}}{\mathsf{\_}}{{\mathit{sh}}_2})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{select}~t)` is :ref:`valid <valid-val>` with the instruction type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


   * The value type :math:`t` is :ref:`valid <valid-val>`.




The instruction :math:`(\mathsf{select})` is :ref:`valid <valid-val>` with the instruction type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


   * The value type :math:`t` is :ref:`valid <valid-val>`.

   * The value type :math:`t` :ref:`matches <match>` the value type :math:`{t'}`.

   * The value type :math:`{t'}` is of the form :math:`{\mathit{numtype}}` or :math:`{t'}` is of the form :math:`{\mathit{vectype}}`.




The instruction :math:`({\mathit{nt}}{.}\mathsf{load}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\rightarrow~{\mathit{nt}}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.




The instruction :math:`({{\mathsf{i}}{N}{.}\mathsf{load}}{{M}{\mathsf{\_}}{{\mathit{sx}}}}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\rightarrow~{\mathsf{i}}{N}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({\mathit{nt}}{.}\mathsf{store}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~{\mathit{nt}}~\rightarrow~\epsilon` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.




The instruction :math:`({{\mathsf{i}}{N}{.}\mathsf{store}}{M}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~{\mathsf{i}}{N}~\rightarrow~\epsilon` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|\mathsf{v{\scriptstyle 128}}|} / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{M}{\mathsf{x}}{N}{\mathsf{\_}}{{\mathit{sx}}}}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8 \cdot N`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{N}{\mathsf{\_}}{\mathsf{splat}}}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{N}{\mathsf{\_}}{\mathsf{zero}}}~x~{\mathit{memarg}})` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{at}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{it}}` if:


   * Either:

      * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is empty.

      * The instruction type :math:`{\mathit{it}}` is of the form :math:`\epsilon~\rightarrow~\epsilon`.

   * Or:

      * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is of the form :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}`.

      * The instruction type :math:`{\mathit{it}}` is of the form :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}~{x_2^\ast}}\,{t_3^\ast}`.

      * The instruction :math:`{\mathit{instr}}_1` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}}\,{t_2^\ast}`.

      * For all :math:`x_1` in :math:`{x_1^\ast}`:

         * The local :math:`C{.}\mathsf{locals}{}[x_1]` exists.

         * The local :math:`C{.}\mathsf{locals}{}[x_1]` is of the form :math:`({\mathit{init}}~t)`.

      * Under the context :math:`C` with the local types of :math:`{x_1^\ast}` updated to :math:`{(\mathsf{set}~t)^\ast}`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_2^\ast}~{\rightarrow}_{{x_2^\ast}}\,{t_3^\ast}`.
   * Or:

      * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{it}''}`.

      * The instruction type :math:`{\mathit{it}''}` :ref:`matches <match>` the instruction type :math:`{\mathit{it}}`.

      * The instruction type :math:`{\mathit{it}}` is :ref:`valid <valid-val>`.
   * Or:

      * The instruction type :math:`{\mathit{it}}` is of the form :math:`{t^\ast}~{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t^\ast}~{t_2^\ast}`.

      * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.

      * The result type :math:`{t^\ast}` is :ref:`valid <valid-val>`.




The instruction sequence :math:`\epsilon` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction sequence :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}~{x_2^\ast}}\,{t_3^\ast}` if:


   * The instruction :math:`{\mathit{instr}}_1` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}}\,{t_2^\ast}`.

   * For all :math:`x_1` in :math:`{x_1^\ast}`:

      * The local :math:`C{.}\mathsf{locals}{}[x_1]` exists.

      * The local :math:`C{.}\mathsf{locals}{}[x_1]` is of the form :math:`({\mathit{init}}~t)`.

   * :math:`{t^\ast}` is the concatenation of all such :math:`t`.

   * Under the context :math:`C` with the local types of :math:`{x_1^\ast}` updated to :math:`{(\mathsf{set}~t)^\ast}`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_2^\ast}~{\rightarrow}_{{x_2^\ast}}\,{t_3^\ast}`.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{it}}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{\mathit{it}'}`.

   * The instruction type :math:`{\mathit{it}'}` :ref:`matches <match>` the instruction type :math:`{\mathit{it}}`.

   * The instruction type :math:`{\mathit{it}}` is :ref:`valid <valid-val>`.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t^\ast}~{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t^\ast}~{t_2^\ast}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.

   * The result type :math:`{t^\ast}` is :ref:`valid <valid-val>`.




The expression :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the result type :math:`{t^\ast}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~{t^\ast}`.




The value type :math:`t` is not defaultable if:


   * The value :math:`{{\mathrm{default}}}_{t}` is absent.




:math:`{\mathit{val}}` is constant if:


   * Either:

      * The value :math:`{\mathit{val}}` is of the form :math:`({\mathit{nt}}{.}\mathsf{const}~c_{\mathit{nt}})`.

   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`({\mathit{vt}}{.}\mathsf{const}~c_{\mathit{vt}})`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{ref{.}null}~{\mathit{ht}})`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`\mathsf{ref{.}i{\scriptstyle 31}}`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{ref{.}func}~x)`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{struct{.}new}~x)`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{struct{.}new\_default}~x)`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{array{.}new}~x)`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{array{.}new\_default}~x)`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{array{.}new\_fixed}~x~n)`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`\mathsf{any{.}convert\_extern}`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`\mathsf{extern{.}convert\_any}`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`(\mathsf{global{.}get}~x)`.

      * The global :math:`C{.}\mathsf{globals}{}[x]` exists.

      * The global :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`(\epsilon~t)`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`({\mathsf{i}}{N}~{.}~{\mathit{binop}})`.

      * :math:`{\mathsf{i}}{N}` is contained in [:math:`\mathsf{i{\scriptstyle 32}}`; :math:`\mathsf{i{\scriptstyle 64}}`].

      * :math:`{\mathit{binop}}` is contained in [:math:`\mathsf{add}`; :math:`\mathsf{sub}`; :math:`\mathsf{mul}`].




:math:`({\mathit{nt}}{.}\mathsf{const}~c_{\mathit{nt}})` is constant.




:math:`({\mathit{vt}}{.}\mathsf{const}~c_{\mathit{vt}})` is constant.




:math:`(\mathsf{ref{.}null}~{\mathit{ht}})` is constant.




:math:`\mathsf{ref{.}i{\scriptstyle 31}}` is constant.




:math:`(\mathsf{ref{.}func}~x)` is constant.




:math:`(\mathsf{struct{.}new}~x)` is constant.




:math:`(\mathsf{struct{.}new\_default}~x)` is constant.




:math:`(\mathsf{array{.}new}~x)` is constant.




:math:`(\mathsf{array{.}new\_default}~x)` is constant.




:math:`(\mathsf{array{.}new\_fixed}~x~n)` is constant.




:math:`\mathsf{any{.}convert\_extern}` is constant.




:math:`\mathsf{extern{.}convert\_any}` is constant.




:math:`(\mathsf{global{.}get}~x)` is constant if:


   * The global :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`(\epsilon~t)`.




:math:`({\mathsf{i}}{N}~{.}~{\mathit{binop}})` is constant if:


   * :math:`{\mathsf{i}}{N}` is contained in [:math:`\mathsf{i{\scriptstyle 32}}`; :math:`\mathsf{i{\scriptstyle 64}}`].

   * :math:`{\mathit{binop}}` is contained in [:math:`\mathsf{add}`; :math:`\mathsf{sub}`; :math:`\mathsf{mul}`].




:math:`{{\mathit{instr}}^\ast}` is constant if:


   * For all :math:`{\mathit{instr}}` in :math:`{{\mathit{instr}}^\ast}`:

      * :math:`{\mathit{instr}}` is constant.




The type definition :math:`(\mathsf{type}~{\mathit{rectype}})` is :ref:`valid <valid-val>` with the defined type sequence :math:`{{\mathit{dt}}^\ast}` if:


   * The length of :math:`C{.}\mathsf{types}` is equal to :math:`x`.

   * The defined type sequence :math:`{{\mathit{dt}}^\ast}` is of the form :math:`{{{{\mathrm{roll}}}_{x}^\ast}}{({\mathit{rectype}})}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the defined type sequence :math:`{{\mathit{dt}}^\ast}` appended to the field :math:`\mathsf{types}`.

   * Under the context :math:`{C'}`, the recursive type :math:`{\mathit{rectype}}` is :ref:`valid <valid-val>` for the type index :math:`x`.




The tag :math:`(\mathsf{tag}~{\mathit{tagtype}})` is :ref:`valid <valid-val>` with the tag type :math:`{\mathit{tagtype}'}` if:


   * The tag type :math:`{\mathit{tagtype}}` is :ref:`valid <valid-val>`.

   * The tag type :math:`{\mathit{tagtype}'}` is :math:`{{\mathrm{clos}}}_{C}({\mathit{tagtype}})`.




The global :math:`(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}})` is :ref:`valid <valid-val>` with the global type :math:`{\mathit{globaltype}}` if:


   * The global type :math:`{\mathit{globaltype}}` is :ref:`valid <valid-val>`.

   * The global type :math:`{\mathit{globaltype}}` is of the form :math:`({\mathsf{mut}^?}~t)`.

   * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`t`.

   * :math:`{\mathit{expr}}` is constant.




The memory :math:`(\mathsf{memory}~{\mathit{memtype}})` is :ref:`valid <valid-val>` with the memory type :math:`{\mathit{memtype}}` if:


   * The memory type :math:`{\mathit{memtype}}` is :ref:`valid <valid-val>`.




The table :math:`(\mathsf{table}~{\mathit{tabletype}}~{\mathit{expr}})` is :ref:`valid <valid-val>` with the table type :math:`{\mathit{tabletype}}` if:


   * The table type :math:`{\mathit{tabletype}}` is :ref:`valid <valid-val>`.

   * The table type :math:`{\mathit{tabletype}}` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.

   * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{rt}}`.

   * :math:`{\mathit{expr}}` is constant.




The local :math:`(\mathsf{local}~t)` is :ref:`valid <valid-val>` with the local type :math:`({\mathit{init}}~t)` if:


   * Either:

      * The initialization status :math:`{\mathit{init}}` is of the form :math:`\mathsf{set}`.

      * A :ref:`default value <aux-default>` for :math:`t` is defined.

   * Or:

      * The initialization status :math:`{\mathit{init}}` is of the form :math:`\mathsf{unset}`.

      * A :ref:`default value <aux-default>` for :math:`t` is not defined.




The local :math:`(\mathsf{local}~t)` is :ref:`valid <valid-val>` with the local type :math:`(\mathsf{set}~t)` if:


   * A :ref:`default value <aux-default>` for :math:`t` is defined.




The local :math:`(\mathsf{local}~t)` is :ref:`valid <valid-val>` with the local type :math:`(\mathsf{unset}~t)` if:


   * A :ref:`default value <aux-default>` for :math:`t` is not defined.




The function :math:`(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}})` is :ref:`valid <valid-val>` with the type :math:`C{.}\mathsf{types}{}[x]` if:


   * The type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.

   * For all :math:`{\mathit{local}}` in :math:`{{\mathit{local}}^\ast}`:

      * The local :math:`{\mathit{local}}` is :ref:`valid <valid-val>` with the local type :math:`{{\mathit{lt}}}`.

   * :math:`{{{\mathit{lt}}}^\ast}` is the concatenation of all such :math:`{{\mathit{lt}}}`.

   * Under the context :math:`C` with the field :math:`\mathsf{locals}` appended by :math:`{(\mathsf{set}~t_1)^\ast}~{{{\mathit{lt}}}^\ast}` and the field :math:`\mathsf{labels}` appended by :math:`{t_2^\ast}` and the field :math:`\mathsf{return}` appended by :math:`{t_2^\ast}`, the expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the result type :math:`{t_2^\ast}`.




The data mode :math:`{\mathit{datamode}}` is :ref:`valid <valid-val>` if:


   * Either:

      * The data mode :math:`{\mathit{datamode}}` is of the form :math:`\mathsf{passive}`.

   * Or:

      * The data mode :math:`{\mathit{datamode}}` is of the form :math:`(\mathsf{active}~x~{\mathit{expr}})`.

      * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

      * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

      * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{at}}`.

      * :math:`{\mathit{expr}}` is constant.




The data mode :math:`\mathsf{passive}` is :ref:`valid <valid-val>`.




The data mode :math:`(\mathsf{active}~x~{\mathit{expr}})` is :ref:`valid <valid-val>` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{at}}`.

   * :math:`{\mathit{expr}}` is constant.




The memory segment :math:`(\mathsf{data}~{b^\ast}~{\mathit{datamode}})` is :ref:`valid <valid-val>` if:


   * The data mode :math:`{\mathit{datamode}}` is :ref:`valid <valid-val>`.




The element mode :math:`{\mathit{elemmode}}` is :ref:`valid <valid-val>` with the element type :math:`{\mathit{rt}}` if:


   * Either:

      * The element mode :math:`{\mathit{elemmode}}` is of the form :math:`\mathsf{passive}`.

   * Or:

      * The element mode :math:`{\mathit{elemmode}}` is of the form :math:`\mathsf{declare}`.
   * Or:

      * The element mode :math:`{\mathit{elemmode}}` is of the form :math:`(\mathsf{active}~x~{\mathit{expr}})`.

      * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

      * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}'})`.

      * The reference type :math:`{\mathit{rt}}` :ref:`matches <match>` the reference type :math:`{\mathit{rt}'}`.

      * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{at}}`.

      * :math:`{\mathit{expr}}` is constant.




The element mode :math:`\mathsf{passive}` is :ref:`valid <valid-val>` with the element type :math:`{\mathit{rt}}`.




The element mode :math:`\mathsf{declare}` is :ref:`valid <valid-val>` with the element type :math:`{\mathit{rt}}`.




The element mode :math:`(\mathsf{active}~x~{\mathit{expr}})` is :ref:`valid <valid-val>` with the element type :math:`{\mathit{rt}}` if:


   * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}'})`.

   * The reference type :math:`{\mathit{rt}}` :ref:`matches <match>` the reference type :math:`{\mathit{rt}'}`.

   * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{at}}`.

   * :math:`{\mathit{expr}}` is constant.




The table segment :math:`(\mathsf{elem}~{\mathit{elemtype}}~{{\mathit{expr}}^\ast}~{\mathit{elemmode}})` is :ref:`valid <valid-val>` with the element type :math:`{\mathit{elemtype}}` if:


   * The reference type :math:`{\mathit{elemtype}}` is :ref:`valid <valid-val>`.

   * For all :math:`{\mathit{expr}}` in :math:`{{\mathit{expr}}^\ast}`:

      * The expression :math:`{\mathit{expr}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{elemtype}}`.

      * :math:`{\mathit{expr}}` is constant.

   * The element mode :math:`{\mathit{elemmode}}` is :ref:`valid <valid-val>` with the element type :math:`{\mathit{elemtype}}`.




The start function :math:`(\mathsf{start}~x)` is :ref:`valid <valid-val>` if:


   * The function :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{funcs}{}[x]` is :math:`(\mathsf{func}~\rightarrow)`.




The import :math:`(\mathsf{import}~{\mathit{name}}_1~{\mathit{name}}_2~{\mathit{xt}})` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{externtype}}` if:


   * The external type :math:`{\mathit{xt}}` is :ref:`valid <valid-val>`.

   * The external type :math:`{\mathit{externtype}}` is :math:`{{\mathrm{clos}}}_{C}({\mathit{xt}})`.




The external index :math:`{\mathit{externidx}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{externtype}}` if:


   * Either:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{tag}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{tag}~{\mathit{jt}})`.

      * The tag :math:`C{.}\mathsf{tags}{}[x]` exists.

      * The tag :math:`C{.}\mathsf{tags}{}[x]` is of the form :math:`{\mathit{jt}}`.

   * Or:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{global}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{global}~{\mathit{gt}})`.

      * The global :math:`C{.}\mathsf{globals}{}[x]` exists.

      * The global :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`{\mathit{gt}}`.
   * Or:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{mem}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{mem}~{\mathit{mt}})`.

      * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

      * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`{\mathit{mt}}`.
   * Or:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{table}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{table}~{\mathit{tt}})`.

      * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

      * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`{\mathit{tt}}`.
   * Or:

      * The external index :math:`{\mathit{externidx}}` is of the form :math:`(\mathsf{func}~x)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{func}~{\mathit{dt}})`.

      * The function :math:`C{.}\mathsf{funcs}{}[x]` exists.

      * The function :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`{\mathit{dt}}`.




The external index :math:`(\mathsf{tag}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{tag}~{\mathit{jt}})` if:


   * The tag :math:`C{.}\mathsf{tags}{}[x]` exists.

   * The tag :math:`C{.}\mathsf{tags}{}[x]` is of the form :math:`{\mathit{jt}}`.




The external index :math:`(\mathsf{global}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{global}~{\mathit{gt}})` if:


   * The global :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`{\mathit{gt}}`.




The external index :math:`(\mathsf{mem}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{mem}~{\mathit{mt}})` if:


   * The memory :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory :math:`C{.}\mathsf{mems}{}[x]` is of the form :math:`{\mathit{mt}}`.




The external index :math:`(\mathsf{table}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{table}~{\mathit{tt}})` if:


   * The table :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table :math:`C{.}\mathsf{tables}{}[x]` is of the form :math:`{\mathit{tt}}`.




The external index :math:`(\mathsf{func}~x)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{func}~{\mathit{dt}})` if:


   * The function :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function :math:`C{.}\mathsf{funcs}{}[x]` is of the form :math:`{\mathit{dt}}`.




The export :math:`(\mathsf{export}~{\mathit{name}}~{\mathit{externidx}})` is :ref:`valid <valid-val>` with the name :math:`{\mathit{name}}` and the external type :math:`{\mathit{xt}}` if:


   * The external index :math:`{\mathit{externidx}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}`.




The global sequence :math:`{{\mathit{global}}^\ast}` is :ref:`valid <valid-val>` with the global type sequence :math:`{{\mathit{globaltype}}^\ast}` if:


   * Either:

      * The global sequence :math:`{{\mathit{global}}^\ast}` is empty.

      * The global type sequence :math:`{{\mathit{globaltype}}^\ast}` is empty.

   * Or:

      * The global sequence :math:`{{\mathit{global}}^\ast}` is of the form :math:`{\mathit{global}}_1~{{\mathit{global}'}^\ast}`.

      * The global type sequence :math:`{{\mathit{globaltype}}^\ast}` is of the form :math:`{\mathit{gt}}_1~{{\mathit{gt}}^\ast}`.

      * The global :math:`{\mathit{global}}_1` is :ref:`valid <valid-val>` with the global type :math:`{\mathit{gt}}_1`.

      * Let :math:`{C'}` be the same context as :math:`C`, but with the global type sequence :math:`{\mathit{gt}}_1` appended to the field :math:`\mathsf{globals}`.

      * Under the context :math:`{C'}`, the global sequence :math:`{{\mathit{global}'}^\ast}` is :ref:`valid <valid-val>` with the global type sequence :math:`{{\mathit{gt}}^\ast}`.




The global sequence :math:`\epsilon` is :ref:`valid <valid-val>` with the global type sequence :math:`\epsilon`.




The global sequence :math:`{\mathit{global}}_1~{{\mathit{global}}^\ast}` is :ref:`valid <valid-val>` with the global type sequence :math:`{\mathit{gt}}_1~{{\mathit{gt}}^\ast}` if:


   * The global :math:`{\mathit{global}}_1` is :ref:`valid <valid-val>` with the global type :math:`{\mathit{gt}}_1`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the global type sequence :math:`{\mathit{gt}}_1` appended to the field :math:`\mathsf{globals}`.

   * Under the context :math:`{C'}`, the global sequence :math:`{{\mathit{global}}^\ast}` is :ref:`valid <valid-val>` with the global type sequence :math:`{{\mathit{gt}}^\ast}`.




The type definition sequence :math:`{{\mathit{type}}^\ast}` is :ref:`valid <valid-val>` with the defined type sequence :math:`{{\mathit{deftype}}^\ast}` if:


   * Either:

      * The type definition sequence :math:`{{\mathit{type}}^\ast}` is empty.

      * The defined type sequence :math:`{{\mathit{deftype}}^\ast}` is empty.

   * Or:

      * The type definition sequence :math:`{{\mathit{type}}^\ast}` is of the form :math:`{\mathit{type}}_1~{{\mathit{type}'}^\ast}`.

      * The defined type sequence :math:`{{\mathit{deftype}}^\ast}` is of the form :math:`{{\mathit{dt}}_1^\ast}~{{\mathit{dt}}^\ast}`.

      * The type definition :math:`{\mathit{type}}_1` is :ref:`valid <valid-val>` with the defined type sequence :math:`{{\mathit{dt}}_1^\ast}`.

      * Let :math:`{C'}` be the same context as :math:`C`, but with the defined type sequence :math:`{{\mathit{dt}}_1^\ast}` appended to the field :math:`\mathsf{types}`.

      * Under the context :math:`{C'}`, the type definition sequence :math:`{{\mathit{type}'}^\ast}` is :ref:`valid <valid-val>` with the defined type sequence :math:`{{\mathit{dt}}^\ast}`.




The type definition sequence :math:`\epsilon` is :ref:`valid <valid-val>` with the defined type sequence :math:`\epsilon`.




The type definition sequence :math:`{\mathit{type}}_1~{{\mathit{type}}^\ast}` is :ref:`valid <valid-val>` with the defined type sequence :math:`{{\mathit{dt}}_1^\ast}~{{\mathit{dt}}^\ast}` if:


   * The type definition :math:`{\mathit{type}}_1` is :ref:`valid <valid-val>` with the defined type sequence :math:`{{\mathit{dt}}_1^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the defined type sequence :math:`{{\mathit{dt}}_1^\ast}` appended to the field :math:`\mathsf{types}`.

   * Under the context :math:`{C'}`, the type definition sequence :math:`{{\mathit{type}}^\ast}` is :ref:`valid <valid-val>` with the defined type sequence :math:`{{\mathit{dt}}^\ast}`.




The module :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{tag}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` is :ref:`valid <valid-val>` with the module type :math:`{\mathit{moduletype}}` if:


   * Under the context :math:`\{ \mathsf{return}~\epsilon \}`, the type definition sequence :math:`{{\mathit{type}}^\ast}` is :ref:`valid <valid-val>` with the defined type sequence :math:`{{\mathit{dt}'}^\ast}`.

   * For all :math:`{\mathit{import}}` in :math:`{{\mathit{import}}^\ast}`:

      * Under the context :math:`\{ \mathsf{types}~{{\mathit{dt}'}^\ast},\;\allowbreak \mathsf{return}~\epsilon \}`, the import :math:`{\mathit{import}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}_{\mathsf{i}}`.

   * :math:`{{\mathit{xt}}_{\mathsf{i}}^\ast}` is the concatenation of all such :math:`{\mathit{xt}}_{\mathsf{i}}`.

   * For all :math:`{\mathit{tag}}` in :math:`{{\mathit{tag}}^\ast}`:

      * Under the context :math:`{C'}`, the tag :math:`{\mathit{tag}}` is :ref:`valid <valid-val>` with the tag type :math:`{\mathit{jt}}`.

   * :math:`{{\mathit{jt}}^\ast}` is the concatenation of all such :math:`{\mathit{jt}}`.

   * Under the context :math:`{C'}`, the global sequence :math:`{{\mathit{global}}^\ast}` is :ref:`valid <valid-val>` with the global type sequence :math:`{{\mathit{gt}}^\ast}`.

   * For all :math:`{\mathit{mem}}` in :math:`{{\mathit{mem}}^\ast}`:

      * Under the context :math:`{C'}`, the memory :math:`{\mathit{mem}}` is :ref:`valid <valid-val>` with the memory type :math:`{\mathit{mt}}`.

   * :math:`{{\mathit{mt}}^\ast}` is the concatenation of all such :math:`{\mathit{mt}}`.

   * For all :math:`{\mathit{table}}` in :math:`{{\mathit{table}}^\ast}`:

      * Under the context :math:`{C'}`, the table :math:`{\mathit{table}}` is :ref:`valid <valid-val>` with the table type :math:`{\mathit{tt}}`.

   * :math:`{{\mathit{tt}}^\ast}` is the concatenation of all such :math:`{\mathit{tt}}`.

   * For all :math:`{\mathit{func}}` in :math:`{{\mathit{func}}^\ast}`:

      * The function :math:`{\mathit{func}}` is :ref:`valid <valid-val>` with the defined type :math:`{\mathit{dt}}`.

   * :math:`{{\mathit{dt}}^\ast}` is the concatenation of all such :math:`{\mathit{dt}}`.

   * For all :math:`{\mathit{data}}` in :math:`{{\mathit{data}}^\ast}`:

      * The memory segment :math:`{\mathit{data}}` is :ref:`valid <valid-val>`.

   * :math:`{{\mathit{ok}}^\ast}` is the concatenation of all such :math:`{\mathit{ok}}`.

   * For all :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}`:

      * The table segment :math:`{\mathit{elem}}` is :ref:`valid <valid-val>` with the element type :math:`{\mathit{rt}}`.

   * :math:`{{\mathit{rt}}^\ast}` is the concatenation of all such :math:`{\mathit{rt}}`.

   * If :math:`{\mathit{start}}` is defined, then:

      * The start function :math:`{\mathit{start}}` is :ref:`valid <valid-val>`.

   * For all :math:`{\mathit{export}}` in :math:`{{\mathit{export}}^\ast}`:

      * The export :math:`{\mathit{export}}` is :ref:`valid <valid-val>` with the name :math:`{\mathit{nm}}` and the external type :math:`{\mathit{xt}}_{\mathsf{e}}`.

   * :math:`{{\mathit{nm}}^\ast}` is the concatenation of all such :math:`{\mathit{nm}}`.

   * :math:`{{\mathit{xt}}_{\mathsf{e}}^\ast}` is the concatenation of all such :math:`{\mathit{xt}}_{\mathsf{e}}`.

   * :math:`{{\mathit{nm}}^\ast}~{\mathrm{disjoint}}` is true.

   * The context :math:`C` is of the form :math:`{C'}` with the field :math:`\mathsf{tags}` appended by :math:`{{\mathit{jt}}_{\mathsf{i}}^\ast}~{{\mathit{jt}}^\ast}` and the field :math:`\mathsf{globals}` appended by :math:`{{\mathit{gt}}^\ast}` and the field :math:`\mathsf{mems}` appended by :math:`{{\mathit{mt}}_{\mathsf{i}}^\ast}~{{\mathit{mt}}^\ast}` and the field :math:`\mathsf{tables}` appended by :math:`{{\mathit{tt}}_{\mathsf{i}}^\ast}~{{\mathit{tt}}^\ast}` and the field :math:`\mathsf{datas}` appended by :math:`{{\mathit{ok}}^\ast}` and the field :math:`\mathsf{elems}` appended by :math:`{{\mathit{rt}}^\ast}`.

   * The context :math:`{C'}` is of the form :math:`\{ \mathsf{types}~{{\mathit{dt}'}^\ast},\;\allowbreak \mathsf{globals}~{{\mathit{gt}}_{\mathsf{i}}^\ast},\;\allowbreak \mathsf{funcs}~{{\mathit{dt}}_{\mathsf{i}}^\ast}~{{\mathit{dt}}^\ast},\;\allowbreak \mathsf{return}~\epsilon,\;\allowbreak \mathsf{refs}~{x^\ast} \}`.

   * The function index sequence :math:`{x^\ast}` is of the form :math:`{\mathrm{funcidx}}({{\mathit{global}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{elem}}^\ast})`.

   * The tag type sequence :math:`{{\mathit{jt}}_{\mathsf{i}}^\ast}` is of the form :math:`{\mathrm{tags}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

   * The global type sequence :math:`{{\mathit{gt}}_{\mathsf{i}}^\ast}` is of the form :math:`{\mathrm{globals}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

   * The memory type sequence :math:`{{\mathit{mt}}_{\mathsf{i}}^\ast}` is of the form :math:`{\mathrm{mems}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

   * The table type sequence :math:`{{\mathit{tt}}_{\mathsf{i}}^\ast}` is of the form :math:`{\mathrm{tables}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

   * The defined type sequence :math:`{{\mathit{dt}}_{\mathsf{i}}^\ast}` is of the form :math:`{\mathrm{funcs}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

   * The module type :math:`{\mathit{moduletype}}` is :math:`{{\mathrm{clos}}}_{C}({{\mathit{xt}}_{\mathsf{i}}^\ast}~\rightarrow~{{\mathit{xt}}_{\mathsf{e}}^\ast})`.




The number value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` is :ref:`valid <valid-val>` with the number type :math:`{\mathit{nt}}`.




The vector value :math:`({\mathit{vt}}{.}\mathsf{const}~c)` is :ref:`valid <valid-val>` with the vector type :math:`{\mathit{vt}}`.




The reference value :math:`{\mathit{ref}}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}}` if:


   * Either:

      * The reference value :math:`{\mathit{ref}}` is of the form :math:`(\mathsf{ref{.}null}~{\mathit{ht}})`.

      * The reference type :math:`{\mathit{rt}}` is of the form :math:`(\mathsf{ref}~\mathsf{null}~{\mathit{ht}'})`.

      * The heap type :math:`{\mathit{ht}'}` :ref:`matches <match>` the heap type :math:`{\mathit{ht}}`.

   * Or:

      * The reference value :math:`{\mathit{ref}}` is of the form :math:`(\mathsf{ref{.}i{\scriptstyle 31}}~i)`.

      * The reference type :math:`{\mathit{rt}}` is of the form :math:`(\mathsf{ref}~\mathsf{i{\scriptstyle 31}})`.
   * Or:

      * The reference value :math:`{\mathit{ref}}` is of the form :math:`(\mathsf{ref{.}struct}~a)`.

      * The reference type :math:`{\mathit{rt}}` is of the form :math:`(\mathsf{ref}~{\mathit{dt}})`.

      * The structure instance :math:`s{.}\mathsf{structs}{}[a]` exists.

      * The defined type :math:`s{.}\mathsf{structs}{}[a]{.}\mathsf{type}` is of the form :math:`{\mathit{dt}}`.
   * Or:

      * The reference value :math:`{\mathit{ref}}` is of the form :math:`(\mathsf{ref{.}array}~a)`.

      * The reference type :math:`{\mathit{rt}}` is of the form :math:`(\mathsf{ref}~{\mathit{dt}})`.

      * The array instance :math:`s{.}\mathsf{arrays}{}[a]` exists.

      * The defined type :math:`s{.}\mathsf{arrays}{}[a]{.}\mathsf{type}` is of the form :math:`{\mathit{dt}}`.
   * Or:

      * The reference value :math:`{\mathit{ref}}` is of the form :math:`(\mathsf{ref{.}func}~a)`.

      * The reference type :math:`{\mathit{rt}}` is of the form :math:`(\mathsf{ref}~{\mathit{dt}})`.

      * The function instance :math:`s{.}\mathsf{funcs}{}[a]` exists.

      * The defined type :math:`s{.}\mathsf{funcs}{}[a]{.}\mathsf{type}` is of the form :math:`{\mathit{dt}}`.
   * Or:

      * The reference value :math:`{\mathit{ref}}` is of the form :math:`(\mathsf{ref{.}exn}~a)`.

      * The reference type :math:`{\mathit{rt}}` is of the form :math:`(\mathsf{ref}~\mathsf{exn})`.

      * The exception instance :math:`s{.}\mathsf{exns}{}[a]` exists.
   * Or:

      * The reference value :math:`{\mathit{ref}}` is of the form :math:`(\mathsf{ref{.}host}~a)`.

      * The reference type :math:`{\mathit{rt}}` is of the form :math:`(\mathsf{ref}~\mathsf{any})`.
   * Or:

      * The reference value :math:`{\mathit{ref}}` is of the form :math:`(\mathsf{ref{.}extern}~{\mathit{addrref}})`.

      * The reference type :math:`{\mathit{rt}}` is of the form :math:`(\mathsf{ref}~\mathsf{extern})`.

      * The reference value :math:`{\mathit{addrref}}` is :ref:`valid <valid-val>` with the reference type :math:`(\mathsf{ref}~\mathsf{any})`.
   * Or:

      * The reference value :math:`{\mathit{ref}}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}'}`.

      * The reference type :math:`{\mathit{rt}'}` :ref:`matches <match>` the reference type :math:`{\mathit{rt}}`.




The reference value :math:`(\mathsf{ref{.}null}~{\mathit{ht}})` is :ref:`valid <valid-val>` with the reference type :math:`(\mathsf{ref}~\mathsf{null}~{\mathit{ht}'})` if:


   * The heap type :math:`{\mathit{ht}'}` :ref:`matches <match>` the heap type :math:`{\mathit{ht}}`.




The reference value :math:`(\mathsf{ref{.}i{\scriptstyle 31}}~i)` is :ref:`valid <valid-val>` with the reference type :math:`(\mathsf{ref}~\mathsf{i{\scriptstyle 31}})`.




The reference value :math:`(\mathsf{ref{.}struct}~a)` is :ref:`valid <valid-val>` with the reference type :math:`(\mathsf{ref}~{\mathit{dt}})` if:


   * The structure instance :math:`s{.}\mathsf{structs}{}[a]` exists.

   * The defined type :math:`s{.}\mathsf{structs}{}[a]{.}\mathsf{type}` is of the form :math:`{\mathit{dt}}`.




The reference value :math:`(\mathsf{ref{.}array}~a)` is :ref:`valid <valid-val>` with the reference type :math:`(\mathsf{ref}~{\mathit{dt}})` if:


   * The array instance :math:`s{.}\mathsf{arrays}{}[a]` exists.

   * The defined type :math:`s{.}\mathsf{arrays}{}[a]{.}\mathsf{type}` is of the form :math:`{\mathit{dt}}`.




The reference value :math:`(\mathsf{ref{.}func}~a)` is :ref:`valid <valid-val>` with the reference type :math:`(\mathsf{ref}~{\mathit{dt}})` if:


   * The function instance :math:`s{.}\mathsf{funcs}{}[a]` exists.

   * The defined type :math:`s{.}\mathsf{funcs}{}[a]{.}\mathsf{type}` is of the form :math:`{\mathit{dt}}`.




The reference value :math:`(\mathsf{ref{.}exn}~a)` is :ref:`valid <valid-val>` with the reference type :math:`(\mathsf{ref}~\mathsf{exn})` if:


   * The exception instance :math:`s{.}\mathsf{exns}{}[a]` exists.




The reference value :math:`(\mathsf{ref{.}host}~a)` is :ref:`valid <valid-val>` with the reference type :math:`(\mathsf{ref}~\mathsf{any})`.




The reference value :math:`(\mathsf{ref{.}extern}~{\mathit{addrref}})` is :ref:`valid <valid-val>` with the reference type :math:`(\mathsf{ref}~\mathsf{extern})` if:


   * The reference value :math:`{\mathit{addrref}}` is :ref:`valid <valid-val>` with the reference type :math:`(\mathsf{ref}~\mathsf{any})`.




The reference value :math:`{\mathit{ref}}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}}` if:


   * The reference value :math:`{\mathit{ref}}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}'}`.

   * The reference type :math:`{\mathit{rt}'}` :ref:`matches <match>` the reference type :math:`{\mathit{rt}}`.




The value :math:`{\mathit{val}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{valtype}}` if:


   * Either:

      * The value :math:`{\mathit{val}}` is of the form :math:`{\mathit{num}}`.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathit{nt}}`.

      * The number value :math:`{\mathit{num}}` is :ref:`valid <valid-val>` with the number type :math:`{\mathit{nt}}`.

   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`{\mathit{vec}}`.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathit{vt}}`.

      * The vector value :math:`{\mathit{vec}}` is :ref:`valid <valid-val>` with the vector type :math:`{\mathit{vt}}`.
   * Or:

      * The value :math:`{\mathit{val}}` is of the form :math:`{\mathit{ref}}`.

      * The value type :math:`{\mathit{valtype}}` is of the form :math:`{\mathit{rt}}`.

      * The reference value :math:`{\mathit{ref}}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}}`.




The value :math:`{\mathit{num}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{nt}}` if:


   * The number value :math:`{\mathit{num}}` is :ref:`valid <valid-val>` with the number type :math:`{\mathit{nt}}`.




The value :math:`{\mathit{vec}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{vt}}` if:


   * The vector value :math:`{\mathit{vec}}` is :ref:`valid <valid-val>` with the vector type :math:`{\mathit{vt}}`.




The value :math:`{\mathit{ref}}` is :ref:`valid <valid-val>` with the value type :math:`{\mathit{rt}}` if:


   * The reference value :math:`{\mathit{ref}}` is :ref:`valid <valid-val>` with the reference type :math:`{\mathit{rt}}`.




The external address :math:`{\mathit{externaddr}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{externtype}}` if:


   * Either:

      * The external address :math:`{\mathit{externaddr}}` is of the form :math:`(\mathsf{tag}~a)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{tag}~{\mathit{taginst}}{.}\mathsf{type})`.

      * The tag instance :math:`s{.}\mathsf{tags}{}[a]` exists.

      * The tag instance :math:`s{.}\mathsf{tags}{}[a]` is of the form :math:`{\mathit{taginst}}`.

   * Or:

      * The external address :math:`{\mathit{externaddr}}` is of the form :math:`(\mathsf{global}~a)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{global}~{\mathit{globalinst}}{.}\mathsf{type})`.

      * The global instance :math:`s{.}\mathsf{globals}{}[a]` exists.

      * The global instance :math:`s{.}\mathsf{globals}{}[a]` is of the form :math:`{\mathit{globalinst}}`.
   * Or:

      * The external address :math:`{\mathit{externaddr}}` is of the form :math:`(\mathsf{mem}~a)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{mem}~{\mathit{meminst}}{.}\mathsf{type})`.

      * The memory instance :math:`s{.}\mathsf{mems}{}[a]` exists.

      * The memory instance :math:`s{.}\mathsf{mems}{}[a]` is of the form :math:`{\mathit{meminst}}`.
   * Or:

      * The external address :math:`{\mathit{externaddr}}` is of the form :math:`(\mathsf{table}~a)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{table}~{\mathit{tableinst}}{.}\mathsf{type})`.

      * The table instance :math:`s{.}\mathsf{tables}{}[a]` exists.

      * The table instance :math:`s{.}\mathsf{tables}{}[a]` is of the form :math:`{\mathit{tableinst}}`.
   * Or:

      * The external address :math:`{\mathit{externaddr}}` is of the form :math:`(\mathsf{func}~a)`.

      * The external type :math:`{\mathit{externtype}}` is of the form :math:`(\mathsf{func}~{\mathit{funcinst}}{.}\mathsf{type})`.

      * The function instance :math:`s{.}\mathsf{funcs}{}[a]` exists.

      * The function instance :math:`s{.}\mathsf{funcs}{}[a]` is of the form :math:`{\mathit{funcinst}}`.
   * Or:

      * The external address :math:`{\mathit{externaddr}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}'}`.

      * The external type :math:`{\mathit{xt}'}` :ref:`matches <match>` the external type :math:`{\mathit{externtype}}`.




The external address :math:`(\mathsf{tag}~a)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{tag}~{\mathit{taginst}}{.}\mathsf{type})` if:


   * The tag instance :math:`s{.}\mathsf{tags}{}[a]` exists.

   * The tag instance :math:`s{.}\mathsf{tags}{}[a]` is of the form :math:`{\mathit{taginst}}`.




The external address :math:`(\mathsf{global}~a)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{global}~{\mathit{globalinst}}{.}\mathsf{type})` if:


   * The global instance :math:`s{.}\mathsf{globals}{}[a]` exists.

   * The global instance :math:`s{.}\mathsf{globals}{}[a]` is of the form :math:`{\mathit{globalinst}}`.




The external address :math:`(\mathsf{mem}~a)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{mem}~{\mathit{meminst}}{.}\mathsf{type})` if:


   * The memory instance :math:`s{.}\mathsf{mems}{}[a]` exists.

   * The memory instance :math:`s{.}\mathsf{mems}{}[a]` is of the form :math:`{\mathit{meminst}}`.




The external address :math:`(\mathsf{table}~a)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{table}~{\mathit{tableinst}}{.}\mathsf{type})` if:


   * The table instance :math:`s{.}\mathsf{tables}{}[a]` exists.

   * The table instance :math:`s{.}\mathsf{tables}{}[a]` is of the form :math:`{\mathit{tableinst}}`.




The external address :math:`(\mathsf{func}~a)` is :ref:`valid <valid-val>` with the external type :math:`(\mathsf{func}~{\mathit{funcinst}}{.}\mathsf{type})` if:


   * The function instance :math:`s{.}\mathsf{funcs}{}[a]` exists.

   * The function instance :math:`s{.}\mathsf{funcs}{}[a]` is of the form :math:`{\mathit{funcinst}}`.




The external address :math:`{\mathit{externaddr}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}}` if:


   * The external address :math:`{\mathit{externaddr}}` is :ref:`valid <valid-val>` with the external type :math:`{\mathit{xt}'}`.

   * The external type :math:`{\mathit{xt}'}` :ref:`matches <match>` the external type :math:`{\mathit{xt}}`.




The identifier context :math:`I` is :ref:`valid <valid-val>` if:


   * :math:`{\bigoplus}\, I{.}\mathsf{types}~{\mathrm{disjoint}}` is true.

   * :math:`{\bigoplus}\, I{.}\mathsf{tags}~{\mathrm{disjoint}}` is true.

   * :math:`{\bigoplus}\, I{.}\mathsf{globals}~{\mathrm{disjoint}}` is true.

   * :math:`{\bigoplus}\, I{.}\mathsf{mems}~{\mathrm{disjoint}}` is true.

   * :math:`{\bigoplus}\, I{.}\mathsf{tables}~{\mathrm{disjoint}}` is true.

   * :math:`{\bigoplus}\, I{.}\mathsf{funcs}~{\mathrm{disjoint}}` is true.

   * :math:`{\bigoplus}\, I{.}\mathsf{datas}~{\mathrm{disjoint}}` is true.

   * :math:`{\bigoplus}\, I{.}\mathsf{elems}~{\mathrm{disjoint}}` is true.

   * :math:`{\bigoplus}\, I{.}\mathsf{locals}~{\mathrm{disjoint}}` is true.

   * :math:`{\bigoplus}\, I{.}\mathsf{labels}~{\mathrm{disjoint}}` is true.

   * For all :math:`{{\mathit{field}}^\ast}` in :math:`{{{\mathit{field}}^\ast}^\ast}`:

      * :math:`{\bigoplus}\, {{\mathit{field}}^\ast}~{\mathrm{disjoint}}` is true.

   * The name sequence sequence :math:`{{{\mathit{field}}^\ast}^\ast}` is of the form :math:`I{.}\mathsf{fields}`.




The instruction sequence :math:`{\mathit{instr}}` is :ref:`valid <valid-val>` with the instruction type :math:`{{\mathit{valtype}}^\ast}~\rightarrow~{{\mathit{valtype}'}^\ast}` if:


   * Either:

      * The instruction :math:`{\mathit{instr}}` is of the form :math:`(\mathsf{i{\scriptstyle 32}}~{.}~\mathsf{add})`.

      * The value type sequence :math:`{{\mathit{valtype}}^\ast}` is of the form :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}`.

      * The value type sequence :math:`{{\mathit{valtype}'}^\ast}` is of the form :math:`\mathsf{i{\scriptstyle 32}}`.

   * Or:

      * The instruction :math:`{\mathit{instr}}` is of the form :math:`(\mathsf{global{.}get}~x)`.

      * The value type sequence :math:`{{\mathit{valtype}}^\ast}` is empty.

      * The value type sequence :math:`{{\mathit{valtype}'}^\ast}` is of the form :math:`t`.

      * The global :math:`C{.}\mathsf{globals}{}[x]` exists.

      * The global :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`(\mathsf{mut}~t)`.
   * Or:

      * The instruction :math:`{\mathit{instr}}` is of the form :math:`(\mathsf{block}~{\mathit{blocktype}}~{{\mathit{instr}'}^\ast})`.

      * The block type :math:`{\mathit{blocktype}}` is :ref:`valid <valid-val>` as the instruction type :math:`{{\mathit{valtype}}^\ast}~\rightarrow~{{\mathit{valtype}'}^\ast}`.

      * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{{\mathit{valtype}'}^\ast}` prepended to the field :math:`\mathsf{labels}`.

      * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}'}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{{\mathit{valtype}}^\ast}~\rightarrow~{{\mathit{valtype}'}^\ast}`.




The instruction sequence :math:`(\mathsf{i{\scriptstyle 32}}~{.}~\mathsf{add})` is :ref:`valid <valid-val>` with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction sequence :math:`(\mathsf{global{.}get}~x)` is :ref:`valid <valid-val>` with the instruction type :math:`\epsilon~\rightarrow~t` if:


   * The global :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global :math:`C{.}\mathsf{globals}{}[x]` is of the form :math:`(\mathsf{mut}~t)`.




The instruction sequence :math:`(\mathsf{block}~{\mathit{blocktype}}~{{\mathit{instr}}^\ast})` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{blocktype}}` is :ref:`valid <valid-val>` as the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is :ref:`valid <valid-val>` with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.


:math:`\mathsf{br}~l`
.....................


1. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

#. Let :math:`L` be the topmost :math:`\mathsf{label}`.

#. Let :math:`n` be the arity of :math:`L`

#. If :math:`l = 0`, then:

   a. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

   #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

   #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{label}` from the stack.

   #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

   #. Jump to the continuation of :math:`L`.

#. Else:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{label}` from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`(\mathsf{br}~l - 1)`.


:math:`\mathsf{return\_call\_ref}~y`
....................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}''}` from the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{frame}`.

#. If :math:`{\mathit{val}''}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}`, then:

   a. Trap.

#. Assert: Due to validation, :math:`{\mathit{val}''}` is some :math:`\mathsf{ref{.}func}~{\mathit{funcaddr}}`.

#. Let :math:`(\mathsf{ref{.}func}~a)` be the destructuring of :math:`{\mathit{val}''}`.

#. Assert: Due to validation, :math:`a < {|z{.}\mathsf{funcs}|}`.

#. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{funcs}{}[a]{.}\mathsf{type}` is some :math:`\mathsf{func}~{\mathit{resulttype}} \rightarrow {\mathit{resulttype}}`.

#. Let :math:`(\mathsf{func}~{t_1^{n}}~\rightarrow~{t_2^{m}})` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{funcs}{}[a]{.}\mathsf{type}`.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

#. Pop the :math:`\mathsf{frame}` from the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Push the value :math:`(\mathsf{ref{.}func}~a)` to the stack.

#. Execute the instruction :math:`(\mathsf{call\_ref}~y)`.


:math:`\mathsf{throw\_ref}`
...........................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`(\mathsf{ref{.}exn}~a)` from the stack.

#. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, :math:`{{\mathit{val}}^\ast} \neq \epsilon`.

#. Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

#. Execute the instruction :math:`\mathsf{throw\_ref}`.


:math:`\mathsf{throw\_ref}`
...........................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`(\mathsf{ref{.}exn}~a)` from the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{handler}`.

#. Let :math:`H` be the topmost :math:`\mathsf{handler}`.

#. Let :math:`n` be the arity of :math:`H`

#. Let :math:`{{\mathit{catch}''}^\ast}` be the catch handler of :math:`H`

#. If :math:`{{\mathit{catch}''}^\ast} = \epsilon`, then:

   a. Pop the :math:`\mathsf{handler}` from the stack.

   #. Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

   #. Execute the instruction :math:`\mathsf{throw\_ref}`.

#. Else if :math:`a \geq {|z{.}\mathsf{exns}|}`, then:

   a. Let :math:`{\mathit{catch}}_0~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}''}^\ast}`.

   #. If :math:`{\mathit{catch}}_0` is some :math:`\mathsf{catch\_all}~{\mathit{labelidx}}`, then:

      1) Let :math:`(\mathsf{catch\_all}~l)` be the destructuring of :math:`{\mathit{catch}}_0`.

      #) Pop the :math:`\mathsf{handler}` from the stack.

      #) Execute the instruction :math:`(\mathsf{br}~l)`.

   #. Else if :math:`{\mathit{catch}}_0` is not some :math:`\mathsf{catch\_all\_ref}~{\mathit{labelidx}}`, then:

      1) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}''}^\ast}`.

      #) Pop the :math:`\mathsf{handler}` from the stack.

      #) Let :math:`{H'}` be the :math:`\mathsf{handler}` whose arity is :math:`n` and whose catch handler is :math:`{{\mathit{catch}'}^\ast}`.

      #) Push the :math:`\mathsf{handler}` :math:`{H'}`.

      #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

      #) Execute the instruction :math:`\mathsf{throw\_ref}`.

   #. Else:

      1) Let :math:`(\mathsf{catch\_all\_ref}~l)` be the destructuring of :math:`{\mathit{catch}}_0`.

      #) Pop the :math:`\mathsf{handler}` from the stack.

      #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

      #) Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

   a. Let :math:`{{\mathit{val}}^\ast}` be :math:`z{.}\mathsf{exns}{}[a]{.}\mathsf{fields}`.

   #. Let :math:`{\mathit{catch}}_0~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}''}^\ast}`.

   #. If :math:`{\mathit{catch}}_0` is some :math:`\mathsf{catch}~{\mathit{tagidx}}~{\mathit{labelidx}}`, then:

      1) Let :math:`(\mathsf{catch}~x~l)` be the destructuring of :math:`{\mathit{catch}}_0`.

      #) If :math:`x < {|z{.}\mathsf{tags}|}` and :math:`z{.}\mathsf{exns}{}[a]{.}\mathsf{tag} = z{.}\mathsf{tags}{}[x]`, then:

         a) Pop the :math:`\mathsf{handler}` from the stack.

         #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

         #) Execute the instruction :math:`(\mathsf{br}~l)`.

      #) Else:

         a) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}''}^\ast}`.

         #) Pop the :math:`\mathsf{handler}` from the stack.

         #) Let :math:`{H'}` be the :math:`\mathsf{handler}` whose arity is :math:`n` and whose catch handler is :math:`{{\mathit{catch}'}^\ast}`.

         #) Push the :math:`\mathsf{handler}` :math:`{H'}`.

         #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

         #) Execute the instruction :math:`\mathsf{throw\_ref}`.

   #. Else if :math:`{\mathit{catch}}_0` is some :math:`\mathsf{catch\_ref}~{\mathit{tagidx}}~{\mathit{labelidx}}`, then:

      1) Let :math:`(\mathsf{catch\_ref}~x~l)` be the destructuring of :math:`{\mathit{catch}}_0`.

      #) If :math:`x \geq {|z{.}\mathsf{tags}|}` or :math:`z{.}\mathsf{exns}{}[a]{.}\mathsf{tag} \neq z{.}\mathsf{tags}{}[x]`, then:

         a) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}''}^\ast}`.

         #) Pop the :math:`\mathsf{handler}` from the stack.

         #) Let :math:`{H'}` be the :math:`\mathsf{handler}` whose arity is :math:`n` and whose catch handler is :math:`{{\mathit{catch}'}^\ast}`.

         #) Push the :math:`\mathsf{handler}` :math:`{H'}`.

         #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

         #) Execute the instruction :math:`\mathsf{throw\_ref}`.

      #) Else:

         a) Pop the :math:`\mathsf{handler}` from the stack.

         #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

         #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

         #) Execute the instruction :math:`(\mathsf{br}~l)`.

   #. Else:

      1) If :math:`{\mathit{catch}}_0` is some :math:`\mathsf{catch\_all}~{\mathit{labelidx}}`, then:

         a) Let :math:`(\mathsf{catch\_all}~l)` be the destructuring of :math:`{\mathit{catch}}_0`.

         #) Pop the :math:`\mathsf{handler}` from the stack.

         #) Execute the instruction :math:`(\mathsf{br}~l)`.

      #) Else if :math:`{\mathit{catch}}_0` is not some :math:`\mathsf{catch\_all\_ref}~{\mathit{labelidx}}`, then:

         a) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}''}^\ast}`.

         #) Pop the :math:`\mathsf{handler}` from the stack.

         #) Let :math:`H` be the :math:`\mathsf{handler}` whose arity is :math:`n` and whose catch handler is :math:`{{\mathit{catch}'}^\ast}`.

         #) Push the :math:`\mathsf{handler}` :math:`H`.

         #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

         #) Execute the instruction :math:`\mathsf{throw\_ref}`.

      #) Else:

         a) Let :math:`(\mathsf{catch\_all\_ref}~l)` be the destructuring of :math:`{\mathit{catch}}_0`.

         #) Pop the :math:`\mathsf{handler}` from the stack.

         #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

         #) Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{table{.}copy}~x_1~x_2`
.....................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` from the stack.

#. If :math:`i_1 + n > {|z{.}\mathsf{tables}{}[x_1]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`i_2 + n > {|z{.}\mathsf{tables}{}[x_2]{.}\mathsf{refs}|}`, then:

   a. Trap.


:math:`\mathsf{table{.}init}~x~y`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

   a. Trap.


:math:`{\mathit{nt}}{.}\mathsf{load}~x~{\mathit{ao}}`
.....................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}}|} / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathit{nt}}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}}|} / 8]`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{N}{.}\mathsf{load}}{{n}{\mathsf{\_}}{{\mathit{sx}}}}~x~{\mathit{ao}}`
..........................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8]`.

#. Push the value :math:`({\mathsf{i}}{N}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{n, {|{\mathsf{i}}{N}|}}^{{\mathit{sx}}}}}{(c)})` to the stack.


:math:`{\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{M}{\mathsf{x}}{K}{\mathsf{\_}}{{\mathit{sx}}}}~x~{\mathit{ao}}`
......................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + M \cdot K / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`{j^{K}}` be the result for which :math:`{({{\mathrm{bytes}}}_{{\mathsf{i}}{M}}({j^{K}}) = z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} + k \cdot M / 8 : M / 8])^{k<K}}`.

#. Let :math:`{\mathsf{i}}{N}` be the result for which :math:`N` :math:`=` :math:`M \cdot 2`.

#. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{K}}^{{-1}}}}{({{{{{\mathrm{extend}}}_{M, N}^{{\mathit{sx}}}}}{(j)}^{K}})}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{N}{\mathsf{\_}}{\mathsf{splat}}}~x~{\mathit{ao}}`
........................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`M` be :math:`128 / N`.

#. Let :math:`{\mathsf{i}}{N}` be the result for which :math:`{|{\mathsf{i}}{N}|}` :math:`=` :math:`N`.

#. Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

#. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({j^{M}})}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{N}{\mathsf{\_}}{\mathsf{zero}}}~x~{\mathit{ao}}`
.......................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

#. Let :math:`c` be :math:`{{{{\mathrm{extend}}}_{N, 128}^{\mathsf{u}}}}{(j)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{memory{.}copy}~x_1~x_2`
......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` from the stack.

#. If :math:`i_1 + n > {|z{.}\mathsf{mems}{}[x_1]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`i_2 + n > {|z{.}\mathsf{mems}{}[x_2]{.}\mathsf{bytes}|}`, then:

   a. Trap.


:math:`\mathsf{memory{.}init}~x~y`
..................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}|}`, then:

   a. Trap.


:math:`{\mathit{nt}}{.}\mathsf{store}~x~{\mathit{ao}}`
......................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}}|} / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathit{nt}}}(c)`.

#. Replace :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}}|} / 8]` with :math:`{b^\ast}`.


:math:`{{\mathsf{i}}{N}{.}\mathsf{store}}{n}~x~{\mathit{ao}}`
.............................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`{\mathsf{i}}{N}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}({{\mathrm{wrap}}}_{{|{\mathsf{i}}{N}|}, n}(c))`.

#. Replace :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8]` with :math:`{b^\ast}`.


:math:`\mathsf{unreachable}`
............................


1. Trap.


:math:`\mathsf{nop}`
....................


1. Do nothing.


:math:`\mathsf{drop}`
.....................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.


:math:`\mathsf{select}~{({t^\ast})^?}`
......................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_2` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_1` from the stack.

#. If :math:`c \neq 0`, then:

   a. Push the value :math:`{\mathit{val}}_1` to the stack.

#. Else:

   a. Push the value :math:`{\mathit{val}}_2` to the stack.


:math:`\mathsf{if}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast}~{{\mathit{instr}}_2^\ast}`
.....................................................................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

   a. Execute the instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast})`.

#. Else:

   a. Execute the instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}_2^\ast})`.


:math:`\mathsf{label}`
......................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

#. Pop the :math:`\mathsf{label}` from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.


:math:`\mathsf{br}~l`
.....................


1. If the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

   a. Let :math:`L` be the topmost :math:`\mathsf{label}`.

   #. Let :math:`n` be the arity of :math:`L`

   #. If :math:`l = 0`, then:

      1) Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

      #) Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

      #) Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

      #) Pop the :math:`\mathsf{label}` from the stack.

      #) Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

      #) Jump to the continuation of :math:`L`.

   #. Else:

      1) Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

      #) Pop the :math:`\mathsf{label}` from the stack.

      #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

      #) Execute the instruction :math:`(\mathsf{br}~l - 1)`.

#. Else:

   a. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{handler}`.

   #. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{handler}` from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{br\_if}~l`
.........................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

   a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

   a. Do nothing.


:math:`\mathsf{br\_table}~{l^\ast}~{l'}`
........................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i < {|{l^\ast}|}`, then:

   a. Execute the instruction :math:`(\mathsf{br}~{l^\ast}{}[i])`.

#. Else:

   a. Execute the instruction :math:`(\mathsf{br}~{l'})`.


:math:`\mathsf{br\_on\_null}~l`
...............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}`, then:

   a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

   a. Push the value :math:`{\mathit{val}}` to the stack.


:math:`\mathsf{br\_on\_non\_null}~l`
....................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}`, then:

   a. Do nothing.

#. Else:

   a. Push the value :math:`{\mathit{val}}` to the stack.

   #. Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{call\_indirect}~x~y`
...................................


1. Execute the instruction :math:`(\mathsf{table{.}get}~x)`.

#. Execute the instruction :math:`(\mathsf{ref{.}cast}~(\mathsf{ref}~\mathsf{null}~y))`.

#. Execute the instruction :math:`(\mathsf{call\_ref}~y)`.


:math:`\mathsf{return\_call\_indirect}~x~y`
...........................................


1. Execute the instruction :math:`(\mathsf{table{.}get}~x)`.

#. Execute the instruction :math:`(\mathsf{ref{.}cast}~(\mathsf{ref}~\mathsf{null}~y))`.

#. Execute the instruction :math:`(\mathsf{return\_call\_ref}~y)`.


:math:`\mathsf{frame}`
......................


1. Let :math:`f` be the topmost :math:`\mathsf{frame}`.

#. Let :math:`n` be the arity of :math:`f`

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{frame}`.

#. Pop the :math:`\mathsf{frame}` from the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.


:math:`\mathsf{return}`
.......................


1. If the first non-value entry of the stack is a :math:`\mathsf{frame}`, then:

   a. Let :math:`f` be the topmost :math:`\mathsf{frame}`.

   #. Let :math:`n` be the arity of :math:`f`

   #. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

   #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

   #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{frame}` from the stack.

   #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Else if the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{label}` from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`\mathsf{return}`.

#. Else:

   a. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{handler}`.

   #. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{handler}` from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`\mathsf{return}`.


:math:`\mathsf{handler}`
........................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{handler}`.

#. Pop the :math:`\mathsf{handler}` from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.


:math:`\mathsf{local{.}tee}~x`
..............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Execute the instruction :math:`(\mathsf{local{.}set}~x)`.


:math:`\mathsf{ref{.}i{\scriptstyle 31}}`
.........................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Push the value :math:`(\mathsf{ref{.}i{\scriptstyle 31}}~{{\mathrm{wrap}}}_{32, 31}(i))` to the stack.


:math:`\mathsf{ref{.}is\_null}`
...............................


1. Assert: Due to validation, a reference value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. If :math:`{\mathit{ref}}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}`, then:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`\mathsf{ref{.}as\_non\_null}`
....................................


1. Assert: Due to validation, a reference value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. If :math:`{\mathit{ref}}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}`, then:

   a. Trap.

#. Push the value :math:`{\mathit{ref}}` to the stack.


:math:`\mathsf{ref{.}eq}`
.........................


1. Assert: Due to validation, a reference value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}_2` from the stack.

#. Assert: Due to validation, a reference value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}_1` from the stack.

#. If :math:`{\mathit{ref}}_1` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}` and :math:`{\mathit{ref}}_2` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}`, then:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else if :math:`{\mathit{ref}}_1 = {\mathit{ref}}_2`, then:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`{\mathsf{i{\scriptstyle 31}{.}get}}{\mathsf{\_}}{{\mathit{sx}}}`
.......................................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}`, then:

   a. Trap.

#. Assert: Due to validation, :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}i{\scriptstyle 31}}~{\mathit{u{\kern-0.1em\scriptstyle 31}}}`.

#. Let :math:`(\mathsf{ref{.}i{\scriptstyle 31}}~i)` be the destructuring of :math:`{\mathit{val}}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{31, 32}^{{\mathit{sx}}}}}{(i)})` to the stack.


:math:`\mathsf{array{.}new}~x`
..............................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)`.


:math:`\mathsf{extern{.}convert\_any}`
......................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}`, then:

   a. Push the value :math:`(\mathsf{ref{.}null}~\mathsf{extern})` to the stack.

#. If :math:`{\mathit{val}}` is address value, then:

   a. Push the value :math:`(\mathsf{ref{.}extern}~{\mathit{val}})` to the stack.


:math:`\mathsf{any{.}convert\_extern}`
......................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}`, then:

   a. Push the value :math:`(\mathsf{ref{.}null}~\mathsf{any})` to the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}extern}~{\mathit{addrref}}`, then:

   a. Let :math:`(\mathsf{ref{.}extern}~{\mathit{addrref}})` be the destructuring of :math:`{\mathit{val}}`.

   #. Push the value :math:`{\mathit{addrref}}` to the stack.


:math:`{\mathit{nt}}~{.}~{\mathit{unop}}`
.........................................


1. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{unop}}}{{}_{{\mathit{nt}}}(c_1)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{unop}}}{{}_{{\mathit{nt}}}(c_1)}`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}}~{.}~{\mathit{binop}}`
..........................................


1. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{binop}}}{{}_{{\mathit{nt}}}(c_1, c_2)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{binop}}}{{}_{{\mathit{nt}}}(c_1, c_2)}`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}}~{.}~{\mathit{testop}}`
...........................................


1. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{testop}}}{{}_{{\mathit{nt}}}(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}}~{.}~{\mathit{relop}}`
..........................................


1. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{relop}}}{{}_{{\mathit{nt}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathit{nt}}_2~{.}~{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_1}`
............................................................................


1. Assert: Due to validation, a value of number type :math:`{\mathit{nt}}_1` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{cvtop}}}{{}_{{\mathit{nt}}_1, {\mathit{nt}}_2}(c_1)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{cvtop}}}{{}_{{\mathit{nt}}_1, {\mathit{nt}}_2}(c_1)}`.

#. Push the value :math:`({\mathit{nt}}_2{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}}~{.}~{\mathit{vvunop}}`
..........................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{|{{\mathit{vvunop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1)}|} > 0`.

#. Let :math:`c` be an element of :math:`{{\mathit{vvunop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}}~{.}~{\mathit{vvbinop}}`
...........................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{|{{\mathit{vvbinop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2)}|} > 0`.

#. Let :math:`c` be an element of :math:`{{\mathit{vvbinop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}}~{.}~{\mathit{vvternop}}`
............................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_3)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{|{{\mathit{vvternop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2, c_3)}|} > 0`.

#. Let :math:`c` be an element of :math:`{{\mathit{vvternop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2, c_3)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}}~{.}~\mathsf{any\_true}`
...........................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{ine}}}_{{|\mathsf{v{\scriptstyle 128}}|}}(c_1, 0)`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}~{.}~{\mathit{vunop}}`
..........................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{vunop}}}{{}_{{\mathit{sh}}}(c_1)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vunop}}}{{}_{{\mathit{sh}}}(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}~{.}~{\mathit{vbinop}}`
...........................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{vbinop}}}{{}_{{\mathit{sh}}}(c_1, c_2)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vbinop}}}{{}_{{\mathit{sh}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}~{.}~{\mathit{vternop}}`
............................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_3)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{vternop}}}{{}_{{\mathit{sh}}}(c_1, c_2, c_3)}` is empty, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vternop}}}{{}_{{\mathit{sh}}}(c_1, c_2, c_3)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}~{.}~{\mathit{vtestop}}`
............................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`i` be :math:`{{\mathit{vtestop}}}{{}_{{\mathit{sh}}}(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.


:math:`{\mathit{sh}}~{.}~{\mathit{vrelop}}`
...........................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vrelop}}}{{}_{{\mathit{sh}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}~{.}~{\mathit{vshiftop}}`
.............................................


1. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vshiftop}}}{{}_{{\mathit{sh}}}}{(c_1, i)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}{.}\mathsf{bitmask}`
........................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{\mathsf{vbitmask}}{{}_{{\mathit{sh}}}(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}~{.}~{\mathit{swizzlop}}`
.............................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{swizzlop}}}{{}_{{\mathit{sh}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}{.}\mathsf{shuffle}~{i^\ast}`
.................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{\mathsf{vshuffle}}{{}_{{\mathit{sh}}}({i^\ast}, c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{N}}{\mathsf{x}}{M}{.}\mathsf{splat}`
.........................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0 = {\mathrm{unpack}}({\mathsf{i}}{N})`.

#. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({{{\mathrm{pack}}}_{{\mathsf{i}}{N}}(c_1)^{M}})}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{{\mathit{lanetype}}}{\mathsf{x}}{M}{.}\mathsf{extract\_lane}}{\mathsf{\_}}{{{\mathit{sx}'}^?}}~i`
..........................................................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{sx}'}^?}` is not defined, then:

   a. Assert: Due to validation, :math:`{\mathit{lanetype}}` is number type.

   #. Assert: Due to validation, :math:`i < {|{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}(c_1)|}`.

   #. Let :math:`c_2` be :math:`{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}(c_1){}[i]`.

   #. Push the value :math:`({\mathit{lanetype}}{.}\mathsf{const}~c_2)` to the stack.

#. Else:

   a. Assert: Due to validation, :math:`{\mathit{lanetype}}` is packed type.

   #. Let :math:`{\mathit{sx}}` be :math:`{{\mathit{sx}'}^?}`.

   #. Assert: Due to validation, :math:`i < {|{{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}(c_1)|}`.

   #. Let :math:`c_2` be :math:`{{{{\mathrm{extend}}}_{{|{\mathit{lanetype}}|}, 32}^{{\mathit{sx}}}}}{({{\mathrm{lanes}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}(c_1){}[i])}`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c_2)` to the stack.


:math:`{{\mathsf{i}}{N}}{\mathsf{x}}{M}{.}\mathsf{replace\_lane}~i`
...................................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0 = {\mathrm{unpack}}({\mathsf{i}}{N})`.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c_1){}[{}[i] = {{\mathrm{pack}}}_{{\mathsf{i}}{N}}(c_2)])}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathit{sh}}_2~{.}~{\mathit{vextunop}}}{\mathsf{\_}}{{\mathit{sh}}_1}`
...............................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vextunop}}}{{}_{{\mathit{sh}}_1, {\mathit{sh}}_2}(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathit{sh}}_2~{.}~{\mathit{vextbinop}}}{\mathsf{\_}}{{\mathit{sh}}_1}`
................................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vextbinop}}}{{}_{{\mathit{sh}}_1, {\mathit{sh}}_2}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathit{sh}}_2~{.}~{\mathit{vextternop}}}{\mathsf{\_}}{{\mathit{sh}}_1}`
.................................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_3)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vextternop}}}{{}_{{\mathit{sh}}_1, {\mathit{sh}}_2}(c_1, c_2, c_3)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathit{sh}}_2{.}\mathsf{narrow}}{\mathsf{\_}}{{\mathit{sh}}_1}{\mathsf{\_}}{{\mathit{sx}}}`
.....................................................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{\mathsf{vnarrow}}{{{}_{{\mathit{sh}}_1, {\mathit{sh}}_2}^{{\mathit{sx}}}}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathit{sh}}_2~{.}~{\mathit{vcvtop}}}{\mathsf{\_}}{{\mathit{sh}}_1}`
.............................................................................


1. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{vcvtop}}}_{{\mathit{sh}}_1, {\mathit{sh}}_2}({\mathit{vcvtop}}, c_1)`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}^\ast}`
............................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{m}}~{\rightarrow}_{{{\mathit{localidx}}_0^\ast}}\,{t_2^{n}}` be the destructuring of :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, :math:`{{\mathit{localidx}}_0^\ast} = \epsilon`.

#. Assert: Due to validation, there are at least :math:`m` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{m}}` from the stack.

#. Let :math:`L` be the :math:`\mathsf{label}` whose arity is :math:`n` and whose continuation is the end of the block.

#. Enter the block :math:`{{\mathit{val}}^{m}}~{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` :math:`L`.


:math:`\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast}`
...........................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{m}}~{\rightarrow}_{{{\mathit{localidx}}_0^\ast}}\,{t_2^{n}}` be the destructuring of :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, :math:`{{\mathit{localidx}}_0^\ast} = \epsilon`.

#. Assert: Due to validation, there are at least :math:`m` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{m}}` from the stack.

#. Let :math:`L` be the :math:`\mathsf{label}` whose arity is :math:`m` and whose continuation is the start of the block.

#. Enter the block :math:`{{\mathit{val}}^{m}}~{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` :math:`L`.


:math:`\mathsf{br\_on\_cast}~l~{\mathit{rt}}_1~{\mathit{rt}}_2`
...............................................................


1. Let :math:`f` be the topmost :math:`\mathsf{frame}`.

#. Assert: Due to validation, a reference value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Let :math:`{\mathit{rt}}` be the type of :math:`{\mathit{ref}}`.

#. Push the value :math:`{\mathit{ref}}` to the stack.

#. If :math:`{\mathit{rt}}` matches :math:`{{\mathrm{inst}}}_{f{.}\mathsf{module}}({\mathit{rt}}_2)`, then:

   a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

   a. Do nothing.


:math:`\mathsf{br\_on\_cast\_fail}~l~{\mathit{rt}}_1~{\mathit{rt}}_2`
.....................................................................


1. Let :math:`f` be the topmost :math:`\mathsf{frame}`.

#. Assert: Due to validation, a reference value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Let :math:`{\mathit{rt}}` be the type of :math:`{\mathit{ref}}`.

#. Push the value :math:`{\mathit{ref}}` to the stack.

#. If :math:`{\mathit{rt}}` matches :math:`{{\mathrm{inst}}}_{f{.}\mathsf{module}}({\mathit{rt}}_2)`, then:

   a. Do nothing.

#. Else:

   a. Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{call}~x`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Let :math:`a` be the address :math:`z{.}\mathsf{module}{.}\mathsf{funcs}{}[x]`.

#. Assert: Due to validation, :math:`a < {|z{.}\mathsf{funcs}|}`.

#. Push the value :math:`(\mathsf{ref{.}func}~a)` to the stack.

#. Execute the instruction :math:`(\mathsf{call\_ref}~z{.}\mathsf{funcs}{}[a]{.}\mathsf{type})`.


:math:`\mathsf{call\_ref}~y`
............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}'}` from the stack.

#. If :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}`, then:

   a. Trap.

#. Assert: Due to validation, :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}func}~{\mathit{funcaddr}}`.

#. Let :math:`(\mathsf{ref{.}func}~a)` be the destructuring of :math:`{\mathit{val}'}`.

#. Assert: Due to validation, :math:`a < {|z{.}\mathsf{funcs}|}`.

#. Let :math:`{\mathit{fi}}` be the function instance :math:`z{.}\mathsf{funcs}{}[a]`.

#. Assert: Due to validation, :math:`{\mathit{fi}}{.}\mathsf{code}` is some :math:`\mathsf{func}~{\mathit{typeidx}}~{{\mathit{local}}^\ast}~{\mathit{expr}}`.

#. Let :math:`(\mathsf{func}~x~{{\mathit{local}}_0^\ast}~{{\mathit{instr}}^\ast})` be the destructuring of :math:`{\mathit{fi}}{.}\mathsf{code}`.

#. Let :math:`{t^\ast}` be the value type sequence :math:`\epsilon`.

#. For each :math:`{\mathit{local}}_0` in :math:`{{\mathit{local}}_0^\ast}`, do:

   a. Let :math:`(\mathsf{local}~t)` be the destructuring of :math:`{\mathit{local}}_0`.

   #. Append :math:`t` to :math:`{t^\ast}`.

#. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`{\mathit{fi}}{.}\mathsf{type}` is some :math:`\mathsf{func}~{\mathit{resulttype}} \rightarrow {\mathit{resulttype}}`.

#. Let :math:`(\mathsf{func}~{t_1^{n}}~\rightarrow~{t_2^{m}})` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`{\mathit{fi}}{.}\mathsf{type}`.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Let :math:`f` be the frame :math:`\{ \mathsf{locals}~{{\mathit{val}}^{n}}~{{{\mathrm{default}}}_{t}^\ast},\;\allowbreak \mathsf{module}~{\mathit{fi}}{.}\mathsf{module} \}`.

#. Let :math:`{f'}` be the :math:`\mathsf{frame}` :math:`f` whose arity is :math:`m`.

#. Push the :math:`\mathsf{frame}` :math:`{f'}`.

#. Let :math:`L` be the :math:`\mathsf{label}` whose arity is :math:`m` and whose continuation is the end of the block.

#. Enter the block :math:`{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` :math:`L`.


:math:`\mathsf{return\_call}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Let :math:`a` be the address :math:`z{.}\mathsf{module}{.}\mathsf{funcs}{}[x]`.

#. Assert: Due to validation, :math:`a < {|z{.}\mathsf{funcs}|}`.

#. Push the value :math:`(\mathsf{ref{.}func}~a)` to the stack.

#. Execute the instruction :math:`(\mathsf{return\_call\_ref}~z{.}\mathsf{funcs}{}[a]{.}\mathsf{type})`.


:math:`\mathsf{return\_call\_ref}~y`
....................................


1. Let :math:`z` be the current state.

#. If the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{label}` from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`(\mathsf{return\_call\_ref}~y)`.

#. Else if the first non-value entry of the stack is a :math:`\mathsf{handler}`, then:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{handler}` from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`(\mathsf{return\_call\_ref}~y)`.

#. Else:

   a. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{frame}`.

   #. Assert: Due to validation, a value is on the top of the stack.

   #. Pop the value :math:`{\mathit{val}''}` from the stack.

   #. If :math:`{\mathit{val}''}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}`, then:

      1) Trap.

   #. Assert: Due to validation, :math:`{\mathit{val}''}` is some :math:`\mathsf{ref{.}func}~{\mathit{funcaddr}}`.

   #. Let :math:`(\mathsf{ref{.}func}~a)` be the destructuring of :math:`{\mathit{val}''}`.

   #. Assert: Due to validation, :math:`a < {|z{.}\mathsf{funcs}|}`.

   #. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{funcs}{}[a]{.}\mathsf{type}` is some :math:`\mathsf{func}~{\mathit{resulttype}} \rightarrow {\mathit{resulttype}}`.

   #. Let :math:`(\mathsf{func}~{t_1^{n}}~\rightarrow~{t_2^{m}})` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{funcs}{}[a]{.}\mathsf{type}`.

   #. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

   #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

   #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

   #. Pop the :math:`\mathsf{frame}` from the stack.

   #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

   #. Push the value :math:`(\mathsf{ref{.}func}~a)` to the stack.

   #. Execute the instruction :math:`(\mathsf{call\_ref}~y)`.


:math:`\mathsf{throw\_ref}`
...........................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}'}` from the stack.

#. If :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}`, then:

   a. Trap.

#. If :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}exn}~{\mathit{exnaddr}}`, then:

   a. Let :math:`(\mathsf{ref{.}exn}~a)` be the destructuring of :math:`{\mathit{val}'}`.

   #. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. If :math:`{{\mathit{val}}^\ast} \neq \epsilon`, then:

      1) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

      #) Execute the instruction :math:`\mathsf{throw\_ref}`.

   #. Else if the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

      1) Pop the :math:`\mathsf{label}` from the stack.

      #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

      #) Execute the instruction :math:`\mathsf{throw\_ref}`.

   #. Else:

      1) If the first non-value entry of the stack is a :math:`\mathsf{frame}`, then:

         a) Pop the :math:`\mathsf{frame}` from the stack.

         #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

         #) Execute the instruction :math:`\mathsf{throw\_ref}`.

      #) Else if the first non-value entry of the stack is not a :math:`\mathsf{handler}`, then:

         a) Throw the exception :math:`{\mathit{val}'}` as a result.

      #) Else:

         a) Let :math:`H` be the topmost :math:`\mathsf{handler}`.

         #) Let :math:`n` be the arity of :math:`H`

         #) Let :math:`{{\mathit{catch}''}^\ast}` be the catch handler of :math:`H`

         #) If :math:`{{\mathit{catch}''}^\ast} = \epsilon`, then:

            1. Pop the :math:`\mathsf{handler}` from the stack.

            #. Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

            #. Execute the instruction :math:`\mathsf{throw\_ref}`.

         #) Else if :math:`a \geq {|z{.}\mathsf{exns}|}`, then:

            1. Let :math:`{\mathit{catch}}_0~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}''}^\ast}`.

            #. If :math:`{\mathit{catch}}_0` is some :math:`\mathsf{catch\_all}~{\mathit{labelidx}}`, then:

               a. Let :math:`(\mathsf{catch\_all}~l)` be the destructuring of :math:`{\mathit{catch}}_0`.

               #. Pop the :math:`\mathsf{handler}` from the stack.

               #. Execute the instruction :math:`(\mathsf{br}~l)`.

            #. Else if :math:`{\mathit{catch}}_0` is not some :math:`\mathsf{catch\_all\_ref}~{\mathit{labelidx}}`, then:

               a. Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}''}^\ast}`.

               #. Pop the :math:`\mathsf{handler}` from the stack.

               #. Let :math:`{H'}` be the :math:`\mathsf{handler}` whose arity is :math:`n` and whose catch handler is :math:`{{\mathit{catch}'}^\ast}`.

               #. Push the :math:`\mathsf{handler}` :math:`{H'}`.

               #. Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

               #. Execute the instruction :math:`\mathsf{throw\_ref}`.

            #. Else:

               a. Let :math:`(\mathsf{catch\_all\_ref}~l)` be the destructuring of :math:`{\mathit{catch}}_0`.

               #. Pop the :math:`\mathsf{handler}` from the stack.

               #. Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

               #. Execute the instruction :math:`(\mathsf{br}~l)`.

         #) Else:

            1. Let :math:`{{\mathit{val}}^\ast}` be :math:`z{.}\mathsf{exns}{}[a]{.}\mathsf{fields}`.

            #. Let :math:`{\mathit{catch}}_0~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}''}^\ast}`.

            #. If :math:`{\mathit{catch}}_0` is some :math:`\mathsf{catch}~{\mathit{tagidx}}~{\mathit{labelidx}}`, then:

               a. Let :math:`(\mathsf{catch}~x~l)` be the destructuring of :math:`{\mathit{catch}}_0`.

               #. If :math:`x < {|z{.}\mathsf{tags}|}` and :math:`z{.}\mathsf{exns}{}[a]{.}\mathsf{tag} = z{.}\mathsf{tags}{}[x]`, then:

                  1) Pop the :math:`\mathsf{handler}` from the stack.

                  #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

                  #) Execute the instruction :math:`(\mathsf{br}~l)`.

               #. Else:

                  1) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}''}^\ast}`.

                  #) Pop the :math:`\mathsf{handler}` from the stack.

                  #) Let :math:`{H'}` be the :math:`\mathsf{handler}` whose arity is :math:`n` and whose catch handler is :math:`{{\mathit{catch}'}^\ast}`.

                  #) Push the :math:`\mathsf{handler}` :math:`{H'}`.

                  #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

                  #) Execute the instruction :math:`\mathsf{throw\_ref}`.

            #. Else if :math:`{\mathit{catch}}_0` is some :math:`\mathsf{catch\_ref}~{\mathit{tagidx}}~{\mathit{labelidx}}`, then:

               a. Let :math:`(\mathsf{catch\_ref}~x~l)` be the destructuring of :math:`{\mathit{catch}}_0`.

               #. If :math:`x \geq {|z{.}\mathsf{tags}|}` or :math:`z{.}\mathsf{exns}{}[a]{.}\mathsf{tag} \neq z{.}\mathsf{tags}{}[x]`, then:

                  1) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}''}^\ast}`.

                  #) Pop the :math:`\mathsf{handler}` from the stack.

                  #) Let :math:`{H'}` be the :math:`\mathsf{handler}` whose arity is :math:`n` and whose catch handler is :math:`{{\mathit{catch}'}^\ast}`.

                  #) Push the :math:`\mathsf{handler}` :math:`{H'}`.

                  #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

                  #) Execute the instruction :math:`\mathsf{throw\_ref}`.

               #. Else:

                  1) Pop the :math:`\mathsf{handler}` from the stack.

                  #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

                  #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

                  #) Execute the instruction :math:`(\mathsf{br}~l)`.

            #. Else:

               a. If :math:`{\mathit{catch}}_0` is some :math:`\mathsf{catch\_all}~{\mathit{labelidx}}`, then:

                  1) Let :math:`(\mathsf{catch\_all}~l)` be the destructuring of :math:`{\mathit{catch}}_0`.

                  #) Pop the :math:`\mathsf{handler}` from the stack.

                  #) Execute the instruction :math:`(\mathsf{br}~l)`.

               #. Else if :math:`{\mathit{catch}}_0` is not some :math:`\mathsf{catch\_all\_ref}~{\mathit{labelidx}}`, then:

                  1) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}''}^\ast}`.

                  #) Pop the :math:`\mathsf{handler}` from the stack.

                  #) Let :math:`H` be the :math:`\mathsf{handler}` whose arity is :math:`n` and whose catch handler is :math:`{{\mathit{catch}'}^\ast}`.

                  #) Push the :math:`\mathsf{handler}` :math:`H`.

                  #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

                  #) Execute the instruction :math:`\mathsf{throw\_ref}`.

               #. Else:

                  1) Let :math:`(\mathsf{catch\_all\_ref}~l)` be the destructuring of :math:`{\mathit{catch}}_0`.

                  #) Pop the :math:`\mathsf{handler}` from the stack.

                  #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

                  #) Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

   a. Assert: Due to validation, the first non-value entry of the stack is not a :math:`\mathsf{label}`.

   #. Assert: Due to validation, the first non-value entry of the stack is not a :math:`\mathsf{frame}`.

   #. Assert: Due to validation, the first non-value entry of the stack is not a :math:`\mathsf{handler}`.

   #. Throw the exception :math:`{\mathit{val}'}` as a result.


:math:`\mathsf{try\_table}~{\mathit{bt}}~{{\mathit{catch}}^\ast}~{{\mathit{instr}}^\ast}`
.........................................................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{m}}~{\rightarrow}_{{{\mathit{localidx}}_0^\ast}}\,{t_2^{n}}` be the destructuring of :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, :math:`{{\mathit{localidx}}_0^\ast} = \epsilon`.

#. Assert: Due to validation, there are at least :math:`m` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{m}}` from the stack.

#. Let :math:`H` be the :math:`\mathsf{handler}` whose arity is :math:`n` and whose catch handler is :math:`{{\mathit{catch}}^\ast}`.

#. Push the :math:`\mathsf{handler}` :math:`H`.

#. Let :math:`L` be the :math:`\mathsf{label}` whose arity is :math:`n` and whose continuation is the end of the block.

#. Enter the block :math:`{{\mathit{val}}^{m}}~{{\mathit{instr}}^\ast}` with the :math:`\mathsf{label}` :math:`L`.


:math:`\mathsf{local{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`z{.}\mathsf{locals}{}[x]` is defined.

#. Let :math:`{\mathit{val}}` be :math:`z{.}\mathsf{locals}{}[x]`.

#. Push the value :math:`{\mathit{val}}` to the stack.


:math:`\mathsf{global{.}get}~x`
...............................


1. Let :math:`z` be the current state.

#. Let :math:`{\mathit{val}}` be the value :math:`z{.}\mathsf{globals}{}[x]{.}\mathsf{value}`.

#. Push the value :math:`{\mathit{val}}` to the stack.


:math:`\mathsf{table{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. Push the value :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i]` to the stack.


:math:`\mathsf{table{.}size}~x`
...............................


1. Let :math:`z` be the current state.

#. Let :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})` be the destructuring of :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{type}`.

#. Let :math:`n` be the length of :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}`.

#. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{table{.}fill}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of number type :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}fill}~x)`.


:math:`\mathsf{table{.}copy}~x_1~x_2`
.....................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` from the stack.

#. If :math:`i_1 + n > {|z{.}\mathsf{tables}{}[x_1]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`i_2 + n > {|z{.}\mathsf{tables}{}[x_2]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. If :math:`i_1 \leq i_2`, then:

      1) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` to the stack.

      #) Execute the instruction :math:`(\mathsf{table{.}get}~x_2)`.

      #) Execute the instruction :math:`(\mathsf{table{.}set}~x_1)`.

      #) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1 + 1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2 + 1)` to the stack.

   #. Else:

      1) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1 + n - 1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2 + n - 1)` to the stack.

      #) Execute the instruction :math:`(\mathsf{table{.}get}~x_2)`.

      #) Execute the instruction :math:`(\mathsf{table{.}set}~x_1)`.

      #) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` to the stack.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}copy}~x_1~x_2)`.


:math:`\mathsf{table{.}init}~x~y`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. Assert: Due to validation, :math:`j < {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[j]` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}init}~x~y)`.


:math:`{{\mathit{nt}}{.}\mathsf{load}}{{{\mathit{loadop}}^?}}~x~{\mathit{ao}}`
..............................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`{{\mathit{loadop}}^?}` is not defined, then:

   a. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}}|} / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathit{nt}}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}}|} / 8]`.

   #. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.

#. Else:

   a. Assert: Due to validation, :math:`{\mathit{nt}}` is :math:`{\mathsf{i}}{N}`.

   #. Let :math:`{\mathit{loadop}}_0` be :math:`{{\mathit{loadop}}^?}`.

   #. Let :math:`{n}{\mathsf{\_}}{{\mathit{sx}}}` be the destructuring of :math:`{\mathit{loadop}}_0`.

   #. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8]`.

   #. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{n, {|{\mathit{nt}}|}}^{{\mathit{sx}}}}}{(c)})` to the stack.


:math:`{\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{{\mathit{vloadop}}^?}}~x~{\mathit{ao}}`
..............................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`{{\mathit{vloadop}}^?}` is not defined, then:

   a. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|\mathsf{v{\scriptstyle 128}}|} / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{\mathsf{v{\scriptstyle 128}}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|\mathsf{v{\scriptstyle 128}}|} / 8]`.

   #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. Else:

   a. Let :math:`{\mathit{vloadop}}_0` be :math:`{{\mathit{vloadop}}^?}`.

   #. If :math:`{\mathit{vloadop}}_0` is some :math:`{{\mathit{sz}}}{\mathsf{x}}{M}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({M}{\mathsf{x}}{K}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vloadop}}_0`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + M \cdot K / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) Let :math:`{j^{K}}` be the result for which :math:`{({{\mathrm{bytes}}}_{{\mathsf{i}}{M}}({j^{K}}) = z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} + k \cdot M / 8 : M / 8])^{k<K}}`.

      #) Let :math:`{\mathsf{i}}{N}` be the result for which :math:`N` :math:`=` :math:`M \cdot 2`.

      #) Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{K}}^{{-1}}}}{({{{{{\mathrm{extend}}}_{M, N}^{{\mathit{sx}}}}}{(j)}^{K}})}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

   #. If :math:`{\mathit{vloadop}}_0` is some :math:`{{\mathit{sz}}}{\mathsf{\_}}{\mathsf{splat}}`, then:

      1) Let :math:`({N}{\mathsf{\_}}{\mathsf{splat}})` be the destructuring of :math:`{\mathit{vloadop}}_0`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) Let :math:`M` be :math:`128 / N`.

      #) Let :math:`{\mathsf{i}}{N}` be the result for which :math:`{|{\mathsf{i}}{N}|}` :math:`=` :math:`N`.

      #) Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

      #) Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({j^{M}})}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

   #. If :math:`{\mathit{vloadop}}_0` is some :math:`{{\mathit{sz}}}{\mathsf{\_}}{\mathsf{zero}}`, then:

      1) Let :math:`({N}{\mathsf{\_}}{\mathsf{zero}})` be the destructuring of :math:`{\mathit{vloadop}}_0`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

      #) Let :math:`c` be :math:`{{{{\mathrm{extend}}}_{N, 128}^{\mathsf{u}}}}{(j)}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{N}{\mathsf{\_}}{\mathsf{lane}}~x~{\mathit{ao}}~j`
.......................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`M` be :math:`{|\mathsf{v{\scriptstyle 128}}|} / N`.

#. Let :math:`{\mathsf{i}}{N}` be the result for which :math:`{|{\mathsf{i}}{N}|}` :math:`=` :math:`N`.

#. Let :math:`k` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(k)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

#. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c_1){}[{}[j] = k])}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{memory{.}size}~x`
................................


1. Let :math:`z` be the current state.

#. Let :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})` be the destructuring of :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{type}`.

#. Let :math:`n \cdot 64 \, {\mathrm{Ki}}` be the length of :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}`.

#. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{memory{.}fill}~x`
................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of number type :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8}~x)`.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{memory{.}fill}~x)`.


:math:`\mathsf{memory{.}copy}~x_1~x_2`
......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` from the stack.

#. If :math:`i_1 + n > {|z{.}\mathsf{mems}{}[x_1]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`i_2 + n > {|z{.}\mathsf{mems}{}[x_2]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. If :math:`i_1 \leq i_2`, then:

      1) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` to the stack.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{load}}{{8}{\mathsf{\_}}{\mathsf{u}}}~x_2)`.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8}~x_1)`.

      #) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1 + 1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2 + 1)` to the stack.

   #. Else:

      1) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1 + n - 1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2 + n - 1)` to the stack.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{load}}{{8}{\mathsf{\_}}{\mathsf{u}}}~x_2)`.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8}~x_1)`.

      #) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` to the stack.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{memory{.}copy}~x_1~x_2)`.


:math:`\mathsf{memory{.}init}~x~y`
..................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. Assert: Due to validation, :math:`j < {|z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}|}`.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}{}[j])` to the stack.

   #. Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8}~x)`.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{memory{.}init}~x~y)`.


:math:`\mathsf{ref{.}null}~x`
.............................


1. Let :math:`z` be the current state.

#. Push the value :math:`(\mathsf{ref{.}null}~z{.}\mathsf{types}{}[x])` to the stack.


:math:`\mathsf{ref{.}func}~x`
.............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Push the value :math:`(\mathsf{ref{.}func}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x])` to the stack.


:math:`\mathsf{ref{.}test}~{\mathit{rt}}`
.........................................


1. Let :math:`f` be the topmost :math:`\mathsf{frame}`.

#. Assert: Due to validation, a reference value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Let :math:`{\mathit{rt}'}` be the type of :math:`{\mathit{ref}}`.

#. If :math:`{\mathit{rt}'}` matches :math:`{{\mathrm{inst}}}_{f{.}\mathsf{module}}({\mathit{rt}})`, then:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`\mathsf{ref{.}cast}~{\mathit{rt}}`
.........................................


1. Let :math:`f` be the topmost :math:`\mathsf{frame}`.

#. Assert: Due to validation, a reference value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Let :math:`{\mathit{rt}'}` be the type of :math:`{\mathit{ref}}`.

#. If :math:`{\mathit{rt}'}` does not match :math:`{{\mathrm{inst}}}_{f{.}\mathsf{module}}({\mathit{rt}})`, then:

   a. Trap.

#. Push the value :math:`{\mathit{ref}}` to the stack.


:math:`\mathsf{struct{.}new\_default}~x`
........................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{struct}~{\mathit{list}}({\mathit{fieldtype}})`.

#. Let :math:`(\mathsf{struct}~{\mathit{list}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

#. Let :math:`{({\mathsf{mut}^?}~{\mathit{zt}})^\ast}` be :math:`{\mathit{list}}_0`.

#. Assert: Due to validation, for all :math:`{\mathit{zt}}` in :math:`{{\mathit{zt}}^\ast}`, :math:`{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}` is defined.

#. Let :math:`{{\mathit{val}}^\ast}` be the value sequence :math:`\epsilon`.

#. For each :math:`{\mathit{zt}}` in :math:`{{\mathit{zt}}^\ast}`, do:

   a. Let :math:`{\mathit{val}}` be :math:`{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}`.

   #. Append :math:`{\mathit{val}}` to :math:`{{\mathit{val}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{val}}^\ast}|} = {|{{\mathit{zt}}^\ast}|}`.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

#. Execute the instruction :math:`(\mathsf{struct{.}new}~x)`.


:math:`{\mathsf{struct{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x~i`
...................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}`, then:

   a. Trap.

#. Assert: Due to validation, :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}struct}~{\mathit{structaddr}}`.

#. Let :math:`(\mathsf{ref{.}struct}~a)` be the destructuring of :math:`{\mathit{val}}`.

#. Assert: Due to validation, :math:`i < {|z{.}\mathsf{structs}{}[a]{.}\mathsf{fields}|}`.

#. Assert: Due to validation, :math:`a < {|z{.}\mathsf{structs}|}`.

#. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{struct}~{\mathit{list}}({\mathit{fieldtype}})`.

#. Let :math:`(\mathsf{struct}~{\mathit{list}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

#. Let :math:`{({\mathsf{mut}^?}~{\mathit{zt}})^\ast}` be :math:`{\mathit{list}}_0`.

#. Assert: Due to validation, :math:`i < {|{{\mathit{zt}}^\ast}|}`.

#. Push the value :math:`{{{{\mathrm{unpack}}}_{{{\mathit{zt}}^\ast}{}[i]}^{{{\mathit{sx}}^?}}}}{(z{.}\mathsf{structs}{}[a]{.}\mathsf{fields}{}[i])}` to the stack.


:math:`\mathsf{array{.}new\_default}~x`
.......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{array}~{\mathit{fieldtype}}`.

#. Let :math:`(\mathsf{array}~{\mathit{fieldtype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

#. Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be the destructuring of :math:`{\mathit{fieldtype}}_0`.

#. Assert: Due to validation, :math:`{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}` is defined.

#. Let :math:`{\mathit{val}}` be :math:`{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}`.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)`.


:math:`\mathsf{array{.}new\_elem}~x~y`
......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. Let :math:`{{\mathit{ref}}^{n}}` be :math:`z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[i : n]`.

#. Push the values :math:`{{\mathit{ref}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)`.


:math:`\mathsf{array{.}new\_data}~x~y`
......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{array}~{\mathit{fieldtype}}`.

#. Let :math:`(\mathsf{array}~{\mathit{fieldtype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

#. Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be the destructuring of :math:`{\mathit{fieldtype}}_0`.

#. If :math:`i + n \cdot {|{\mathit{zt}}|} / 8 > {|z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`{{{\mathit{byte}}^\ast}^\ast}` be the result for which each :math:`{{\mathit{byte}}^\ast}` has length :math:`{|{\mathit{zt}}|} / 8`, and the :ref:`concatenation <notation-concat>` of :math:`{{{\mathit{byte}}^\ast}^\ast}` is :math:`z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}{}[i : n \cdot {|{\mathit{zt}}|} / 8]`.

#. Let :math:`{c^{n}}` be the result for which :math:`{({{\mathrm{bytes}}}_{{\mathit{zt}}}({c^{n}}) = {{\mathit{byte}}^\ast})^\ast}`.

#. Push the values :math:`{{\mathrm{unpack}}({\mathit{zt}}){.}\mathsf{const}~{{\mathrm{unpack}}}_{{\mathit{zt}}}(c)^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)`.


:math:`{\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x`
................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}`, then:

   a. Trap.

#. Assert: Due to validation, :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}array}~{\mathit{arrayaddr}}`.

#. Let :math:`(\mathsf{ref{.}array}~a)` be the destructuring of :math:`{\mathit{val}}`.

#. If :math:`a < {|z{.}\mathsf{arrays}|}` and :math:`i \geq {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

   a. Trap.

#. If :math:`i < {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}` and :math:`a < {|z{.}\mathsf{arrays}|}`, then:

   a. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{array}~{\mathit{fieldtype}}`.

   #. Let :math:`(\mathsf{array}~{\mathit{fieldtype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

   #. Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be the destructuring of :math:`{\mathit{fieldtype}}_0`.

   #. Push the value :math:`{{{{\mathrm{unpack}}}_{{\mathit{zt}}}^{{{\mathit{sx}}^?}}}}{(z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}{}[i])}` to the stack.


:math:`\mathsf{array{.}len}`
............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}`, then:

   a. Trap.

#. Assert: Due to validation, :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}array}~{\mathit{arrayaddr}}`.

#. Let :math:`(\mathsf{ref{.}array}~a)` be the destructuring of :math:`{\mathit{val}}`.

#. Assert: Due to validation, :math:`a < {|z{.}\mathsf{arrays}|}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|})` to the stack.


:math:`\mathsf{array{.}fill}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}'}` from the stack.

#. If :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}`, then:

   a. Trap.

#. Assert: Due to validation, :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}array}~{\mathit{arrayaddr}}`.

#. Let :math:`(\mathsf{ref{.}array}~a)` be the destructuring of :math:`{\mathit{val}'}`.

#. If :math:`a \geq {|z{.}\mathsf{arrays}|}`, then:

   a. Do nothing.

#. Else if :math:`i + n > {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Execute the instruction :math:`(\mathsf{array{.}set}~x)`.

   #. Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{array{.}fill}~x)`.


:math:`\mathsf{array{.}copy}~x_1~x_2`
.....................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}'}` from the stack.

#. If :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}` and :math:`{\mathit{val}}` is reference value, then:

   a. Trap.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}` and :math:`{\mathit{val}'}` is reference value, then:

   a. Trap.

#. If :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}array}~{\mathit{arrayaddr}}`, then:

   a. Let :math:`(\mathsf{ref{.}array}~a_1)` be the destructuring of :math:`{\mathit{val}'}`.

   #. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}array}~{\mathit{arrayaddr}}`, then:

      1) If :math:`a_1 < {|z{.}\mathsf{arrays}|}` and :math:`i_1 + n > {|z{.}\mathsf{arrays}{}[a_1]{.}\mathsf{fields}|}`, then:

         a) Trap.

      #) Let :math:`(\mathsf{ref{.}array}~a_2)` be the destructuring of :math:`{\mathit{val}}`.

      #) If :math:`a_2 \geq {|z{.}\mathsf{arrays}|}`, then:

         a) Do nothing.

      #) Else if :math:`i_2 + n > {|z{.}\mathsf{arrays}{}[a_2]{.}\mathsf{fields}|}`, then:

         a) Trap.

      #) If :math:`n = 0`, then:

         a) Do nothing.

      #) Else:

         a) Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x_2]` is some :math:`\mathsf{array}~{\mathit{fieldtype}}`.

         #) Let :math:`(\mathsf{array}~{\mathit{fieldtype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x_2]`.

         #) Let :math:`({\mathsf{mut}^?}~{\mathit{zt}}_2)` be the destructuring of :math:`{\mathit{fieldtype}}_0`.

         #) Let :math:`{{\mathit{sx}}^?}` be :math:`{\mathrm{sx}}({\mathit{zt}}_2)`.

         #) Push the value :math:`(\mathsf{ref{.}array}~a_1)` to the stack.

         #) If :math:`i_1 \leq i_2`, then:

            1. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1)` to the stack.

            #. Push the value :math:`(\mathsf{ref{.}array}~a_2)` to the stack.

            #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2)` to the stack.

            #. Execute the instruction :math:`({\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x_2)`.

            #. Execute the instruction :math:`(\mathsf{array{.}set}~x_1)`.

            #. Push the value :math:`(\mathsf{ref{.}array}~a_1)` to the stack.

            #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1 + 1)` to the stack.

            #. Push the value :math:`(\mathsf{ref{.}array}~a_2)` to the stack.

            #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2 + 1)` to the stack.

         #) Else:

            1. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1 + n - 1)` to the stack.

            #. Push the value :math:`(\mathsf{ref{.}array}~a_2)` to the stack.

            #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2 + n - 1)` to the stack.

            #. Execute the instruction :math:`({\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x_2)`.

            #. Execute the instruction :math:`(\mathsf{array{.}set}~x_1)`.

            #. Push the value :math:`(\mathsf{ref{.}array}~a_1)` to the stack.

            #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1)` to the stack.

            #. Push the value :math:`(\mathsf{ref{.}array}~a_2)` to the stack.

            #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2)` to the stack.

         #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

         #) Execute the instruction :math:`(\mathsf{array{.}copy}~x_1~x_2)`.


:math:`\mathsf{array{.}init\_elem}~x~y`
.......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}`, then:

   a. Trap.

#. Assert: Due to validation, :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}array}~{\mathit{arrayaddr}}`.

#. Let :math:`(\mathsf{ref{.}array}~a)` be the destructuring of :math:`{\mathit{val}}`.

#. If :math:`a < {|z{.}\mathsf{arrays}|}` and :math:`i + n > {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else if :math:`j < {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

   a. Let :math:`{\mathit{ref}}` be the reference value :math:`z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[j]`.

   #. Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`{\mathit{ref}}` to the stack.

   #. Execute the instruction :math:`(\mathsf{array{.}set}~x)`.

   #. Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{array{.}init\_elem}~x~y)`.


:math:`\mathsf{array{.}init\_data}~x~y`
.......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}`, then:

   a. Trap.

#. Assert: Due to validation, :math:`{\mathit{val}}` is some :math:`\mathsf{ref{.}array}~{\mathit{arrayaddr}}`.

#. Let :math:`(\mathsf{ref{.}array}~a)` be the destructuring of :math:`{\mathit{val}}`.

#. If :math:`a < {|z{.}\mathsf{arrays}|}` and :math:`i + n > {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

   a. Trap.

#. If the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{array}~{\mathit{fieldtype}}`, then:

   a. Let :math:`(\mathsf{array}~{\mathit{fieldtype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

   #. Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be the destructuring of :math:`{\mathit{fieldtype}}_0`.

   #. If :math:`j + n \cdot {|{\mathit{zt}}|} / 8 > {|z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. If :math:`n = 0`, then:

      1) Do nothing.

   #. Else:

      1) Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathit{zt}}}(c)` :math:`=` :math:`z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}{}[j : {|{\mathit{zt}}|} / 8]`.

      #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

      #) Push the value :math:`{\mathrm{unpack}}({\mathit{zt}}){.}\mathsf{const}~{{\mathrm{unpack}}}_{{\mathit{zt}}}(c)` to the stack.

      #) Execute the instruction :math:`(\mathsf{array{.}set}~x)`.

      #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + {|{\mathit{zt}}|} / 8)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

      #) Execute the instruction :math:`(\mathsf{array{.}init\_data}~x~y)`.

#. Else if :math:`n = 0`, then:

   a. Do nothing.


:math:`\mathsf{throw}~x`
........................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{tags}|}`.

#. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{tags}{}[x]{.}\mathsf{type}` is some :math:`\mathsf{func}~{\mathit{resulttype}} \rightarrow {\mathit{resulttype}}`.

#. Let :math:`(\mathsf{func}~{t^{n}}~\rightarrow~{\mathit{resulttype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{tags}{}[x]{.}\mathsf{type}`.

#. Assert: Due to validation, :math:`{\mathit{resulttype}}_0 = \epsilon`.

#. Let :math:`a` be the length of :math:`z{.}\mathsf{exns}`.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Let :math:`{\mathit{exn}}` be the exception instance :math:`\{ \mathsf{tag}~z{.}\mathsf{tags}{}[x],\;\allowbreak \mathsf{fields}~{{\mathit{val}}^{n}} \}`.

#. Append :math:`{\mathit{exn}}` to :math:`z{.}\mathsf{exns}`.

#. Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

#. Execute the instruction :math:`\mathsf{throw\_ref}`.


:math:`\mathsf{local{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Replace :math:`z{.}\mathsf{locals}{}[x]` with :math:`{\mathit{val}}`.


:math:`\mathsf{global{.}set}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Replace :math:`z{.}\mathsf{globals}{}[x]{.}\mathsf{value}` with :math:`{\mathit{val}}`.


:math:`\mathsf{table{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a reference value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. Replace :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i]` with :math:`{\mathit{ref}}`.


:math:`\mathsf{table{.}grow}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a reference value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Either:

   a. Let :math:`{\mathit{ti}}` be the table instance :math:`{\mathrm{growtable}}(z{.}\mathsf{tables}{}[x], n, {\mathit{ref}})`.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|})` to the stack.

   #. Replace :math:`z{.}\mathsf{tables}{}[x]` with :math:`{\mathit{ti}}`.

#. Or:

   a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{{|{\mathit{at}}|}}^{{-1}}}}{({-1})})` to the stack.


:math:`\mathsf{elem{.}drop}~x`
..............................


1. Let :math:`z` be the current state.

#. Replace :math:`z{.}\mathsf{elems}{}[x]{.}\mathsf{refs}` with :math:`\epsilon`.


:math:`{{\mathit{nt}}{.}\mathsf{store}}{{{\mathit{storeop}}^?}}~x~{\mathit{ao}}`
................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{nt}'}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{nt}} = {\mathit{nt}'}`.

#. If :math:`{{\mathit{storeop}}^?}` is not defined, then:

   a. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}'}|} / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathit{nt}'}}(c)`.

   #. Replace :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}'}|} / 8]` with :math:`{b^\ast}`.

#. Else:

   a. Assert: Due to validation, :math:`{\mathit{nt}'}` is :math:`{\mathsf{i}}{N}`.

   #. Let :math:`n` be :math:`{{\mathit{storeop}}^?}`.

   #. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}({{\mathrm{wrap}}}_{{|{\mathit{nt}'}|}, n}(c))`.

   #. Replace :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8]` with :math:`{b^\ast}`.


:math:`\mathsf{v{\scriptstyle 128}}{.}\mathsf{store}~x~{\mathit{ao}}`
.....................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|\mathsf{v{\scriptstyle 128}}|} / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{\mathsf{v{\scriptstyle 128}}}(c)`.

#. Replace :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|\mathsf{v{\scriptstyle 128}}|} / 8]` with :math:`{b^\ast}`.


:math:`{\mathsf{v{\scriptstyle 128}}{.}\mathsf{store}}{N}{\mathsf{\_}}{\mathsf{lane}}~x~{\mathit{ao}}~j`
........................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of vector type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`M` be :math:`128 / N`.

#. Let :math:`{\mathsf{i}}{N}` be the result for which :math:`{|{\mathsf{i}}{N}|}` :math:`=` :math:`N`.

#. Assert: Due to validation, :math:`j < {|{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c)|}`.

#. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}({{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c){}[j])`.

#. Replace :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]` with :math:`{b^\ast}`.


:math:`\mathsf{memory{.}grow}~x`
................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a number value is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` from the stack.

#. Either:

   a. Let :math:`{\mathit{mi}}` be the memory instance :math:`{\mathrm{growmem}}(z{.}\mathsf{mems}{}[x], n)`.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~{|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|} / (64 \, {\mathrm{Ki}}))` to the stack.

   #. Replace :math:`z{.}\mathsf{mems}{}[x]` with :math:`{\mathit{mi}}`.

#. Or:

   a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{{|{\mathit{at}}|}}^{{-1}}}}{({-1})})` to the stack.


:math:`\mathsf{data{.}drop}~x`
..............................


1. Let :math:`z` be the current state.

#. Replace :math:`z{.}\mathsf{datas}{}[x]{.}\mathsf{bytes}` with :math:`\epsilon`.


:math:`\mathsf{struct{.}new}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{struct}~{\mathit{list}}({\mathit{fieldtype}})`.

#. Let :math:`(\mathsf{struct}~{\mathit{list}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

#. Let :math:`{({\mathsf{mut}^?}~{\mathit{zt}})^{n}}` be :math:`{\mathit{list}}_0`.

#. Let :math:`a` be the length of :math:`z{.}\mathsf{structs}`.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Let :math:`{\mathit{si}}` be the structure instance :math:`\{ \mathsf{type}~z{.}\mathsf{types}{}[x],\;\allowbreak \mathsf{fields}~{{{\mathrm{pack}}}_{{\mathit{zt}}}({\mathit{val}})^{n}} \}`.

#. Push the value :math:`(\mathsf{ref{.}struct}~a)` to the stack.

#. Append :math:`{\mathit{si}}` to :math:`z{.}\mathsf{structs}`.


:math:`\mathsf{struct{.}set}~x~i`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}'}` from the stack.

#. If :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}`, then:

   a. Trap.

#. Assert: Due to validation, :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}struct}~{\mathit{structaddr}}`.

#. Let :math:`(\mathsf{ref{.}struct}~a)` be the destructuring of :math:`{\mathit{val}'}`.

#. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{struct}~{\mathit{list}}({\mathit{fieldtype}})`.

#. Let :math:`(\mathsf{struct}~{\mathit{list}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

#. Let :math:`{({\mathsf{mut}^?}~{\mathit{zt}})^\ast}` be :math:`{\mathit{list}}_0`.

#. Assert: Due to validation, :math:`i < {|{{\mathit{zt}}^\ast}|}`.

#. Replace :math:`z{.}\mathsf{structs}{}[a]{.}\mathsf{fields}{}[i]` with :math:`{{\mathrm{pack}}}_{{{\mathit{zt}}^\ast}{}[i]}({\mathit{val}})`.


:math:`\mathsf{array{.}new\_fixed}~x~n`
.......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{array}~{\mathit{fieldtype}}`.

#. Let :math:`(\mathsf{array}~{\mathit{fieldtype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

#. Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be the destructuring of :math:`{\mathit{fieldtype}}_0`.

#. Let :math:`a` be the length of :math:`z{.}\mathsf{arrays}`.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Let :math:`{\mathit{ai}}` be the array instance :math:`\{ \mathsf{type}~z{.}\mathsf{types}{}[x],\;\allowbreak \mathsf{fields}~{{{\mathrm{pack}}}_{{\mathit{zt}}}({\mathit{val}})^{n}} \}`.

#. Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

#. Append :math:`{\mathit{ai}}` to :math:`z{.}\mathsf{arrays}`.


:math:`\mathsf{array{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of number type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}'}` from the stack.

#. If :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}`, then:

   a. Trap.

#. Assert: Due to validation, :math:`{\mathit{val}'}` is some :math:`\mathsf{ref{.}array}~{\mathit{arrayaddr}}`.

#. Let :math:`(\mathsf{ref{.}array}~a)` be the destructuring of :math:`{\mathit{val}'}`.

#. If :math:`a < {|z{.}\mathsf{arrays}|}` and :math:`i \geq {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

   a. Trap.

#. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{array}~{\mathit{fieldtype}}`.

#. Let :math:`(\mathsf{array}~{\mathit{fieldtype}}_0)` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

#. Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be the destructuring of :math:`{\mathit{fieldtype}}_0`.

#. Replace :math:`z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}{}[i]` with :math:`{{\mathrm{pack}}}_{{\mathit{zt}}}({\mathit{val}})`.


:math:`{\mathrm{min}}(i, j)`
............................


1. If :math:`i \leq j`, then:

   a. Return :math:`i`.

#. Return :math:`j`.


:math:`{\Sigma}\, {{n''}^\ast}`
...............................


1. If :math:`{{n''}^\ast} = \epsilon`, then:

   a. Return :math:`0`.

#. Let :math:`n~{{n'}^\ast}` be :math:`{{n''}^\ast}`.

#. Return :math:`n + {\Sigma}\, {{n'}^\ast}`.


:math:`{\Pi}\, {{n''}^\ast}`
............................


1. If :math:`{{n''}^\ast} = \epsilon`, then:

   a. Return :math:`1`.

#. Let :math:`n~{{n'}^\ast}` be :math:`{{n''}^\ast}`.

#. Return :math:`n \cdot {\Pi}\, {{n'}^\ast}`.


:math:`{X^\ast}`
................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{X^\ast}|} = 1`.

#. Let :math:`w` be :math:`{X^\ast}`.

#. Return :math:`w`.


:math:`{\bigoplus}\, {X^\ast}`
..............................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{w^\ast}~{{{w'}^\ast}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`{w^\ast}~{\bigoplus}\, {{{w'}^\ast}^\ast}`.


:math:`{\bigoplus}\, {X^\ast}`
..............................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{w^{n}}~{({{w'}^{n}})^\ast}` be :math:`{X^\ast}`.

#. Return :math:`{w^{n}}~{\bigoplus}\, {({{w'}^{n}})^\ast}`.


:math:`{\bigoplus}\, {X^\ast}`
..............................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{w^?}~{({{w'}^?})^\ast}` be :math:`{X^\ast}`.

#. Return :math:`{w^?}~{\bigoplus}\, {({{w'}^?})^\ast}`.


:math:`{X^\ast}~{\mathrm{disjoint}}`
....................................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return true.

#. Let :math:`w~{{w'}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`w` is not contained in :math:`{{w'}^\ast}` and :math:`{{w'}^\ast}~{\mathrm{disjoint}}`.


:math:`{{\mathrm{setminus{\kern-0.1em\scriptstyle 1}}}}_{X}(w, {X^\ast})`
.........................................................................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`w`.

#. Let :math:`w_1~{{w'}^\ast}` be :math:`{X^\ast}`.

#. If :math:`w = w_1`, then:

   a. Return :math:`\epsilon`.

#. Return :math:`{{\mathrm{setminus{\kern-0.1em\scriptstyle 1}}}}_{X}(w, {{w'}^\ast})`.


:math:`{X^\ast} \setminus {w^\ast}`
...................................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`w_1~{{w'}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`{{\mathrm{setminus{\kern-0.1em\scriptstyle 1}}}}_{X}(w_1, {w^\ast})~{{w'}^\ast} \setminus {w^\ast}`.


:math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{X}(w_1, {X^\ast})`
.............................................................................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{{w'}^\ast}~{{w^\ast}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`w_1~{{w'}^\ast}~{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{X}(w_1, {{w^\ast}^\ast})`.


:math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{X}({X^\ast}, {{w^\ast}^\ast})`
.........................................................................................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`w_1~{{w'}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{X}(w_1, {{w^\ast}^\ast})~{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{X}({{w'}^\ast}, {{w^\ast}^\ast})`.


:math:`{\Large\times}~{X^\ast}`
...............................


1. If :math:`{X^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{w_1^\ast}~{{w^\ast}^\ast}` be :math:`{X^\ast}`.

#. Return :math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{X}({w_1^\ast}, {\Large\times}~{{w^\ast}^\ast})`.


:math:`{\mathrm{signif}}(N)`
............................


1. If :math:`N = 32`, then:

   a. Return :math:`23`.

#. Assert: Due to validation, :math:`N = 64`.

#. Return :math:`52`.


:math:`{\mathrm{expon}}(N)`
...........................


1. If :math:`N = 32`, then:

   a. Return :math:`8`.

#. Assert: Due to validation, :math:`N = 64`.

#. Return :math:`11`.


:math:`M`
.........


1. Return :math:`{\mathrm{signif}}(N)`.


:math:`E`
.........


1. Return :math:`{\mathrm{expon}}(N)`.


:math:`{+0}`
............


1. Return :math:`({+((0 + 0 \cdot {2^{{-M}}}) \cdot {2^{e}})})`.


:math:`{+N}`
............


1. Return :math:`({+((1 + n \cdot {2^{{-M}}}) \cdot {2^{0}})})`.


:math:`{+1}`
............


1. Return :math:`({+((1 + 1 \cdot {2^{{-M}}}) \cdot {2^{0}})})`.


:math:`{{\mathrm{canon}}}_{N}`
..............................


1. Return :math:`{2^{{\mathrm{signif}}(N) - 1}}`.


:math:`{\mathrm{cont}}(b)`
..........................


1. Assert: Due to validation, :math:`128 < b`.

#. Assert: Due to validation, :math:`b < 192`.

#. Return :math:`b - 128`.


:math:`{\mathrm{funcs}}({{\mathit{externidx}'}^\ast})`
......................................................


1. If :math:`{{\mathit{externidx}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}'}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is some :math:`\mathsf{func}~{\mathit{funcidx}}`, then:

   a. Let :math:`(\mathsf{func}~x)` be the destructuring of :math:`{\mathit{externidx}}_0`.

   #. Return :math:`x~{\mathrm{funcs}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}'}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externidx}'}^\ast})`
........................................................


1. If :math:`{{\mathit{externidx}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}'}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is some :math:`\mathsf{global}~{\mathit{globalidx}}`, then:

   a. Let :math:`(\mathsf{global}~x)` be the destructuring of :math:`{\mathit{externidx}}_0`.

   #. Return :math:`x~{\mathrm{globals}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}'}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externidx}'}^\ast})`
.......................................................


1. If :math:`{{\mathit{externidx}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}'}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is some :math:`\mathsf{table}~{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table}~x)` be the destructuring of :math:`{\mathit{externidx}}_0`.

   #. Return :math:`x~{\mathrm{tables}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}'}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externidx}'}^\ast})`
.....................................................


1. If :math:`{{\mathit{externidx}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}'}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is some :math:`\mathsf{mem}~{\mathit{memidx}}`, then:

   a. Let :math:`(\mathsf{mem}~x)` be the destructuring of :math:`{\mathit{externidx}}_0`.

   #. Return :math:`x~{\mathrm{mems}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}'}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{tags}}({{\mathit{externidx}'}^\ast})`
.....................................................


1. If :math:`{{\mathit{externidx}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}'}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is some :math:`\mathsf{tag}~{\mathit{tagidx}}`, then:

   a. Let :math:`(\mathsf{tag}~x)` be the destructuring of :math:`{\mathit{externidx}}_0`.

   #. Return :math:`x~{\mathrm{tags}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}'}^\ast}`.

#. Return :math:`{\mathrm{tags}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{free}}_{\mathit{opt}}({{\mathit{free}'}^?})`
............................................................


1. If :math:`{{\mathit{free}'}^?}` is not defined, then:

   a. Return :math:`\{  \}`.

#. Let :math:`{\mathit{free}}` be :math:`{{\mathit{free}'}^?}`.

#. Return :math:`{\mathit{free}}`.


:math:`{\mathrm{free}}_{\mathit{list}}({{\mathit{free}''}^\ast})`
.................................................................


1. If :math:`{{\mathit{free}''}^\ast} = \epsilon`, then:

   a. Return :math:`\{  \}`.

#. Let :math:`{\mathit{free}}~{{\mathit{free}'}^\ast}` be :math:`{{\mathit{free}''}^\ast}`.

#. Return `free ++ $free_list(free'*{free' <- free'*})`.


:math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`
..............................................................


1. Return :math:`\{ \mathsf{types}~{\mathit{typeidx}} \}`.


:math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`
..............................................................


1. Return :math:`\{ \mathsf{funcs}~{\mathit{funcidx}} \}`.


:math:`{\mathrm{free}}_{\mathit{globalidx}}({\mathit{globalidx}})`
..................................................................


1. Return :math:`\{ \mathsf{globals}~{\mathit{globalidx}} \}`.


:math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`
................................................................


1. Return :math:`\{ \mathsf{tables}~{\mathit{tableidx}} \}`.


:math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`
............................................................


1. Return :math:`\{ \mathsf{mems}~{\mathit{memidx}} \}`.


:math:`{\mathrm{free}}_{\mathit{elemidx}}({\mathit{elemidx}})`
..............................................................


1. Return :math:`\{ \mathsf{elems}~{\mathit{elemidx}} \}`.


:math:`{\mathrm{free}}_{\mathit{dataidx}}({\mathit{dataidx}})`
..............................................................


1. Return :math:`\{ \mathsf{datas}~{\mathit{dataidx}} \}`.


:math:`{\mathrm{free}}_{\mathit{localidx}}({\mathit{localidx}})`
................................................................


1. Return :math:`\{ \mathsf{locals}~{\mathit{localidx}} \}`.


:math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`
................................................................


1. Return :math:`\{ \mathsf{labels}~{\mathit{labelidx}} \}`.


:math:`{\mathrm{free}}_{\mathit{externidx}}({\mathit{externidx}})`
..................................................................


1. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{func}~{\mathit{funcidx}}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{funcidx}})` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.

#. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{global}~{\mathit{globalidx}}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{globalidx}})` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{globalidx}}({\mathit{globalidx}})`.

#. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{table}~{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{tableidx}})` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. Assert: Due to validation, :math:`{\mathit{externidx}}` is some :math:`\mathsf{mem}~{\mathit{memidx}}`.

#. Let :math:`(\mathsf{mem}~{\mathit{memidx}})` be the destructuring of :math:`{\mathit{externidx}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`.


:math:`\mathsf{anyref}`
.......................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{any})`.


:math:`\mathsf{eqref}`
......................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{eq})`.


:math:`\mathsf{i{\scriptstyle 31}ref}`
......................................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{i{\scriptstyle 31}})`.


:math:`\mathsf{structref}`
..........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{struct})`.


:math:`\mathsf{arrayref}`
.........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{array})`.


:math:`\mathsf{funcref}`
........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{func})`.


:math:`\mathsf{exnref}`
.......................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{exn})`.


:math:`\mathsf{externref}`
..........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{extern})`.


:math:`\mathsf{nullref}`
........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{none})`.


:math:`\mathsf{nullfuncref}`
............................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{nofunc})`.


:math:`\mathsf{nullexnref}`
...........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{noexn})`.


:math:`\mathsf{nullexternref}`
..............................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{noextern})`.


:math:`{\mathsf{i}}{N}`
.......................


1. If :math:`N = 32`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 32}}`.

#. Assert: Due to validation, :math:`N = 64`.

#. Return :math:`\mathsf{i{\scriptstyle 64}}`.


:math:`{\mathsf{f}}{N}`
.......................


1. If :math:`N = 32`, then:

   a. Return :math:`\mathsf{f{\scriptstyle 32}}`.

#. Assert: Due to validation, :math:`N = 64`.

#. Return :math:`\mathsf{f{\scriptstyle 64}}`.


:math:`{\mathsf{i}}{N}`
.......................


1. If :math:`N = 8`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 8}}`.

#. If :math:`N = 16`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 16}}`.

#. If :math:`N = 32`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 32}}`.

#. Assert: Due to validation, :math:`N = 64`.

#. Return :math:`\mathsf{i{\scriptstyle 64}}`.


:math:`{|{\mathit{numtype}}|}`
..............................


1. If :math:`{\mathit{numtype}} = \mathsf{i{\scriptstyle 32}}`, then:

   a. Return :math:`32`.

#. If :math:`{\mathit{numtype}} = \mathsf{i{\scriptstyle 64}}`, then:

   a. Return :math:`64`.

#. If :math:`{\mathit{numtype}} = \mathsf{f{\scriptstyle 32}}`, then:

   a. Return :math:`32`.

#. Assert: Due to validation, :math:`{\mathit{numtype}} = \mathsf{f{\scriptstyle 64}}`.

#. Return :math:`64`.


:math:`{|\mathsf{v{\scriptstyle 128}}|}`
........................................


1. Return :math:`128`.


:math:`{|{\mathit{packtype}}|}`
...............................


1. If :math:`{\mathit{packtype}} = \mathsf{i{\scriptstyle 8}}`, then:

   a. Return :math:`8`.

#. Assert: Due to validation, :math:`{\mathit{packtype}} = \mathsf{i{\scriptstyle 16}}`.

#. Return :math:`16`.


:math:`{|{\mathit{lanetype}}|}`
...............................


1. If :math:`{\mathit{lanetype}}` is number type, then:

   a. Return :math:`{|{\mathit{lanetype}}|}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is packed type.

#. Return :math:`{|{\mathit{lanetype}}|}`.


:math:`{|{\mathit{storagetype}}|}`
..................................


1. If :math:`{\mathit{storagetype}}` is number type, then:

   a. Return :math:`{|{\mathit{storagetype}}|}`.

#. If :math:`{\mathit{storagetype}}` is vector type, then:

   a. Return :math:`{|{\mathit{storagetype}}|}`.

#. Assert: Due to validation, :math:`{\mathit{storagetype}}` is packed type.

#. Return :math:`{|{\mathit{storagetype}}|}`.


:math:`{|{\mathsf{i}}{N}|}`
...........................


1. Return :math:`{|{\mathsf{i}}{N}|}`.


:math:`{|{\mathsf{i}}{N}|}`
...........................


1. Return :math:`{|{\mathsf{i}}{N}|}`.


:math:`{|{\mathsf{f}}{N}|}`
...........................


1. Return :math:`{|{\mathsf{f}}{N}|}`.


:math:`{\mathrm{inv}}_{\mathit{isize}}(n)`
..........................................


1. If :math:`n = 32`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 32}}`.

#. If :math:`n = 64`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 64}}`.

#. Fail.


:math:`{\mathrm{inv}}_{\mathit{jsize}}(n)`
..........................................


1. If :math:`n = 8`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 8}}`.

#. If :math:`n = 16`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 16}}`.

#. Return :math:`{\mathrm{inv}}_{\mathit{isize}}(n)`.


:math:`{\mathrm{inv}}_{\mathit{fsize}}(n)`
..........................................


1. If :math:`n = 32`, then:

   a. Return :math:`\mathsf{f{\scriptstyle 32}}`.

#. If :math:`n = 64`, then:

   a. Return :math:`\mathsf{f{\scriptstyle 64}}`.

#. Fail.


:math:`N`
.........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N_1`
...........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N_2`
...........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{vt}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{pt}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`N_1`
...........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`N_2`
...........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathsf{i}}{N}|}`.


:math:`{\mathrm{inv}}_{\mathit{jsizenn}}(n)`
............................................


1. Return :math:`{\mathrm{inv}}_{\mathit{jsize}}(n)`.


:math:`{\mathrm{unpack}}({\mathit{lanetype}})`
..............................................


1. If :math:`{\mathit{lanetype}}` is number type, then:

   a. Return :math:`{\mathit{lanetype}}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is packed type.

#. Return :math:`\mathsf{i{\scriptstyle 32}}`.


:math:`{\mathrm{unpack}}({\mathit{storagetype}})`
.................................................


1. If :math:`{\mathit{storagetype}}` is value type, then:

   a. Return :math:`{\mathit{storagetype}}`.

#. Assert: Due to validation, :math:`{\mathit{storagetype}}` is packed type.

#. Return :math:`\mathsf{i{\scriptstyle 32}}`.


:math:`{\mathrm{unpack}}({\mathit{storagetype}})`
.................................................


1. If :math:`{\mathit{storagetype}}` is number type, then:

   a. Return :math:`{\mathit{storagetype}}`.

#. If :math:`{\mathit{storagetype}}` is packed type, then:

   a. Return :math:`\mathsf{i{\scriptstyle 32}}`.

#. Fail.


:math:`{\mathrm{unpack}}({\mathit{vectype}})`
.............................................


1. Return :math:`{\mathit{vectype}}`.


:math:`{\mathrm{unpack}}({\mathit{storagetype}})`
.................................................


1. If :math:`{\mathit{storagetype}}` is constant type, then:

   a. Return :math:`{\mathit{storagetype}}`.

#. If :math:`{\mathit{storagetype}}` is packed type, then:

   a. Return :math:`\mathsf{i{\scriptstyle 32}}`.

#. If :math:`{\mathit{storagetype}}` is lane type, then:

   a. Return :math:`{\mathrm{unpack}}({\mathit{storagetype}})`.

#. Fail.


:math:`{\mathrm{min}}({\mathit{at}}_1, {\mathit{at}}_2)`
........................................................


1. If :math:`{|{\mathit{at}}_1|} \leq {|{\mathit{at}}_2|}`, then:

   a. Return :math:`{\mathit{at}}_1`.

#. Return :math:`{\mathit{at}}_2`.


:math:`\mathsf{ref}~{{\mathsf{null}}_1^?}~{\mathit{ht}}_1 \setminus \mathsf{ref}~{\mathsf{null}^?}~{\mathit{ht}}_2`
...................................................................................................................


1. If :math:`{\mathsf{null}^?} = \mathsf{null}`, then:

   a. Return :math:`(\mathsf{ref}~{\mathit{ht}}_1)`.

#. Assert: Due to validation, :math:`{\mathsf{null}^?}` is not defined.

#. Return :math:`(\mathsf{ref}~{{\mathsf{null}}_1^?}~{\mathit{ht}}_1)`.


:math:`{\mathit{dt}}`
.....................


1. Return :math:`{\mathit{dt}}`.


:math:`{\mathrm{tags}}({{\mathit{externtype}'}^\ast})`
......................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{tag}~{\mathit{tagtype}}`, then:

   a. Let :math:`(\mathsf{tag}~{\mathit{jt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{jt}}~{\mathrm{tags}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{tags}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externtype}'}^\ast})`
.........................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{global}~{\mathit{globaltype}}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{gt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{gt}}~{\mathrm{globals}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externtype}'}^\ast})`
......................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{mem}~{\mathit{memtype}}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{mt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{mt}}~{\mathrm{mems}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externtype}'}^\ast})`
........................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{table}~{\mathit{tabletype}}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{tt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{tt}}~{\mathrm{tables}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{funcs}}({{\mathit{externtype}'}^\ast})`
.......................................................


1. If :math:`{{\mathit{externtype}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is some :math:`\mathsf{func}~{\mathit{typeuse}}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{dt}})` be the destructuring of :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{dt}}~{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}'}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.


:math:`{{\mathit{tv}}}{{}[ {{\mathit{typevar}}^\ast} := {{\mathit{typeuse}}^\ast} ]}`
.....................................................................................


1. If :math:`{{\mathit{typeuse}}^\ast} = \epsilon`, then:

   a. Assert: Due to validation, :math:`{{\mathit{typevar}}^\ast} = \epsilon`.

   #. Return :math:`{\mathit{tv}}`.

#. Else:

   a. Let :math:`{\mathit{tu}}_1~{{\mathit{tu}'}^\ast}` be :math:`{{\mathit{typeuse}}^\ast}`.

   #. Assert: Due to validation, :math:`{|{{\mathit{typevar}}^\ast}|} \geq 1`.

   #. Let :math:`{\mathit{tv}}_1~{{\mathit{tv}'}^\ast}` be :math:`{{\mathit{typevar}}^\ast}`.

   #. If :math:`{\mathit{tv}} = {\mathit{tv}}_1`, then:

      1) Return :math:`{\mathit{tu}}_1`.

   #. Return :math:`{{\mathit{tv}}}{{}[ {{\mathit{tv}'}^\ast} := {{\mathit{tu}'}^\ast} ]}`.


:math:`{\mathrm{minus}}_{\mathit{recs}}({{\mathit{typevar}}^\ast}, {{\mathit{typeuse}}^\ast})`
..............................................................................................


1. If :math:`{{\mathit{typevar}}^\ast} = \epsilon`, then:

   a. If :math:`{{\mathit{typeuse}}^\ast} = \epsilon`, then:

      1) Return :math:`(\epsilon, \epsilon)`.

#. Else:

   a. Let :math:`{\mathit{typevar}}_0~{{\mathit{tv}}^\ast}` be :math:`{{\mathit{typevar}}^\ast}`.

   #. If :math:`{\mathit{typevar}}_0` is some :math:`\mathsf{rec}~{.}~n` and :math:`{|{{\mathit{typeuse}}^\ast}|} \geq 1`, then:

      1) Let :math:`{\mathit{tu}}_1~{{\mathit{tu}}^\ast}` be :math:`{{\mathit{typeuse}}^\ast}`.

      #) Return :math:`{\mathrm{minus}}_{\mathit{recs}}({{\mathit{tv}}^\ast}, {{\mathit{tu}}^\ast})`.

#. Assert: Due to validation, :math:`{|{{\mathit{typeuse}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{tu}}_1~{{\mathit{tu}}^\ast}` be :math:`{{\mathit{typeuse}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{typevar}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{typevar}}_0~{{\mathit{tv}}^\ast}` be :math:`{{\mathit{typevar}}^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{typevar}}_0` is some :math:`{\mathit{typeidx}}`.

#. Let :math:`x` be the type variable :math:`{\mathit{typevar}}_0`.

#. Let :math:`({{\mathit{tv}'}^\ast}, {{\mathit{tu}'}^\ast})` be the destructuring of :math:`{\mathrm{minus}}_{\mathit{recs}}({{\mathit{tv}}^\ast}, {{\mathit{tu}}^\ast})`.

#. Return :math:`(x~{{\mathit{tv}'}^\ast}, {\mathit{tu}}_1~{{\mathit{tu}'}^\ast})`.


:math:`{{\mathit{pt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{\mathit{pt}}`.


:math:`{{\mathit{nt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{\mathit{nt}}`.


:math:`{{\mathit{vt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{\mathit{vt}}`.


:math:`{{\mathit{typeuse}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
................................................................................


1. If :math:`{\mathit{typeuse}}` is type variable, then:

   a. Return :math:`{{\mathit{typeuse}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. Assert: Due to validation, :math:`{\mathit{typeuse}}` is defined type.

#. Return :math:`{{\mathit{typeuse}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.


:math:`{{\mathit{heaptype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.................................................................................


1. If :math:`{\mathit{heaptype}}` is type variable, then:

   a. Return :math:`{{\mathit{heaptype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. If :math:`{\mathit{heaptype}}` is defined type, then:

   a. Return :math:`{{\mathit{heaptype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. Return :math:`{\mathit{heaptype}}`.


:math:`{\mathsf{ref}~{\mathsf{null}^?}~{\mathit{ht}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
..........................................................................................................


1. Return :math:`(\mathsf{ref}~{\mathsf{null}^?}~{{\mathit{ht}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{{\mathit{valtype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
................................................................................


1. If :math:`{\mathit{valtype}}` is number type, then:

   a. Return :math:`{{\mathit{valtype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. If :math:`{\mathit{valtype}}` is vector type, then:

   a. Return :math:`{{\mathit{valtype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. If :math:`{\mathit{valtype}}` is reference type, then:

   a. Return :math:`{{\mathit{valtype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. Assert: Due to validation, :math:`{\mathit{valtype}} = \mathsf{bot}`.

#. Return :math:`\mathsf{bot}`.


:math:`{{\mathit{storagetype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
....................................................................................


1. If :math:`{\mathit{storagetype}}` is value type, then:

   a. Return :math:`{{\mathit{storagetype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. Assert: Due to validation, :math:`{\mathit{storagetype}}` is packed type.

#. Return :math:`{{\mathit{storagetype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.


:math:`{{\mathsf{mut}^?}~{\mathit{zt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
............................................................................................


1. Return :math:`({\mathsf{mut}^?}~{{\mathit{zt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{{\mathit{comptype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.................................................................................


1. If :math:`{\mathit{comptype}}` is some :math:`\mathsf{struct}~{\mathit{list}}({\mathit{fieldtype}})`, then:

   a. Let :math:`(\mathsf{struct}~{{\mathit{ft}}^\ast})` be the destructuring of :math:`{\mathit{comptype}}`.

   #. Return :math:`(\mathsf{struct}~{{{\mathit{ft}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast})`.

#. If :math:`{\mathit{comptype}}` is some :math:`\mathsf{array}~{\mathit{fieldtype}}`, then:

   a. Let :math:`(\mathsf{array}~{\mathit{ft}})` be the destructuring of :math:`{\mathit{comptype}}`.

   #. Return :math:`(\mathsf{array}~{{\mathit{ft}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. Assert: Due to validation, :math:`{\mathit{comptype}}` is some :math:`\mathsf{func}~{\mathit{resulttype}} \rightarrow {\mathit{resulttype}}`.

#. Let :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})` be the destructuring of :math:`{\mathit{comptype}}`.

#. Return :math:`(\mathsf{func}~{{t_1}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}~\rightarrow~{{t_2}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast})`.


:math:`{\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{tu}'}^\ast}~{\mathit{ct}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.................................................................................................................................


1. Return :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{{\mathit{tu}'}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}~{{\mathit{ct}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{\mathsf{rec}~{{\mathit{st}}^\ast}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...............................................................................................


1. Let :math:`({{\mathit{tv}'}^\ast}, {{\mathit{tu}'}^\ast})` be the destructuring of :math:`{\mathrm{minus}}_{\mathit{recs}}({{\mathit{tv}}^\ast}, {{\mathit{tu}}^\ast})`.

#. Return :math:`(\mathsf{rec}~{{{\mathit{st}}}{{}[ {{\mathit{tv}'}^\ast} := {{\mathit{tu}'}^\ast} ]}^\ast})`.


:math:`{{\mathit{qt}}~{.}~i}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.................................................................................


1. Return :math:`({{\mathit{qt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}~{.}~i)`.


:math:`{{\mathit{at}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{\mathit{at}}`.


:math:`{{\mathit{tu}'}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
............................................................................


1. Return :math:`{{\mathit{tu}'}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.


:math:`{{\mathsf{mut}^?}~t}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
................................................................................


1. Return :math:`({\mathsf{mut}^?}~{t}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{{\mathit{at}}~{\mathit{lim}}~\mathsf{page}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
........................................................................................................


1. Return :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.


:math:`{{\mathit{at}}~{\mathit{lim}}~{\mathit{rt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
........................................................................................................


1. Return :math:`({\mathit{at}}~{\mathit{lim}}~{{\mathit{rt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{{\mathit{externtype}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...................................................................................


1. If :math:`{\mathit{externtype}}` is some :math:`\mathsf{tag}~{\mathit{tagtype}}`, then:

   a. Let :math:`(\mathsf{tag}~{\mathit{jt}})` be the destructuring of :math:`{\mathit{externtype}}`.

   #. Return :math:`(\mathsf{tag}~{{\mathit{jt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. If :math:`{\mathit{externtype}}` is some :math:`\mathsf{global}~{\mathit{globaltype}}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{gt}})` be the destructuring of :math:`{\mathit{externtype}}`.

   #. Return :math:`(\mathsf{global}~{{\mathit{gt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. If :math:`{\mathit{externtype}}` is some :math:`\mathsf{table}~{\mathit{tabletype}}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{tt}})` be the destructuring of :math:`{\mathit{externtype}}`.

   #. Return :math:`(\mathsf{table}~{{\mathit{tt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. If :math:`{\mathit{externtype}}` is some :math:`\mathsf{mem}~{\mathit{memtype}}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{mt}})` be the destructuring of :math:`{\mathit{externtype}}`.

   #. Return :math:`(\mathsf{mem}~{{\mathit{mt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. Assert: Due to validation, :math:`{\mathit{externtype}}` is some :math:`\mathsf{func}~{\mathit{typeuse}}`.

#. Let :math:`(\mathsf{func}~{\mathit{dt}})` be the destructuring of :math:`{\mathit{externtype}}`.

#. Return :math:`(\mathsf{func}~{{\mathit{dt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{{{\mathit{xt}}_1^\ast}~\rightarrow~{{\mathit{xt}}_2^\ast}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.......................................................................................................................


1. Return :math:`{{{\mathit{xt}}_1}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}~\rightarrow~{{{\mathit{xt}}_2}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}`.


:math:`{t}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.............................................


1. Return :math:`{t}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{rt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{rt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{dt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{dt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{jt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{jt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{gt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{gt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{mt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{mt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{tt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{tt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{xt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{xt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{mmt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
..........................................................


1. Return :math:`{{\mathit{mmt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{{\mathit{deftype}}^\ast}}{{}[ {:=}\, {{\mathit{tu}}^\ast} ]}`
......................................................................


1. If :math:`{{\mathit{deftype}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{dt}}_1~{{\mathit{dt}}^\ast}` be :math:`{{\mathit{deftype}}^\ast}`.

#. Return :math:`{{\mathit{dt}}_1}{{}[ {:=}\, {{\mathit{tu}}^\ast} ]}~{{{\mathit{dt}}^\ast}}{{}[ {:=}\, {{\mathit{tu}}^\ast} ]}`.


:math:`{{\mathrm{roll}}}_{x}({\mathit{rectype}})`
.................................................


1. Let :math:`(\mathsf{rec}~{{\mathit{subtype}}^{n}})` be the destructuring of :math:`{\mathit{rectype}}`.

#. Return :math:`(\mathsf{rec}~{{{\mathit{subtype}}}{{}[ {x + i^{i<n}} := {(\mathsf{rec}~{.}~{.})^{i<n}} ]}^{n}})`.


:math:`{\mathrm{unroll}}({\mathit{rectype}})`
.............................................


1. Let :math:`(\mathsf{rec}~{{\mathit{subtype}}^{n}})` be the destructuring of :math:`{\mathit{rectype}}`.

#. Return :math:`(\mathsf{rec}~{{{\mathit{subtype}}}{{}[ {(\mathsf{rec}~{.}~i)^{i<n}} := {({\mathit{rectype}}~{.}~i)^{i<n}} ]}^{n}})`.


:math:`{{{{\mathrm{roll}}}_{x}^\ast}}{({\mathit{rectype}})}`
............................................................


1. Let :math:`(\mathsf{rec}~{{\mathit{subtype}}^{n}})` be the destructuring of :math:`{{\mathrm{roll}}}_{x}({\mathit{rectype}})`.

#. Return :math:`{((\mathsf{rec}~{{\mathit{subtype}}^{n}})~{.}~i)^{i<n}}`.


:math:`{\mathrm{unroll}}({\mathit{rectype}}~{.}~i)`
...................................................


1. Let :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` be the destructuring of :math:`{\mathrm{unroll}}({\mathit{rectype}})`.

#. Return :math:`{{\mathit{subtype}}^\ast}{}[i]`.


:math:`{\mathrm{expand}}({\mathit{deftype}})`
.............................................


1. Let :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{comptype}})` be the destructuring of :math:`{\mathrm{unroll}}({\mathit{deftype}})`.

#. Return :math:`{\mathit{comptype}}`.


:math:`{\mathrm{free}}_{\mathit{addrtype}}({\mathit{addrtype}})`
................................................................


1. Return :math:`\{  \}`.


:math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`
..............................................................


1. Return :math:`\{  \}`.


:math:`{\mathrm{free}}_{\mathit{packtype}}({\mathit{packtype}})`
................................................................


1. Return :math:`\{  \}`.


:math:`{\mathrm{free}}_{\mathit{lanetype}}({\mathit{lanetype}})`
................................................................


1. If :math:`{\mathit{lanetype}}` is number type, then:

   a. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{lanetype}})`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is packed type.

#. Return :math:`{\mathrm{free}}_{\mathit{packtype}}({\mathit{lanetype}})`.


:math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`
..............................................................


1. Return :math:`\{  \}`.


:math:`{\mathrm{free}}_{\mathit{consttype}}({\mathit{consttype}})`
..................................................................


1. If :math:`{\mathit{consttype}}` is number type, then:

   a. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{consttype}})`.

#. Assert: Due to validation, :math:`{\mathit{consttype}}` is vector type.

#. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{consttype}})`.


:math:`{\mathrm{free}}_{\mathit{absheaptype}}({\mathit{absheaptype}})`
......................................................................


1. Return :math:`\{  \}`.


:math:`{\mathrm{free}}_{\mathit{typevar}}({\mathit{typevar}})`
..............................................................


1. If :math:`{\mathit{typevar}}` is some :math:`{\mathit{typeidx}}`, then:

   a. Let :math:`{\mathit{typeidx}}` be the type variable :math:`{\mathit{typevar}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. Assert: Due to validation, :math:`{\mathit{typevar}}` is some :math:`\mathsf{rec}~{.}~n`.

#. Return :math:`\{  \}`.


:math:`{\mathrm{free}}_{\mathit{heaptype}}({\mathit{heaptype}})`
................................................................


1. If :math:`{\mathit{heaptype}}` is abstract heap type, then:

   a. Return :math:`{\mathrm{free}}_{\mathit{absheaptype}}({\mathit{heaptype}})`.

#. Assert: Due to validation, :math:`{\mathit{heaptype}}` is type use.

#. Return :math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{heaptype}})`.


:math:`{\mathrm{free}}_{\mathit{reftype}}(\mathsf{ref}~{\mathsf{null}^?}~{\mathit{heaptype}})`
..............................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{heaptype}}({\mathit{heaptype}})`.


:math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{typeuse}})`
..............................................................


1. If :math:`{\mathit{typeuse}}` is type variable, then:

   a. Return :math:`{\mathrm{free}}_{\mathit{typevar}}({\mathit{typeuse}})`.

#. Assert: Due to validation, :math:`{\mathit{typeuse}}` is defined type.

#. Return :math:`{\mathrm{free}}_{\mathit{deftype}}({\mathit{typeuse}})`.


:math:`{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})`
..............................................................


1. If :math:`{\mathit{valtype}}` is number type, then:

   a. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{valtype}})`.

#. If :math:`{\mathit{valtype}}` is vector type, then:

   a. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{valtype}})`.

#. If :math:`{\mathit{valtype}}` is reference type, then:

   a. Return :math:`{\mathrm{free}}_{\mathit{reftype}}({\mathit{valtype}})`.

#. Assert: Due to validation, :math:`{\mathit{valtype}} = \mathsf{bot}`.

#. Return :math:`\{  \}`.


:math:`{\mathrm{free}}_{\mathit{resulttype}}({{\mathit{valtype}}^\ast})`
........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})^\ast})`.


:math:`{\mathrm{free}}_{\mathit{storagetype}}({\mathit{storagetype}})`
......................................................................


1. If :math:`{\mathit{storagetype}}` is value type, then:

   a. Return :math:`{\mathrm{free}}_{\mathit{valtype}}({\mathit{storagetype}})`.

#. Assert: Due to validation, :math:`{\mathit{storagetype}}` is packed type.

#. Return :math:`{\mathrm{free}}_{\mathit{packtype}}({\mathit{storagetype}})`.


:math:`{\mathrm{free}}_{\mathit{fieldtype}}({\mathsf{mut}^?}~{\mathit{storagetype}})`
.....................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{storagetype}}({\mathit{storagetype}})`.


:math:`{\mathrm{free}}_{\mathit{comptype}}({\mathit{comptype}})`
................................................................


1. If :math:`{\mathit{comptype}}` is some :math:`\mathsf{struct}~{\mathit{list}}({\mathit{fieldtype}})`, then:

   a. Let :math:`(\mathsf{struct}~{{\mathit{fieldtype}}^\ast})` be the destructuring of :math:`{\mathit{comptype}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{fieldtype}}({\mathit{fieldtype}})^\ast})`.

#. If :math:`{\mathit{comptype}}` is some :math:`\mathsf{array}~{\mathit{fieldtype}}`, then:

   a. Let :math:`(\mathsf{array}~{\mathit{fieldtype}})` be the destructuring of :math:`{\mathit{comptype}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{fieldtype}}({\mathit{fieldtype}})`.

#. Assert: Due to validation, :math:`{\mathit{comptype}}` is some :math:`\mathsf{func}~{\mathit{resulttype}} \rightarrow {\mathit{resulttype}}`.

#. Let :math:`(\mathsf{func}~{\mathit{resulttype}}_1~\rightarrow~{\mathit{resulttype}}_2)` be the destructuring of :math:`{\mathit{comptype}}`.

#. Return `$free_resulttype(resulttype_1) ++ $free_resulttype(resulttype_2)`.


:math:`{\mathrm{free}}_{\mathit{subtype}}(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{comptype}})`
.........................................................................................................................


1. Return `$free_list($free_typeuse(typeuse)*{typeuse <- typeuse*}) ++ $free_comptype(comptype)`.


:math:`{\mathrm{free}}_{\mathit{rectype}}(\mathsf{rec}~{{\mathit{subtype}}^\ast})`
..................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{subtype}}({\mathit{subtype}})^\ast})`.


:math:`{\mathrm{free}}_{\mathit{deftype}}({\mathit{rectype}}~{.}~n)`
....................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{rectype}}({\mathit{rectype}})`.


:math:`{\mathrm{free}}_{\mathit{tagtype}}({\mathit{deftype}})`
..............................................................


1. Return :math:`{\mathrm{free}}_{\mathit{deftype}}({\mathit{deftype}})`.


:math:`{\mathrm{free}}_{\mathit{globaltype}}({\mathsf{mut}^?}~{\mathit{valtype}})`
..................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})`.


:math:`{\mathrm{free}}_{\mathit{memtype}}({\mathit{addrtype}}~{\mathit{limits}}~\mathsf{page})`
...............................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{addrtype}}({\mathit{addrtype}})`.


:math:`{\mathrm{free}}_{\mathit{tabletype}}({\mathit{addrtype}}~{\mathit{limits}}~{\mathit{reftype}})`
......................................................................................................


1. Return `$free_addrtype(addrtype) ++ $free_reftype(reftype)`.


:math:`{\mathrm{free}}_{\mathit{datatype}}(\mathsf{ok})`
........................................................


1. Return :math:`\{  \}`.


:math:`{\mathrm{free}}_{\mathit{elemtype}}({\mathit{reftype}})`
...............................................................


1. Return :math:`{\mathrm{free}}_{\mathit{reftype}}({\mathit{reftype}})`.


:math:`{\mathrm{free}}_{\mathit{externtype}}({\mathit{externtype}})`
....................................................................


1. If :math:`{\mathit{externtype}}` is some :math:`\mathsf{tag}~{\mathit{tagtype}}`, then:

   a. Let :math:`(\mathsf{tag}~{\mathit{tagtype}})` be the destructuring of :math:`{\mathit{externtype}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tagtype}}({\mathit{tagtype}})`.

#. If :math:`{\mathit{externtype}}` is some :math:`\mathsf{global}~{\mathit{globaltype}}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{globaltype}})` be the destructuring of :math:`{\mathit{externtype}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{globaltype}}({\mathit{globaltype}})`.

#. If :math:`{\mathit{externtype}}` is some :math:`\mathsf{mem}~{\mathit{memtype}}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{memtype}})` be the destructuring of :math:`{\mathit{externtype}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{memtype}}({\mathit{memtype}})`.

#. If :math:`{\mathit{externtype}}` is some :math:`\mathsf{table}~{\mathit{tabletype}}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{tabletype}})` be the destructuring of :math:`{\mathit{externtype}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tabletype}}({\mathit{tabletype}})`.

#. Assert: Due to validation, :math:`{\mathit{externtype}}` is some :math:`\mathsf{func}~{\mathit{typeuse}}`.

#. Let :math:`(\mathsf{func}~{\mathit{typeuse}})` be the destructuring of :math:`{\mathit{externtype}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{typeuse}})`.


:math:`{\mathrm{free}}_{\mathit{moduletype}}({{\mathit{externtype}}_1^\ast}~\rightarrow~{{\mathit{externtype}}_2^\ast})`
........................................................................................................................


1. Return `$free_list($free_externtype(externtype_1)*{externtype_1 <- externtype_1*}) ++ $free_list($free_externtype(externtype_2)*{externtype_2 <- externtype_2*})`.


:math:`{\mathrm{dim}}({{\mathsf{i}}{N}}{\mathsf{x}}{N})`
........................................................


1. Return :math:`N`.


:math:`{\mathrm{lanetype}}({{\mathsf{i}}{N}}{\mathsf{x}}{N})`
.............................................................


1. Return :math:`{\mathsf{i}}{N}`.


:math:`{\mathrm{unpack}}({{\mathsf{i}}{N}}{\mathsf{x}}{N})`
...........................................................


1. Return :math:`{\mathrm{unpack}}({\mathsf{i}}{N})`.






1. Return :math:`\{ \mathsf{align}~0,\;\allowbreak \mathsf{offset}~0 \}`.


:math:`{\mathit{consttype}}{.}\mathsf{const}~c`
...............................................


1. If :math:`{\mathit{consttype}}` is number type, then:

   a. Return :math:`({\mathit{consttype}}{.}\mathsf{const}~c)`.

#. Assert: Due to validation, :math:`{\mathit{consttype}}` is vector type.

#. Return :math:`({\mathit{consttype}}{.}\mathsf{const}~c)`.


:math:`{\mathrm{free}}_{\mathit{shape}}({{\mathit{lanetype}}}{\mathsf{x}}{{\mathit{dim}}})`
...........................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{lanetype}}({\mathit{lanetype}})`.


:math:`{\mathrm{free}}_{\mathit{blocktype}}({\mathit{blocktype}})`
..................................................................


1. If :math:`{\mathit{blocktype}}` is some :math:`{{\mathit{valtype}}^?}`, then:

   a. Let :math:`{{\mathit{valtype}}^?}` be the block type :math:`{\mathit{blocktype}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{opt}}({{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})^?})`.

#. Assert: Due to validation, :math:`{\mathit{blocktype}}` is some :math:`{\mathit{funcidx}}`.

#. Let :math:`{\mathit{funcidx}}` be the block type :math:`{\mathit{blocktype}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.


:math:`{\mathrm{shift}}_{\mathit{labelidxs}}({{\mathit{labelidx}''}^\ast})`
...........................................................................


1. If :math:`{{\mathit{labelidx}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{labelidx}}_0~{{\mathit{labelidx}'}^\ast}` be :math:`{{\mathit{labelidx}''}^\ast}`.

#. If :math:`{\mathit{labelidx}}_0 = 0`, then:

   a. Return :math:`{\mathrm{shift}}_{\mathit{labelidxs}}({{\mathit{labelidx}'}^\ast})`.

#. Let :math:`{\mathit{labelidx}}~{{\mathit{labelidx}'}^\ast}` be :math:`{{\mathit{labelidx}''}^\ast}`.

#. Return :math:`{\mathit{labelidx}} - 1~{\mathrm{shift}}_{\mathit{labelidxs}}({{\mathit{labelidx}'}^\ast})`.


:math:`{\mathrm{free}}_{\mathit{instr}}({\mathit{instr}'})`
...........................................................


1. If :math:`{\mathit{instr}'} = \mathsf{nop}`, then:

   a. Return :math:`\{  \}`.

#. If :math:`{\mathit{instr}'} = \mathsf{unreachable}`, then:

   a. Return :math:`\{  \}`.

#. If :math:`{\mathit{instr}'} = \mathsf{drop}`, then:

   a. Return :math:`\{  \}`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{select}~{({{\mathit{valtype}}^\ast})^?}`, then:

   a. Let :math:`(\mathsf{select}~{({{\mathit{valtype}}^\ast})^?})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{opt}}({{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})^\ast})^?})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{block}~{\mathit{blocktype}}~{{\mathit{instr}}^\ast}`, then:

   a. Let :math:`(\mathsf{block}~{\mathit{blocktype}}~{{\mathit{instr}}^\ast})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_blocktype(blocktype) ++ $free_block(instr*{instr <- instr*})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{loop}~{\mathit{blocktype}}~{{\mathit{instr}}^\ast}`, then:

   a. Let :math:`(\mathsf{loop}~{\mathit{blocktype}}~{{\mathit{instr}}^\ast})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_blocktype(blocktype) ++ $free_block(instr*{instr <- instr*})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{if}~{\mathit{blocktype}}~{{\mathit{instr}}^\ast}~\mathsf{else}~{{\mathit{instr}}^\ast}`, then:

   a. Let :math:`(\mathsf{if}~{\mathit{blocktype}}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_blocktype(blocktype) ++ $free_block(instr_1*{instr_1 <- instr_1*}) ++ $free_block(instr_2*{instr_2 <- instr_2*})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{br}~{\mathit{labelidx}}`, then:

   a. Let :math:`(\mathsf{br}~{\mathit{labelidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{br\_if}~{\mathit{labelidx}}`, then:

   a. Let :math:`(\mathsf{br\_if}~{\mathit{labelidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{br\_table}~{{\mathit{labelidx}}^\ast}~{\mathit{labelidx}}`, then:

   a. Let :math:`(\mathsf{br\_table}~{{\mathit{labelidx}}^\ast}~{\mathit{labelidx}''})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_list($free_labelidx(labelidx)*{labelidx <- labelidx'*}) ++ $free_labelidx(labelidx'')`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{br\_on\_null}~{\mathit{labelidx}}`, then:

   a. Let :math:`(\mathsf{br\_on\_null}~{\mathit{labelidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{br\_on\_non\_null}~{\mathit{labelidx}}`, then:

   a. Let :math:`(\mathsf{br\_on\_non\_null}~{\mathit{labelidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{br\_on\_cast}~{\mathit{labelidx}}~{\mathit{reftype}}~{\mathit{reftype}}`, then:

   a. Let :math:`(\mathsf{br\_on\_cast}~{\mathit{labelidx}}~{\mathit{reftype}}_1~{\mathit{reftype}}_2)` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_labelidx(labelidx) ++ $free_reftype(reftype_1) ++ $free_reftype(reftype_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{br\_on\_cast\_fail}~{\mathit{labelidx}}~{\mathit{reftype}}~{\mathit{reftype}}`, then:

   a. Let :math:`(\mathsf{br\_on\_cast\_fail}~{\mathit{labelidx}}~{\mathit{reftype}}_1~{\mathit{reftype}}_2)` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_labelidx(labelidx) ++ $free_reftype(reftype_1) ++ $free_reftype(reftype_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{call}~{\mathit{funcidx}}`, then:

   a. Let :math:`(\mathsf{call}~{\mathit{funcidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{call\_ref}~{\mathit{typeuse}}`, then:

   a. Let :math:`(\mathsf{call\_ref}~{\mathit{typeuse}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{typeuse}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{call\_indirect}~{\mathit{tableidx}}~{\mathit{typeuse}}`, then:

   a. Let :math:`(\mathsf{call\_indirect}~{\mathit{tableidx}}~{\mathit{typeuse}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_tableidx(tableidx) ++ $free_typeuse(typeuse)`.

#. If :math:`{\mathit{instr}'} = \mathsf{return}`, then:

   a. Return :math:`\{  \}`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{return\_call}~{\mathit{funcidx}}`, then:

   a. Let :math:`(\mathsf{return\_call}~{\mathit{funcidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{return\_call\_ref}~{\mathit{typeuse}}`, then:

   a. Let :math:`(\mathsf{return\_call\_ref}~{\mathit{typeuse}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{typeuse}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{return\_call\_indirect}~{\mathit{tableidx}}~{\mathit{typeuse}}`, then:

   a. Let :math:`(\mathsf{return\_call\_indirect}~{\mathit{tableidx}}~{\mathit{typeuse}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_tableidx(tableidx) ++ $free_typeuse(typeuse)`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{numtype}}{.}\mathsf{const}~{{\mathit{num}}}_{{\mathit{numtype}}}`, then:

   a. Let :math:`({\mathit{numtype}}{.}\mathsf{const}~{\mathit{numlit}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{numtype}}~{.}~{{\mathit{unop}}}_{{\mathit{numtype}}}`, then:

   a. Let :math:`({\mathit{numtype}}~{.}~{\mathit{unop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{numtype}}~{.}~{{\mathit{binop}}}_{{\mathit{numtype}}}`, then:

   a. Let :math:`({\mathit{numtype}}~{.}~{\mathit{binop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{numtype}}~{.}~{{\mathit{testop}}}_{{\mathit{numtype}}}`, then:

   a. Let :math:`({\mathit{numtype}}~{.}~{\mathit{testop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{numtype}}~{.}~{{\mathit{relop}}}_{{\mathit{numtype}}}`, then:

   a. Let :math:`({\mathit{numtype}}~{.}~{\mathit{relop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{{\mathit{numtype}}_1~{.}~{{\mathit{cvtop}}}_{{\mathit{numtype}}_2, {\mathit{numtype}}_1}}{\mathsf{\_}}{{\mathit{numtype}}_2}`, then:

   a. Let :math:`({{\mathit{numtype}}_1~{.}~{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{numtype}}_2})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_numtype(numtype_1) ++ $free_numtype(numtype_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{vectype}}{.}\mathsf{const}~{{\mathit{vec}}}_{{\mathit{vectype}}}`, then:

   a. Let :math:`({\mathit{vectype}}{.}\mathsf{const}~{\mathit{veclit}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{vectype}}~{.}~{\mathit{vvunop}}`, then:

   a. Let :math:`({\mathit{vectype}}~{.}~{\mathit{vvunop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{vectype}}~{.}~{\mathit{vvbinop}}`, then:

   a. Let :math:`({\mathit{vectype}}~{.}~{\mathit{vvbinop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{vectype}}~{.}~{\mathit{vvternop}}`, then:

   a. Let :math:`({\mathit{vectype}}~{.}~{\mathit{vvternop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{vectype}}~{.}~{\mathit{vvtestop}}`, then:

   a. Let :math:`({\mathit{vectype}}~{.}~{\mathit{vvtestop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{shape}}~{.}~{{\mathit{vunop}}}_{{\mathit{shape}}}`, then:

   a. Let :math:`({\mathit{shape}}~{.}~{\mathit{vunop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{shape}}~{.}~{{\mathit{vbinop}}}_{{\mathit{shape}}}`, then:

   a. Let :math:`({\mathit{shape}}~{.}~{\mathit{vbinop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{shape}}~{.}~{{\mathit{vternop}}}_{{\mathit{shape}}}`, then:

   a. Let :math:`({\mathit{shape}}~{.}~{\mathit{vternop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{shape}}~{.}~{{\mathit{vtestop}}}_{{\mathit{shape}}}`, then:

   a. Let :math:`({\mathit{shape}}~{.}~{\mathit{vtestop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{shape}}~{.}~{{\mathit{vrelop}}}_{{\mathit{shape}}}`, then:

   a. Let :math:`({\mathit{shape}}~{.}~{\mathit{vrelop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{ishape}}~{.}~{{\mathit{vshiftop}}}_{{\mathit{ishape}}}`, then:

   a. Let :math:`({\mathit{ishape}}~{.}~{\mathit{vshiftop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{ishape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{ishape}}{.}\mathsf{bitmask}`, then:

   a. Let :math:`({\mathit{ishape}}{.}\mathsf{bitmask})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{ishape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{bshape}}~{.}~{{\mathit{vswizzlop}}}_{{\mathit{bshape}}}`, then:

   a. Let :math:`({\mathit{bshape}}~{.}~{\mathit{vswizzlop}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{bshape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{bshape}}{.}\mathsf{shuffle}~{{\mathit{laneidx}}^\ast}`, then:

   a. Let :math:`({\mathit{bshape}}{.}\mathsf{shuffle}~{{\mathit{laneidx}}^\ast})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{bshape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{{\mathit{ishape}}_1~{.}~{{\mathit{vextunop}}}_{{\mathit{ishape}}_2, {\mathit{ishape}}_1}}{\mathsf{\_}}{{\mathit{ishape}}_2}`, then:

   a. Let :math:`({{\mathit{ishape}}_1~{.}~{\mathit{vextunop}}}{\mathsf{\_}}{{\mathit{ishape}}_2})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_shape(ishape_1) ++ $free_shape(ishape_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`{{\mathit{ishape}}_1~{.}~{{\mathit{vextbinop}}}_{{\mathit{ishape}}_2, {\mathit{ishape}}_1}}{\mathsf{\_}}{{\mathit{ishape}}_2}`, then:

   a. Let :math:`({{\mathit{ishape}}_1~{.}~{\mathit{vextbinop}}}{\mathsf{\_}}{{\mathit{ishape}}_2})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_shape(ishape_1) ++ $free_shape(ishape_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`{{\mathit{ishape}}_1~{.}~{{\mathit{vextternop}}}_{{\mathit{ishape}}_2, {\mathit{ishape}}_1}}{\mathsf{\_}}{{\mathit{ishape}}_2}`, then:

   a. Let :math:`({{\mathit{ishape}}_1~{.}~{\mathit{vextternop}}}{\mathsf{\_}}{{\mathit{ishape}}_2})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_shape(ishape_1) ++ $free_shape(ishape_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`{{\mathit{ishape}}_1{.}\mathsf{narrow}}{\mathsf{\_}}{{\mathit{ishape}}_2}{\mathsf{\_}}{{\mathit{sx}}}`, then:

   a. Let :math:`({{\mathit{ishape}}_1{.}\mathsf{narrow}}{\mathsf{\_}}{{\mathit{ishape}}_2}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_shape(ishape_1) ++ $free_shape(ishape_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`{{\mathit{shape}}_1~{.}~{{\mathit{vcvtop}}}_{{\mathit{shape}}_2, {\mathit{shape}}_1}}{\mathsf{\_}}{{\mathit{shape}}_2}`, then:

   a. Let :math:`({{\mathit{shape}}_1~{.}~{\mathit{vcvtop}}}{\mathsf{\_}}{{\mathit{shape}}_2})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_shape(shape_1) ++ $free_shape(shape_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{shape}}{.}\mathsf{splat}`, then:

   a. Let :math:`({\mathit{shape}}{.}\mathsf{splat})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{{\mathit{shape}}{.}\mathsf{extract\_lane}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~{\mathit{laneidx}}`, then:

   a. Let :math:`({{\mathit{shape}}{.}\mathsf{extract\_lane}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~{\mathit{laneidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{shape}}{.}\mathsf{replace\_lane}~{\mathit{laneidx}}`, then:

   a. Let :math:`({\mathit{shape}}{.}\mathsf{replace\_lane}~{\mathit{laneidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{ref{.}null}~{\mathit{heaptype}}`, then:

   a. Let :math:`(\mathsf{ref{.}null}~{\mathit{heaptype}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{heaptype}}({\mathit{heaptype}})`.

#. If :math:`{\mathit{instr}'} = \mathsf{ref{.}is\_null}`, then:

   a. Return :math:`\{  \}`.

#. If :math:`{\mathit{instr}'} = \mathsf{ref{.}as\_non\_null}`, then:

   a. Return :math:`\{  \}`.

#. If :math:`{\mathit{instr}'} = \mathsf{ref{.}eq}`, then:

   a. Return :math:`\{  \}`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{ref{.}test}~{\mathit{reftype}}`, then:

   a. Let :math:`(\mathsf{ref{.}test}~{\mathit{reftype}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{reftype}}({\mathit{reftype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{ref{.}cast}~{\mathit{reftype}}`, then:

   a. Let :math:`(\mathsf{ref{.}cast}~{\mathit{reftype}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{reftype}}({\mathit{reftype}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{ref{.}func}~{\mathit{funcidx}}`, then:

   a. Let :math:`(\mathsf{ref{.}func}~{\mathit{funcidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.

#. If :math:`{\mathit{instr}'} = \mathsf{ref{.}i{\scriptstyle 31}}`, then:

   a. Return :math:`\{  \}`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathsf{i{\scriptstyle 31}{.}get}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

   a. Return :math:`\{  \}`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{struct{.}new}~{\mathit{typeidx}}`, then:

   a. Return :math:`\{  \}`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{struct{.}new\_default}~{\mathit{typeidx}}`, then:

   a. Let :math:`(\mathsf{struct{.}new\_default}~{\mathit{typeidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathsf{struct{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~{\mathit{typeidx}}~{\mathit{u{\kern-0.1em\scriptstyle 32}}}`, then:

   a. Let :math:`({\mathsf{struct{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~{\mathit{typeidx}}~{\mathit{u{\kern-0.1em\scriptstyle 32}}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{struct{.}set}~{\mathit{typeidx}}~{\mathit{u{\kern-0.1em\scriptstyle 32}}}`, then:

   a. Let :math:`(\mathsf{struct{.}set}~{\mathit{typeidx}}~{\mathit{u{\kern-0.1em\scriptstyle 32}}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{array{.}new}~{\mathit{typeidx}}`, then:

   a. Let :math:`(\mathsf{array{.}new}~{\mathit{typeidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{array{.}new\_default}~{\mathit{typeidx}}`, then:

   a. Let :math:`(\mathsf{array{.}new\_default}~{\mathit{typeidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{array{.}new\_fixed}~{\mathit{typeidx}}~{\mathit{u{\kern-0.1em\scriptstyle 32}}}`, then:

   a. Let :math:`(\mathsf{array{.}new\_fixed}~{\mathit{typeidx}}~{\mathit{u{\kern-0.1em\scriptstyle 32}}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{array{.}new\_data}~{\mathit{typeidx}}~{\mathit{dataidx}}`, then:

   a. Let :math:`(\mathsf{array{.}new\_data}~{\mathit{typeidx}}~{\mathit{dataidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_typeidx(typeidx) ++ $free_dataidx(dataidx)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{array{.}new\_elem}~{\mathit{typeidx}}~{\mathit{elemidx}}`, then:

   a. Let :math:`(\mathsf{array{.}new\_elem}~{\mathit{typeidx}}~{\mathit{elemidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_typeidx(typeidx) ++ $free_elemidx(elemidx)`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~{\mathit{typeidx}}`, then:

   a. Let :math:`({\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~{\mathit{typeidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{array{.}set}~{\mathit{typeidx}}`, then:

   a. Let :math:`(\mathsf{array{.}set}~{\mathit{typeidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}'} = \mathsf{array{.}len}`, then:

   a. Return :math:`\{  \}`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{array{.}fill}~{\mathit{typeidx}}`, then:

   a. Let :math:`(\mathsf{array{.}fill}~{\mathit{typeidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{array{.}copy}~{\mathit{typeidx}}~{\mathit{typeidx}}`, then:

   a. Let :math:`(\mathsf{array{.}copy}~{\mathit{typeidx}}_1~{\mathit{typeidx}}_2)` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_typeidx(typeidx_1) ++ $free_typeidx(typeidx_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{array{.}init\_data}~{\mathit{typeidx}}~{\mathit{dataidx}}`, then:

   a. Let :math:`(\mathsf{array{.}init\_data}~{\mathit{typeidx}}~{\mathit{dataidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_typeidx(typeidx) ++ $free_dataidx(dataidx)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{array{.}init\_elem}~{\mathit{typeidx}}~{\mathit{elemidx}}`, then:

   a. Let :math:`(\mathsf{array{.}init\_elem}~{\mathit{typeidx}}~{\mathit{elemidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_typeidx(typeidx) ++ $free_elemidx(elemidx)`.

#. If :math:`{\mathit{instr}'} = \mathsf{extern{.}convert\_any}`, then:

   a. Return :math:`\{  \}`.

#. If :math:`{\mathit{instr}'} = \mathsf{any{.}convert\_extern}`, then:

   a. Return :math:`\{  \}`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{local{.}get}~{\mathit{localidx}}`, then:

   a. Let :math:`(\mathsf{local{.}get}~{\mathit{localidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{localidx}}({\mathit{localidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{local{.}set}~{\mathit{localidx}}`, then:

   a. Let :math:`(\mathsf{local{.}set}~{\mathit{localidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{localidx}}({\mathit{localidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{local{.}tee}~{\mathit{localidx}}`, then:

   a. Let :math:`(\mathsf{local{.}tee}~{\mathit{localidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{localidx}}({\mathit{localidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{global{.}get}~{\mathit{globalidx}}`, then:

   a. Let :math:`(\mathsf{global{.}get}~{\mathit{globalidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{globalidx}}({\mathit{globalidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{global{.}set}~{\mathit{globalidx}}`, then:

   a. Let :math:`(\mathsf{global{.}set}~{\mathit{globalidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{globalidx}}({\mathit{globalidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{table{.}get}~{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table{.}get}~{\mathit{tableidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{table{.}set}~{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table{.}set}~{\mathit{tableidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{table{.}size}~{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table{.}size}~{\mathit{tableidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{table{.}grow}~{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table{.}grow}~{\mathit{tableidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{table{.}fill}~{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table{.}fill}~{\mathit{tableidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{table{.}copy}~{\mathit{tableidx}}~{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table{.}copy}~{\mathit{tableidx}}_1~{\mathit{tableidx}}_2)` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_tableidx(tableidx_1) ++ $free_tableidx(tableidx_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{table{.}init}~{\mathit{tableidx}}~{\mathit{elemidx}}`, then:

   a. Let :math:`(\mathsf{table{.}init}~{\mathit{tableidx}}~{\mathit{elemidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_tableidx(tableidx) ++ $free_elemidx(elemidx)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{elem{.}drop}~{\mathit{elemidx}}`, then:

   a. Let :math:`(\mathsf{elem{.}drop}~{\mathit{elemidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{elemidx}}({\mathit{elemidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`{{\mathit{numtype}}{.}\mathsf{load}}{{{{\mathit{loadop}}}_{{\mathit{numtype}}}^?}}~{\mathit{memidx}}~{\mathit{memarg}}`, then:

   a. Let :math:`({{\mathit{numtype}}{.}\mathsf{load}}{{{\mathit{loadop}}^?}}~{\mathit{memidx}}~{\mathit{memarg}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_numtype(numtype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}'}` is some :math:`{{\mathit{numtype}}{.}\mathsf{store}}{{{{\mathit{storeop}}}_{{\mathit{numtype}}}^?}}~{\mathit{memidx}}~{\mathit{memarg}}`, then:

   a. Let :math:`({{\mathit{numtype}}{.}\mathsf{store}}{{{\mathit{storeop}}^?}}~{\mathit{memidx}}~{\mathit{memarg}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_numtype(numtype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}'}` is some :math:`{{\mathit{vectype}}{.}\mathsf{load}}{{{{\mathit{vloadop}}}_{{\mathit{vectype}}}^?}}~{\mathit{memidx}}~{\mathit{memarg}}`, then:

   a. Let :math:`({{\mathit{vectype}}{.}\mathsf{load}}{{{\mathit{vloadop}}^?}}~{\mathit{memidx}}~{\mathit{memarg}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_vectype(vectype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}'}` is some :math:`{{\mathit{vectype}}{.}\mathsf{load}}{{\mathit{sz}}}{\mathsf{\_}}{\mathsf{lane}}~{\mathit{memidx}}~{\mathit{memarg}}~{\mathit{laneidx}}`, then:

   a. Let :math:`({{\mathit{vectype}}{.}\mathsf{load}}{{\mathit{sz}}}{\mathsf{\_}}{\mathsf{lane}}~{\mathit{memidx}}~{\mathit{memarg}}~{\mathit{laneidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_vectype(vectype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}'}` is some :math:`{\mathit{vectype}}{.}\mathsf{store}~{\mathit{memidx}}~{\mathit{memarg}}`, then:

   a. Let :math:`({\mathit{vectype}}{.}\mathsf{store}~{\mathit{memidx}}~{\mathit{memarg}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_vectype(vectype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}'}` is some :math:`{{\mathit{vectype}}{.}\mathsf{store}}{{\mathit{sz}}}{\mathsf{\_}}{\mathsf{lane}}~{\mathit{memidx}}~{\mathit{memarg}}~{\mathit{laneidx}}`, then:

   a. Let :math:`({{\mathit{vectype}}{.}\mathsf{store}}{{\mathit{sz}}}{\mathsf{\_}}{\mathsf{lane}}~{\mathit{memidx}}~{\mathit{memarg}}~{\mathit{laneidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_vectype(vectype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{memory{.}size}~{\mathit{memidx}}`, then:

   a. Let :math:`(\mathsf{memory{.}size}~{\mathit{memidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{memory{.}grow}~{\mathit{memidx}}`, then:

   a. Let :math:`(\mathsf{memory{.}grow}~{\mathit{memidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{memory{.}fill}~{\mathit{memidx}}`, then:

   a. Let :math:`(\mathsf{memory{.}fill}~{\mathit{memidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{memory{.}copy}~{\mathit{memidx}}~{\mathit{memidx}}`, then:

   a. Let :math:`(\mathsf{memory{.}copy}~{\mathit{memidx}}_1~{\mathit{memidx}}_2)` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_memidx(memidx_1) ++ $free_memidx(memidx_2)`.

#. If :math:`{\mathit{instr}'}` is some :math:`\mathsf{memory{.}init}~{\mathit{memidx}}~{\mathit{dataidx}}`, then:

   a. Let :math:`(\mathsf{memory{.}init}~{\mathit{memidx}}~{\mathit{dataidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

   #. Return `$free_memidx(memidx) ++ $free_dataidx(dataidx)`.

#. Assert: Due to validation, :math:`{\mathit{instr}'}` is some :math:`\mathsf{data{.}drop}~{\mathit{dataidx}}`.

#. Let :math:`(\mathsf{data{.}drop}~{\mathit{dataidx}})` be the destructuring of :math:`{\mathit{instr}'}`.

#. Return :math:`{\mathrm{free}}_{\mathit{dataidx}}({\mathit{dataidx}})`.


:math:`{\mathrm{free}}_{\mathit{block}}({{\mathit{instr}}^\ast})`
.................................................................


1. Let :math:`{\mathit{free}}` be :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{instr}}({\mathit{instr}})^\ast})`.

#. Return :math:`{\mathit{free}}{}[{.}\mathsf{labels} = {\mathrm{shift}}_{\mathit{labelidxs}}({\mathit{free}}{.}\mathsf{labels})]`.


:math:`{\mathrm{free}}_{\mathit{expr}}({{\mathit{instr}}^\ast})`
................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{instr}}({\mathit{instr}})^\ast})`.


:math:`{\mathrm{free}}_{\mathit{type}}(\mathsf{type}~{\mathit{rectype}})`
.........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{rectype}}({\mathit{rectype}})`.


:math:`{\mathrm{free}}_{\mathit{tag}}(\mathsf{tag}~{\mathit{tagtype}})`
.......................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{tagtype}}({\mathit{tagtype}})`.


:math:`{\mathrm{free}}_{\mathit{global}}(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}})`
................................................................................................


1. Return `$free_globaltype(globaltype) ++ $free_expr(expr)`.


:math:`{\mathrm{free}}_{\mathit{mem}}(\mathsf{memory}~{\mathit{memtype}})`
..........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{memtype}}({\mathit{memtype}})`.


:math:`{\mathrm{free}}_{\mathit{table}}(\mathsf{table}~{\mathit{tabletype}}~{\mathit{expr}})`
.............................................................................................


1. Return `$free_tabletype(tabletype) ++ $free_expr(expr)`.


:math:`{\mathrm{free}}_{\mathit{local}}(\mathsf{local}~t)`
..........................................................


1. Return :math:`{\mathrm{free}}_{\mathit{valtype}}(t)`.


:math:`{\mathrm{free}}_{\mathit{func}}(\mathsf{func}~{\mathit{typeidx}}~{{\mathit{local}}^\ast}~{\mathit{expr}})`
.................................................................................................................


1. Return `$free_typeidx(typeidx) ++ $free_list($free_local(local)*{local <- local*}) ++ update($free_block(expr).LOCALS, [])`.


:math:`{\mathrm{free}}_{\mathit{datamode}}({\mathit{datamode}})`
................................................................


1. If :math:`{\mathit{datamode}}` is some :math:`\mathsf{active}~{\mathit{memidx}}~{\mathit{expr}}`, then:

   a. Let :math:`(\mathsf{active}~{\mathit{memidx}}~{\mathit{expr}})` be the destructuring of :math:`{\mathit{datamode}}`.

   #. Return `$free_memidx(memidx) ++ $free_expr(expr)`.

#. Assert: Due to validation, :math:`{\mathit{datamode}} = \mathsf{passive}`.

#. Return :math:`\{  \}`.


:math:`{\mathrm{free}}_{\mathit{data}}(\mathsf{data}~{{\mathit{byte}}^\ast}~{\mathit{datamode}})`
.................................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{datamode}}({\mathit{datamode}})`.


:math:`{\mathrm{free}}_{\mathit{elemmode}}({\mathit{elemmode}})`
................................................................


1. If :math:`{\mathit{elemmode}}` is some :math:`\mathsf{active}~{\mathit{tableidx}}~{\mathit{expr}}`, then:

   a. Let :math:`(\mathsf{active}~{\mathit{tableidx}}~{\mathit{expr}})` be the destructuring of :math:`{\mathit{elemmode}}`.

   #. Return `$free_tableidx(tableidx) ++ $free_expr(expr)`.

#. If :math:`{\mathit{elemmode}} = \mathsf{passive}`, then:

   a. Return :math:`\{  \}`.

#. Assert: Due to validation, :math:`{\mathit{elemmode}} = \mathsf{declare}`.

#. Return :math:`\{  \}`.


:math:`{\mathrm{free}}_{\mathit{elem}}(\mathsf{elem}~{\mathit{reftype}}~{{\mathit{expr}}^\ast}~{\mathit{elemmode}})`
....................................................................................................................


1. Return `$free_reftype(reftype) ++ $free_list($free_expr(expr)*{expr <- expr*}) ++ $free_elemmode(elemmode)`.


:math:`{\mathrm{free}}_{\mathit{start}}(\mathsf{start}~{\mathit{funcidx}})`
...........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.


:math:`{\mathrm{free}}_{\mathit{import}}(\mathsf{import}~{\mathit{name}}_1~{\mathit{name}}_2~{\mathit{externtype}})`
....................................................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{externtype}}({\mathit{externtype}})`.


:math:`{\mathrm{free}}_{\mathit{export}}(\mathsf{export}~{\mathit{name}}~{\mathit{externidx}})`
...............................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{externidx}}({\mathit{externidx}})`.


:math:`{\mathrm{free}}_{\mathit{module}}(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{tag}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})`
..........................................................................................................................................................................................................................................................................................................................


1. Return `$free_list($free_type(type)*{type <- type*}) ++ $free_list($free_tag(tag)*{tag <- tag*}) ++ $free_list($free_global(global)*{global <- global*}) ++ $free_list($free_mem(mem)*{mem <- mem*}) ++ $free_list($free_table(table)*{table <- table*}) ++ $free_list($free_func(func)*{func <- func*}) ++ $free_list($free_data(data)*{data <- data*}) ++ $free_list($free_elem(elem)*{elem <- elem*}) ++ $free_opt($free_start(start)?{start <- start?}) ++ $free_list($free_import(import)*{import <- import*}) ++ $free_list($free_export(export)*{export <- export*})`.


:math:`{\mathrm{funcidx}}({\mathit{module}})`
.............................................


1. Return :math:`{\mathrm{free}}_{\mathit{module}}({\mathit{module}}){.}\mathsf{funcs}`.


:math:`{\mathrm{dataidx}}({{\mathit{func}}^\ast})`
..................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{func}}({\mathit{func}})^\ast}){.}\mathsf{datas}`.


:math:`C` with the local types of :math:`{{\mathit{localidx}}^\ast}` updated to :math:`{{\mathit{localtype}}^\ast}`
...................................................................................................................


1. If :math:`{{\mathit{localtype}}^\ast} = \epsilon`, then:

   a. Assert: Due to validation, :math:`{{\mathit{localidx}}^\ast} = \epsilon`.

   #. Return :math:`C`.

#. Else:

   a. Let :math:`{{\mathit{lt}}}_1~{{{\mathit{lt}}}^\ast}` be :math:`{{\mathit{localtype}}^\ast}`.

   #. Assert: Due to validation, :math:`{|{{\mathit{localidx}}^\ast}|} \geq 1`.

   #. Let :math:`x_1~{x^\ast}` be :math:`{{\mathit{localidx}}^\ast}`.

   #. Return :math:`C{}[{.}\mathsf{locals}{}[x_1] = {{\mathit{lt}}}_1]` with the local types of :math:`{x^\ast}` updated to :math:`{{{\mathit{lt}}}^\ast}`.


:math:`{{{\mathrm{clos}}^\ast}}{({{\mathit{deftype}}^\ast})}`
.............................................................


1. If :math:`{{\mathit{deftype}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{{\mathit{dt}}^\ast}~{\mathit{dt}}_n` be :math:`{{\mathit{deftype}}^\ast}`.

#. Let :math:`{{\mathit{dt}'}^\ast}` be :math:`{{{\mathrm{clos}}^\ast}}{({{\mathit{dt}}^\ast})}`.

#. Return :math:`{{\mathit{dt}'}^\ast}~{{\mathit{dt}}_n}{{}[ {:=}\, {{\mathit{dt}'}^\ast} ]}`.


:math:`{{\mathrm{clos}}}_{C}(t)`
................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{{{\mathrm{clos}}^\ast}}{(C{.}\mathsf{types})}`.

#. Return :math:`{t}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{clos}}}_{C}({\mathit{dt}})`
............................................


1. Let :math:`{{\mathit{dt}'}^\ast}` be :math:`{{{\mathrm{clos}}^\ast}}{(C{.}\mathsf{types})}`.

#. Return :math:`{{\mathit{dt}}}{{}[ {:=}\, {{\mathit{dt}'}^\ast} ]}`.


:math:`{{\mathrm{clos}}}_{C}({\mathit{jt}})`
............................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{{{\mathrm{clos}}^\ast}}{(C{.}\mathsf{types})}`.

#. Return :math:`{{\mathit{jt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{clos}}}_{C}({\mathit{xt}})`
............................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{{{\mathrm{clos}}^\ast}}{(C{.}\mathsf{types})}`.

#. Return :math:`{{\mathit{xt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{clos}}}_{C}({\mathit{mmt}})`
.............................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{{{\mathrm{clos}}^\ast}}{(C{.}\mathsf{types})}`.

#. Return :math:`{{\mathit{mmt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{\mathit{typeuse}} \prec x, i`
.....................................


1. If :math:`{\mathit{typeuse}}` is defined type, then:

   a. Return true.

#. If :math:`{\mathit{typeuse}}` is some :math:`{\mathit{typeidx}}`, then:

   a. Let :math:`{\mathit{typeidx}}` be the type use :math:`{\mathit{typeuse}}`.

   #. Return :math:`{\mathit{typeidx}} < x`.

#. Assert: Due to validation, :math:`{\mathit{typeuse}}` is some :math:`\mathsf{rec}~{.}~{.}`.

#. Let :math:`(\mathsf{rec}~{.}~{.})` be the destructuring of :math:`{\mathit{typeuse}}`.

#. Return :math:`j < i`.


:math:`{{\mathrm{unroll}}}_{C}({\mathit{heaptype}})`
....................................................


1. If :math:`{\mathit{heaptype}}` is defined type, then:

   a. Return :math:`{\mathrm{unroll}}({\mathit{heaptype}})`.

#. If :math:`{\mathit{heaptype}}` is some :math:`{\mathit{typeidx}}`, then:

   a. Let :math:`{\mathit{typeidx}}` be the heap type :math:`{\mathit{heaptype}}`.

   #. Return :math:`{\mathrm{unroll}}(C{.}\mathsf{types}{}[{\mathit{typeidx}}])`.

#. Assert: Due to validation, :math:`{\mathit{heaptype}}` is some :math:`\mathsf{rec}~{.}~{.}`.

#. Let :math:`(\mathsf{rec}~{.}~{.})` be the destructuring of :math:`{\mathit{heaptype}}`.

#. Return :math:`C{.}\mathsf{recs}{}[i]`.


:math:`{{\mathrm{default}}}_{{\mathit{valtype}}}`
.................................................


1. If :math:`{\mathit{valtype}}` is :math:`{\mathsf{i}}{N}`, then:

   a. Return :math:`({\mathit{valtype}}{.}\mathsf{const}~0)`.

#. If :math:`{\mathit{valtype}}` is :math:`{\mathsf{f}}{N}`, then:

   a. Return :math:`({\mathit{valtype}}{.}\mathsf{const}~{+0})`.

#. If :math:`{\mathit{valtype}}` is :math:`{\mathsf{v}}{N}`, then:

   a. Return :math:`({\mathit{valtype}}{.}\mathsf{const}~0)`.

#. Assert: Due to validation, :math:`{\mathit{valtype}}` is some :math:`\mathsf{ref}~{\mathsf{null}^?}~{\mathit{heaptype}}`.

#. Let :math:`(\mathsf{ref}~{{\mathit{NULL}}_0^?}~{\mathit{ht}})` be the destructuring of :math:`{\mathit{valtype}}`.

#. If :math:`{{\mathit{NULL}}_0^?} = \mathsf{null}`, then:

   a. Return :math:`(\mathsf{ref{.}null}~{\mathit{ht}})`.

#. Assert: Due to validation, :math:`{{\mathit{NULL}}_0^?}` is not defined.

#. Return :math:`\epsilon`.


:math:`{\mathit{zt}}` is a packed type
......................................


1. Return :math:`{\mathit{zt}} = {\mathrm{unpack}}({\mathit{zt}})`.


:math:`{\mathrm{funcidx}}({{\mathit{global}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{elem}}^\ast})`
.........................................................................................................................


1. Return :math:`{\mathrm{funcidx}}(\mathsf{module}~{{\mathit{global}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{elem}}^\ast})`.


:math:`{{\mathrm{relaxed}}(i)}{{}[ X_1, X_2 ]}`
...............................................


1. If :math:`{\mathrm{ND}}`, then:

   a. Return :math:`X_1~X_2{}[i]`.

#. Return :math:`X_1~X_2{}[0]`.


:math:`{{\mathrm{relaxed}}(i)}{{}[ X_1, X_2, X_3, X_4 ]}`
.........................................................


1. If :math:`{\mathrm{ND}}`, then:

   a. Return :math:`X_1~X_2~X_3~X_4{}[i]`.

#. Return :math:`X_1~X_2~X_3~X_4{}[0]`.


:math:`{{\mathrm{signed}}}_{N}(i)`
..................................


1. If :math:`i < {2^{N - 1}}`, then:

   a. Return :math:`i`.

#. Assert: Due to validation, :math:`{2^{N - 1}} \leq i`.

#. Assert: Due to validation, :math:`i < {2^{N}}`.

#. Return :math:`i - {2^{N}}`.


:math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{(i)}`
...............................................


1. If :math:`0 \leq i` and :math:`i < {2^{N - 1}}`, then:

   a. Return :math:`i`.

#. Assert: Due to validation, :math:`{-{2^{N - 1}}} \leq i`.

#. Assert: Due to validation, :math:`i < 0`.

#. Return :math:`i + {2^{N}}`.


:math:`{\mathrm{sx}}({\mathit{storagetype}})`
.............................................


1. If :math:`{\mathit{storagetype}}` is constant type, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{\mathit{storagetype}}` is packed type.

#. Return :math:`\mathsf{s}`.


:math:`0`
.........


1. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}`, then:

   a. Return :math:`0`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}`.

#. Return :math:`{+0}`.


:math:`\mathbb{B}(b)`
.....................


1. If :math:`b` is false, then:

   a. Return :math:`0`.

#. Assert: Due to validation, :math:`b` is true.

#. Return :math:`1`.


:math:`{{\mathrm{sat\_u}}}_{N}(i)`
..................................


1. If :math:`i < 0`, then:

   a. Return :math:`0`.

#. If :math:`i > {2^{N}} - 1`, then:

   a. Return :math:`{2^{N}} - 1`.

#. Return :math:`i`.


:math:`{{\mathrm{sat\_s}}}_{N}(i)`
..................................


1. If :math:`i < {-{2^{N - 1}}}`, then:

   a. Return :math:`{-{2^{N - 1}}}`.

#. If :math:`i > {2^{N - 1}} - 1`, then:

   a. Return :math:`{2^{N - 1}} - 1`.

#. Return :math:`i`.


:math:`{{\mathrm{ineg}}}_{N}(i_1)`
..................................


1. Return :math:`({2^{N}} - i_1) \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{\mathrm{iabs}}}_{N}(i_1)`
..................................


1. If :math:`{{\mathrm{signed}}}_{N}(i_1) \geq 0`, then:

   a. Return :math:`i_1`.

#. Return :math:`{{\mathrm{ineg}}}_{N}(i_1)`.


:math:`{{{{\mathrm{iextend}}}_{N, M}^{{\mathit{sx}}}}}{(i)}`
............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`i \mathbin{\mathrm{mod}} ({2^{M}})`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({{\mathrm{signed}}}_{M}(i \mathbin{\mathrm{mod}} ({2^{M}})))}`.


:math:`{{\mathrm{iadd}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`(i_1 + i_2) \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{\mathrm{isub}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`({2^{N}} + i_1 - i_2) \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{\mathrm{imul}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`i_1 \cdot i_2 \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{\mathrm{idiv}}}{{\mathit{sx}}}{{}_{N}(i_1, i_2)}`
..........................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. If :math:`i_2 = 0`, then:

      1) Return :math:`\epsilon`.

   #. Return :math:`{\mathrm{truncz}}(i_1 / i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. If :math:`i_2 = 0`, then:

   a. Return :math:`\epsilon`.

#. If :math:`{{\mathrm{signed}}}_{N}(i_1) / {{\mathrm{signed}}}_{N}(i_2) = {2^{N - 1}}`, then:

   a. Return :math:`\epsilon`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({\mathrm{truncz}}({{\mathrm{signed}}}_{N}(i_1) / {{\mathrm{signed}}}_{N}(i_2)))}`.


:math:`{{\mathrm{irem}}}{{\mathit{sx}}}{{}_{N}(i_1, i_2)}`
..........................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. If :math:`i_2 = 0`, then:

      1) Return :math:`\epsilon`.

   #. Return :math:`i_1 - i_2 \cdot {\mathrm{truncz}}(i_1 / i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. If :math:`i_2 = 0`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`j_1` be :math:`{{\mathrm{signed}}}_{N}(i_1)`.

#. Let :math:`j_2` be :math:`{{\mathrm{signed}}}_{N}(i_2)`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{(j_1 - j_2 \cdot {\mathrm{truncz}}(j_1 / j_2))}`.


:math:`{{\mathrm{imin}}}{{\mathit{sx}}}{{}_{N}(i_1, i_2)}`
..........................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. If :math:`i_1 \leq i_2`, then:

      1) Return :math:`i_1`.

   #. Return :math:`i_2`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. If :math:`{{\mathrm{signed}}}_{N}(i_1) \leq {{\mathrm{signed}}}_{N}(i_2)`, then:

   a. Return :math:`i_1`.

#. Return :math:`i_2`.


:math:`{{\mathrm{imax}}}{{\mathit{sx}}}{{}_{N}(i_1, i_2)}`
..........................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. If :math:`i_1 \geq i_2`, then:

      1) Return :math:`i_1`.

   #. Return :math:`i_2`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. If :math:`{{\mathrm{signed}}}_{N}(i_1) \geq {{\mathrm{signed}}}_{N}(i_2)`, then:

   a. Return :math:`i_1`.

#. Return :math:`i_2`.


:math:`{{\mathrm{iadd\_sat}}}{{\mathit{sx}}}{{}_{N}(i_1, i_2)}`
...............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`{{\mathrm{sat\_u}}}_{N}(i_1 + i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({{\mathrm{sat\_s}}}_{N}({{\mathrm{signed}}}_{N}(i_1) + {{\mathrm{signed}}}_{N}(i_2)))}`.


:math:`{{\mathrm{isub\_sat}}}{{\mathit{sx}}}{{}_{N}(i_1, i_2)}`
...............................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`{{\mathrm{sat\_u}}}_{N}(i_1 - i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({{\mathrm{sat\_s}}}_{N}({{\mathrm{signed}}}_{N}(i_1) - {{\mathrm{signed}}}_{N}(i_2)))}`.


:math:`{{\mathrm{ieqz}}}_{N}(i_1)`
..................................


1. Return :math:`\mathbb{B}(i_1 = 0)`.


:math:`{{\mathrm{inez}}}_{N}(i_1)`
..................................


1. Return :math:`\mathbb{B}(i_1 \neq 0)`.


:math:`{{\mathrm{ieq}}}_{N}(i_1, i_2)`
......................................


1. Return :math:`\mathbb{B}(i_1 = i_2)`.


:math:`{{\mathrm{ine}}}_{N}(i_1, i_2)`
......................................


1. Return :math:`\mathbb{B}(i_1 \neq i_2)`.


:math:`{{\mathrm{ilt}}}{{\mathit{sx}}}{{}_{N}(i_1, i_2)}`
.........................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 < i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) < {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{\mathrm{igt}}}{{\mathit{sx}}}{{}_{N}(i_1, i_2)}`
.........................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 > i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) > {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{\mathrm{ile}}}{{\mathit{sx}}}{{}_{N}(i_1, i_2)}`
.........................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 \leq i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) \leq {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{\mathrm{ige}}}{{\mathit{sx}}}{{}_{N}(i_1, i_2)}`
.........................................................


1. If :math:`{\mathit{sx}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 \geq i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) \geq {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{\mathrm{pack}}}_{{\mathit{lanetype}}}(c)`
..................................................


1. If :math:`{\mathit{lanetype}}` is number type, then:

   a. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is packed type.

#. Return :math:`{{\mathrm{wrap}}}_{{|{\mathrm{unpack}}({\mathit{lanetype}})|}, {|{\mathit{lanetype}}|}}(c)`.


:math:`{{\mathrm{pack}}}_{{\mathit{storagetype}}}(c)`
.....................................................


1. If :math:`{\mathit{storagetype}}` is constant type, then:

   a. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{storagetype}}` is packed type.

#. Return :math:`{{\mathrm{wrap}}}_{{|{\mathrm{unpack}}({\mathit{storagetype}})|}, {|{\mathit{storagetype}}|}}(c)`.


:math:`{{\mathrm{unpack}}}_{{\mathit{lanetype}}}(c)`
....................................................


1. If :math:`{\mathit{lanetype}}` is number type, then:

   a. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is packed type.

#. Return :math:`{{{{\mathrm{extend}}}_{{|{\mathit{lanetype}}|}, {|{\mathrm{unpack}}({\mathit{lanetype}})|}}^{\mathsf{u}}}}{(c)}`.


:math:`{{\mathrm{unpack}}}_{{\mathit{storagetype}}}(c)`
.......................................................


1. If :math:`{\mathit{storagetype}}` is constant type, then:

   a. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{storagetype}}` is packed type.

#. Return :math:`{{{{\mathrm{extend}}}_{{|{\mathit{storagetype}}|}, {|{\mathrm{unpack}}({\mathit{storagetype}})|}}^{\mathsf{u}}}}{(c)}`.


:math:`{{\mathit{unop}}}{{}_{{\mathit{numtype}}}(i)}`
.....................................................


1. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{unop}} = \mathsf{clz}`, then:

      1) Return :math:`{{\mathrm{iclz}}}_{N}(i)`.

   #. If :math:`{\mathit{unop}} = \mathsf{ctz}`, then:

      1) Return :math:`{{\mathrm{ictz}}}_{N}(i)`.

   #. If :math:`{\mathit{unop}} = \mathsf{popcnt}`, then:

      1) Return :math:`{{\mathrm{ipopcnt}}}_{N}(i)`.

   #. Assert: Due to validation, :math:`{\mathit{unop}}` is some :math:`{\mathsf{extend}}{{\mathit{sz}}}{\mathsf{\_}}{\mathsf{s}}`.

   #. Let :math:`({\mathsf{extend}}{M}{\mathsf{\_}}{\mathsf{s}})` be the destructuring of :math:`{\mathit{unop}}`.

   #. Return :math:`{{{{\mathrm{iextend}}}_{N, M}^{\mathsf{s}}}}{(i)}`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{unop}} = \mathsf{abs}`, then:

   a. Return :math:`{{\mathrm{fabs}}}_{N}(i)`.

#. If :math:`{\mathit{unop}} = \mathsf{neg}`, then:

   a. Return :math:`{{\mathrm{fneg}}}_{N}(i)`.

#. If :math:`{\mathit{unop}} = \mathsf{sqrt}`, then:

   a. Return :math:`{{\mathrm{fsqrt}}}_{N}(i)`.

#. If :math:`{\mathit{unop}} = \mathsf{ceil}`, then:

   a. Return :math:`{{\mathrm{fceil}}}_{N}(i)`.

#. If :math:`{\mathit{unop}} = \mathsf{floor}`, then:

   a. Return :math:`{{\mathrm{ffloor}}}_{N}(i)`.

#. If :math:`{\mathit{unop}} = \mathsf{trunc}`, then:

   a. Return :math:`{{\mathrm{ftrunc}}}_{N}(i)`.

#. Assert: Due to validation, :math:`{\mathit{unop}} = \mathsf{nearest}`.

#. Return :math:`{{\mathrm{fnearest}}}_{N}(i)`.


:math:`{{\mathit{binop}}}{{}_{{\mathit{numtype}}}(i_1, i_2)}`
.............................................................


1. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{binop}} = \mathsf{add}`, then:

      1) Return :math:`{{\mathrm{iadd}}}_{N}(i_1, i_2)`.

   #. If :math:`{\mathit{binop}} = \mathsf{sub}`, then:

      1) Return :math:`{{\mathrm{isub}}}_{N}(i_1, i_2)`.

   #. If :math:`{\mathit{binop}} = \mathsf{mul}`, then:

      1) Return :math:`{{\mathrm{imul}}}_{N}(i_1, i_2)`.

   #. If :math:`{\mathit{binop}}` is some :math:`{\mathsf{div}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{div}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{binop}}`.

      #) Return :math:`{{\mathrm{idiv}}}{{\mathit{sx}}}{{}_{N}(i_1, i_2)}`.

   #. If :math:`{\mathit{binop}}` is some :math:`{\mathsf{rem}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{rem}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{binop}}`.

      #) Return :math:`{{\mathrm{irem}}}{{\mathit{sx}}}{{}_{N}(i_1, i_2)}`.

   #. If :math:`{\mathit{binop}} = \mathsf{and}`, then:

      1) Return :math:`{{\mathrm{iand}}}_{N}(i_1, i_2)`.

   #. If :math:`{\mathit{binop}} = \mathsf{or}`, then:

      1) Return :math:`{{\mathrm{ior}}}_{N}(i_1, i_2)`.

   #. If :math:`{\mathit{binop}} = \mathsf{xor}`, then:

      1) Return :math:`{{\mathrm{ixor}}}_{N}(i_1, i_2)`.

   #. If :math:`{\mathit{binop}} = \mathsf{shl}`, then:

      1) Return :math:`{{\mathrm{ishl}}}_{N}(i_1, i_2)`.

   #. If :math:`{\mathit{binop}}` is some :math:`{\mathsf{shr}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{shr}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{binop}}`.

      #) Return :math:`{{\mathrm{ishr}}}{{\mathit{sx}}}{{}_{N}(i_1, i_2)}`.

   #. If :math:`{\mathit{binop}} = \mathsf{rotl}`, then:

      1) Return :math:`{{\mathrm{irotl}}}_{N}(i_1, i_2)`.

   #. If :math:`{\mathit{binop}} = \mathsf{rotr}`, then:

      1) Return :math:`{{\mathrm{irotr}}}_{N}(i_1, i_2)`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{binop}} = \mathsf{add}`, then:

   a. Return :math:`{{\mathrm{fadd}}}_{N}(i_1, i_2)`.

#. If :math:`{\mathit{binop}} = \mathsf{sub}`, then:

   a. Return :math:`{{\mathrm{fsub}}}_{N}(i_1, i_2)`.

#. If :math:`{\mathit{binop}} = \mathsf{mul}`, then:

   a. Return :math:`{{\mathrm{fmul}}}_{N}(i_1, i_2)`.

#. If :math:`{\mathit{binop}} = \mathsf{div}`, then:

   a. Return :math:`{{\mathrm{fdiv}}}_{N}(i_1, i_2)`.

#. If :math:`{\mathit{binop}} = \mathsf{min}`, then:

   a. Return :math:`{{\mathrm{fmin}}}_{N}(i_1, i_2)`.

#. If :math:`{\mathit{binop}} = \mathsf{max}`, then:

   a. Return :math:`{{\mathrm{fmax}}}_{N}(i_1, i_2)`.

#. Assert: Due to validation, :math:`{\mathit{binop}} = \mathsf{copysign}`.

#. Return :math:`{{\mathrm{fcopysign}}}_{N}(i_1, i_2)`.


:math:`{\mathsf{eqz}}{{}_{{\mathsf{i}}{N}}(i)}`
...............................................


1. Return :math:`{{\mathrm{ieqz}}}_{N}(i)`.


:math:`{{\mathit{relop}}}{{}_{{\mathit{numtype}}}(i_1, i_2)}`
.............................................................


1. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{relop}} = \mathsf{eq}`, then:

      1) Return :math:`{{\mathrm{ieq}}}_{N}(i_1, i_2)`.

   #. If :math:`{\mathit{relop}} = \mathsf{ne}`, then:

      1) Return :math:`{{\mathrm{ine}}}_{N}(i_1, i_2)`.

   #. If :math:`{\mathit{relop}}` is some :math:`{\mathsf{lt}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{lt}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{\mathrm{ilt}}}{{\mathit{sx}}}{{}_{N}(i_1, i_2)}`.

   #. If :math:`{\mathit{relop}}` is some :math:`{\mathsf{gt}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{gt}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{\mathrm{igt}}}{{\mathit{sx}}}{{}_{N}(i_1, i_2)}`.

   #. If :math:`{\mathit{relop}}` is some :math:`{\mathsf{le}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{le}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{\mathrm{ile}}}{{\mathit{sx}}}{{}_{N}(i_1, i_2)}`.

   #. If :math:`{\mathit{relop}}` is some :math:`{\mathsf{ge}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{ge}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{relop}}`.

      #) Return :math:`{{\mathrm{ige}}}{{\mathit{sx}}}{{}_{N}(i_1, i_2)}`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{relop}} = \mathsf{eq}`, then:

   a. Return :math:`{{\mathrm{feq}}}_{N}(i_1, i_2)`.

#. If :math:`{\mathit{relop}} = \mathsf{ne}`, then:

   a. Return :math:`{{\mathrm{fne}}}_{N}(i_1, i_2)`.

#. If :math:`{\mathit{relop}} = \mathsf{lt}`, then:

   a. Return :math:`{{\mathrm{flt}}}_{N}(i_1, i_2)`.

#. If :math:`{\mathit{relop}} = \mathsf{gt}`, then:

   a. Return :math:`{{\mathrm{fgt}}}_{N}(i_1, i_2)`.

#. If :math:`{\mathit{relop}} = \mathsf{le}`, then:

   a. Return :math:`{{\mathrm{fle}}}_{N}(i_1, i_2)`.

#. Assert: Due to validation, :math:`{\mathit{relop}} = \mathsf{ge}`.

#. Return :math:`{{\mathrm{fge}}}_{N}(i_1, i_2)`.


:math:`{{\mathit{cvtop}}}{{}_{{\mathit{numtype}}, {\mathit{numtype}'}}(i_1)}`
.............................................................................


1. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{N}` and :math:`{\mathit{numtype}'}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{cvtop}}` is some :math:`{\mathsf{extend}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{extend}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{cvtop}}`.

      #) Return :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(i_1)}`.

   #. If :math:`{\mathit{cvtop}} = \mathsf{wrap}`, then:

      1) Return :math:`{{\mathrm{wrap}}}_{N_1, N_2}(i_1)`.

#. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{N}` and :math:`{\mathit{numtype}'}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{cvtop}}` is some :math:`{\mathsf{trunc}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{trunc}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{cvtop}}`.

      #) Return :math:`{{{{\mathrm{trunc}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(i_1)}`.

   #. If :math:`{\mathit{cvtop}}` is some :math:`{\mathsf{trunc\_sat}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{trunc\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{cvtop}}`.

      #) Return :math:`{{{{\mathrm{trunc\_sat}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(i_1)}`.

#. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{N}` and :math:`{\mathit{numtype}'}` is :math:`{\mathsf{f}}{N}` and :math:`{\mathit{cvtop}}` is some :math:`{\mathsf{convert}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

   a. Let :math:`({\mathsf{convert}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{cvtop}}`.

   #. Return :math:`{{{{\mathrm{convert}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(i_1)}`.

#. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{N}` and :math:`{\mathit{numtype}'}` is :math:`{\mathsf{f}}{N}`, then:

   a. If :math:`{\mathit{cvtop}} = \mathsf{promote}`, then:

      1) Return :math:`{{\mathrm{promote}}}_{N_1, N_2}(i_1)`.

   #. If :math:`{\mathit{cvtop}} = \mathsf{demote}`, then:

      1) Return :math:`{{\mathrm{demote}}}_{N_1, N_2}(i_1)`.

#. If :math:`{\mathit{numtype}}` is :math:`{\mathsf{i}}{N}` and :math:`{\mathit{numtype}'}` is :math:`{\mathsf{f}}{N}` and :math:`{\mathit{cvtop}} = \mathsf{reinterpret}` and :math:`{|{\mathit{numtype}}|} = {|{\mathit{numtype}'}|}`, then:

   a. Return :math:`{{\mathrm{reinterpret}}}_{{\mathit{numtype}}, {\mathit{numtype}'}}(i_1)`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}` is :math:`{\mathsf{f}}{N}`.

#. Assert: Due to validation, :math:`{\mathit{numtype}'}` is :math:`{\mathsf{i}}{N}`.

#. Assert: Due to validation, :math:`{\mathit{cvtop}} = \mathsf{reinterpret}`.

#. Assert: Due to validation, :math:`{|{\mathit{numtype}}|} = {|{\mathit{numtype}'}|}`.

#. Return :math:`{{\mathrm{reinterpret}}}_{{\mathit{numtype}}, {\mathit{numtype}'}}(i_1)`.


:math:`{\mathrm{zeroop}}({{\mathit{lanetype}'}}{\mathsf{x}}{M_1}, {{\mathit{lanetype}}}{\mathsf{x}}{M_2}, {\mathit{vcvtop}})`
.............................................................................................................................


1. If :math:`{\mathit{lanetype}'}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}` and :math:`{\mathit{vcvtop}}` is some :math:`{\mathsf{extend}}{\mathsf{\_}}{{\mathit{half}}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Return :math:`\epsilon`.

   #. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}` and :math:`{\mathit{vcvtop}}` is some :math:`{\mathsf{convert}}{\mathsf{\_}}{{{\mathit{half}}^?}}`, then:

      1) Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}'}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{vcvtop}}` is some :math:`{\mathsf{trunc\_sat}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{trunc\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

      #) Return :math:`{{\mathit{zero}}^?}`.

   #. If :math:`{\mathit{vcvtop}}` is some :math:`{\mathsf{relaxed\_trunc}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{relaxed\_trunc}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

      #) Return :math:`{{\mathit{zero}}^?}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{vcvtop}}` is some :math:`{\mathsf{demote}}{\mathsf{\_}}{\mathsf{zero}}~{\mathit{zero}}`, then:

   a. Let :math:`({\mathsf{demote}}{\mathsf{\_}}{\mathsf{zero}}~{\mathit{zero}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

   #. Return :math:`{\mathit{zero}}`.

#. Assert: Due to validation, :math:`{\mathit{vcvtop}} = `.

#. Return :math:`\epsilon`.


:math:`{\mathrm{halfop}}({{\mathit{lanetype}'}}{\mathsf{x}}{M_1}, {{\mathit{lanetype}}}{\mathsf{x}}{M_2}, {\mathit{vcvtop}})`
.............................................................................................................................


1. If :math:`{\mathit{lanetype}'}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}` and :math:`{\mathit{vcvtop}}` is some :math:`{\mathsf{extend}}{\mathsf{\_}}{{\mathit{half}}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{extend}}{\mathsf{\_}}{{\mathit{half}}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

      #) Return :math:`{\mathit{half}}`.

   #. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}` and :math:`{\mathit{vcvtop}}` is some :math:`{\mathsf{convert}}{\mathsf{\_}}{{{\mathit{half}}^?}}`, then:

      1) Let :math:`({\mathsf{convert}}{\mathsf{\_}}{{{\mathit{half}}^?}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

      #) Return :math:`{{\mathit{half}}^?}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}'}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{vcvtop}}` is some :math:`{\mathsf{trunc\_sat}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Return :math:`\epsilon`.

   #. If :math:`{\mathit{vcvtop}}` is some :math:`{\mathsf{relaxed\_trunc}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{vcvtop}}` is some :math:`{\mathsf{demote}}{\mathsf{\_}}{\mathsf{zero}}~{\mathit{zero}}`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{\mathit{vcvtop}} = `.

#. Return :math:`\mathsf{low}`.


:math:`{\mathrm{half}}({\mathit{half}}, i, j)`
..............................................


1. If :math:`{\mathit{half}} = \mathsf{low}`, then:

   a. Return :math:`i`.

#. Assert: Due to validation, :math:`{\mathit{half}} = \mathsf{high}`.

#. Return :math:`j`.


:math:`{{\mathrm{iswizzle}}_{{\mathit{lane}}}}_{N}({c^\ast}, i)`
................................................................


1. If :math:`i < {|{c^\ast}|}`, then:

   a. Return :math:`{c^\ast}{}[i]`.

#. Return :math:`0`.


:math:`{{\mathrm{irelaxed}}_{{\mathit{swizzle}}_{{\mathit{lane}}}}}_{N}({c^\ast}, i)`
.....................................................................................


1. If :math:`i < {|{c^\ast}|}`, then:

   a. Return :math:`{c^\ast}{}[i]`.

#. If :math:`{{\mathrm{signed}}}_{N}(i) < 0`, then:

   a. Return :math:`0`.

#. Return :math:`{{\mathrm{relaxed}}({\mathrm{R}}_{\mathit{swizzle}})}{{}[ 0, {c^\ast}{}[i \mathbin{\mathrm{mod}} {|{c^\ast}|}] ]}`.


:math:`{{\mathrm{ivunop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1)`
.................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c^\ast}` be :math:`\epsilon`.

#. For each :math:`c_1` in :math:`{c_1^\ast}`, do:

   a. Let :math:`c` be :math:`{{\mathrm{f}}}_{N}(c_1)`.

   #. Append :math:`c` to :math:`{c^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1)`
.................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{f}}}_{N}(c_1)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{ivbinop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2)`
.......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`\epsilon`.

#. For each :math:`c_1` in :math:`{c_1^\ast}` and :math:`c_2` in :math:`{c_2^\ast}`, do:

   a. Let :math:`c` be :math:`{{\mathrm{f}}}_{N}(c_1, c_2)`.

   #. Append :math:`c` to :math:`{c^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{sx}}, v_1, v_2)`
........................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`\epsilon`.

#. For each :math:`c_1` in :math:`{c_1^\ast}` and :math:`c_2` in :math:`{c_2^\ast}`, do:

   a. Let :math:`c` be :math:`{{\mathrm{f}}}_{N}({\mathit{sx}}, c_1, c_2)`.

   #. Append :math:`c` to :math:`{c^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivbinopsxnd}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{sx}}, v_1, v_2)`
..........................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{f}}}_{N}({\mathit{sx}}, c_1, c_2)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2)`
.......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{f}}}_{N}(c_1, c_2)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{ivternopnd}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2, v_3)`
...............................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c_3^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_3)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{f}}}_{N}(c_1, c_2, c_3)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{fvternop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2, v_3)`
.............................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c_3^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_3)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{f}}}_{N}(c_1, c_2, c_3)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{ivtestop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1)`
...................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c^\ast}` be :math:`\epsilon`.

#. For each :math:`c_1` in :math:`{c_1^\ast}`, do:

   a. Let :math:`c` be :math:`{{\mathrm{f}}}_{N}(c_1)`.

   #. Append :math:`c` to :math:`{c^\ast}`.

#. Return :math:`{\Pi}\, {c^\ast}`.


:math:`{{\mathrm{fvtestop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1)`
...................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c^\ast}` be :math:`\epsilon`.

#. For each :math:`c_1` in :math:`{c_1^\ast}`, do:

   a. Let :math:`c` be :math:`{{\mathrm{f}}}_{N}(c_1)`.

   #. Append :math:`c` to :math:`{c^\ast}`.

#. Return :math:`{\Pi}\, {c^\ast}`.


:math:`{{\mathrm{ivrelop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2)`
.......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`\epsilon`.

#. For each :math:`c_1` in :math:`{c_1^\ast}` and :math:`c_2` in :math:`{c_2^\ast}`, do:

   a. Let :math:`c` be :math:`{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{f}}}_{N}(c_1, c_2))}`.

   #. Append :math:`c` to :math:`{c^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivrelopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{sx}}, v_1, v_2)`
........................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`\epsilon`.

#. For each :math:`c_1` in :math:`{c_1^\ast}` and :math:`c_2` in :math:`{c_2^\ast}`, do:

   a. Let :math:`c` be :math:`{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{f}}}_{N}({\mathit{sx}}, c_1, c_2))}`.

   #. Append :math:`c` to :math:`{c^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2)`
.......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{\mathsf{i}}{N}` be the result for which :math:`{|{\mathsf{i}}{N}|}` :math:`=` :math:`{|{\mathsf{f}}{N}|}`.

#. Let :math:`{c^\ast}` be :math:`\epsilon`.

#. For each :math:`c_1` in :math:`{c_1^\ast}` and :math:`c_2` in :math:`{c_2^\ast}`, do:

   a. Let :math:`c` be :math:`{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{f}}}_{N}(c_1, c_2))}`.

   #. Append :math:`c` to :math:`{c^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivshiftop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, i)`
.......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c^\ast}` be :math:`\epsilon`.

#. For each :math:`c_1` in :math:`{c_1^\ast}`, do:

   a. Let :math:`c` be :math:`{{\mathrm{f}}}_{N}(c_1, i)`.

   #. Append :math:`c` to :math:`{c^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivshiftopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{sx}}, v_1, i)`
........................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c^\ast}` be :math:`\epsilon`.

#. For each :math:`c_1` in :math:`{c_1^\ast}`, do:

   a. Let :math:`c` be :math:`{{\mathrm{f}}}_{N}({\mathit{sx}}, c_1, i)`.

   #. Append :math:`c` to :math:`{c^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivbitmaskop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`
........................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`c` be the result for which :math:`{{\mathrm{bits}}}_{{\mathsf{i}}{32}}(c)` :math:`=` :math:`{{{\mathrm{ilt}}}{\mathsf{s}}{{}_{N}(c_1, 0)}^\ast}~{0^{32 - M}}`.

#. Return :math:`{{\mathrm{irev}}}_{32}(c)`.


:math:`{{\mathrm{ivswizzlop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2)`
..........................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`\epsilon`.

#. For each :math:`c_2` in :math:`{c_2^\ast}`, do:

   a. Let :math:`c` be :math:`{{\mathrm{f}}}_{N}({c_1^\ast}, c_2)`.

   #. Append :math:`c` to :math:`{c^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivshufflop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({i^\ast}, v_1, v_2)`
......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`\epsilon`.

#. For each :math:`i` in :math:`{i^\ast}`, do:

   a. Let :math:`c` be :math:`{c_1^\ast}~{c_2^\ast}{}[i]`.

   #. Append :math:`c` to :math:`{c^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{\mathsf{not}}{{}_{{\mathsf{v}}{N}}(v)}`
...............................................


1. Return :math:`{{\mathrm{inot}}}_{N}(v)`.


:math:`{{\mathit{vvbinop}}}{{}_{{\mathsf{v}}{N}}(v_1, v_2)}`
............................................................


1. If :math:`{\mathit{vvbinop}} = \mathsf{and}`, then:

   a. Return :math:`{{\mathrm{iand}}}_{N}(v_1, v_2)`.

#. If :math:`{\mathit{vvbinop}} = \mathsf{andnot}`, then:

   a. Return :math:`{{\mathrm{iandnot}}}_{N}(v_1, v_2)`.

#. If :math:`{\mathit{vvbinop}} = \mathsf{or}`, then:

   a. Return :math:`{{\mathrm{ior}}}_{N}(v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{vvbinop}} = \mathsf{xor}`.

#. Return :math:`{{\mathrm{ixor}}}_{N}(v_1, v_2)`.


:math:`{\mathsf{bitselect}}{{}_{{\mathsf{v}}{N}}(v_1, v_2, v_3)}`
.................................................................


1. Return :math:`{{\mathrm{ibitselect}}}_{N}(v_1, v_2, v_3)`.


:math:`{{\mathit{vunop}}}{{}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}(v)}`
........................................................................


1. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}`, then:

   a. If :math:`{\mathit{vunop}} = \mathsf{abs}`, then:

      1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fabs}}, v)`.

   #. If :math:`{\mathit{vunop}} = \mathsf{neg}`, then:

      1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fneg}}, v)`.

   #. If :math:`{\mathit{vunop}} = \mathsf{sqrt}`, then:

      1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fsqrt}}, v)`.

   #. If :math:`{\mathit{vunop}} = \mathsf{ceil}`, then:

      1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fceil}}, v)`.

   #. If :math:`{\mathit{vunop}} = \mathsf{floor}`, then:

      1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{ffloor}}, v)`.

   #. If :math:`{\mathit{vunop}} = \mathsf{trunc}`, then:

      1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{ftrunc}}, v)`.

   #. If :math:`{\mathit{vunop}} = \mathsf{nearest}`, then:

      1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fnearest}}, v)`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}`.

#. If :math:`{\mathit{vunop}} = \mathsf{abs}`, then:

   a. Return :math:`{{\mathrm{ivunop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{iabs}}, v)`.

#. If :math:`{\mathit{vunop}} = \mathsf{neg}`, then:

   a. Return :math:`{{\mathrm{ivunop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{ineg}}, v)`.

#. Assert: Due to validation, :math:`{\mathit{vunop}} = \mathsf{popcnt}`.

#. Return :math:`{{\mathrm{ivunop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{ipopcnt}}, v)`.


:math:`{{\mathit{vbinop}}}{{}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}(v_1, v_2)}`
................................................................................


1. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{vbinop}} = \mathsf{add}`, then:

      1) Return :math:`{{\mathrm{ivbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{iadd}}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}} = \mathsf{sub}`, then:

      1) Return :math:`{{\mathrm{ivbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{isub}}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}} = \mathsf{mul}`, then:

      1) Return :math:`{{\mathrm{ivbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{imul}}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}}` is some :math:`{\mathsf{add\_sat}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{add\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vbinop}}`.

      #) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{iadd}}_{{\mathit{sat}}}, {\mathit{sx}}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}}` is some :math:`{\mathsf{sub\_sat}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{sub\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vbinop}}`.

      #) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{isub}}_{{\mathit{sat}}}, {\mathit{sx}}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}}` is some :math:`{\mathsf{min}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{min}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vbinop}}`.

      #) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{imin}}, {\mathit{sx}}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}}` is some :math:`{\mathsf{max}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{max}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vbinop}}`.

      #) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{imax}}, {\mathit{sx}}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}} = `, then:

      1) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{iavgr}}, \mathsf{u}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}} = `, then:

      1) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{iq{\kern-0.1em\scriptstyle 15\kern-0.1em}mulr}}_{{\mathit{sat}}}, \mathsf{s}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}} = `, then:

      1) Return :math:`{{\mathrm{ivbinopsxnd}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{irelaxed}}_{{\mathit{q{\kern-0.1em\scriptstyle 15\kern-0.1em}mulr}}}, \mathsf{s}, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{vbinop}} = \mathsf{add}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fadd}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}} = \mathsf{sub}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fsub}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}} = \mathsf{mul}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fmul}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}} = \mathsf{div}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fdiv}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}} = \mathsf{min}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fmin}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}} = \mathsf{max}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fmax}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}} = \mathsf{pmin}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fpmin}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}} = \mathsf{pmax}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fpmax}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}} = \mathsf{relaxed\_min}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{frelaxed}}_{{\mathit{min}}}, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{vbinop}} = \mathsf{relaxed\_max}`.

#. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{frelaxed}}_{{\mathit{max}}}, v_1, v_2)`.


:math:`{{\mathit{vternop}}}{{}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}(v_1, v_2, v_3)}`
......................................................................................


1. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}` and :math:`{\mathit{vternop}} = \mathsf{relaxed\_laneselect}`, then:

   a. Return :math:`{{\mathrm{ivternopnd}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{irelaxed}}_{{\mathit{laneselect}}}, v_1, v_2, v_3)`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{vternop}} = \mathsf{relaxed\_madd}`, then:

   a. Return :math:`{{\mathrm{fvternop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{frelaxed}}_{{\mathit{madd}}}, v_1, v_2, v_3)`.

#. Assert: Due to validation, :math:`{\mathit{vternop}} = \mathsf{relaxed\_nmadd}`.

#. Return :math:`{{\mathrm{fvternop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{frelaxed}}_{{\mathit{nmadd}}}, v_1, v_2, v_3)`.


:math:`{\mathsf{all\_true}}{{}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v)}`
......................................................................


1. Return :math:`{{\mathrm{ivtestop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{inez}}, v)`.


:math:`{{\mathit{vrelop}}}{{}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}(v_1, v_2)}`
................................................................................


1. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{vrelop}} = \mathsf{eq}`, then:

      1) Return :math:`{{\mathrm{ivrelop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{ieq}}, v_1, v_2)`.

   #. If :math:`{\mathit{vrelop}} = \mathsf{ne}`, then:

      1) Return :math:`{{\mathrm{ivrelop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{ine}}, v_1, v_2)`.

   #. If :math:`{\mathit{vrelop}}` is some :math:`{\mathsf{lt}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{lt}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vrelop}}`.

      #) Return :math:`{{\mathrm{ivrelopsx}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{ilt}}, {\mathit{sx}}, v_1, v_2)`.

   #. If :math:`{\mathit{vrelop}}` is some :math:`{\mathsf{gt}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{gt}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vrelop}}`.

      #) Return :math:`{{\mathrm{ivrelopsx}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{igt}}, {\mathit{sx}}, v_1, v_2)`.

   #. If :math:`{\mathit{vrelop}}` is some :math:`{\mathsf{le}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{le}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vrelop}}`.

      #) Return :math:`{{\mathrm{ivrelopsx}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{ile}}, {\mathit{sx}}, v_1, v_2)`.

   #. If :math:`{\mathit{vrelop}}` is some :math:`{\mathsf{ge}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{ge}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vrelop}}`.

      #) Return :math:`{{\mathrm{ivrelopsx}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{ige}}, {\mathit{sx}}, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{vrelop}} = \mathsf{eq}`, then:

   a. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{feq}}, v_1, v_2)`.

#. If :math:`{\mathit{vrelop}} = \mathsf{ne}`, then:

   a. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fne}}, v_1, v_2)`.

#. If :math:`{\mathit{vrelop}} = \mathsf{lt}`, then:

   a. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{flt}}, v_1, v_2)`.

#. If :math:`{\mathit{vrelop}} = \mathsf{gt}`, then:

   a. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fgt}}, v_1, v_2)`.

#. If :math:`{\mathit{vrelop}} = \mathsf{le}`, then:

   a. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fle}}, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{vrelop}} = \mathsf{ge}`.

#. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathit{lanetype}}}{\mathsf{x}}{M}}({\mathrm{fge}}, v_1, v_2)`.


:math:`{{\mathrm{lcvtop}}}_{{{\mathit{lanetype}'}}{\mathsf{x}}{M_1}, {{\mathit{lanetype}}}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}, c_1)`
.....................................................................................................................................


1. If :math:`{\mathit{lanetype}'}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}` and :math:`{\mathit{vcvtop}}` is some :math:`{\mathsf{extend}}{\mathsf{\_}}{{\mathit{half}}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{extend}}{\mathsf{\_}}{{\mathit{half}}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

      #) Let :math:`c` be :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(c_1)}`.

      #) Return :math:`c`.

   #. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}` and :math:`{\mathit{vcvtop}}` is some :math:`{\mathsf{convert}}{\mathsf{\_}}{{{\mathit{half}}^?}}`, then:

      1) Let :math:`({\mathsf{convert}}{\mathsf{\_}}{{{\mathit{half}}^?}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

      #) Let :math:`c` be :math:`{{{{\mathrm{convert}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(c_1)}`.

      #) Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}'}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{lanetype}}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{vcvtop}}` is some :math:`{\mathsf{trunc\_sat}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{trunc\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

      #) Let :math:`{c^?}` be :math:`{{{{\mathrm{trunc\_sat}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(c_1)}`.

      #) Return :math:`{c^?}`.

   #. If :math:`{\mathit{vcvtop}}` is some :math:`{\mathsf{relaxed\_trunc}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

      1) Let :math:`({\mathsf{relaxed\_trunc}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vcvtop}}`.

      #) Let :math:`{c^?}` be :math:`{{{{\mathrm{relaxed\_trunc}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(c_1)}`.

      #) Return :math:`{c^?}`.

#. Assert: Due to validation, :math:`{\mathit{lanetype}}` is :math:`{\mathsf{f}}{N}`.

#. If :math:`{\mathit{vcvtop}} = ({\mathsf{demote}}{\mathsf{\_}}{\mathsf{zero}}~\mathsf{zero})`, then:

   a. Let :math:`{c^\ast}` be :math:`{{\mathrm{demote}}}_{N_1, N_2}(c_1)`.

   #. Return :math:`{c^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{vcvtop}} = `.

#. Let :math:`{c^\ast}` be :math:`{{\mathrm{promote}}}_{N_1, N_2}(c_1)`.

#. Return :math:`{c^\ast}`.


:math:`{{\mathrm{vcvtop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M'}}}({\mathit{vcvtop}}, v_1)`
...................................................................................................................................


1. If :math:`M = {M'}` and :math:`{\mathrm{halfop}}({{{\mathsf{i}}{N}}_1}{\mathsf{x}}{{M'}}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M'}}, {\mathit{vcvtop}})` is not defined and :math:`{\mathrm{zeroop}}({{{\mathsf{i}}{N}}_1}{\mathsf{x}}{{M'}}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M'}}, {\mathit{vcvtop}})` is not defined, then:

   a. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{{M'}}}(v_1)`.

   #. Let :math:`{{c^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{lcvtop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{{M'}}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M'}}}({\mathit{vcvtop}}, c_1)^\ast}`.

   #. Let :math:`v` be an element of :math:`{{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M'}}}^{{-1}}}}{({c^\ast})}^\ast}`.

   #. Return :math:`v`.

#. If :math:`{\mathrm{halfop}}({{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M'}}, {\mathit{vcvtop}})` is defined, then:

   a. Let :math:`{\mathit{half}}` be :math:`{\mathrm{halfop}}({{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M'}}, {\mathit{vcvtop}})`.

   #. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M}}(v_1){}[{\mathrm{half}}({\mathit{half}}, 0, {M'}) : {M'}]`.

   #. Let :math:`{{c^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{lcvtop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M'}}}({\mathit{vcvtop}}, c_1)^\ast}`.

   #. Let :math:`v` be an element of :math:`{{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M'}}}^{{-1}}}}{({c^\ast})}^\ast}`.

   #. Return :math:`v`.

#. Assert: Due to validation, :math:`{\mathrm{zeroop}}({{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M'}}, {\mathit{vcvtop}}) = \mathsf{zero}`.

#. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`{\Large\times}~{{{\mathrm{lcvtop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M'}}}({\mathit{vcvtop}}, c_1)^\ast}~{0^{M}}`.

#. Let :math:`v` be an element of :math:`{{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{{M'}}}^{{-1}}}}{({c^\ast})}^\ast}`.

#. Return :math:`v`.


:math:`{{\mathit{vshiftop}}}{{}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}}{(v, i)}`
............................................................................


1. If :math:`{\mathit{vshiftop}} = \mathsf{shl}`, then:

   a. Return :math:`{{\mathrm{ivshiftop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ishl}}, v, i)`.

#. Assert: Due to validation, :math:`{\mathit{vshiftop}}` is some :math:`{\mathsf{shr}}{\mathsf{\_}}{{\mathit{sx}}}`.

#. Let :math:`({\mathsf{shr}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vshiftop}}`.

#. Return :math:`{{\mathrm{ivshiftopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ishr}}, {\mathit{sx}}, v, i)`.


:math:`{\mathsf{vbitmask}}{{}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v)}`
.....................................................................


1. Return :math:`{{\mathrm{ivbitmaskop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v)`.


:math:`{{\mathit{vswizzlop}}}{{}_{{\mathsf{i{\scriptstyle 8}}}{\mathsf{x}}{M}}(v_1, v_2)}`
..........................................................................................


1. If :math:`{\mathit{vswizzlop}} = \mathsf{swizzle}`, then:

   a. Return :math:`{{\mathrm{ivswizzlop}}}_{{\mathsf{i{\scriptstyle 8}}}{\mathsf{x}}{M}}({\mathrm{iswizzle}}_{{\mathit{lane}}}, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{vswizzlop}} = \mathsf{relaxed\_swizzle}`.

#. Return :math:`{{\mathrm{ivswizzlop}}}_{{\mathsf{i{\scriptstyle 8}}}{\mathsf{x}}{M}}({\mathrm{irelaxed}}_{{\mathit{swizzle}}_{{\mathit{lane}}}}, v_1, v_2)`.


:math:`{\mathsf{vshuffle}}{{}_{{\mathsf{i{\scriptstyle 8}}}{\mathsf{x}}{M}}({i^\ast}, v_1, v_2)}`
.................................................................................................


1. Return :math:`{{\mathrm{ivshufflop}}}_{{\mathsf{i{\scriptstyle 8}}}{\mathsf{x}}{M}}({i^\ast}, v_1, v_2)`.


:math:`{\mathsf{vnarrow}}{{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{\mathit{sx}}}}}{(v_1, v_2)}`
.............................................................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_2)`.

#. Let :math:`{{c'}_1^\ast}` be :math:`\epsilon`.

#. For each :math:`c_1` in :math:`{c_1^\ast}`, do:

   a. Let :math:`{c'}_1` be :math:`{{{{\mathrm{narrow}}}_{{|{{\mathsf{i}}{N}}_1|}, {|{{\mathsf{i}}{N}}_2|}}^{{\mathit{sx}}}}}{c_1}`.

   #. Append :math:`{c'}_1` to :math:`{{c'}_1^\ast}`.

#. Let :math:`{{c'}_2^\ast}` be :math:`\epsilon`.

#. For each :math:`c_2` in :math:`{c_2^\ast}`, do:

   a. Let :math:`{c'}_2` be :math:`{{{{\mathrm{narrow}}}_{{|{{\mathsf{i}}{N}}_1|}, {|{{\mathsf{i}}{N}}_2|}}^{{\mathit{sx}}}}}{c_2}`.

   #. Append :math:`{c'}_2` to :math:`{{c'}_2^\ast}`.

#. Let :math:`v` be :math:`{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({{c'}_1^\ast}~{{c'}_2^\ast})}`.

#. Return :math:`v`.


:math:`{{\mathrm{ivadd\_pairwise}}}_{N}({i^\ast})`
..................................................


1. Let :math:`{j_1~j_2^\ast}` be the result for which the :ref:`concatenation <notation-concat>` of :math:`{j_1~j_2^\ast}` is :math:`{i^\ast}`.

#. Return :math:`{{{\mathrm{iadd}}}_{N}(j_1, j_2)^\ast}`.


:math:`{{\mathrm{ivextunop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{f}}, {\mathit{sx}}, v_1)`
.................................................................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_1)`.

#. Let :math:`{{c'}_1^\ast}` be :math:`\epsilon`.

#. For each :math:`c_1` in :math:`{c_1^\ast}`, do:

   a. Let :math:`{c'}_1` be :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(c_1)}`.

   #. Append :math:`{c'}_1` to :math:`{{c'}_1^\ast}`.

#. Let :math:`{c^\ast}` be :math:`{{\mathrm{f}}}_{N_2}({{c'}_1^\ast})`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathsf{extadd\_pairwise}}{\mathsf{\_}}{{\mathit{sx}}}}{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}(v_1)}`
...........................................................................................................................................................


1. Return :math:`{{\mathrm{ivextunop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{ivadd}}_{{\mathit{pairwise}}}, {\mathit{sx}}, v_1)`.


:math:`{{\mathrm{ivdot}}}_{N}({i_1^\ast}, {i_2^\ast})`
......................................................


1. Let :math:`{j_1~j_2^\ast}` be the result for which the :ref:`concatenation <notation-concat>` of :math:`{j_1~j_2^\ast}` is :math:`{{{\mathrm{imul}}}_{N}(i_1, i_2)^\ast}`.

#. Return :math:`{{{\mathrm{iadd}}}_{N}(j_1, j_2)^\ast}`.


:math:`{{\mathrm{ivdot\_sat}}}_{N}({i_1^\ast}, {i_2^\ast})`
...........................................................


1. Let :math:`{j_1~j_2^\ast}` be the result for which the :ref:`concatenation <notation-concat>` of :math:`{j_1~j_2^\ast}` is :math:`{{{\mathrm{imul}}}_{N}(i_1, i_2)^\ast}`.

#. Return :math:`{{{\mathrm{iadd\_sat}}}{\mathsf{s}}{{}_{N}(j_1, j_2)}^\ast}`.


:math:`{{\mathrm{ivextbinop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{f}}, {\mathit{sx}}_1, {\mathit{sx}}_2, i, k, v_1, v_2)`
................................................................................................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_1){}[i : k]`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_2){}[i : k]`.

#. Let :math:`{{c'}_1^\ast}` be :math:`\epsilon`.

#. For each :math:`c_1` in :math:`{c_1^\ast}`, do:

   a. Let :math:`{c'}_1` be :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}_1}}}{(c_1)}`.

   #. Append :math:`{c'}_1` to :math:`{{c'}_1^\ast}`.

#. Let :math:`{{c'}_2^\ast}` be :math:`\epsilon`.

#. For each :math:`c_2` in :math:`{c_2^\ast}`, do:

   a. Let :math:`{c'}_2` be :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}_2}}}{(c_2)}`.

   #. Append :math:`{c'}_2` to :math:`{{c'}_2^\ast}`.

#. Let :math:`{c^\ast}` be :math:`{{\mathrm{f}}}_{N_2}({{c'}_1^\ast}, {{c'}_2^\ast})`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivmul}}}_{N}({i_1^\ast}, {i_2^\ast})`
......................................................


1. Return :math:`{{{\mathrm{imul}}}_{N}(i_1, i_2)^\ast}`.


:math:`{{\mathit{vextbinop}}}{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}(v_1, v_2)}`
.............................................................................................................................


1. If :math:`{\mathit{vextbinop}}` is some :math:`{\mathsf{extmul}}{\mathsf{\_}}{{\mathit{half}}}{\mathsf{\_}}{{\mathit{sx}}}`, then:

   a. Let :math:`({\mathsf{extmul}}{\mathsf{\_}}{{\mathit{half}}}{\mathsf{\_}}{{\mathit{sx}}})` be the destructuring of :math:`{\mathit{vextbinop}}`.

   #. Return :math:`{{\mathrm{ivextbinop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{ivmul}}, {\mathit{sx}}, {\mathit{sx}}, {\mathrm{half}}({\mathit{half}}, 0, M_2), M_2, v_1, v_2)`.

#. If :math:`{\mathit{vextbinop}} = `, then:

   a. Return :math:`{{\mathrm{ivextbinop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{ivdot}}, \mathsf{s}, \mathsf{s}, 0, M_1, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{vextbinop}} = `.

#. Return :math:`{{\mathrm{ivextbinop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{ivdot}}_{{\mathit{sat}}}, \mathsf{s}, {{\mathrm{relaxed}}({\mathrm{R}}_{\mathit{idot}})}{{}[ \mathsf{s}, \mathsf{u} ]}, 0, M_1, v_1, v_2)`.


:math:`{}{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}(c_1, c_2, c_3)}`
..............................................................................................................


1. Let :math:`M` be :math:`2 \, M_2`.

#. Let :math:`{\mathsf{i}}{N}` be the result for which :math:`N` :math:`=` :math:`2 \cdot N_1`.

#. Let :math:`{c'}` be :math:`{}{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c_1, c_2)}`.

#. Let :math:`{c''}` be :math:`{{\mathsf{extadd\_pairwise}}{\mathsf{\_}}{\mathsf{s}}}{{}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({c'})}`.

#. Let :math:`c` be an element of :math:`{\mathsf{add}}{{}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({c''}, c_3)}`.

#. Return :math:`c`.


:math:`{\mathrm{Ki}}`
.....................


1. Return :math:`1024`.


:math:`{{\mathrm{pack}}}_{{\mathit{storagetype}}}({\mathit{val}})`
..................................................................


1. If :math:`{\mathit{storagetype}}` is value type, then:

   a. Return :math:`{\mathit{val}}`.

#. Assert: Due to validation, :math:`{\mathit{storagetype}}` is packed type.

#. Assert: Due to validation, :math:`{\mathit{val}}` is some :math:`{\mathit{numtype}}{.}\mathsf{const}~{{\mathit{num}}}_{{\mathit{numtype}}}`.

#. Let :math:`({\mathit{numtype}}_0{.}\mathsf{const}~i)` be the destructuring of :math:`{\mathit{val}}`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0 = \mathsf{i{\scriptstyle 32}}`.

#. Return :math:`({\mathit{storagetype}}{.}\mathsf{pack}~{{\mathrm{wrap}}}_{32, {|{\mathit{storagetype}}|}}(i))`.


:math:`{{{{\mathrm{unpack}}}_{{\mathit{storagetype}}}^{{{\mathit{sx}'}^?}}}}{({\mathit{fieldval}})}`
....................................................................................................


1. If :math:`{\mathit{storagetype}}` is value type and :math:`{\mathit{fieldval}}` is value and :math:`{{\mathit{sx}'}^?}` is not defined, then:

   a. Return :math:`{\mathit{fieldval}}`.

#. Assert: Due to validation, :math:`{\mathit{fieldval}}` is some :math:`{\mathit{packtype}}{.}\mathsf{pack}~{i}{N}`.

#. Let :math:`({\mathit{packtype}}{.}\mathsf{pack}~i)` be the destructuring of :math:`{\mathit{fieldval}}`.

#. Assert: Due to validation, :math:`{{\mathit{sx}'}^?}` is defined.

#. Let :math:`{\mathit{sx}}` be :math:`{{\mathit{sx}'}^?}`.

#. Assert: Due to validation, :math:`{\mathit{storagetype}} = {\mathit{packtype}}`.

#. Return :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{{|{\mathit{packtype}}|}, 32}^{{\mathit{sx}}}}}{(i)})`.


:math:`{\mathrm{tags}}({{\mathit{externaddr}'}^\ast})`
......................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{tag}~{\mathit{tagaddr}}`, then:

   a. Let :math:`(\mathsf{tag}~a)` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`a~{\mathrm{tags}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{tags}}({{\mathit{xa}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`
.........................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{global}~{\mathit{globaladdr}}`, then:

   a. Let :math:`(\mathsf{global}~a)` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`a~{\mathrm{globals}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xa}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`
......................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{mem}~{\mathit{memaddr}}`, then:

   a. Let :math:`(\mathsf{mem}~a)` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`a~{\mathrm{mems}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xa}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`
........................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{table}~{\mathit{tableaddr}}`, then:

   a. Let :math:`(\mathsf{table}~a)` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`a~{\mathrm{tables}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xa}}^\ast})`.


:math:`{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`
.......................................................


1. If :math:`{{\mathit{externaddr}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is some :math:`\mathsf{func}~{\mathit{funcaddr}}`, then:

   a. Let :math:`(\mathsf{func}~a)` be the destructuring of :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`a~{\mathrm{funcs}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}'}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xa}}^\ast})`.


:math:`(s, f){.}\mathsf{store}`
...............................


1. Return.


:math:`(s, f){.}\mathsf{frame}`
...............................


1. Return :math:`f`.


:math:`(s, f){.}\mathsf{tags}`
..............................


1. Return :math:`f{.}\mathsf{module}{.}\mathsf{tags}`.


:math:`(s, f){.}\mathsf{module}`
................................


1. Return :math:`f{.}\mathsf{module}`.


:math:`(s, f){.}\mathsf{tags}`
..............................


1. Return :math:`s{.}\mathsf{tags}`.


:math:`(s, f){.}\mathsf{globals}`
.................................


1. Return :math:`s{.}\mathsf{globals}`.


:math:`(s, f){.}\mathsf{mems}`
..............................


1. Return :math:`s{.}\mathsf{mems}`.


:math:`(s, f){.}\mathsf{tables}`
................................


1. Return :math:`s{.}\mathsf{tables}`.


:math:`(s, f){.}\mathsf{funcs}`
...............................


1. Return :math:`s{.}\mathsf{funcs}`.


:math:`(s, f){.}\mathsf{datas}`
...............................


1. Return :math:`s{.}\mathsf{datas}`.


:math:`(s, f){.}\mathsf{elems}`
...............................


1. Return :math:`s{.}\mathsf{elems}`.


:math:`(s, f){.}\mathsf{structs}`
.................................


1. Return :math:`s{.}\mathsf{structs}`.


:math:`(s, f){.}\mathsf{arrays}`
................................


1. Return :math:`s{.}\mathsf{arrays}`.


:math:`(s, f){.}\mathsf{exns}`
..............................


1. Return :math:`s{.}\mathsf{exns}`.


:math:`(s, f){.}\mathsf{types}{}[x]`
....................................


1. Return :math:`f{.}\mathsf{module}{.}\mathsf{types}{}[x]`.


:math:`(s, f){.}\mathsf{tags}{}[x]`
...................................


1. Return :math:`s{.}\mathsf{tags}{}[f{.}\mathsf{module}{.}\mathsf{tags}{}[x]]`.


:math:`(s, f){.}\mathsf{globals}{}[x]`
......................................


1. Return :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]`.


:math:`(s, f){.}\mathsf{mems}{}[x]`
...................................


1. Return :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]`.


:math:`(s, f){.}\mathsf{tables}{}[x]`
.....................................


1. Return :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]`.


:math:`(s, f){.}\mathsf{funcs}{}[x]`
....................................


1. Return :math:`s{.}\mathsf{funcs}{}[f{.}\mathsf{module}{.}\mathsf{funcs}{}[x]]`.


:math:`(s, f){.}\mathsf{datas}{}[x]`
....................................


1. Return :math:`s{.}\mathsf{datas}{}[f{.}\mathsf{module}{.}\mathsf{datas}{}[x]]`.


:math:`(s, f){.}\mathsf{elems}{}[x]`
....................................


1. Return :math:`s{.}\mathsf{elems}{}[f{.}\mathsf{module}{.}\mathsf{elems}{}[x]]`.


:math:`(s, f){.}\mathsf{locals}{}[x]`
.....................................


1. Return :math:`f{.}\mathsf{locals}{}[x]`.


:math:`(s, f){}[{.}\mathsf{locals}{}[x] = v]`
.............................................


1. Replace :math:`f{.}\mathsf{locals}{}[x]` with :math:`v`.


:math:`(s, f){}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = v]`
...............................................................


1. Replace :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]{.}\mathsf{value}` with :math:`v`.


:math:`(s, f){}[{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i] = r]`
..................................................................


1. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]{.}\mathsf{refs}{}[i]` with :math:`r`.


:math:`(s, f){}[{.}\mathsf{tables}{}[x] = {\mathit{ti}}]`
.........................................................


1. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]` with :math:`{\mathit{ti}}`.


:math:`(s, f){}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i : j] = {b^\ast}]`
............................................................................


1. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]{.}\mathsf{bytes}{}[i : j]` with :math:`{b^\ast}`.


:math:`(s, f){}[{.}\mathsf{mems}{}[x] = {\mathit{mi}}]`
.......................................................


1. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]` with :math:`{\mathit{mi}}`.


:math:`(s, f){}[{.}\mathsf{elems}{}[x]{.}\mathsf{refs} = {r^\ast}]`
...................................................................


1. Replace :math:`s{.}\mathsf{elems}{}[f{.}\mathsf{module}{.}\mathsf{elems}{}[x]]{.}\mathsf{refs}` with :math:`{r^\ast}`.


:math:`(s, f){}[{.}\mathsf{datas}{}[x]{.}\mathsf{bytes} = {b^\ast}]`
....................................................................


1. Replace :math:`s{.}\mathsf{datas}{}[f{.}\mathsf{module}{.}\mathsf{datas}{}[x]]{.}\mathsf{bytes}` with :math:`{b^\ast}`.


:math:`(s, f){}[{.}\mathsf{structs}{}[a]{.}\mathsf{fields}{}[i] = {\mathit{fv}}]`
.................................................................................


1. Replace :math:`s{.}\mathsf{structs}{}[a]{.}\mathsf{fields}{}[i]` with :math:`{\mathit{fv}}`.


:math:`(s, f){}[{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}{}[i] = {\mathit{fv}}]`
................................................................................


1. Replace :math:`s{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}{}[i]` with :math:`{\mathit{fv}}`.


:math:`(s, f){}[{.}\mathsf{structs} \mathrel{{=}{\oplus}} {{\mathit{si}}^\ast}]`
................................................................................


1. Append :math:`{{\mathit{si}}^\ast}` to :math:`s{.}\mathsf{structs}`.


:math:`(s, f){}[{.}\mathsf{arrays} \mathrel{{=}{\oplus}} {{\mathit{ai}}^\ast}]`
...............................................................................


1. Append :math:`{{\mathit{ai}}^\ast}` to :math:`s{.}\mathsf{arrays}`.


:math:`(s, f){}[{.}\mathsf{exns} \mathrel{{=}{\oplus}} {{\mathit{exn}}^\ast}]`
..............................................................................


1. Append :math:`{{\mathit{exn}}^\ast}` to :math:`s{.}\mathsf{exns}`.


:math:`{\mathrm{growtable}}({\mathit{tableinst}}, n, r)`
........................................................


1. Let :math:`\{ \mathsf{type}~({\mathit{at}}~{}[ i .. {j^?} ]~{\mathit{rt}}),\;\allowbreak \mathsf{refs}~{{r'}^\ast} \}` be the destructuring of :math:`{\mathit{tableinst}}`.

#. Let :math:`{i'}` be :math:`{|{{r'}^\ast}|} + n`.

#. If :math:`{({i'} \leq j)^?}`, then:

   a. Let :math:`{\mathit{tableinst}'}` be the table instance :math:`\{ \mathsf{type}~({\mathit{at}}~{}[ {i'} .. {j^?} ]~{\mathit{rt}}),\;\allowbreak \mathsf{refs}~{{r'}^\ast}~{r^{n}} \}`.

   #. Return :math:`{\mathit{tableinst}'}`.

#. Fail.


:math:`{\mathrm{growmem}}({\mathit{meminst}}, n)`
.................................................


1. Let :math:`\{ \mathsf{type}~({\mathit{at}}~{}[ i .. {j^?} ]~\mathsf{page}),\;\allowbreak \mathsf{bytes}~{b^\ast} \}` be the destructuring of :math:`{\mathit{meminst}}`.

#. Let :math:`{i'}` be :math:`{|{b^\ast}|} / (64 \, {\mathrm{Ki}}) + n`.

#. If :math:`{({i'} \leq j)^?}`, then:

   a. Let :math:`{\mathit{meminst}'}` be the memory instance :math:`\{ \mathsf{type}~({\mathit{at}}~{}[ {i'} .. {j^?} ]~\mathsf{page}),\;\allowbreak \mathsf{bytes}~{b^\ast}~{\mathtt{0x00}^{n \cdot 64 \, {\mathrm{Ki}}}} \}`.

   #. Return :math:`{\mathit{meminst}'}`.

#. Fail.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}(t)`
....................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{t}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}({\mathit{rt}})`
................................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{{\mathit{rt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}({\mathit{gt}})`
................................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{{\mathit{gt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}({\mathit{mt}})`
................................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{{\mathit{mt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}({\mathit{tt}})`
................................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{{\mathit{tt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{blocktype}}}_{z}({\mathit{blocktype}})`
........................................................


1. If :math:`{\mathit{blocktype}}` is some :math:`{\mathit{funcidx}}`, then:

   a. Let :math:`x` be the block type :math:`{\mathit{blocktype}}`.

   #. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]` is some :math:`\mathsf{func}~{\mathit{resulttype}} \rightarrow {\mathit{resulttype}}`.

   #. Let :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`z{.}\mathsf{types}{}[x]`.

   #. Return :math:`{t_1^\ast}~{\rightarrow}_{\epsilon}\,{t_2^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{blocktype}}` is some :math:`{{\mathit{valtype}}^?}`.

#. Let :math:`{t^?}` be the block type :math:`{\mathit{blocktype}}`.

#. Return :math:`\epsilon~{\rightarrow}_{\epsilon}\,{t^?}`.


:math:`{{{\mathrm{alloctype}}^\ast}}{({{\mathit{type}''}^\ast})}`
.................................................................


1. If :math:`{{\mathit{type}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{{\mathit{type}'}^\ast}~{\mathit{type}}` be :math:`{{\mathit{type}''}^\ast}`.

#. Let :math:`(\mathsf{type}~{\mathit{rectype}})` be the destructuring of :math:`{\mathit{type}}`.

#. Let :math:`{{\mathit{deftype}'}^\ast}` be :math:`{{{\mathrm{alloctype}}^\ast}}{({{\mathit{type}'}^\ast})}`.

#. Let :math:`x` be the length of :math:`{{\mathit{deftype}'}^\ast}`.

#. Let :math:`{{\mathit{deftype}}^\ast}` be :math:`{{{{{\mathrm{roll}}}_{x}^\ast}}{({\mathit{rectype}})}}{{}[ {:=}\, {{\mathit{deftype}'}^\ast} ]}`.

#. Return :math:`{{\mathit{deftype}'}^\ast}~{{\mathit{deftype}}^\ast}`.


:math:`{\mathrm{alloctag}}(s, {\mathit{tagtype}})`
..................................................


1. Let :math:`{\mathit{taginst}}` be the tag instance :math:`\{ \mathsf{type}~{\mathit{tagtype}} \}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{tags}`.

#. Append :math:`{\mathit{taginst}}` to :math:`s{.}\mathsf{tags}`.

#. Return :math:`a`.


:math:`{{{\mathrm{alloctag}}^\ast}}{(s, {{\mathit{tagtype}''}^\ast})}`
......................................................................


1. If :math:`{{\mathit{tagtype}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{tagtype}}~{{\mathit{tagtype}'}^\ast}` be :math:`{{\mathit{tagtype}''}^\ast}`.

#. Let :math:`{\mathit{ja}}` be :math:`{\mathrm{alloctag}}(s, {\mathit{tagtype}})`.

#. Let :math:`{{\mathit{ja}'}^\ast}` be :math:`{{{\mathrm{alloctag}}^\ast}}{(s, {{\mathit{tagtype}'}^\ast})}`.

#. Return :math:`{\mathit{ja}}~{{\mathit{ja}'}^\ast}`.


:math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`
........................................................................


1. Let :math:`{\mathit{globalinst}}` be the global instance :math:`\{ \mathsf{type}~{\mathit{globaltype}},\;\allowbreak \mathsf{value}~{\mathit{val}} \}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{globals}`.

#. Append :math:`{\mathit{globalinst}}` to :math:`s{.}\mathsf{globals}`.

#. Return :math:`a`.


:math:`{{{\mathrm{allocglobal}}^\ast}}{(s, {{\mathit{globaltype}''}^\ast}, {{\mathit{val}''}^\ast})}`
.....................................................................................................


1. If :math:`{{\mathit{globaltype}''}^\ast} = \epsilon`, then:

   a. Assert: Due to validation, :math:`{{\mathit{val}''}^\ast} = \epsilon`.

   #. Return :math:`\epsilon`.

#. Else:

   a. Let :math:`{\mathit{globaltype}}~{{\mathit{globaltype}'}^\ast}` be :math:`{{\mathit{globaltype}''}^\ast}`.

   #. Assert: Due to validation, :math:`{|{{\mathit{val}''}^\ast}|} \geq 1`.

   #. Let :math:`{\mathit{val}}~{{\mathit{val}'}^\ast}` be :math:`{{\mathit{val}''}^\ast}`.

   #. Let :math:`{\mathit{ga}}` be :math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`.

   #. Let :math:`{{\mathit{ga}'}^\ast}` be :math:`{{{\mathrm{allocglobal}}^\ast}}{(s, {{\mathit{globaltype}'}^\ast}, {{\mathit{val}'}^\ast})}`.

   #. Return :math:`{\mathit{ga}}~{{\mathit{ga}'}^\ast}`.


:math:`{\mathrm{allocmem}}(s, {\mathit{at}}~{}[ i .. {j^?} ]~\mathsf{page})`
............................................................................


1. Let :math:`{\mathit{meminst}}` be the memory instance :math:`\{ \mathsf{type}~({\mathit{at}}~{}[ i .. {j^?} ]~\mathsf{page}),\;\allowbreak \mathsf{bytes}~{\mathtt{0x00}^{i \cdot 64 \, {\mathrm{Ki}}}} \}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{mems}`.

#. Append :math:`{\mathit{meminst}}` to :math:`s{.}\mathsf{mems}`.

#. Return :math:`a`.


:math:`{{{\mathrm{allocmem}}^\ast}}{(s, {{\mathit{memtype}''}^\ast})}`
......................................................................


1. If :math:`{{\mathit{memtype}''}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{memtype}}~{{\mathit{memtype}'}^\ast}` be :math:`{{\mathit{memtype}''}^\ast}`.

#. Let :math:`{\mathit{ma}}` be :math:`{\mathrm{allocmem}}(s, {\mathit{memtype}})`.

#. Let :math:`{{\mathit{ma}'}^\ast}` be :math:`{{{\mathrm{allocmem}}^\ast}}{(s, {{\mathit{memtype}'}^\ast})}`.

#. Return :math:`{\mathit{ma}}~{{\mathit{ma}'}^\ast}`.


:math:`{\mathrm{alloctable}}(s, {\mathit{at}}~{}[ i .. {j^?} ]~{\mathit{rt}}, {\mathit{ref}})`
..............................................................................................


1. Let :math:`{\mathit{tableinst}}` be the table instance :math:`\{ \mathsf{type}~({\mathit{at}}~{}[ i .. {j^?} ]~{\mathit{rt}}),\;\allowbreak \mathsf{refs}~{{\mathit{ref}}^{i}} \}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{tables}`.

#. Append :math:`{\mathit{tableinst}}` to :math:`s{.}\mathsf{tables}`.

#. Return :math:`a`.


:math:`{{{\mathrm{alloctable}}^\ast}}{(s, {{\mathit{tabletype}''}^\ast}, {{\mathit{ref}''}^\ast})}`
...................................................................................................


1. If :math:`{{\mathit{ref}''}^\ast} = \epsilon`, then:

   a. Assert: Due to validation, :math:`{{\mathit{tabletype}''}^\ast} = \epsilon`.

   #. Return :math:`\epsilon`.

#. Else:

   a. Let :math:`{\mathit{ref}}~{{\mathit{ref}'}^\ast}` be :math:`{{\mathit{ref}''}^\ast}`.

   #. Assert: Due to validation, :math:`{|{{\mathit{tabletype}''}^\ast}|} \geq 1`.

   #. Let :math:`{\mathit{tabletype}}~{{\mathit{tabletype}'}^\ast}` be :math:`{{\mathit{tabletype}''}^\ast}`.

   #. Let :math:`{\mathit{ta}}` be :math:`{\mathrm{alloctable}}(s, {\mathit{tabletype}}, {\mathit{ref}})`.

   #. Let :math:`{{\mathit{ta}'}^\ast}` be :math:`{{{\mathrm{alloctable}}^\ast}}{(s, {{\mathit{tabletype}'}^\ast}, {{\mathit{ref}'}^\ast})}`.

   #. Return :math:`{\mathit{ta}}~{{\mathit{ta}'}^\ast}`.


:math:`{\mathrm{allocfunc}}(s, {\mathit{deftype}}, {\mathit{code}}, {\mathit{moduleinst}})`
...........................................................................................


1. Let :math:`{\mathit{funcinst}}` be the function instance :math:`\{ \mathsf{type}~{\mathit{deftype}},\;\allowbreak \mathsf{module}~{\mathit{moduleinst}},\;\allowbreak \mathsf{code}~{\mathit{code}} \}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{funcs}`.

#. Append :math:`{\mathit{funcinst}}` to :math:`s{.}\mathsf{funcs}`.

#. Return :math:`a`.


:math:`{{{\mathrm{allocfunc}}^\ast}}{(s, {{\mathit{deftype}}^\ast}, {{{\mathit{code}}''}^\ast}, {{\mathit{moduleinst}''}^\ast})}`
.................................................................................................................................


1. If :math:`{{\mathit{deftype}}^\ast} = \epsilon`, then:

   a. Assert: Due to validation, :math:`{{{\mathit{code}}''}^\ast} = \epsilon`.

   #. Assert: Due to validation, :math:`{{\mathit{moduleinst}''}^\ast} = \epsilon`.

   #. Return :math:`\epsilon`.

#. Else:

   a. Let :math:`{\mathit{dt}}~{{\mathit{dt}'}^\ast}` be :math:`{{\mathit{deftype}}^\ast}`.

   #. Assert: Due to validation, :math:`{|{{{\mathit{code}}''}^\ast}|} \geq 1`.

   #. Let :math:`{\mathit{code}}~{{{\mathit{code}}'}^\ast}` be :math:`{{{\mathit{code}}''}^\ast}`.

   #. Assert: Due to validation, :math:`{|{{\mathit{moduleinst}''}^\ast}|} \geq 1`.

   #. Let :math:`{\mathit{moduleinst}}~{{\mathit{moduleinst}'}^\ast}` be :math:`{{\mathit{moduleinst}''}^\ast}`.

   #. Let :math:`{\mathit{fa}}` be :math:`{\mathrm{allocfunc}}(s, {\mathit{dt}}, {\mathit{code}}, {\mathit{moduleinst}})`.

   #. Let :math:`{{\mathit{fa}'}^\ast}` be :math:`{{{\mathrm{allocfunc}}^\ast}}{(s, {{\mathit{dt}'}^\ast}, {{{\mathit{code}}'}^\ast}, {{\mathit{moduleinst}'}^\ast})}`.

   #. Return :math:`{\mathit{fa}}~{{\mathit{fa}'}^\ast}`.


:math:`{\mathrm{allocdata}}(s, \mathsf{ok}, {{\mathit{byte}}^\ast})`
....................................................................


1. Let :math:`{\mathit{datainst}}` be the data instance :math:`\{ \mathsf{bytes}~{{\mathit{byte}}^\ast} \}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{datas}`.

#. Append :math:`{\mathit{datainst}}` to :math:`s{.}\mathsf{datas}`.

#. Return :math:`a`.


:math:`{{{\mathrm{allocdata}}^\ast}}{(s, {{\mathit{datatype}}^\ast}, {{\mathit{byte}}^\ast})}`
..............................................................................................


1. If :math:`{{\mathit{byte}}^\ast} = \epsilon`, then:

   a. Assert: Due to validation, :math:`{{\mathit{datatype}}^\ast} = \epsilon`.

   #. Return :math:`\epsilon`.

#. Else:

   a. Let :math:`{b^\ast}~{{{b'}^\ast}^\ast}` be :math:`{{\mathit{byte}}^\ast}`.

   #. Assert: Due to validation, :math:`{|{{\mathit{datatype}}^\ast}|} \geq 1`.

   #. Let :math:`{\mathit{ok}}~{{\mathit{ok}'}^\ast}` be :math:`{{\mathit{datatype}}^\ast}`.

   #. Let :math:`{\mathit{da}}` be :math:`{\mathrm{allocdata}}(s, {\mathit{ok}}, {b^\ast})`.

   #. Let :math:`{{\mathit{da}'}^\ast}` be :math:`{{{\mathrm{allocdata}}^\ast}}{(s, {{\mathit{ok}'}^\ast}, {{{b'}^\ast}^\ast})}`.

   #. Return :math:`{\mathit{da}}~{{\mathit{da}'}^\ast}`.


:math:`{\mathrm{allocelem}}(s, {\mathit{elemtype}}, {{\mathit{ref}}^\ast})`
...........................................................................


1. Let :math:`{\mathit{eleminst}}` be the element instance :math:`\{ \mathsf{type}~{\mathit{elemtype}},\;\allowbreak \mathsf{refs}~{{\mathit{ref}}^\ast} \}`.

#. Let :math:`a` be the length of :math:`s{.}\mathsf{elems}`.

#. Append :math:`{\mathit{eleminst}}` to :math:`s{.}\mathsf{elems}`.

#. Return :math:`a`.


:math:`{{{\mathrm{allocelem}}^\ast}}{(s, {{\mathit{elemtype}}^\ast}, {{\mathit{ref}''}^\ast})}`
...............................................................................................


1. If :math:`{{\mathit{ref}''}^\ast} = \epsilon`, then:

   a. Assert: Due to validation, :math:`{{\mathit{elemtype}}^\ast} = \epsilon`.

   #. Return :math:`\epsilon`.

#. Else:

   a. Let :math:`{{\mathit{ref}}^\ast}~{{{\mathit{ref}'}^\ast}^\ast}` be :math:`{{\mathit{ref}''}^\ast}`.

   #. Assert: Due to validation, :math:`{|{{\mathit{elemtype}}^\ast}|} \geq 1`.

   #. Let :math:`{\mathit{rt}}~{{\mathit{rt}'}^\ast}` be :math:`{{\mathit{elemtype}}^\ast}`.

   #. Let :math:`{\mathit{ea}}` be :math:`{\mathrm{allocelem}}(s, {\mathit{rt}}, {{\mathit{ref}}^\ast})`.

   #. Let :math:`{{\mathit{ea}'}^\ast}` be :math:`{{{\mathrm{allocelem}}^\ast}}{(s, {{\mathit{rt}'}^\ast}, {{{\mathit{ref}'}^\ast}^\ast})}`.

   #. Return :math:`{\mathit{ea}}~{{\mathit{ea}'}^\ast}`.


:math:`{\mathrm{allocexport}}({\mathit{moduleinst}}, \mathsf{export}~{\mathit{name}}~{\mathit{externidx}})`
...........................................................................................................


1. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{tag}~{\mathit{tagidx}}`, then:

   a. Let :math:`(\mathsf{tag}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`\{ \mathsf{name}~{\mathit{name}},\;\allowbreak \mathsf{addr}~(\mathsf{tag}~{\mathit{moduleinst}}{.}\mathsf{tags}{}[x]) \}`.

#. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{global}~{\mathit{globalidx}}`, then:

   a. Let :math:`(\mathsf{global}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`\{ \mathsf{name}~{\mathit{name}},\;\allowbreak \mathsf{addr}~(\mathsf{global}~{\mathit{moduleinst}}{.}\mathsf{globals}{}[x]) \}`.

#. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{mem}~{\mathit{memidx}}`, then:

   a. Let :math:`(\mathsf{mem}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`\{ \mathsf{name}~{\mathit{name}},\;\allowbreak \mathsf{addr}~(\mathsf{mem}~{\mathit{moduleinst}}{.}\mathsf{mems}{}[x]) \}`.

#. If :math:`{\mathit{externidx}}` is some :math:`\mathsf{table}~{\mathit{tableidx}}`, then:

   a. Let :math:`(\mathsf{table}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

   #. Return :math:`\{ \mathsf{name}~{\mathit{name}},\;\allowbreak \mathsf{addr}~(\mathsf{table}~{\mathit{moduleinst}}{.}\mathsf{tables}{}[x]) \}`.

#. Assert: Due to validation, :math:`{\mathit{externidx}}` is some :math:`\mathsf{func}~{\mathit{funcidx}}`.

#. Let :math:`(\mathsf{func}~x)` be the destructuring of :math:`{\mathit{externidx}}`.

#. Return :math:`\{ \mathsf{name}~{\mathit{name}},\;\allowbreak \mathsf{addr}~(\mathsf{func}~{\mathit{moduleinst}}{.}\mathsf{funcs}{}[x]) \}`.


:math:`{{{\mathrm{allocexport}}^\ast}}{({\mathit{moduleinst}}, {{\mathit{export}}^\ast})}`
..........................................................................................


1. Return :math:`{{\mathrm{allocexport}}({\mathit{moduleinst}}, {\mathit{export}})^\ast}`.


:math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}_{\mathsf{g}}^\ast}, {{\mathit{ref}}_{\mathsf{t}}^\ast}, {{{\mathit{ref}}_{\mathsf{e}}^\ast}^\ast})`
.....................................................................................................................................................................................................


1. Let :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{tag}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be the destructuring of :math:`{\mathit{module}}`.

#. Let :math:`{{\mathit{aa}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{tags}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ga}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{globals}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{fa}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ma}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{mems}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ta}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{tables}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{fa}}^\ast}` be :math:`{|s{.}\mathsf{funcs}|} + i_{\mathsf{f}}` for all :math:`i_{\mathsf{f}}` from :math:`0` to :math:`{|{{\mathit{func}}^\ast}|} - 1`.

#. Let :math:`{{\mathit{tagtype}}^\ast}` be the tag type sequence :math:`\epsilon`.

#. For each :math:`{\mathit{tag}}` in :math:`{{\mathit{tag}}^\ast}`, do:

   a. Let :math:`(\mathsf{tag}~{\mathit{tagtype}})` be the destructuring of :math:`{\mathit{tag}}`.

   #. Append :math:`{\mathit{tagtype}}` to :math:`{{\mathit{tagtype}}^\ast}`.

#. Let :math:`{{{\mathit{byte}}^\ast}^\ast}` be the byte sequence sequence :math:`\epsilon`.

#. For each :math:`{\mathit{data}}` in :math:`{{\mathit{data}}^\ast}`, do:

   a. Let :math:`(\mathsf{data}~{{\mathit{byte}}^\ast}~{\mathit{datamode}})` be the destructuring of :math:`{\mathit{data}}`.

   #. Append :math:`{{\mathit{byte}}^\ast}` to :math:`{{{\mathit{byte}}^\ast}^\ast}`.

#. Let :math:`{{\mathit{globaltype}}^\ast}` be the global type sequence :math:`\epsilon`.

#. For each :math:`{\mathit{global}}` in :math:`{{\mathit{global}}^\ast}`, do:

   a. Let :math:`(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_{\mathsf{g}})` be the destructuring of :math:`{\mathit{global}}`.

   #. Append :math:`{\mathit{globaltype}}` to :math:`{{\mathit{globaltype}}^\ast}`.

#. Let :math:`{{\mathit{tabletype}}^\ast}` be the table type sequence :math:`\epsilon`.

#. For each :math:`{\mathit{table}}` in :math:`{{\mathit{table}}^\ast}`, do:

   a. Let :math:`(\mathsf{table}~{\mathit{tabletype}}~{\mathit{expr}}_{\mathsf{t}})` be the destructuring of :math:`{\mathit{table}}`.

   #. Append :math:`{\mathit{tabletype}}` to :math:`{{\mathit{tabletype}}^\ast}`.

#. Let :math:`{{\mathit{memtype}}^\ast}` be the memory type sequence :math:`\epsilon`.

#. For each :math:`{\mathit{mem}}` in :math:`{{\mathit{mem}}^\ast}`, do:

   a. Let :math:`(\mathsf{memory}~{\mathit{memtype}})` be the destructuring of :math:`{\mathit{mem}}`.

   #. Append :math:`{\mathit{memtype}}` to :math:`{{\mathit{memtype}}^\ast}`.

#. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{{{\mathrm{alloctype}}^\ast}}{({{\mathit{type}}^\ast})}`.

#. Let :math:`{{\mathit{elemtype}}^\ast}` be the reference type sequence :math:`\epsilon`.

#. For each :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}`, do:

   a. Let :math:`(\mathsf{elem}~{\mathit{elemtype}}~{{\mathit{expr}}_{\mathsf{e}}^\ast}~{\mathit{elemmode}})` be the destructuring of :math:`{\mathit{elem}}`.

   #. Append :math:`{\mathit{elemtype}}` to :math:`{{\mathit{elemtype}}^\ast}`.

#. Let :math:`{{\mathit{expr}}_{\mathsf{f}}^\ast}` be the expression sequence :math:`\epsilon`.

#. Let :math:`{{{\mathit{local}}^\ast}^\ast}` be the local sequence sequence :math:`\epsilon`.

#. Let :math:`{x^\ast}` be the type index sequence :math:`\epsilon`.

#. For each :math:`{\mathit{func}}` in :math:`{{\mathit{func}}^\ast}`, do:

   a. Let :math:`(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}}_{\mathsf{f}})` be the destructuring of :math:`{\mathit{func}}`.

   #. Append :math:`{\mathit{expr}}_{\mathsf{f}}` to :math:`{{\mathit{expr}}_{\mathsf{f}}^\ast}`.

   #. Append :math:`{{\mathit{local}}^\ast}` to :math:`{{{\mathit{local}}^\ast}^\ast}`.

   #. Append :math:`x` to :math:`{x^\ast}`.

#. Let :math:`{{\mathit{aa}}^\ast}` be :math:`\epsilon`.

#. For each :math:`{\mathit{tagtype}}` in :math:`{{\mathit{tagtype}}^\ast}`, do:

   a. Let :math:`{\mathit{aa}}` be the tag address :math:`{\mathrm{alloctag}}(s, {{\mathit{tagtype}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]})`.

   #. Append :math:`{\mathit{aa}}` to :math:`{{\mathit{aa}}^\ast}`.

#. Let :math:`{{\mathit{ga}}^\ast}` be :math:`\epsilon`.

#. For each :math:`{\mathit{globaltype}}` in :math:`{{\mathit{globaltype}}^\ast}` and :math:`{\mathit{val}}_{\mathsf{g}}` in :math:`{{\mathit{val}}_{\mathsf{g}}^\ast}`, do:

   a. Let :math:`{\mathit{ga}}` be the global address :math:`{\mathrm{allocglobal}}(s, {{\mathit{globaltype}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}, {\mathit{val}}_{\mathsf{g}})`.

   #. Append :math:`{\mathit{ga}}` to :math:`{{\mathit{ga}}^\ast}`.

#. Let :math:`{{\mathit{ma}}^\ast}` be :math:`\epsilon`.

#. For each :math:`{\mathit{memtype}}` in :math:`{{\mathit{memtype}}^\ast}`, do:

   a. Let :math:`{\mathit{ma}}` be the memory address :math:`{\mathrm{allocmem}}(s, {{\mathit{memtype}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]})`.

   #. Append :math:`{\mathit{ma}}` to :math:`{{\mathit{ma}}^\ast}`.

#. Let :math:`{{\mathit{ta}}^\ast}` be :math:`\epsilon`.

#. For each :math:`{\mathit{tabletype}}` in :math:`{{\mathit{tabletype}}^\ast}` and :math:`{\mathit{ref}}_{\mathsf{t}}` in :math:`{{\mathit{ref}}_{\mathsf{t}}^\ast}`, do:

   a. Let :math:`{\mathit{ta}}` be the table address :math:`{\mathrm{alloctable}}(s, {{\mathit{tabletype}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}, {\mathit{ref}}_{\mathsf{t}})`.

   #. Append :math:`{\mathit{ta}}` to :math:`{{\mathit{ta}}^\ast}`.

#. Let :math:`{{\mathit{xi}}^\ast}` be :math:`\epsilon`.

#. For each :math:`{\mathit{export}}` in :math:`{{\mathit{export}}^\ast}`, do:

   a. Let :math:`{\mathit{xi}}` be the export instance :math:`{\mathrm{allocexport}}({\mathit{moduleinst}}, {\mathit{export}})`.

   #. Append :math:`{\mathit{xi}}` to :math:`{{\mathit{xi}}^\ast}`.

#. Let :math:`{{\mathit{da}}^\ast}` be :math:`\epsilon`.

#. For each :math:`{{\mathit{byte}}^\ast}` in :math:`{{{\mathit{byte}}^\ast}^\ast}`, do:

   a. Let :math:`{\mathit{da}}` be the data address :math:`{\mathrm{allocdata}}(s, \mathsf{ok}, {{\mathit{byte}}^\ast})`.

   #. Append :math:`{\mathit{da}}` to :math:`{{\mathit{da}}^\ast}`.

#. Let :math:`{{\mathit{ea}}^\ast}` be :math:`\epsilon`.

#. For each :math:`{\mathit{elemtype}}` in :math:`{{\mathit{elemtype}}^\ast}` and :math:`{{\mathit{ref}}_{\mathsf{e}}^\ast}` in :math:`{{{\mathit{ref}}_{\mathsf{e}}^\ast}^\ast}`, do:

   a. Let :math:`{\mathit{ea}}` be the elem address :math:`{\mathrm{allocelem}}(s, {{\mathit{elemtype}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}, {{\mathit{ref}}_{\mathsf{e}}^\ast})`.

   #. Append :math:`{\mathit{ea}}` to :math:`{{\mathit{ea}}^\ast}`.

#. Let :math:`{\mathit{moduleinst}}` be the module instance :math:`\{ \mathsf{types}~{{\mathit{dt}}^\ast},\;\allowbreak \mathsf{tags}~{{\mathit{aa}}_{\mathsf{i}}^\ast}~{{\mathit{aa}}^\ast},\;\allowbreak \mathsf{globals}~{{\mathit{ga}}_{\mathsf{i}}^\ast}~{{\mathit{ga}}^\ast},\;\allowbreak \mathsf{mems}~{{\mathit{ma}}_{\mathsf{i}}^\ast}~{{\mathit{ma}}^\ast},\;\allowbreak \mathsf{tables}~{{\mathit{ta}}_{\mathsf{i}}^\ast}~{{\mathit{ta}}^\ast},\;\allowbreak \mathsf{funcs}~{{\mathit{fa}}_{\mathsf{i}}^\ast}~{{\mathit{fa}}^\ast},\;\allowbreak \mathsf{datas}~{{\mathit{da}}^\ast},\;\allowbreak \mathsf{elems}~{{\mathit{ea}}^\ast},\;\allowbreak \mathsf{exports}~{{\mathit{xi}}^\ast} \}`.

#. Let :math:`{{\mathit{funcaddr}}_0^\ast}` be :math:`\epsilon`.

#. For each :math:`{\mathit{expr}}_{\mathsf{f}}` in :math:`{{\mathit{expr}}_{\mathsf{f}}^\ast}` and :math:`{{\mathit{local}}^\ast}` in :math:`{{{\mathit{local}}^\ast}^\ast}` and :math:`x` in :math:`{x^\ast}`, do:

   a. Let :math:`{\mathit{funcaddr}}_0` be the function address :math:`{\mathrm{allocfunc}}(s, {{\mathit{dt}}^\ast}{}[x], \mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}}_{\mathsf{f}}, {\mathit{moduleinst}})`.

   #. Append :math:`{\mathit{funcaddr}}_0` to :math:`{{\mathit{funcaddr}}_0^\ast}`.

#. Assert: Due to validation, :math:`{{\mathit{funcaddr}}_0^\ast} = {{\mathit{fa}}^\ast}`.

#. Return :math:`{\mathit{moduleinst}}`.


:math:`{{\mathrm{rundata}}}_{x}(\mathsf{data}~{b^{n}}~{\mathit{datamode}})`
...........................................................................


1. If :math:`{\mathit{datamode}} = \mathsf{passive}`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{\mathit{datamode}}` is some :math:`\mathsf{active}~{\mathit{memidx}}~{\mathit{expr}}`.

#. Let :math:`(\mathsf{active}~y~{{\mathit{instr}}^\ast})` be the destructuring of :math:`{\mathit{datamode}}`.

#. Return :math:`{{\mathit{instr}}^\ast}~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)~(\mathsf{memory{.}init}~y~x)~(\mathsf{data{.}drop}~x)`.


:math:`{{\mathrm{runelem}}}_{x}(\mathsf{elem}~{\mathit{rt}}~{e^{n}}~{\mathit{elemmode}})`
.........................................................................................


1. If :math:`{\mathit{elemmode}} = \mathsf{passive}`, then:

   a. Return :math:`\epsilon`.

#. If :math:`{\mathit{elemmode}} = \mathsf{declare}`, then:

   a. Return :math:`(\mathsf{elem{.}drop}~x)`.

#. Assert: Due to validation, :math:`{\mathit{elemmode}}` is some :math:`\mathsf{active}~{\mathit{tableidx}}~{\mathit{expr}}`.

#. Let :math:`(\mathsf{active}~y~{{\mathit{instr}}^\ast})` be the destructuring of :math:`{\mathit{elemmode}}`.

#. Return :math:`{{\mathit{instr}}^\ast}~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)~(\mathsf{table{.}init}~y~x)~(\mathsf{elem{.}drop}~x)`.


:math:`{{{\mathrm{evalglobal}}^\ast}}{(z, {{\mathit{globaltype}}^\ast}, {{\mathit{expr}''}^\ast})}`
...................................................................................................


1. If :math:`{{\mathit{expr}''}^\ast} = \epsilon`, then:

   a. Assert: Due to validation, :math:`{{\mathit{globaltype}}^\ast} = \epsilon`.

   #. Return :math:`\epsilon`.

#. Else:

   a. Let :math:`{\mathit{expr}}~{{\mathit{expr}'}^\ast}` be :math:`{{\mathit{expr}''}^\ast}`.

   #. Assert: Due to validation, :math:`{|{{\mathit{globaltype}}^\ast}|} \geq 1`.

   #. Let :math:`{\mathit{gt}}~{{\mathit{gt}'}^\ast}` be :math:`{{\mathit{globaltype}}^\ast}`.

   #. Let :math:`(s, f)` be the destructuring of :math:`z`.

   #. Let :math:`{\mathit{val}}` be the result of :ref:`evaluating <exec-expr>` :math:`{\mathit{expr}}` with state :math:`z`.

   #. Let :math:`a` be :math:`{\mathrm{allocglobal}}(s, {\mathit{gt}}, {\mathit{val}})`.

   #. Append :math:`a` to :math:`f{.}\mathsf{module}{.}\mathsf{globals}`.

   #. Let :math:`{{\mathit{val}'}^\ast}` be :math:`{{{\mathrm{evalglobal}}^\ast}}{((s, f), {{\mathit{gt}'}^\ast}, {{\mathit{expr}'}^\ast})}`.

   #. Return :math:`{\mathit{val}}~{{\mathit{val}'}^\ast}`.


:math:`{\mathrm{instantiate}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast})`
..................................................................................


1. If :math:`{\mathit{module}}` is not :ref:`valid <valid-val>`, then:

   a. Fail.

#. Let :math:`{{\mathit{xt}}_{\mathsf{i}}^\ast}~\rightarrow~{{\mathit{xt}}_{\mathsf{e}}^\ast}` be the destructuring of the type of :math:`{\mathit{module}}`.

#. Let :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{tag}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be the destructuring of :math:`{\mathit{module}}`.

#. If :math:`{|{{\mathit{externaddr}}^\ast}|} \neq {|{{\mathit{xt}}_{\mathsf{i}}^\ast}|}`, then:

   a. Fail.

#. For all :math:`{\mathit{externaddr}}` in :math:`{{\mathit{externaddr}}^\ast}`, and corresponding :math:`{\mathit{xt}}_{\mathsf{i}}` in :math:`{{\mathit{xt}}_{\mathsf{i}}^\ast}`:

   a. If :math:`{\mathit{externaddr}}` is not :ref:`valid <valid-val>` with type :math:`{\mathit{xt}}_{\mathsf{i}}`, then:

      1) Fail.

#. Let :math:`{{\mathit{instr}}_{\mathsf{d}}^\ast}` be the :ref:`concatenation <notation-concat>` of :math:`{{{\mathrm{rundata}}}_{i_{\mathsf{d}}}({{\mathit{data}}^\ast}{}[i_{\mathsf{d}}])^{i_{\mathsf{d}}<{|{{\mathit{data}}^\ast}|}}}`.

#. Let :math:`{{\mathit{instr}}_{\mathsf{e}}^\ast}` be the :ref:`concatenation <notation-concat>` of :math:`{{{\mathrm{runelem}}}_{i_{\mathsf{e}}}({{\mathit{elem}}^\ast}{}[i_{\mathsf{e}}])^{i_{\mathsf{e}}<{|{{\mathit{elem}}^\ast}|}}}`.

#. Let :math:`{\mathit{moduleinst}}_0` be the module instance :math:`\{ \mathsf{types}~{{{\mathrm{alloctype}}^\ast}}{({{\mathit{type}}^\ast})},\;\allowbreak \mathsf{globals}~{\mathrm{globals}}({{\mathit{externaddr}}^\ast}),\;\allowbreak \mathsf{funcs}~{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})~{({|s{.}\mathsf{funcs}|} + i_{\mathsf{f}})^{i_{\mathsf{f}}<{|{{\mathit{func}}^\ast}|}}} \}`.

#. Let :math:`{{\mathit{expr}}_{\mathsf{t}}^\ast}` be the expression sequence :math:`\epsilon`.

#. For each :math:`{\mathit{table}}` in :math:`{{\mathit{table}}^\ast}`, do:

   a. Let :math:`(\mathsf{table}~{\mathit{tabletype}}~{\mathit{expr}}_{\mathsf{t}})` be the destructuring of :math:`{\mathit{table}}`.

   #. Append :math:`{\mathit{expr}}_{\mathsf{t}}` to :math:`{{\mathit{expr}}_{\mathsf{t}}^\ast}`.

#. Let :math:`{{\mathit{expr}}_{\mathsf{g}}^\ast}` be the expression sequence :math:`\epsilon`.

#. Let :math:`{{\mathit{globaltype}}^\ast}` be the global type sequence :math:`\epsilon`.

#. For each :math:`{\mathit{global}}` in :math:`{{\mathit{global}}^\ast}`, do:

   a. Let :math:`(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_{\mathsf{g}})` be the destructuring of :math:`{\mathit{global}}`.

   #. Append :math:`{\mathit{expr}}_{\mathsf{g}}` to :math:`{{\mathit{expr}}_{\mathsf{g}}^\ast}`.

   #. Append :math:`{\mathit{globaltype}}` to :math:`{{\mathit{globaltype}}^\ast}`.

#. Let :math:`{{{\mathit{expr}}_{\mathsf{e}}^\ast}^\ast}` be the expression sequence sequence :math:`\epsilon`.

#. For each :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}`, do:

   a. Let :math:`(\mathsf{elem}~{\mathit{reftype}}~{{\mathit{expr}}_{\mathsf{e}}^\ast}~{\mathit{elemmode}})` be the destructuring of :math:`{\mathit{elem}}`.

   #. Append :math:`{{\mathit{expr}}_{\mathsf{e}}^\ast}` to :math:`{{{\mathit{expr}}_{\mathsf{e}}^\ast}^\ast}`.

#. Let :math:`z` be the state :math:`(s, \{ \mathsf{module}~{\mathit{moduleinst}}_0 \})`.

#. Let :math:`F` be the :math:`\mathsf{frame}` :math:`z{.}\mathsf{frame}`.

#. Push the :math:`\mathsf{frame}` :math:`F`.

#. Let :math:`{{\mathit{val}}_{\mathsf{g}}^\ast}` be :math:`{{{\mathrm{evalglobal}}^\ast}}{(z, {{\mathit{globaltype}}^\ast}, {{\mathit{expr}}_{\mathsf{g}}^\ast})}`.

#. Let :math:`{{\mathit{ref}}_{\mathsf{t}}^\ast}` be the reference value sequence :math:`\epsilon`.

#. For each :math:`{\mathit{expr}}_{\mathsf{t}}` in :math:`{{\mathit{expr}}_{\mathsf{t}}^\ast}`, do:

   a. Let :math:`{\mathit{ref}}_{\mathsf{t}}` be the result of :ref:`evaluating <exec-expr>` :math:`{\mathit{expr}}_{\mathsf{t}}` with state :math:`z`.

   #. Append :math:`{\mathit{ref}}_{\mathsf{t}}` to :math:`{{\mathit{ref}}_{\mathsf{t}}^\ast}`.

#. Let :math:`{{{\mathit{ref}}_{\mathsf{e}}^\ast}^\ast}` be the reference value sequence sequence :math:`\epsilon`.

#. For each :math:`{{\mathit{expr}}_{\mathsf{e}}^\ast}` in :math:`{{{\mathit{expr}}_{\mathsf{e}}^\ast}^\ast}`, do:

   a. Let :math:`{{\mathit{ref}}_{\mathsf{e}}^\ast}` be the reference value sequence :math:`\epsilon`.

   #. For each :math:`{\mathit{expr}}_{\mathsf{e}}` in :math:`{{\mathit{expr}}_{\mathsf{e}}^\ast}`, do:

      1) Let :math:`{\mathit{ref}}_{\mathsf{e}}` be the result of :ref:`evaluating <exec-expr>` :math:`{\mathit{expr}}_{\mathsf{e}}` with state :math:`z`.

      #) Append :math:`{\mathit{ref}}_{\mathsf{e}}` to :math:`{{\mathit{ref}}_{\mathsf{e}}^\ast}`.

   #. Append :math:`{{\mathit{ref}}_{\mathsf{e}}^\ast}` to :math:`{{{\mathit{ref}}_{\mathsf{e}}^\ast}^\ast}`.

#. Pop the :math:`\mathsf{frame}` from the stack.

#. Let :math:`{\mathit{moduleinst}}` be :math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}_{\mathsf{g}}^\ast}, {{\mathit{ref}}_{\mathsf{t}}^\ast}, {{{\mathit{ref}}_{\mathsf{e}}^\ast}^\ast})`.

#. Let :math:`{F'}` be the :math:`\mathsf{frame}` :math:`\{ \mathsf{module}~{\mathit{moduleinst}} \}`.

#. Push the :math:`\mathsf{frame}` :math:`{F'}`.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{e}}^\ast}`.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{d}}^\ast}`.

#. If :math:`{{\mathit{start}}^?}` is defined, then:

   a. Let :math:`(\mathsf{start}~x)` be :math:`{{\mathit{start}}^?}`.

   #. Let :math:`{\mathit{instr}}_{\mathsf{s}}` be the instruction :math:`(\mathsf{call}~x)`.

   #. Execute the instruction :math:`{\mathit{instr}}_{\mathsf{s}}`.

#. Pop the :math:`\mathsf{frame}` from the stack.

#. Return :math:`{\mathit{moduleinst}}`.


:math:`{\mathrm{invoke}}(s, {\mathit{funcaddr}}, {{\mathit{val}}^\ast})`
........................................................................


1. Assert: Due to validation, the :ref:`expansion <aux-expand-deftype>` of :math:`s{.}\mathsf{funcs}{}[{\mathit{funcaddr}}]{.}\mathsf{type}` is some :math:`\mathsf{func}~{\mathit{resulttype}} \rightarrow {\mathit{resulttype}}`.

#. Let :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})` be the destructuring of the :ref:`expansion <aux-expand-deftype>` of :math:`s{.}\mathsf{funcs}{}[{\mathit{funcaddr}}]{.}\mathsf{type}`.

#. If :math:`{|{t_1^\ast}|} \neq {|{{\mathit{val}}^\ast}|}`, then:

   a. Fail.

#. For all :math:`t_1` in :math:`{t_1^\ast}`, and corresponding :math:`{\mathit{val}}` in :math:`{{\mathit{val}}^\ast}`:

   a. If :math:`{\mathit{val}}` is not :ref:`valid <valid-val>` with type :math:`t_1`, then:

      1) Fail.

#. Let :math:`k` be the length of :math:`{t_2^\ast}`.

#. Let :math:`F` be the :math:`\mathsf{frame}` :math:`\{ \mathsf{module}~\{  \} \}` whose arity is :math:`k`.

#. Push the :math:`\mathsf{frame}` :math:`F`.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

#. Push the value :math:`(\mathsf{ref{.}func}~{\mathit{funcaddr}})` to the stack.

#. Execute the instruction :math:`(\mathsf{call\_ref}~s{.}\mathsf{funcs}{}[{\mathit{funcaddr}}]{.}\mathsf{type})`.

#. Pop the values :math:`{{\mathit{val}'}^{k}}` from the stack.

#. Pop the :math:`\mathsf{frame}` from the stack.

#. Return :math:`{{\mathit{val}'}^{k}}`.


:math:`{\mathrm{concat}}_{\mathit{idctxt}}({{\mathit{idctxt}}^\ast})`
.....................................................................


1. If :math:`{{\mathit{idctxt}}^\ast} = \epsilon`, then:

   a. Return :math:`\{  \}`.

#. Let :math:`I~{I'}` be :math:`{{\mathit{idctxt}}^\ast}`.

#. Return `I ++ $concat_idctxt(I'*{})`.


:math:`{\mathrm{types}}({{\mathit{decl}'}^\ast})`
.................................................


1. If :math:`{{\mathit{decl}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{type}}~{{\mathit{decl}'}^\ast}` be :math:`{{\mathit{decl}'}^\ast}`.

#. Return :math:`{\mathit{type}}~{\mathrm{types}}({{\mathit{decl}'}^\ast})`.


:math:`{\mathrm{imports}}({{\mathit{decl}'}^\ast})`
...................................................


1. If :math:`{{\mathit{decl}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{import}}~{{\mathit{decl}'}^\ast}` be :math:`{{\mathit{decl}'}^\ast}`.

#. Return :math:`{\mathit{import}}~{\mathrm{imports}}({{\mathit{decl}'}^\ast})`.


:math:`{\mathrm{tags}}({{\mathit{decl}'}^\ast})`
................................................


1. If :math:`{{\mathit{decl}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{tag}}~{{\mathit{decl}'}^\ast}` be :math:`{{\mathit{decl}'}^\ast}`.

#. Return :math:`{\mathit{tag}}~{\mathrm{tags}}({{\mathit{decl}'}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{decl}'}^\ast})`
...................................................


1. If :math:`{{\mathit{decl}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{global}}~{{\mathit{decl}'}^\ast}` be :math:`{{\mathit{decl}'}^\ast}`.

#. Return :math:`{\mathit{global}}~{\mathrm{globals}}({{\mathit{decl}'}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{decl}'}^\ast})`
................................................


1. If :math:`{{\mathit{decl}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{mem}}~{{\mathit{decl}'}^\ast}` be :math:`{{\mathit{decl}'}^\ast}`.

#. Return :math:`{\mathit{mem}}~{\mathrm{mems}}({{\mathit{decl}'}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{decl}'}^\ast})`
..................................................


1. If :math:`{{\mathit{decl}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{table}}~{{\mathit{decl}'}^\ast}` be :math:`{{\mathit{decl}'}^\ast}`.

#. Return :math:`{\mathit{table}}~{\mathrm{tables}}({{\mathit{decl}'}^\ast})`.


:math:`{\mathrm{funcs}}({{\mathit{decl}'}^\ast})`
.................................................


1. If :math:`{{\mathit{decl}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{func}}~{{\mathit{decl}'}^\ast}` be :math:`{{\mathit{decl}'}^\ast}`.

#. Return :math:`{\mathit{func}}~{\mathrm{funcs}}({{\mathit{decl}'}^\ast})`.


:math:`{\mathrm{datas}}({{\mathit{decl}'}^\ast})`
.................................................


1. If :math:`{{\mathit{decl}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{data}}~{{\mathit{decl}'}^\ast}` be :math:`{{\mathit{decl}'}^\ast}`.

#. Return :math:`{\mathit{data}}~{\mathrm{datas}}({{\mathit{decl}'}^\ast})`.


:math:`{\mathrm{elems}}({{\mathit{decl}'}^\ast})`
.................................................


1. If :math:`{{\mathit{decl}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{elem}}~{{\mathit{decl}'}^\ast}` be :math:`{{\mathit{decl}'}^\ast}`.

#. Return :math:`{\mathit{elem}}~{\mathrm{elems}}({{\mathit{decl}'}^\ast})`.


:math:`{\mathrm{starts}}({{\mathit{decl}'}^\ast})`
..................................................


1. If :math:`{{\mathit{decl}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{start}}~{{\mathit{decl}'}^\ast}` be :math:`{{\mathit{decl}'}^\ast}`.

#. Return :math:`{\mathit{start}}~{\mathrm{starts}}({{\mathit{decl}'}^\ast})`.


:math:`{\mathrm{exports}}({{\mathit{decl}'}^\ast})`
...................................................


1. If :math:`{{\mathit{decl}'}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{export}}~{{\mathit{decl}'}^\ast}` be :math:`{{\mathit{decl}'}^\ast}`.

#. Return :math:`{\mathit{export}}~{\mathrm{exports}}({{\mathit{decl}'}^\ast})`.


:math:`{\mathrm{ordered}}({{\mathit{decl}}^\ast})`
..................................................


1. If :math:`{{\mathit{decl}}^\ast} = \epsilon`, then:

   a. Return true.

#. Return :math:`{\mathrm{imports}}({{\mathit{decl}}^\ast}) = \epsilon`.

#. Assert: Due to validation, YetE: Nondeterministic assignment target: decl_1*{decl_1 <- decl_1*} :: [import] :: decl_2*{decl_2 <- decl_2*}.

#. Let :math:`{{\mathit{decl}}_1^\ast}~{\mathit{import}}~{{\mathit{decl}}_2^\ast}` be :math:`{{\mathit{decl}}^\ast}`.

#. Return :math:`{\mathrm{imports}}({{\mathit{decl}}_1^\ast}) = \epsilon` and :math:`{\mathrm{tags}}({{\mathit{decl}}_1^\ast}) = \epsilon` and :math:`{\mathrm{globals}}({{\mathit{decl}}_1^\ast}) = \epsilon` and :math:`{\mathrm{mems}}({{\mathit{decl}}_1^\ast}) = \epsilon` and :math:`{\mathrm{tables}}({{\mathit{decl}}_1^\ast}) = \epsilon` and :math:`{\mathrm{funcs}}({{\mathit{decl}}_1^\ast}) = \epsilon`.


:math:`{{{\mathrm{allocX}}^\ast}}{(s, {{X''}^\ast}, {{Y''}^\ast})}`
...................................................................


1. If :math:`{{X''}^\ast} = \epsilon`, then:

   a. Assert: Due to validation, :math:`{{Y''}^\ast} = \epsilon`.

   #. Return :math:`\epsilon`.

#. Else:

   a. Let :math:`X~{{X'}^\ast}` be :math:`{{X''}^\ast}`.

   #. Assert: Due to validation, :math:`{|{{Y''}^\ast}|} \geq 1`.

   #. Let :math:`Y~{{Y'}^\ast}` be :math:`{{Y''}^\ast}`.

   #. Let :math:`a` be :math:`{\mathrm{allocX}}(X, Y, s, X, Y)`.

   #. Let :math:`{{a'}^\ast}` be :math:`{{{\mathrm{allocX}}^\ast}}{(s, {{X'}^\ast}, {{Y'}^\ast})}`.

   #. Return :math:`a~{{a'}^\ast}`.


:math:`X`
.........


1. Return :math:`0`.


:math:`\mathsf{eval\_expr}~{{\mathit{instr}}^\ast}`
...................................................


1. Execute the sequence :math:`{{\mathit{instr}}^\ast}`.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Return :math:`{\mathit{val}}`.


== Complete.
spectec 0.5 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...
Untranslated relation Expand: `%~~%`(deftype, comptype)
Untranslated relation Expand_use: `%~~_%%`(typeuse, context, comptype)
Numtype_ok
- the number type numtype is always valid.

Vectype_ok
- the vector type vectype is always valid.

Packtype_ok
- the packed type packtype is always valid.

Packtype_sub
- packtype matches only itself.

Numtype_sub
- numtype matches only itself.

Vectype_sub
- vectype matches only itself.

Heaptype_ok
- the heap type heaptype is valid if:
  - Either:
    - heaptype is absheaptype.
  - Or:
    - heaptype is typeuse.
    - the type use typeuse is valid.

Heaptype_ok/abs
- the heap type absheaptype is always valid.

Heaptype_ok/typeuse
- the heap type typeuse is valid if:
  - typeuse is valid.

Reftype_ok
- the reference type (REF NULL? heaptype) is valid if:
  - the heap type heaptype is valid.

Valtype_ok
- the value type valtype is valid if:
  - Either:
    - valtype is numtype.
    - the number type numtype is valid.
  - Or:
    - valtype is vectype.
    - the vector type vectype is valid.
  - Or:
    - valtype is reftype.
    - the reference type reftype is valid.
  - Or:
    - valtype is BOT.

Valtype_ok/num
- the value type numtype is valid if:
  - numtype is valid.

Valtype_ok/vec
- the value type vectype is valid if:
  - vectype is valid.

Valtype_ok/ref
- the value type reftype is valid if:
  - reftype is valid.

Valtype_ok/bot
- the value type BOT is always valid.

Typeuse_ok
- the type use typeuse is valid if:
  - Either:
    - typeuse is (_IDX typeidx).
    - the type C.TYPES[typeidx] exists.
  - Or:
    - typeuse is (REC i).
    - the recursive type C.RECS[i] exists.
  - Or:
    - typeuse is deftype.
    - the defined type deftype is valid.

Typeuse_ok/typeidx
- the type use (_IDX typeidx) is valid if:
  - the type C.TYPES[typeidx] exists.

Typeuse_ok/rec
- the type use (REC i) is valid if:
  - the recursive type C.RECS[i] exists.

Typeuse_ok/deftype
- the type use deftype is valid if:
  - deftype is valid.

Resulttype_ok
- the result type t* is valid if:
  - For all t in t*:
    - the value type t is valid.

Fieldtype_ok
- the field type (MUT? storagetype) is valid if:
  - the storage type storagetype is valid.

Storagetype_ok
- the storage type storagetype is valid if:
  - Either:
    - storagetype is valtype.
    - the value type valtype is valid.
  - Or:
    - storagetype is packtype.
    - the packed type packtype is valid.

Storagetype_ok/val
- the storage type valtype is valid if:
  - valtype is valid.

Storagetype_ok/pack
- the storage type packtype is valid if:
  - packtype is valid.

Comptype_ok
- the composite type comptype is valid if:
  - Either:
    - comptype is (STRUCT fieldtype*).
    - For all fieldtype in fieldtype*:
      - the field type fieldtype is valid.
  - Or:
    - comptype is (ARRAY fieldtype).
    - fieldtype is valid.
  - Or:
    - comptype is (FUNC t_1* -> t_2*).
    - the result type t_1* is valid.
    - the result type t_2* is valid.

Comptype_ok/struct
- the composite type (STRUCT fieldtype*) is valid if:
  - For all fieldtype in fieldtype*:
    - the field type fieldtype is valid.

Comptype_ok/array
- the composite type (ARRAY fieldtype) is valid if:
  - the field type fieldtype is valid.

Comptype_ok/func
- the composite type (FUNC t_1* -> t_2*) is valid if:
  - the result type t_1* is valid.
  - the result type t_2* is valid.

Subtype_ok
- the sub type (SUB FINAL? (_IDX x)* comptype) is valid for the type index (OK x_0) if:
  - |x*| is less than or equal to 1.
  - For all x in x*:
    - the index x is less than x_0.
    - the type C.TYPES[x] exists.
    - the sub type $unrolldt(C.TYPES[x]) is (SUB ?() (_IDX x')* comptype').
  - comptype'* is the concatenation of all such comptype'.
  - the composite type comptype is valid.
  - For all comptype' in comptype'*:
    - comptype matches the composite type comptype'.

Rectype_ok
- the recursive type (REC subtype*) is valid for the type index (OK x) if:
  - Either:
    - the sub type sequence subtype* is [].
  - Or:
    - subtype* is [subtype_1] :: subtype'*.
    - the sub type subtype_1 is valid for (OK x).
    - the recursive type (REC subtype'*) is valid for the type index (OK (x + 1)).

Rectype_ok/empty
- the recursive type (REC []) is valid for (OK x).

Rectype_ok/cons
- the recursive type (REC [subtype_1] :: subtype*) is valid for the type index (OK x) if:
  - the sub type subtype_1 is valid for (OK x).
  - the recursive type (REC subtype*) is valid for the type index (OK (x + 1)).

Subtype_ok2
- the sub type (SUB FINAL? typeuse* compttype) is valid for (OK x i) if:
  - |typeuse*| is less than or equal to 1.
  - For all typeuse in typeuse*:
    - $before(typeuse, x, i) is true.
    - the sub type $unrollht(C, typeuse) is (SUB ?() typeuse'* comptype').
  - comptype'* is the concatenation of all such comptype'.
  - the composite type comptype is valid.
  - For all comptype' in comptype'*:
    - comptype matches the composite type comptype'.

Rectype_ok2
- the recursive type (REC subtype*) is valid for (OK x i) if:
  - Either:
    - the sub type sequence subtype* is [].
  - Or:
    - subtype* is [subtype_1] :: subtype'*.
    - the sub type subtype_1 is valid for (OK x i).
    - the recursive type (REC subtype'*) is valid for (OK (x + 1) (i + 1)).

Rectype_ok2/empty
- the recursive type (REC []) is valid for (OK x i).

Rectype_ok2/cons
- the recursive type (REC [subtype_1] :: subtype*) is valid for (OK x i) if:
  - the sub type subtype_1 is valid for (OK x i).
  - the recursive type (REC subtype*) is valid for (OK (x + 1) (i + 1)).

Deftype_ok
- the defined type (_DEF rectype i) is valid if:
  - the recursive type rectype is valid for the type index (OK x).
  - rectype is (REC subtype^n).
  - i is less than n.

Comptype_sub
- the composite type comptype_1 matches the composite type comptype_2 if:
  - Either:
    - comptype_1 is (STRUCT ft_1* :: ft'_1*).
    - comptype_2 is (STRUCT ft_2*).
    - For all ft_1 in ft_1*, and corresponding ft_2 in ft_2*:
      - the field type ft_1 matches the field type ft_2.
  - Or:
    - comptype_1 is (ARRAY ft_1).
    - comptype_2 is (ARRAY ft_2).
    - ft_1 matches ft_2.
  - Or:
    - comptype_1 is (FUNC t_11* -> t_12*).
    - comptype_2 is (FUNC t_21* -> t_22*).
    - the result type t_21* matches the result type t_11*.
    - the result type t_12* matches the result type t_22*.

Comptype_sub/struct
- the composite type (STRUCT ft_1* :: ft'_1*) matches the composite type (STRUCT ft_2*) if:
  - For all ft_1 in ft_1*, and corresponding ft_2 in ft_2*:
    - the field type ft_1 matches the field type ft_2.

Comptype_sub/array
- the composite type (ARRAY ft_1) matches the composite type (ARRAY ft_2) if:
  - the field type ft_1 matches the field type ft_2.

Comptype_sub/func
- the composite type (FUNC t_11* -> t_12*) matches the composite type (FUNC t_21* -> t_22*) if:
  - the result type t_21* matches the result type t_11*.
  - the result type t_12* matches the result type t_22*.

Deftype_sub
- the defined type deftype_1 matches the defined type deftype_2 if:
  - Either:
    - the defined type $clos_deftype(C, deftype_1) is $clos_deftype(C, deftype_2).
  - Or:
    - the sub type $unrolldt(deftype_1) is (SUB final? typeuse* ct).
    - |typeuse*| is greater than i.
    - the type use typeuse*[i] matches deftype_2.

Deftype_sub/refl
- the defined type deftype_1 matches the defined type deftype_2 if:
  - the defined type $clos_deftype(C, deftype_1) is $clos_deftype(C, deftype_2).

Deftype_sub/super
- the defined type deftype_1 matches the defined type deftype_2 if:
  - the sub type $unrolldt(deftype_1) is (SUB final? typeuse* ct).
  - |typeuse*| is greater than i.
  - the type use typeuse*[i] matches deftype_2.

Heaptype_sub
- the heap type heaptype_1 matches the heap type heaptype_2 if:
  - Either:
    - heaptype_2 is heaptype_1.
  - Or:
    - the heap type heaptype' is valid.
    - heaptype_1 matches heaptype'.
    - heaptype' matches heaptype_2.
  - Or:
    - heaptype_1 is EQ.
    - heaptype_2 is ANY.
  - Or:
    - heaptype_1 is I31.
    - heaptype_2 is EQ.
  - Or:
    - heaptype_1 is STRUCT.
    - heaptype_2 is EQ.
  - Or:
    - heaptype_1 is ARRAY.
    - heaptype_2 is EQ.
  - Or:
    - heaptype_1 is deftype.
    - heaptype_2 is STRUCT.
    - The :ref:`expansion <aux-expand-deftype>` of deftype is (STRUCT fieldtype*).
  - Or:
    - heaptype_1 is deftype.
    - heaptype_2 is ARRAY.
    - The :ref:`expansion <aux-expand-deftype>` of deftype is (ARRAY fieldtype).
  - Or:
    - heaptype_1 is deftype.
    - heaptype_2 is FUNC.
    - The :ref:`expansion <aux-expand-deftype>` of deftype is (FUNC t_1* -> t_2*).
  - Or:
    - heaptype_1 is deftype_1.
    - heaptype_2 is deftype_2.
    - the defined type deftype_1 matches the defined type deftype_2.
  - Or:
    - heaptype_1 is (_IDX typeidx).
    - the type C.TYPES[typeidx] exists.
    - C.TYPES[typeidx] matches heaptype_2.
  - Or:
    - heaptype_2 is (_IDX typeidx).
    - C.TYPES[typeidx] exists.
    - heaptype_1 matches C.TYPES[typeidx].
  - Or:
    - heaptype_1 is (REC i).
    - |typeuse*| is greater than j.
    - heaptype_2 is typeuse*[j].
    - the recursive type C.RECS[i] exists.
    - C.RECS[i] is (SUB final? typeuse* ct).
  - Or:
    - heaptype_1 is NONE.
    - heaptype_2 matches the heap type ANY.
  - Or:
    - heaptype_1 is NOFUNC.
    - heaptype_2 matches the heap type FUNC.
  - Or:
    - heaptype_1 is NOEXN.
    - heaptype_2 matches the heap type EXN.
  - Or:
    - heaptype_1 is NOEXTERN.
    - heaptype_2 matches the heap type EXTERN.
  - Or:
    - heaptype_1 is BOT.

Heaptype_sub/refl
- the heap type heaptype matches only itself.

Heaptype_sub/trans
- the heap type heaptype_1 matches the heap type heaptype_2 if:
  - the heap type heaptype' is valid.
  - heaptype_1 matches heaptype'.
  - heaptype' matches heaptype_2.

Heaptype_sub/eq
- the heap type EQ matches the heap type ANY.

Heaptype_sub/i31
- the heap type I31 matches EQ.

Heaptype_sub/struct
- the heap type STRUCT matches EQ.

Heaptype_sub/array
- the heap type ARRAY matches EQ.

Heaptype_sub/struct
- the heap type deftype matches the heap type STRUCT if:
  - The :ref:`expansion <aux-expand-deftype>` of deftype is (STRUCT fieldtype*).

Heaptype_sub/array
- the heap type deftype matches the heap type ARRAY if:
  - The :ref:`expansion <aux-expand-deftype>` of deftype is (ARRAY fieldtype).

Heaptype_sub/func
- the heap type deftype matches the heap type FUNC if:
  - The :ref:`expansion <aux-expand-deftype>` of deftype is (FUNC t_1* -> t_2*).

Heaptype_sub/def
- the heap type deftype_1 matches the heap type deftype_2 if:
  - deftype_1 matches deftype_2.

Heaptype_sub/typeidx
- the heap type (_IDX typeidx) matches the heap type heaptype if:
  - the type C.TYPES[typeidx] exists.
  - C.TYPES[typeidx] matches heaptype.

Heaptype_sub/typeidx
- the heap type heaptype matches the heap type (_IDX typeidx) if:
  - the type C.TYPES[typeidx] exists.
  - heaptype matches C.TYPES[typeidx].

Heaptype_sub/rec
- the heap type (REC i) matches the type use typeuse*[j] if:
  - |typeuse*| is greater than j.
  - the recursive type C.RECS[i] exists.
  - C.RECS[i] is (SUB final? typeuse* ct).

Heaptype_sub/none
- the heap type NONE matches the heap type heaptype if:
  - heaptype matches the heap type ANY.

Heaptype_sub/nofunc
- the heap type NOFUNC matches the heap type heaptype if:
  - heaptype matches the heap type FUNC.

Heaptype_sub/noexn
- the heap type NOEXN matches the heap type heaptype if:
  - heaptype matches the heap type EXN.

Heaptype_sub/noextern
- the heap type NOEXTERN matches the heap type heaptype if:
  - heaptype matches the heap type EXTERN.

Heaptype_sub/bot
- the heap type BOT matches heaptype.

Reftype_sub
- the reference type (REF null_1? ht_1) matches the reference type (REF null_2? ht_2) if:
  - the heap type ht_1 matches the heap type ht_2.
  - Either:
    - null_1? is ?().
    - null_2? is ?().
  - Or:
    - null_1? is NULL?.
    - null_2? is ?(NULL).

Reftype_sub/nonnull
- the reference type (REF ?() ht_1) matches the reference type (REF ?() ht_2) if:
  - the heap type ht_1 matches the heap type ht_2.

Reftype_sub/null
- the reference type (REF NULL? ht_1) matches the reference type (REF ?(NULL) ht_2) if:
  - the heap type ht_1 matches the heap type ht_2.

Valtype_sub
- the value type valtype_1 matches the value type valtype_2 if:
  - Either:
    - valtype_1 is numtype_1.
    - valtype_2 is numtype_2.
    - the number type numtype_1 matches the number type numtype_2.
  - Or:
    - valtype_1 is vectype_1.
    - valtype_2 is vectype_2.
    - the vector type vectype_1 matches the vector type vectype_2.
  - Or:
    - valtype_1 is reftype_1.
    - valtype_2 is reftype_2.
    - the reference type reftype_1 matches the reference type reftype_2.
  - Or:
    - valtype_1 is BOT.

Valtype_sub/num
- the value type numtype_1 matches the value type numtype_2 if:
  - numtype_1 matches numtype_2.

Valtype_sub/vec
- the value type vectype_1 matches the value type vectype_2 if:
  - vectype_1 matches vectype_2.

Valtype_sub/ref
- the value type reftype_1 matches the value type reftype_2 if:
  - reftype_1 matches reftype_2.

Valtype_sub/bot
- the value type BOT matches the value type valtype.

Resulttype_sub
- the result type t_1* matches the result type t_2* if:
  - For all t_1 in t_1*, and corresponding t_2 in t_2*:
    - the value type t_1 matches the value type t_2.

Storagetype_sub
- the storage type storagetype_1 matches the storage type storagetype_2 if:
  - Either:
    - storagetype_1 is valtype_1.
    - storagetype_2 is valtype_2.
    - the value type valtype_1 matches the value type valtype_2.
  - Or:
    - storagetype_1 is packtype_1.
    - storagetype_2 is packtype_2.
    - the packed type packtype_1 matches the packed type packtype_2.

Storagetype_sub/val
- the storage type valtype_1 matches the storage type valtype_2 if:
  - valtype_1 matches valtype_2.

Storagetype_sub/pack
- the storage type packtype_1 matches the storage type packtype_2 if:
  - packtype_1 matches packtype_2.

Fieldtype_sub
- the field type (mut_1? zt_1) matches the field type (mut_2? zt_2) if:
  - the storage type zt_1 matches the storage type zt_2.
  - Either:
    - mut_1? is ?().
    - mut_2? is ?().
  - Or:
    - mut_1? is ?(MUT).
    - mut_2? is ?(MUT).
    - zt_2 matches zt_1.

Fieldtype_sub/const
- the field type (?() zt_1) matches the field type (?() zt_2) if:
  - the storage type zt_1 matches the storage type zt_2.

Fieldtype_sub/var
- the field type (?(MUT) zt_1) matches the field type (?(MUT) zt_2) if:
  - the storage type zt_1 matches the storage type zt_2.
  - zt_2 matches zt_1.

Instrtype_ok
- the instruction type t_1* ->_ x* t_2* is valid if:
  - the result type t_1* is valid.
  - the result type t_2* is valid.
  - For all x in x*:
    - the local C.LOCALS[x] exists.

Limits_ok
- the limits range ([ n .. m? ]) is valid within k if:
  - n is less than or equal to k.
  - If m is defined, then:
    - n is less than or equal to m.
    - m is less than or equal to k.

Tagtype_ok
- the tag type typeuse is valid if:
  - typeuse is valid.
  - The :ref:`expansion <aux-expand-typeuse>` of C is (FUNC t_1* -> t_2*).

Globaltype_ok
- the global type (MUT? t) is valid if:
  - the value type t is valid.

Memtype_ok
- the memory type addrtype limits PAGE is valid if:
  - the limits range limits is valid within (2 ^ 16).

Tabletype_ok
- the table type (addrtype limits reftype) is valid if:
  - the limits range limits is valid within ((2 ^ 32) - 1).
  - the reference type reftype is valid.

Externtype_ok
- the external type externtype is valid if:
  - Either:
    - externtype is (TAG tagtype).
    - the tag type tagtype is valid.
  - Or:
    - externtype is (GLOBAL globaltype).
    - the global type globaltype is valid.
  - Or:
    - externtype is (MEM memtype).
    - the memory type memtype is valid.
  - Or:
    - externtype is (TABLE tabletype).
    - the table type tabletype is valid.
  - Or:
    - externtype is (FUNC typeuse).
    - the type use typeuse is valid.
    - The :ref:`expansion <aux-expand-typeuse>` of C is (FUNC t_1* -> t_2*).

Externtype_ok/tag
- the external type (TAG tagtype) is valid if:
  - the tag type tagtype is valid.

Externtype_ok/global
- the external type (GLOBAL globaltype) is valid if:
  - the global type globaltype is valid.

Externtype_ok/mem
- the external type (MEM memtype) is valid if:
  - the memory type memtype is valid.

Externtype_ok/table
- the external type (TABLE tabletype) is valid if:
  - the table type tabletype is valid.

Externtype_ok/func
- the external type (FUNC typeuse) is valid if:
  - the type use typeuse is valid.
  - The :ref:`expansion <aux-expand-typeuse>` of C is (FUNC t_1* -> t_2*).

Instrtype_sub
- the instruction type t_11* ->_ x_1* t_12* matches the instruction type t_21* ->_ x_2* t_22* if:
  - the result type t_21* matches the result type t_11*.
  - the result type t_12* matches the result type t_22*.
  - the local index sequence x* is $setminus_(`localidx, x_2*, x_1*).
  - For all x in x*:
    - the local C.LOCALS[x] exists.
    - C.LOCALS[x] is (SET t).

Limits_sub
- the limits range ([ n_1 .. ?(m_1) ]) matches the limits range ([ n_2 .. ?(m_2) ]) if:
  - n_1 is greater than or equal to n_2.
  - m_1 is less than or equal to m_2.

Tagtype_sub
- the tag type deftype_1 matches the tag type deftype_2 if:
  - deftype_1 matches deftype_2.
  - deftype_2 matches deftype_1.

Globaltype_sub
- the global type (mut_1? valtype_1) matches the global type (mut_2? valtype_2) if:
  - the value type valtype_1 matches the value type valtype_2.
  - Either:
    - mut_1? is ?().
    - mut_2? is ?().
  - Or:
    - mut_1? is ?(MUT).
    - mut_2? is ?(MUT).
    - valtype_2 matches valtype_1.

Globaltype_sub/const
- the global type (?() valtype_1) matches the global type (?() valtype_2) if:
  - the value type valtype_1 matches the value type valtype_2.

Globaltype_sub/var
- the global type (?(MUT) valtype_1) matches the global type (?(MUT) valtype_2) if:
  - the value type valtype_1 matches the value type valtype_2.
  - valtype_2 matches valtype_1.

Memtype_sub
- the memory type addrtype limits_1 PAGE matches the memory type addrtype limits_2 PAGE if:
  - the limits range limits_1 matches the limits range limits_2.

Tabletype_sub
- the table type (addrtype limits_1 reftype_1) matches the table type (addrtype limits_2 reftype_2) if:
  - the limits range limits_1 matches the limits range limits_2.
  - the reference type reftype_1 matches the reference type reftype_2.
  - reftype_2 matches reftype_1.

Externtype_sub
- the external type externtype_1 matches the external type externtype_2 if:
  - Either:
    - externtype_1 is (TAG tagtype_1).
    - externtype_2 is (TAG tagtype_2).
    - the tag type tagtype_1 matches the tag type tagtype_2.
  - Or:
    - externtype_1 is (GLOBAL globaltype_1).
    - externtype_2 is (GLOBAL globaltype_2).
    - the global type globaltype_1 matches the global type globaltype_2.
  - Or:
    - externtype_1 is (MEM memtype_1).
    - externtype_2 is (MEM memtype_2).
    - the memory type memtype_1 matches the memory type memtype_2.
  - Or:
    - externtype_1 is (TABLE tabletype_1).
    - externtype_2 is (TABLE tabletype_2).
    - the table type tabletype_1 matches the table type tabletype_2.
  - Or:
    - externtype_1 is (FUNC deftype_1).
    - externtype_2 is (FUNC deftype_2).
    - the defined type deftype_1 matches the defined type deftype_2.

Externtype_sub/tag
- the external type (TAG tagtype_1) matches the external type (TAG tagtype_2) if:
  - the tag type tagtype_1 matches the tag type tagtype_2.

Externtype_sub/global
- the external type (GLOBAL globaltype_1) matches the external type (GLOBAL globaltype_2) if:
  - the global type globaltype_1 matches the global type globaltype_2.

Externtype_sub/mem
- the external type (MEM memtype_1) matches the external type (MEM memtype_2) if:
  - the memory type memtype_1 matches the memory type memtype_2.

Externtype_sub/table
- the external type (TABLE tabletype_1) matches the external type (TABLE tabletype_2) if:
  - the table type tabletype_1 matches the table type tabletype_2.

Externtype_sub/func
- the external type (FUNC deftype_1) matches the external type (FUNC deftype_2) if:
  - the defined type deftype_1 matches the defined type deftype_2.

Blocktype_ok
- the block type blocktype is valid as the instruction type valtype* -> valtype'* if:
  - Either:
    - blocktype is (_RESULT valtype''?).
    - the value type sequence valtype* is [].
    - the value type sequence valtype'* is valtype''?.
    - If valtype'' is defined, then:
      - the value type valtype'' is valid.
  - Or:
    - blocktype is (_IDX typeidx).
    - the type C.TYPES[typeidx] exists.
    - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[typeidx] is (FUNC valtype* -> valtype'*).

Blocktype_ok/valtype
- the block type (_RESULT valtype?) is valid as the instruction type [] -> valtype? if:
  - If valtype is defined, then:
    - the value type valtype is valid.

Blocktype_ok/typeidx
- the block type (_IDX typeidx) is valid as the instruction type t_1* -> t_2* if:
  - the type C.TYPES[typeidx] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[typeidx] is (FUNC t_1* -> t_2*).

Catch_ok
- the catch clause catch is valid if:
  - the label C.LABELS[l] exists.
  - Either:
    - catch is (CATCH x l).
    - the tag C.TAGS[x] exists.
    - The :ref:`expansion <aux-expand-deftype>` of $as_deftype(C.TAGS[x]) is (FUNC t* -> []).
    - the result type t* matches C.LABELS[l].
  - Or:
    - catch is (CATCH_REF x l).
    - C.TAGS[x] exists.
    - The :ref:`expansion <aux-expand-deftype>` of $as_deftype(C.TAGS[x]) is (FUNC t* -> []).
    - the result type t* :: [(REF ?() EXN)] matches C.LABELS[l].
  - Or:
    - catch is (CATCH_ALL l).
    - the result type [] matches C.LABELS[l].
  - Or:
    - catch is (CATCH_ALL_REF l).
    - the result type [(REF ?() EXN)] matches C.LABELS[l].

Catch_ok/catch
- the catch clause (CATCH x l) is valid if:
  - the tag C.TAGS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of $as_deftype(C.TAGS[x]) is (FUNC t* -> []).
  - the label C.LABELS[l] exists.
  - the result type t* matches C.LABELS[l].

Catch_ok/catch_ref
- the catch clause (CATCH_REF x l) is valid if:
  - the tag C.TAGS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of $as_deftype(C.TAGS[x]) is (FUNC t* -> []).
  - the label C.LABELS[l] exists.
  - the result type t* :: [(REF ?() EXN)] matches C.LABELS[l].

Catch_ok/catch_all
- the catch clause (CATCH_ALL l) is valid if:
  - the label C.LABELS[l] exists.
  - the result type [] matches C.LABELS[l].

Catch_ok/catch_all_ref
- the catch clause (CATCH_ALL_REF l) is valid if:
  - the label C.LABELS[l] exists.
  - the result type [(REF ?() EXN)] matches C.LABELS[l].

Defaultable
- the value type t is defaultable if:
  - the value $default_(t) is not ?().

Instr_ok/nop
- the instruction NOP is valid with the instruction type [] -> [].

Instr_ok/unreachable
- the instruction UNREACHABLE is valid with the instruction type t_1* -> t_2* if:
  - t_1* -> t_2* is valid.

Instr_ok/drop
- the instruction DROP is valid with the instruction type [t] -> [] if:
  - the value type t is valid.

Instr_ok/select
- the instruction (SELECT valtype?) is valid with the instruction type [t, t, I32] -> [t] if:
  - the value type t is valid.
  - Either:
    - the value type sequence valtype? is ?([t]).
  - Or:
    - valtype? is ?().
    - t matches the value type t'.
    - t' is numtype or t' is vectype.

Instr_ok/block
- the instruction (BLOCK bt instr*) is valid with the instruction type t_1* -> t_2* if:
  - the block type bt is valid as t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr* is valid with the instruction type t_1* ->_ x* t_2*.

Instr_ok/loop
- the instruction (LOOP bt instr*) is valid with the instruction type t_1* -> t_2* if:
  - the block type bt is valid as t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_1*].
  - Under the context C', the instruction sequence instr* is valid with the instruction type t_1* ->_ x* t_2*.

Instr_ok/if
- the instruction (IF bt instr_1* ELSE instr_2*) is valid with the instruction type t_1* :: [I32] -> t_2* if:
  - the block type bt is valid as the instruction type t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr_1* is valid with the instruction type t_1* ->_ x_1* t_2*.
  - Under the context C', the instruction sequence instr_2* is valid with the instruction type t_1* ->_ x_2* t_2*.

Instr_ok/br
- the instruction (BR l) is valid with the instruction type t_1* :: t* -> t_2* if:
  - the label C.LABELS[l] exists.
  - C.LABELS[l] is t*.
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/br_if
- the instruction (BR_IF l) is valid with the instruction type t* :: [I32] -> t* if:
  - the label C.LABELS[l] exists.
  - C.LABELS[l] is t*.

Instr_ok/br_table
- the instruction (BR_TABLE l* l') is valid with the instruction type t_1* :: t* :: [I32] -> t_2* if:
  - For all l in l*:
    - the label C.LABELS[l] exists.
    - the result type t* matches C.LABELS[l].
  - the label C.LABELS[l'] exists.
  - t* matches C.LABELS[l'].
  - t_1* :: t* :: [I32] -> t_2* is valid.

Instr_ok/br_on_null
- the instruction (BR_ON_NULL l) is valid with the instruction type t* :: [(REF ?(NULL) ht)] -> t* :: [(REF ?() ht)] if:
  - the label C.LABELS[l] exists.
  - C.LABELS[l] is t*.
  - the heap type ht is valid.

Instr_ok/br_on_non_null
- the instruction (BR_ON_NON_NULL l) is valid with the instruction type t* :: [(REF ?(NULL) ht)] -> t* if:
  - the label C.LABELS[l] exists.
  - C.LABELS[l] is t* :: [(REF NULL? ht)].

Instr_ok/br_on_cast
- the instruction (BR_ON_CAST l rt_1 rt_2) is valid with the instruction type t* :: [rt_1] -> t* :: [reftype] if:
  - the label C.LABELS[l] exists.
  - C.LABELS[l] is t* :: [rt].
  - the reference type rt_1 is valid.
  - the reference type rt_2 is valid.
  - rt_2 matches rt_1.
  - rt_2 matches the reference type rt.
  - the reference type reftype is $diffrt(rt_1, rt_2).

Instr_ok/br_on_cast_fail
- the instruction (BR_ON_CAST_FAIL l rt_1 rt_2) is valid with the instruction type t* :: [rt_1] -> t* :: [rt_2] if:
  - the label C.LABELS[l] exists.
  - C.LABELS[l] is t* :: [rt].
  - the reference type rt_1 is valid.
  - the reference type rt_2 is valid.
  - rt_2 matches rt_1.
  - the reference type $diffrt(rt_1, rt_2) matches the reference type rt.

Instr_ok/call
- the instruction (CALL x) is valid with the instruction type t_1* -> t_2* if:
  - the function C.FUNCS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.FUNCS[x] is (FUNC t_1* -> t_2*).

Instr_ok/call_ref
- the instruction (CALL_REF (_IDX x)) is valid with the instruction type t_1* :: [(REF ?(NULL) (_IDX x))] -> t_2* if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (FUNC t_1* -> t_2*).

Instr_ok/call_indirect
- the instruction (CALL_INDIRECT x (_IDX y)) is valid with the instruction type t_1* :: [at] -> t_2* if:
  - the table C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt).
  - the reference type rt matches the reference type (REF ?(NULL) FUNC).
  - the type C.TYPES[y] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[y] is (FUNC t_1* -> t_2*).

Instr_ok/return
- the instruction RETURN is valid with the instruction type t_1* :: t* -> t_2* if:
  - the result type C.RETURN is ?(t*).
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/return_call
- the instruction (RETURN_CALL x) is valid with the instruction type t_3* :: t_1* -> t_4* if:
  - the function C.FUNCS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.FUNCS[x] is (FUNC t_1* -> t_2*).
  - the result type C.RETURN is ?(t'_2*).
  - the result type t_2* matches the result type t'_2*.
  - the instruction type t_3* -> t_4* is valid.

Instr_ok/return_call_ref
- the instruction (RETURN_CALL_REF (_IDX x)) is valid with the instruction type t_3* :: t_1* :: [(REF ?(NULL) (_IDX x))] -> t_4* if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (FUNC t_1* -> t_2*).
  - the result type C.RETURN is ?(t'_2*).
  - the result type t_2* matches the result type t'_2*.
  - the instruction type t_3* -> t_4* is valid.

Instr_ok/return_call_indirect
- the instruction (RETURN_CALL_INDIRECT x (_IDX y)) is valid with the instruction type t_3* :: t_1* :: [at] -> t_4* if:
  - the table C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt).
  - the reference type rt matches the reference type (REF ?(NULL) FUNC).
  - the type C.TYPES[y] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[y] is (FUNC t_1* -> t_2*).
  - the result type C.RETURN is ?(t'_2*).
  - the result type t_2* matches the result type t'_2*.
  - the instruction type t_3* -> t_4* is valid.

Instr_ok/throw
- the instruction (THROW x) is valid with the instruction type t_1* :: t* -> t_2* if:
  - the tag C.TAGS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of $as_deftype(C.TAGS[x]) is (FUNC t* -> []).
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/throw_ref
- the instruction THROW_REF is valid with the instruction type t_1* :: [(REF ?(NULL) EXN)] -> t_2* if:
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/try_table
- the instruction (TRY_TABLE bt catch* instr*) is valid with the instruction type t_1* -> t_2* if:
  - the block type bt is valid as t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr* is valid with the instruction type t_1* ->_ x* t_2*.
  - For all catch in catch*:
    - the catch clause catch is valid.

Instr_ok/ref.null
- the instruction (REF.NULL ht) is valid with the instruction type [] -> [(REF ?(NULL) ht)] if:
  - the heap type ht is valid.

Instr_ok/ref.func
- the instruction (REF.FUNC x) is valid with the instruction type [] -> [(REF ?() dt)] if:
  - the function C.FUNCS[x] exists.
  - C.FUNCS[x] is dt.
  - x is contained in C.REFS.

Instr_ok/ref.i31
- the instruction REF.I31 is valid with the instruction type [I32] -> [(REF ?() I31)].

Instr_ok/ref.is_null
- the instruction REF.IS_NULL is valid with the instruction type [(REF ?(NULL) ht)] -> [I32] if:
  - the heap type ht is valid.

Instr_ok/ref.as_non_null
- the instruction REF.AS_NON_NULL is valid with the instruction type [(REF ?(NULL) ht)] -> [(REF ?() ht)] if:
  - the heap type ht is valid.

Instr_ok/ref.eq
- the instruction REF.EQ is valid with the instruction type [(REF ?(NULL) EQ), (REF ?(NULL) EQ)] -> [I32].

Instr_ok/ref.test
- the instruction (REF.TEST rt) is valid with the instruction type [rt'] -> [I32] if:
  - the reference type rt is valid.
  - the reference type rt' is valid.
  - rt matches rt'.

Instr_ok/ref.cast
- the instruction (REF.CAST rt) is valid with the instruction type [rt'] -> [rt] if:
  - the reference type rt is valid.
  - the reference type rt' is valid.
  - rt matches rt'.

Instr_ok/i31.get
- the instruction (I31.GET sx) is valid with the instruction type [(REF ?(NULL) I31)] -> [I32].

Instr_ok/struct.new
- the instruction (STRUCT.NEW x) is valid with the instruction type t* -> [(REF ?() (_IDX x))] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (STRUCT (mut? zt)*).
  - the value type sequence t* is $unpack(zt)*.

Instr_ok/struct.new_default
- the instruction (STRUCT.NEW_DEFAULT x) is valid with the instruction type [] -> [(REF ?() (_IDX x))] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (STRUCT (mut? zt)*).
  - For all zt in zt*:
    - A :ref:`default value <aux-default>` for $unpack(zt) is defined.

Instr_ok/struct.get
- the instruction (STRUCT.GET sx? x i) is valid with the instruction type [(REF ?(NULL) (_IDX x))] -> [t] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (STRUCT ft*).
  - |ft*| is greater than i.
  - the field type ft*[i] is (mut? zt).
  - the signedness sx? is ?() if and only if $is_packtype(zt).
  - the value type t is $unpack(zt).

Instr_ok/struct.set
- the instruction (STRUCT.SET x i) is valid with the instruction type [(REF ?(NULL) (_IDX x)), t] -> [] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (STRUCT ft*).
  - |ft*| is greater than i.
  - the field type ft*[i] is (?(MUT) zt).
  - the value type t is $unpack(zt).

Instr_ok/array.new
- the instruction (ARRAY.NEW x) is valid with the instruction type [t, I32] -> [(REF ?() (_IDX x))] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (ARRAY (mut? zt)).
  - the value type t is $unpack(zt).

Instr_ok/array.new_default
- the instruction (ARRAY.NEW_DEFAULT x) is valid with the instruction type [I32] -> [(REF ?() (_IDX x))] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (ARRAY (mut? zt)).
  - A :ref:`default value <aux-default>` for $unpack(zt) is defined.

Instr_ok/array.new_fixed
- the instruction (ARRAY.NEW_FIXED x n) is valid with the instruction type t^n -> [(REF ?() (_IDX x))] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (ARRAY (mut? zt)).
  - the value type t is $unpack(zt).

Instr_ok/array.new_elem
- the instruction (ARRAY.NEW_ELEM x y) is valid with the instruction type [I32, I32] -> [(REF ?() (_IDX x))] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (ARRAY (mut? rt)).
  - the element segment C.ELEMS[y] exists.
  - C.ELEMS[y] matches the reference type rt.

Instr_ok/array.new_data
- the instruction (ARRAY.NEW_DATA x y) is valid with the instruction type [I32, I32] -> [(REF ?() (_IDX x))] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (ARRAY (mut? zt)).
  - $unpack(zt) is numtype or the value type $unpack(zt) is vectype.
  - the data segment C.DATAS[y] exists.
  - C.DATAS[y] is OK.

Instr_ok/array.get
- the instruction (ARRAY.GET sx? x) is valid with the instruction type [(REF ?(NULL) (_IDX x)), I32] -> [t] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (ARRAY (mut? zt)).
  - the signedness sx? is ?() if and only if $is_packtype(zt).
  - the value type t is $unpack(zt).

Instr_ok/array.set
- the instruction (ARRAY.SET x) is valid with the instruction type [(REF ?(NULL) (_IDX x)), I32, t] -> [] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (ARRAY (?(MUT) zt)).
  - the value type t is $unpack(zt).

Instr_ok/array.len
- the instruction ARRAY.LEN is valid with the instruction type [(REF ?(NULL) ARRAY)] -> [I32].

Instr_ok/array.fill
- the instruction (ARRAY.FILL x) is valid with the instruction type [(REF ?(NULL) (_IDX x)), I32, t, I32] -> [] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (ARRAY (?(MUT) zt)).
  - the value type t is $unpack(zt).

Instr_ok/array.copy
- the instruction (ARRAY.COPY x_1 x_2) is valid with the instruction type [(REF ?(NULL) (_IDX x_1)), I32, (REF ?(NULL) (_IDX x_2)), I32, I32] -> [] if:
  - the type C.TYPES[x_1] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x_1] is (ARRAY (?(MUT) zt_1)).
  - the type C.TYPES[x_2] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x_2] is (ARRAY (mut? zt_2)).
  - the storage type zt_2 matches the storage type zt_1.

Instr_ok/array.init_elem
- the instruction (ARRAY.INIT_ELEM x y) is valid with the instruction type [(REF ?(NULL) (_IDX x)), I32, I32, I32] -> [] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (ARRAY (?(MUT) zt)).
  - the element segment C.ELEMS[y] exists.
  - C.ELEMS[y] matches the storage type zt.

Instr_ok/array.init_data
- the instruction (ARRAY.INIT_DATA x y) is valid with the instruction type [(REF ?(NULL) (_IDX x)), I32, I32, I32] -> [] if:
  - the type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (ARRAY (?(MUT) zt)).
  - $unpack(zt) is numtype or the value type $unpack(zt) is vectype.
  - the data segment C.DATAS[y] exists.
  - C.DATAS[y] is OK.

Instr_ok/extern.convert_any
- the instruction EXTERN.CONVERT_ANY is valid with the instruction type [(REF null_1? ANY)] -> [(REF null_2? EXTERN)] if:
  - null_1? is null_2?.

Instr_ok/any.convert_extern
- the instruction ANY.CONVERT_EXTERN is valid with the instruction type [(REF null_1? EXTERN)] -> [(REF null_2? ANY)] if:
  - null_1? is null_2?.

Instr_ok/local.get
- the instruction (LOCAL.GET x) is valid with the instruction type [] -> [t] if:
  - the local C.LOCALS[x] exists.
  - C.LOCALS[x] is (SET t).

Instr_ok/local.set
- the instruction (LOCAL.SET x) is valid with the instruction type [t] ->_ [x] [] if:
  - the local C.LOCALS[x] exists.
  - C.LOCALS[x] is (init t).

Instr_ok/local.tee
- the instruction (LOCAL.TEE x) is valid with the instruction type [t] ->_ [x] [t] if:
  - the local C.LOCALS[x] exists.
  - C.LOCALS[x] is (init t).

Instr_ok/global.get
- the instruction (GLOBAL.GET x) is valid with the instruction type [] -> [t] if:
  - the global C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (mut? t).

Instr_ok/global.set
- the instruction (GLOBAL.SET x) is valid with the instruction type [t] -> [] if:
  - the global C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?(MUT) t).

Instr_ok/table.get
- the instruction (TABLE.GET x) is valid with the instruction type [at] -> [rt] if:
  - the table C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt).

Instr_ok/table.set
- the instruction (TABLE.SET x) is valid with the instruction type [at, rt] -> [] if:
  - the table C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt).

Instr_ok/table.size
- the instruction (TABLE.SIZE x) is valid with the instruction type [] -> [at] if:
  - the table C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt).

Instr_ok/table.grow
- the instruction (TABLE.GROW x) is valid with the instruction type [rt, at] -> [I32] if:
  - the table C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt).

Instr_ok/table.fill
- the instruction (TABLE.FILL x) is valid with the instruction type [at, rt, at] -> [] if:
  - the table C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt).

Instr_ok/table.copy
- the instruction (TABLE.COPY x_1 x_2) is valid with the instruction type [at_1, at_2, addrtype] -> [] if:
  - the table C.TABLES[x_1] exists.
  - C.TABLES[x_1] is (at_1 lim_1 rt_1).
  - the table C.TABLES[x_2] exists.
  - C.TABLES[x_2] is (at_2 lim_2 rt_2).
  - the reference type rt_2 matches the reference type rt_1.
  - the address type addrtype is $minat(at_1, at_2).

Instr_ok/table.init
- the instruction (TABLE.INIT x y) is valid with the instruction type [at, I32, I32] -> [] if:
  - the table C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt_1).
  - the element segment C.ELEMS[y] exists.
  - C.ELEMS[y] is rt_2.
  - the reference type rt_2 matches the reference type rt_1.

Instr_ok/elem.drop
- the instruction (ELEM.DROP x) is valid with the instruction type [] -> [] if:
  - the element segment C.ELEMS[x] exists.

Instr_ok/memory.size
- the instruction (MEMORY.SIZE x) is valid with the instruction type [] -> [at] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.

Instr_ok/memory.grow
- the instruction (MEMORY.GROW x) is valid with the instruction type [at] -> [at] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.

Instr_ok/memory.fill
- the instruction (MEMORY.FILL x) is valid with the instruction type [at, I32, at] -> [] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.

Instr_ok/memory.copy
- the instruction (MEMORY.COPY x_1 x_2) is valid with the instruction type [at_1, at_2, addrtype] -> [] if:
  - the memory C.MEMS[x_1] exists.
  - C.MEMS[x_1] is at_1 lim_1 PAGE.
  - the memory C.MEMS[x_2] exists.
  - C.MEMS[x_2] is at_2 lim_2 PAGE.
  - the address type addrtype is $minat(at_1, at_2).

Instr_ok/memory.init
- the instruction (MEMORY.INIT x y) is valid with the instruction type [at, I32, I32] -> [] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - the data segment C.DATAS[y] exists.
  - C.DATAS[y] is OK.

Instr_ok/data.drop
- the instruction (DATA.DROP x) is valid with the instruction type [] -> [] if:
  - the data segment C.DATAS[x] exists.
  - C.DATAS[x] is OK.

Instr_ok/load
- the instruction (LOAD nt loadop_? x memarg) is valid with the instruction type [at] -> [valtype] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - Either:
    - loadop_? is ?().
    - the value type valtype is nt.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - Or:
    - the number type nt is Inn.
    - loadop_? is ?(M _ sx).
    - valtype is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store
- the instruction (STORE nt storeop_? x memarg) is valid with the instruction type [at, valtype] -> [] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - Either:
    - storeop_? is ?().
    - the value type valtype is nt.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - Or:
    - the number type nt is Inn.
    - storeop_? is ?(M).
    - valtype is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/vload
- the instruction (VLOAD V128 vloadop_? x memarg) is valid with the instruction type [at] -> [V128] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - Either:
    - vloadop_? is ?().
    - (2 ^ memarg.ALIGN) is less than or equal to ($vsize(V128) / 8).
  - Or:
    - vloadop_? is ?((SHAPE M X N _ sx)).
    - (2 ^ memarg.ALIGN) is less than or equal to ((M / 8) * N).
  - Or:
    - vloadop_? is ?((SPLAT N)).
    - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).
  - Or:
    - vloadop_? is ?((ZERO N)).
    - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).

Instr_ok/vload_lane
- the instruction (VLOAD_LANE V128 N x memarg i) is valid with the instruction type [at, V128] -> [V128] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).
  - i is less than (128 / N).

Instr_ok/vstore
- the instruction (VSTORE V128 x memarg) is valid with the instruction type [at, V128] -> [] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to ($vsize(V128) / 8).

Instr_ok/vstore_lane
- the instruction (VSTORE_LANE V128 N x memarg i) is valid with the instruction type [at, V128] -> [] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).
  - i is less than (128 / N).

Instr_ok/const
- the instruction (nt.CONST c_nt) is valid with the instruction type [] -> [nt].

Instr_ok/unop
- the instruction (UNOP nt unop_nt) is valid with the instruction type [nt] -> [nt].

Instr_ok/binop
- the instruction (BINOP nt binop_nt) is valid with the instruction type [nt, nt] -> [nt].

Instr_ok/testop
- the instruction (TESTOP nt testop_nt) is valid with the instruction type [nt] -> [I32].

Instr_ok/relop
- the instruction (RELOP nt relop_nt) is valid with the instruction type [nt, nt] -> [I32].

Instr_ok/cvtop
- the instruction (CVTOP nt_1 nt_2 cvtop) is valid with the instruction type [nt_2] -> [nt_1].

Instr_ok/vconst
- the instruction (V128.CONST c) is valid with the instruction type [] -> [V128].

Instr_ok/vvunop
- the instruction (VVUNOP V128 vvunop) is valid with the instruction type [V128] -> [V128].

Instr_ok/vvbinop
- the instruction (VVBINOP V128 vvbinop) is valid with the instruction type [V128, V128] -> [V128].

Instr_ok/vvternop
- the instruction (VVTERNOP V128 vvternop) is valid with the instruction type [V128, V128, V128] -> [V128].

Instr_ok/vvtestop
- the instruction (VVTESTOP V128 vvtestop) is valid with the instruction type [V128] -> [I32].

Instr_ok/vunop
- the instruction (VUNOP sh vunop) is valid with [V128] -> [V128].

Instr_ok/vbinop
- the instruction (VBINOP sh vbinop) is valid with [V128, V128] -> [V128].

Instr_ok/vternop
- the instruction (VTERNOP sh vternop) is valid with [V128, V128, V128] -> [V128].

Instr_ok/vtestop
- the instruction (VTESTOP sh vtestop) is valid with [V128] -> [I32].

Instr_ok/vrelop
- the instruction (VRELOP sh vrelop) is valid with [V128, V128] -> [V128].

Instr_ok/vshiftop
- the instruction (VSHIFTOP sh vshiftop) is valid with the instruction type [V128, I32] -> [V128].

Instr_ok/vbitmask
- the instruction (VBITMASK sh) is valid with [V128] -> [I32].

Instr_ok/vswizzlop
- the instruction (VSWIZZLOP sh vswizzlop) is valid with [V128, V128] -> [V128].

Instr_ok/vshuffle
- the instruction (VSHUFFLE sh i*) is valid with the instruction type [V128, V128] -> [V128] if:
  - For all i in i*:
    - the lane index i is less than (2 * $dim(sh)).

Instr_ok/vsplat
- the instruction (VSPLAT sh) is valid with the instruction type [numtype] -> [V128] if:
  - the number type numtype is $unpackshape(sh).

Instr_ok/vextract_lane
- the instruction (VEXTRACT_LANE sh sx? i) is valid with the instruction type [V128] -> [numtype] if:
  - the lane index i is less than $dim(sh).
  - the number type numtype is $unpackshape(sh).

Instr_ok/vreplace_lane
- the instruction (VREPLACE_LANE sh i) is valid with the instruction type [V128, numtype] -> [V128] if:
  - the lane index i is less than $dim(sh).
  - the number type numtype is $unpackshape(sh).

Instr_ok/vextunop
- the instruction (VEXTUNOP sh_1 sh_2 vextunop) is valid with the instruction type [V128] -> [V128].

Instr_ok/vextbinop
- the instruction (VEXTBINOP sh_1 sh_2 vextbinop) is valid with the instruction type [V128, V128] -> [V128].

Instr_ok/vextternop
- the instruction (VEXTTERNOP sh_1 sh_2 vextternop) is valid with the instruction type [V128, V128, V128] -> [V128].

Instr_ok/vnarrow
- the instruction (VNARROW sh_1 sh_2 sx) is valid with [V128, V128] -> [V128].

Instr_ok/vcvtop
- the instruction (VCVTOP sh_1 sh_2 vcvtop) is valid with [V128] -> [V128].

Instr_ok/select-expl
- the instruction (SELECT ?([t])) is valid with the instruction type [t, t, I32] -> [t] if:
  - the value type t is valid.

Instr_ok/select-impl
- the instruction (SELECT ?()) is valid with the instruction type [t, t, I32] -> [t] if:
  - the value type t is valid.
  - t matches the value type t'.
  - t' is numtype or t' is vectype.

Instr_ok/load-val
- the instruction (LOAD nt ?() x memarg) is valid with the instruction type [at] -> [nt] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).

Instr_ok/load-pack
- the instruction (LOAD Inn ?(M _ sx) x memarg) is valid with the instruction type [at] -> [Inn] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store-val
- the instruction (STORE nt ?() x memarg) is valid with the instruction type [at, nt] -> [] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).

Instr_ok/store-pack
- the instruction (STORE Inn ?(M) x memarg) is valid with the instruction type [at, Inn] -> [] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/vload-val
- the instruction (VLOAD V128 ?() x memarg) is valid with the instruction type [at] -> [V128] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to ($vsize(V128) / 8).

Instr_ok/vload-pack
- the instruction (VLOAD V128 ?((SHAPE M X N _ sx)) x memarg) is valid with the instruction type [at] -> [V128] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to ((M / 8) * N).

Instr_ok/vload-splat
- the instruction (VLOAD V128 ?((SPLAT N)) x memarg) is valid with the instruction type [at] -> [V128] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).

Instr_ok/vload-zero
- the instruction (VLOAD V128 ?((ZERO N)) x memarg) is valid with the instruction type [at] -> [V128] if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).

Instrs_ok
- the instruction sequence instr* is valid with the instruction type it if:
  - Either:
    - instr* is [].
    - it is [] -> [].
  - Or:
    - instr* is [instr_1] :: instr_2*.
    - it is t_1* ->_ x_1* :: x_2* t_3*.
    - the instruction instr_1 is valid with the instruction type t_1* ->_ x_1* t_2*.
    - For all x_1 in x_1*:
      - the local C.LOCALS[x_1] exists.
      - C.LOCALS[x_1] is (init t).
    - Under the context $with_locals(C, x_1*, (SET t)*), the instruction sequence instr_2* is valid with the instruction type t_2* ->_ x_2* t_3*.
  - Or:
    - instr* is valid with the instruction type it''.
    - it'' matches it.
    - it is valid.
  - Or:
    - it is t* :: t_1* ->_ x* t* :: t_2*.
    - instr* is valid with the instruction type t_1* ->_ x* t_2*.
    - the result type t* is valid.

Instrs_ok/empty
- the instruction sequence [] is valid with the instruction type [] -> [].

Instrs_ok/seq
- the instruction sequence [instr_1] :: instr_2* is valid with the instruction type t_1* ->_ x_1* :: x_2* t_3* if:
  - the instruction instr_1 is valid with the instruction type t_1* ->_ x_1* t_2*.
  - For all x_1 in x_1*:
    - the local C.LOCALS[x_1] exists.
    - C.LOCALS[x_1] is (init t).
  - t* is the concatenation of all such t.
  - Under the context $with_locals(C, x_1*, (SET t)*), the instruction sequence instr_2* is valid with the instruction type t_2* ->_ x_2* t_3*.

Instrs_ok/sub
- the instruction sequence instr* is valid with the instruction type it if:
  - instr* is valid with the instruction type it'.
  - it' matches it.
  - it is valid.

Instrs_ok/frame
- the instruction sequence instr* is valid with the instruction type t* :: t_1* ->_ x* t* :: t_2* if:
  - instr* is valid with the instruction type t_1* ->_ x* t_2*.
  - the result type t* is valid.

Expr_ok
- the expression instr* is valid with the result type t* if:
  - instr* is valid with the instruction type [] -> t*.

Nondefaultable
- the value type t is not defaultable if:
  - the value $default_(t) is ?().

Instr_const
- the value val is constant if:
  - Either:
    - val is (nt.CONST c_nt).
  - Or:
    - val is (vt.CONST c_vt).
  - Or:
    - val is (REF.NULL ht).
  - Or:
    - val is REF.I31.
  - Or:
    - val is (REF.FUNC x).
  - Or:
    - val is (STRUCT.NEW x).
  - Or:
    - val is (STRUCT.NEW_DEFAULT x).
  - Or:
    - val is (ARRAY.NEW x).
  - Or:
    - val is (ARRAY.NEW_DEFAULT x).
  - Or:
    - val is (ARRAY.NEW_FIXED x n).
  - Or:
    - val is ANY.CONVERT_EXTERN.
  - Or:
    - val is EXTERN.CONVERT_ANY.
  - Or:
    - val is (GLOBAL.GET x).
    - the global C.GLOBALS[x] exists.
    - C.GLOBALS[x] is (?() t).
  - Or:
    - val is (BINOP Inn binop).
    - Inn is contained in [I32, I64].
    - binop is contained in [ADD, SUB, MUL].

Instr_const/const
- the instruction (nt.CONST c_nt) is constant.

Instr_const/vconst
- the instruction (vt.CONST c_vt) is constant.

Instr_const/ref.null
- the instruction (REF.NULL ht) is constant.

Instr_const/ref.i31
- the instruction REF.I31 is constant.

Instr_const/ref.func
- the instruction (REF.FUNC x) is constant.

Instr_const/struct.new
- the instruction (STRUCT.NEW x) is constant.

Instr_const/struct.new_default
- the instruction (STRUCT.NEW_DEFAULT x) is constant.

Instr_const/array.new
- the instruction (ARRAY.NEW x) is constant.

Instr_const/array.new_default
- the instruction (ARRAY.NEW_DEFAULT x) is constant.

Instr_const/array.new_fixed
- the instruction (ARRAY.NEW_FIXED x n) is constant.

Instr_const/any.convert_extern
- the instruction ANY.CONVERT_EXTERN is constant.

Instr_const/extern.convert_any
- the instruction EXTERN.CONVERT_ANY is constant.

Instr_const/global.get
- the instruction (GLOBAL.GET x) is constant if:
  - the global C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?() t).

Instr_const/binop
- the instruction (BINOP Inn binop) is constant if:
  - Inn is contained in [I32, I64].
  - binop is contained in [ADD, SUB, MUL].

Expr_const
- the expression instr* is constant if:
  - For all instr in instr*:
    - the instruction instr is constant.

Type_ok
- the type definition (TYPE rectype) is valid with the defined type sequence dt* if:
  - |C.TYPES| is x.
  - dt* is $rolldt(x, rectype).
  - the context C' is the context C with .TYPES appended by dt*.
  - Under the context C', the recursive type rectype is valid for the type index (OK x).

Tag_ok
- the tag (TAG tagtype) is valid with the tag type tagtype' if:
  - the tag type tagtype is valid.
  - tagtype' is $clos_tagtype(C, tagtype).

Global_ok
- the global (GLOBAL globaltype expr) is valid with the global type globaltype if:
  - globaltype is valid.
  - globaltype is (MUT? t).
  - the expression expr is valid with the value type t.
  - expr is constant.

Mem_ok
- the memory (MEMORY memtype) is valid with the memory type memtype if:
  - memtype is valid.

Table_ok
- the table (TABLE tabletype expr) is valid with the table type tabletype if:
  - tabletype is valid.
  - tabletype is (at lim rt).
  - the expression expr is valid with the value type rt.
  - expr is constant.

Local_ok
- the local (LOCAL t) is valid with the local type (init t) if:
  - Either:
    - the initialization status init is SET.
    - A :ref:`default value <aux-default>` for t is defined.
  - Or:
    - init is UNSET.
    - A :ref:`default value <aux-default>` for t is not defined.

Local_ok/set
- the local (LOCAL t) is valid with the local type (SET t) if:
  - A :ref:`default value <aux-default>` for t is defined.

Local_ok/unset
- the local (LOCAL t) is valid with the local type (UNSET t) if:
  - A :ref:`default value <aux-default>` for t is not defined.

Func_ok
- the function (FUNC x local* expr) is valid with the type C.TYPES[x] if:
  - C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (FUNC t_1* -> t_2*).
  - For all local in local*:
    - the local local is valid with the local type lct.
  - lct* is the concatenation of all such lct.
  - Under the context C with .LOCALS appended by (SET t_1)* :: lct* and .LABELS appended by [t_2*] and .RETURN appended by ?(t_2*), the expression expr is valid with the result type t_2*.

Datamode_ok
- the data mode datamode is valid if:
  - Either:
    - datamode is PASSIVE.
  - Or:
    - datamode is (ACTIVE x expr).
    - the memory C.MEMS[x] exists.
    - C.MEMS[x] is at lim PAGE.
    - the expression expr is valid with the value type at.
    - expr is constant.

Datamode_ok/passive
- the data mode PASSIVE is always valid.

Datamode_ok/active
- the data mode (ACTIVE x expr) is valid if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - the expression expr is valid with the value type at.
  - expr is constant.

Data_ok
- the memory segment (DATA b* datamode) is valid if:
  - the data mode datamode is valid.

Elemmode_ok
- the element mode elemmode is valid with the element type rt if:
  - Either:
    - elemmode is PASSIVE.
  - Or:
    - elemmode is DECLARE.
  - Or:
    - elemmode is (ACTIVE x expr).
    - the table C.TABLES[x] exists.
    - C.TABLES[x] is (at lim rt').
    - rt matches the reference type rt'.
    - the expression expr is valid with the value type at.
    - expr is constant.

Elemmode_ok/passive
- the element mode PASSIVE is valid with rt.

Elemmode_ok/declare
- the element mode DECLARE is valid with rt.

Elemmode_ok/active
- the element mode (ACTIVE x expr) is valid with the element type rt if:
  - the table C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt').
  - rt matches the reference type rt'.
  - the expression expr is valid with the value type at.
  - expr is constant.

Elem_ok
- the table segment (ELEM elemtype expr* elemmode) is valid with the element type elemtype if:
  - elemtype is valid.
  - For all expr in expr*:
    - the expression expr is valid with elemtype.
    - expr is constant.
  - the element mode elemmode is valid with elemtype.

Start_ok
- the start function (START x) is valid if:
  - the function C.FUNCS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.FUNCS[x] is (FUNC [] -> []).

Import_ok
- the import (IMPORT name_1 name_2 xt) is valid with the external type externtype if:
  - the external type xt is valid.
  - externtype is $clos_externtype(C, xt).

Externidx_ok
- the external index externidx is valid with the external type externtype if:
  - Either:
    - externidx is (TAG x).
    - externtype is (TAG jt).
    - the tag C.TAGS[x] exists.
    - C.TAGS[x] is jt.
  - Or:
    - externidx is (GLOBAL x).
    - externtype is (GLOBAL gt).
    - the global C.GLOBALS[x] exists.
    - C.GLOBALS[x] is gt.
  - Or:
    - externidx is (MEM x).
    - externtype is (MEM mt).
    - the memory C.MEMS[x] exists.
    - C.MEMS[x] is mt.
  - Or:
    - externidx is (TABLE x).
    - externtype is (TABLE tt).
    - the table C.TABLES[x] exists.
    - C.TABLES[x] is tt.
  - Or:
    - externidx is (FUNC x).
    - externtype is (FUNC dt).
    - the function C.FUNCS[x] exists.
    - C.FUNCS[x] is dt.

Externidx_ok/tag
- the external index (TAG x) is valid with the external type (TAG jt) if:
  - the tag C.TAGS[x] exists.
  - C.TAGS[x] is jt.

Externidx_ok/global
- the external index (GLOBAL x) is valid with the external type (GLOBAL gt) if:
  - the global C.GLOBALS[x] exists.
  - C.GLOBALS[x] is gt.

Externidx_ok/mem
- the external index (MEM x) is valid with the external type (MEM mt) if:
  - the memory C.MEMS[x] exists.
  - C.MEMS[x] is mt.

Externidx_ok/table
- the external index (TABLE x) is valid with the external type (TABLE tt) if:
  - the table C.TABLES[x] exists.
  - C.TABLES[x] is tt.

Externidx_ok/func
- the external index (FUNC x) is valid with the external type (FUNC dt) if:
  - the function C.FUNCS[x] exists.
  - C.FUNCS[x] is dt.

Export_ok
- the export (EXPORT name externidx) is valid with the name name and the external type xt if:
  - the external index externidx is valid with xt.

Globals_ok
- the global sequence global* is valid with the global type sequence globaltype* if:
  - Either:
    - global* is [].
    - globaltype* is [].
  - Or:
    - global* is [global_1] :: global'*.
    - globaltype* is [gt_1] :: gt*.
    - the global global_1 is valid with the global type gt_1.
    - the context C' is the context C with .GLOBALS appended by [gt_1].
    - Under the context C', the global sequence global'* is valid with the global type sequence gt*.

Globals_ok/empty
- [] is valid with the global type sequence [].

Globals_ok/cons
- the global sequence [global_1] :: global* is valid with the global type sequence [gt_1] :: gt* if:
  - the global global_1 is valid with the global type gt_1.
  - the context C' is the context C with .GLOBALS appended by [gt_1].
  - Under the context C', the global sequence global* is valid with the global type sequence gt*.

Types_ok
- the type definition sequence type* is valid with the defined type sequence deftype* if:
  - Either:
    - type* is [].
    - deftype* is [].
  - Or:
    - type* is [type_1] :: type'*.
    - deftype* is dt_1* :: dt*.
    - the type definition type_1 is valid with the defined type sequence dt_1*.
    - the context C' is the context C with .TYPES appended by dt_1*.
    - Under the context C', the type definition sequence type'* is valid with the defined type sequence dt*.

Types_ok/empty
- [] is valid with the defined type sequence [].

Types_ok/cons
- the type definition sequence [type_1] :: type* is valid with the defined type sequence dt_1* :: dt* if:
  - the type definition type_1 is valid with the defined type sequence dt_1*.
  - the context C' is the context C with .TYPES appended by dt_1*.
  - Under the context C', the type definition sequence type* is valid with the defined type sequence dt*.

Module_ok
- the module (MODULE type* import* tag* global* mem* table* func* data* elem* start? export*) is valid with the module type moduletype if:
  - Under the context { RETURN: ?() }, the type definition sequence type* is valid with the defined type sequence dt'*.
  - For all import in import*:
    - Under the context { TYPES: dt'*; RETURN: ?() }, the import import is valid with the external type xt_I.
  - xt_I* is the concatenation of all such xt_I.
  - For all tag in tag*:
    - Under the context C', the tag tag is valid with the tag type jt.
  - jt* is the concatenation of all such jt.
  - Under the context C', the global sequence global* is valid with the global type sequence gt*.
  - For all mem in mem*:
    - Under the context C', the memory mem is valid with the memory type mt.
  - mt* is the concatenation of all such mt.
  - For all table in table*:
    - Under the context C', the table table is valid with the table type tt.
  - tt* is the concatenation of all such tt.
  - For all func in func*:
    - the function func is valid with the defined type dt.
  - dt* is the concatenation of all such dt.
  - For all data in data*:
    - the memory segment data is valid.
  - ok* is the concatenation of all such ok.
  - For all elem in elem*:
    - the table segment elem is valid with the element type rt.
  - rt* is the concatenation of all such rt.
  - If start is defined, then:
    - the start function start is valid.
  - For all export in export*:
    - the export export is valid with the name nm and the external type xt_E.
  - nm* is the concatenation of all such nm.
  - xt_E* is the concatenation of all such xt_E.
  - $disjoint_(`name, nm*) is true.
  - the context C is C' with .TAGS appended by jt_I* :: jt* and .GLOBALS appended by gt* and .MEMS appended by mt_I* :: mt* and .TABLES appended by tt_I* :: tt* and .DATAS appended by ok* and .ELEMS appended by rt*.
  - the context C' is { TYPES: dt'*; GLOBALS: gt_I*; FUNCS: dt_I* :: dt*; RETURN: ?(); REFS: x* }.
  - the function index sequence x* is $funcidx_nonfuncs((global* mem* table* elem*)).
  - the tag type sequence jt_I* is $tagsxt(xt_I*).
  - the global type sequence gt_I* is $globalsxt(xt_I*).
  - the memory type sequence mt_I* is $memsxt(xt_I*).
  - the table type sequence tt_I* is $tablesxt(xt_I*).
  - the defined type sequence dt_I* is $funcsxt(xt_I*).
  - moduletype is $clos_moduletype(C, xt_I* -> xt_E*).

Num_ok
- the number value (nt.CONST c) is valid with the number type nt.

Vec_ok
- the vector value (vt.CONST c) is valid with the vector type vt.

Ref_ok
- the reference value ref is valid with the reference type rt if:
  - Either:
    - ref is (REF.NULL ht).
    - rt is (REF ?(NULL) ht').
    - the heap type ht' matches the heap type ht.
  - Or:
    - ref is (REF.I31_NUM i).
    - rt is (REF ?() I31).
  - Or:
    - ref is (REF.STRUCT_ADDR a).
    - rt is (REF ?() dt).
    - the structure instance s.STRUCTS[a] exists.
    - the defined type s.STRUCTS[a].TYPE is dt.
  - Or:
    - ref is (REF.ARRAY_ADDR a).
    - rt is (REF ?() dt).
    - the array instance s.ARRAYS[a] exists.
    - the defined type s.ARRAYS[a].TYPE is dt.
  - Or:
    - ref is (REF.FUNC_ADDR a).
    - rt is (REF ?() dt).
    - the function instance s.FUNCS[a] exists.
    - the defined type s.FUNCS[a].TYPE is dt.
  - Or:
    - ref is (REF.EXN_ADDR a).
    - rt is (REF ?() EXN).
    - the exception instance s.EXNS[a] exists.
  - Or:
    - ref is (REF.HOST_ADDR a).
    - rt is (REF ?() ANY).
  - Or:
    - ref is (REF.EXTERN addrref).
    - rt is (REF ?() EXTERN).
    - the reference value addrref is valid with the reference type (REF ?() ANY).
  - Or:
    - ref is valid with the reference type rt'.
    - rt' matches rt.

Ref_ok/null
- the reference value (REF.NULL ht) is valid with the reference type (REF ?(NULL) ht') if:
  - the heap type ht' matches the heap type ht.

Ref_ok/i31
- the reference value (REF.I31_NUM i) is valid with the reference type (REF ?() I31).

Ref_ok/struct
- the reference value (REF.STRUCT_ADDR a) is valid with the reference type (REF ?() dt) if:
  - the structure instance s.STRUCTS[a] exists.
  - the defined type s.STRUCTS[a].TYPE is dt.

Ref_ok/array
- the reference value (REF.ARRAY_ADDR a) is valid with the reference type (REF ?() dt) if:
  - the array instance s.ARRAYS[a] exists.
  - the defined type s.ARRAYS[a].TYPE is dt.

Ref_ok/func
- the reference value (REF.FUNC_ADDR a) is valid with the reference type (REF ?() dt) if:
  - the function instance s.FUNCS[a] exists.
  - the defined type s.FUNCS[a].TYPE is dt.

Ref_ok/exn
- the reference value (REF.EXN_ADDR a) is valid with the reference type (REF ?() EXN) if:
  - the exception instance s.EXNS[a] exists.

Ref_ok/host
- the reference value (REF.HOST_ADDR a) is valid with the reference type (REF ?() ANY).

Ref_ok/extern
- the reference value (REF.EXTERN addrref) is valid with the reference type (REF ?() EXTERN) if:
  - the reference value addrref is valid with the reference type (REF ?() ANY).

Ref_ok/sub
- the reference value ref is valid with the reference type rt if:
  - ref is valid with the reference type rt'.
  - rt' matches rt.

Val_ok
- the value val is valid with the value type valtype if:
  - Either:
    - val is num.
    - valtype is nt.
    - the number value num is valid with the number type nt.
  - Or:
    - val is vec.
    - valtype is vt.
    - the vector value vec is valid with the vector type vt.
  - Or:
    - val is ref.
    - valtype is rt.
    - the reference value ref is valid with the reference type rt.

Val_ok/num
- the value num is valid with the value type nt if:
  - num is valid with nt.

Val_ok/vec
- the value vec is valid with the value type vt if:
  - vec is valid with vt.

Val_ok/ref
- the value ref is valid with the value type rt if:
  - ref is valid with rt.

Externaddr_ok
- the external address externaddr is valid with the external type externtype if:
  - Either:
    - externaddr is (TAG a).
    - externtype is (TAG taginst.TYPE).
    - the tag instance s.TAGS[a] exists.
    - s.TAGS[a] is taginst.
  - Or:
    - externaddr is (GLOBAL a).
    - externtype is (GLOBAL globalinst.TYPE).
    - the global instance s.GLOBALS[a] exists.
    - s.GLOBALS[a] is globalinst.
  - Or:
    - externaddr is (MEM a).
    - externtype is (MEM meminst.TYPE).
    - the memory instance s.MEMS[a] exists.
    - s.MEMS[a] is meminst.
  - Or:
    - externaddr is (TABLE a).
    - externtype is (TABLE tableinst.TYPE).
    - the table instance s.TABLES[a] exists.
    - s.TABLES[a] is tableinst.
  - Or:
    - externaddr is (FUNC a).
    - externtype is (FUNC funcinst.TYPE).
    - the function instance s.FUNCS[a] exists.
    - s.FUNCS[a] is funcinst.
  - Or:
    - externaddr is valid with the external type xt'.
    - xt' matches externtype.

Externaddr_ok/tag
- the external address (TAG a) is valid with the external type (TAG taginst.TYPE) if:
  - the tag instance s.TAGS[a] exists.
  - s.TAGS[a] is taginst.

Externaddr_ok/global
- the external address (GLOBAL a) is valid with the external type (GLOBAL globalinst.TYPE) if:
  - the global instance s.GLOBALS[a] exists.
  - s.GLOBALS[a] is globalinst.

Externaddr_ok/mem
- the external address (MEM a) is valid with the external type (MEM meminst.TYPE) if:
  - the memory instance s.MEMS[a] exists.
  - s.MEMS[a] is meminst.

Externaddr_ok/table
- the external address (TABLE a) is valid with the external type (TABLE tableinst.TYPE) if:
  - the table instance s.TABLES[a] exists.
  - s.TABLES[a] is tableinst.

Externaddr_ok/func
- the external address (FUNC a) is valid with the external type (FUNC funcinst.TYPE) if:
  - the function instance s.FUNCS[a] exists.
  - s.FUNCS[a] is funcinst.

Externaddr_ok/sub
- the external address externaddr is valid with the external type xt if:
  - externaddr is valid with the external type xt'.
  - xt' matches xt.

Idctxt_ok
- the identifier context I is valid if:
  - $disjoint_(`name, $concatopt_(`name, I.TYPES)) is true.
  - $disjoint_(`name, $concatopt_(`name, I.TAGS)) is true.
  - $disjoint_(`name, $concatopt_(`name, I.GLOBALS)) is true.
  - $disjoint_(`name, $concatopt_(`name, I.MEMS)) is true.
  - $disjoint_(`name, $concatopt_(`name, I.TABLES)) is true.
  - $disjoint_(`name, $concatopt_(`name, I.FUNCS)) is true.
  - $disjoint_(`name, $concatopt_(`name, I.DATAS)) is true.
  - $disjoint_(`name, $concatopt_(`name, I.ELEMS)) is true.
  - $disjoint_(`name, $concatopt_(`name, I.LOCALS)) is true.
  - $disjoint_(`name, $concatopt_(`name, I.LABELS)) is true.
  - For all field* in field**:
    - $disjoint_(`name, $concatopt_(`name, [?(field*)])) is true.
  - the name sequence sequence [?(field*)*] is I.FIELDS.

NotationTypingInstrScheme
- the instruction sequence [instr] is valid with the instruction type valtype* -> valtype'* if:
  - Either:
    - the instruction instr is (BINOP I32 ADD).
    - the value type sequence valtype* is [I32, I32].
    - the value type sequence valtype'* is [I32].
  - Or:
    - instr is (GLOBAL.GET x).
    - valtype* is [].
    - valtype'* is [t].
    - the global C.GLOBALS[x] exists.
    - C.GLOBALS[x] is (?(mut) t).
  - Or:
    - instr is (BLOCK blocktype instr'*).
    - the block type blocktype is valid as valtype* -> valtype'*.
    - the context C' is the context C with .LABELS prepended by [valtype'*].
    - Under the context C', the instruction sequence instr'* is valid with valtype* -> valtype'*.

NotationTypingInstrScheme/i32.add
- the instruction sequence [(BINOP I32 ADD)] is valid with the instruction type [I32, I32] -> [I32].

NotationTypingInstrScheme/global.get
- the instruction sequence [(GLOBAL.GET x)] is valid with the instruction type [] -> [t] if:
  - the global C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?(mut) t).

NotationTypingInstrScheme/block
- the instruction sequence [(BLOCK blocktype instr*)] is valid with the instruction type t_1* -> t_2* if:
  - the block type blocktype is valid as t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr* is valid with t_1* -> t_2*.

Step_pure/br-label-* l
1. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
2. Let (LABEL_ n { instr'* }) be the topmost LABEL_.
3. If (l = 0), then:
  a. Assert: Due to validation, there are at least n values on the top of the stack.
  b. Pop the values val^n from the stack.
  c. Pop all values val'* from the top of the stack.
  d. Pop the label (LABEL_ _ { _ }) from the stack.
  e. Push the values val^n to the stack.
  f. Execute the sequence instr'*.
4. Else:
  a. Pop all values val* from the top of the stack.
  b. Pop the label (LABEL_ _ { _ }) from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction (BR (l - 1)).

Step_read/return_call_ref-frame-* yy
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val'' from the stack.
4. Assert: Due to validation, the first non-value entry of the stack is a FRAME_.
5. If val'' is some REF.NULL, then:
  a. Trap.
6. Assert: Due to validation, val'' is some REF.FUNC_ADDR.
7. Let (REF.FUNC_ADDR a) be val''.
8. Assert: Due to validation, (a < |$funcinst(z)|).
9. Assert: Due to validation, $Expand($funcinst(z)[a].TYPE) is some FUNC.
10. Let (FUNC t_1^n -> t_2^m) be $Expand($funcinst(z)[a].TYPE).
11. Assert: Due to validation, there are at least n values on the top of the stack.
12. Pop the values val^n from the stack.
13. Pop all values val'* from the top of the stack.
14. Pop the frame (FRAME_ _ { _ }) from the stack.
15. Push the values val^n to the stack.
16. Push the value (REF.FUNC_ADDR a) to the stack.
17. Execute the instruction (CALL_REF yy).

Step_read/throw_ref-instrs-*
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value (REF.EXN_ADDR a) from the stack.
3. Pop all values val* from the top of the stack.
4. Assert: Due to validation, (val* =/= []).
5. Push the value (REF.EXN_ADDR a) to the stack.
6. Execute the instruction THROW_REF.

Step_read/throw_ref-handler-*
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value (REF.EXN_ADDR a) from the stack.
4. Assert: Due to validation, the first non-value entry of the stack is a HANDLER_.
5. Let (HANDLER_ n { catch''* }) be the topmost HANDLER_.
6. If (catch''* = []), then:
  a. Pop the handler (HANDLER_ _ { _ }) from the stack.
  b. Push the value (REF.EXN_ADDR a) to the stack.
  c. Execute the instruction THROW_REF.
7. Else if (a >= |$exninst(z)|), then:
  a. Let [catch_0] :: catch'* be catch''*.
  b. If catch_0 is some CATCH_ALL, then:
    1) Let (CATCH_ALL l) be catch_0.
    2) Pop the handler (HANDLER_ _ { _ }) from the stack.
    3) Execute the instruction (BR l).
  c. Else if catch_0 is not CATCH_ALL_REF, then:
    1) Let [catch] :: catch'* be catch''*.
    2) Pop the handler (HANDLER_ _ { _ }) from the stack.
    3) Push the handler (HANDLER_ n { catch'* }) to the stack.
    4) Push the value (REF.EXN_ADDR a) to the stack.
    5) Execute the instruction THROW_REF.
  d. Else:
    1) Let (CATCH_ALL_REF l) be catch_0.
    2) Pop the handler (HANDLER_ _ { _ }) from the stack.
    3) Push the value (REF.EXN_ADDR a) to the stack.
    4) Execute the instruction (BR l).
8. Else:
  a. Let val* be $exninst(z)[a].FIELDS.
  b. Let [catch_0] :: catch'* be catch''*.
  c. If catch_0 is some CATCH, then:
    1) Let (CATCH x l) be catch_0.
    2) If ((x < |$tagaddr(z)|) /\ ($exninst(z)[a].TAG = $tagaddr(z)[x])), then:
      a) Pop the handler (HANDLER_ _ { _ }) from the stack.
      b) Push the values val* to the stack.
      c) Execute the instruction (BR l).
    3) Else:
      a) Let [catch] :: catch'* be catch''*.
      b) Pop the handler (HANDLER_ _ { _ }) from the stack.
      c) Push the handler (HANDLER_ n { catch'* }) to the stack.
      d) Push the value (REF.EXN_ADDR a) to the stack.
      e) Execute the instruction THROW_REF.
  d. Else if catch_0 is some CATCH_REF, then:
    1) Let (CATCH_REF x l) be catch_0.
    2) If ((x >= |$tagaddr(z)|) \/ ($exninst(z)[a].TAG =/= $tagaddr(z)[x])), then:
      a) Let [catch] :: catch'* be catch''*.
      b) Pop the handler (HANDLER_ _ { _ }) from the stack.
      c) Push the handler (HANDLER_ n { catch'* }) to the stack.
      d) Push the value (REF.EXN_ADDR a) to the stack.
      e) Execute the instruction THROW_REF.
    3) Else:
      a) Pop the handler (HANDLER_ _ { _ }) from the stack.
      b) Push the values val* to the stack.
      c) Push the value (REF.EXN_ADDR a) to the stack.
      d) Execute the instruction (BR l).
  e. Else if catch_0 is some CATCH_ALL, then:
    1) Let (CATCH_ALL l) be catch_0.
    2) Pop the handler (HANDLER_ _ { _ }) from the stack.
    3) Execute the instruction (BR l).
  f. Else if catch_0 is not CATCH_ALL_REF, then:
    1) Let [catch] :: catch'* be catch''*.
    2) Pop the handler (HANDLER_ _ { _ }) from the stack.
    3) Push the handler (HANDLER_ n { catch'* }) to the stack.
    4) Push the value (REF.EXN_ADDR a) to the stack.
    5) Execute the instruction THROW_REF.
  g. Else:
    1) Let (CATCH_ALL_REF l) be catch_0.
    2) Pop the handler (HANDLER_ _ { _ }) from the stack.
    3) Push the value (REF.EXN_ADDR a) to the stack.
    4) Execute the instruction (BR l).

Step_read/table.copy-oob-* x_1 x_2
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST n) from the stack.
4. Assert: Due to validation, a value of value type num is on the top of the stack.
5. Pop the value (at_2.CONST i_2) from the stack.
6. Assert: Due to validation, a value of value type num is on the top of the stack.
7. Pop the value (at_1.CONST i_1) from the stack.
8. If ((i_1 + n) > |$table(z, x_1).REFS|), then:
  a. Trap.
9. If ((i_2 + n) > |$table(z, x_2).REFS|), then:
  a. Trap.

Step_read/table.init-oob-* x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST j) from the stack.
6. Assert: Due to validation, a value of value type num is on the top of the stack.
7. Pop the value (at.CONST i) from the stack.
8. If ((i + n) > |$table(z, x).REFS|), then:
  a. Trap.
9. If ((j + n) > |$elem(z, y).REFS|), then:
  a. Trap.

Step_read/load-num-* nt ?() x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST i) from the stack.
4. If (((i + ao.OFFSET) + ($size(nt) / 8)) > |$mem(z, x).BYTES|), then:
  a. Trap.
5. Let c be $nbytes__1^-1(nt, $mem(z, x).BYTES[(i + ao.OFFSET) : ($size(nt) / 8)]).
6. Push the value (nt.CONST c) to the stack.

Step_read/load-pack-* Inn ?(n _ sx) x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST i) from the stack.
4. If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, x).BYTES|), then:
  a. Trap.
5. Let c be $ibytes__1^-1(n, $mem(z, x).BYTES[(i + ao.OFFSET) : (n / 8)]).
6. Push the value (Inn.CONST $extend__(n, $size(Inn), sx, c)) to the stack.

Step_read/vload-pack-* V128 ?((SHAPE M X K _ sx)) x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST i) from the stack.
4. If (((i + ao.OFFSET) + ((M * K) / 8)) > |$mem(z, x).BYTES|), then:
  a. Trap.
5. Let j^K be $ibytes__1^-1(M, $mem(z, x).BYTES[((i + ao.OFFSET) + ((k * M) / 8)) : (M / 8)])^(k<K).
6. Let Jnn be $jsizenn^-1((M * 2)).
7. Let c be $inv_lanes_(Jnn X K, $extend__(M, $jsizenn(Jnn), sx, j)^K).
8. Push the value (V128.CONST c) to the stack.

Step_read/vload-splat-* V128 ?((SPLAT N)) x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST i) from the stack.
4. If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, x).BYTES|), then:
  a. Trap.
5. Let M be (128 / N).
6. Let Jnn be $jsize^-1(N).
7. Let j be $ibytes__1^-1(N, $mem(z, x).BYTES[(i + ao.OFFSET) : (N / 8)]).
8. Let c be $inv_lanes_(Jnn X M, j^M).
9. Push the value (V128.CONST c) to the stack.

Step_read/vload-zero-* V128 ?((ZERO N)) x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST i) from the stack.
4. If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, x).BYTES|), then:
  a. Trap.
5. Let j be $ibytes__1^-1(N, $mem(z, x).BYTES[(i + ao.OFFSET) : (N / 8)]).
6. Let c be $extend__(N, 128, U, j).
7. Push the value (V128.CONST c) to the stack.

Step_read/memory.copy-oob-* x_1 x_2
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST n) from the stack.
4. Assert: Due to validation, a value of value type num is on the top of the stack.
5. Pop the value (at_2.CONST i_2) from the stack.
6. Assert: Due to validation, a value of value type num is on the top of the stack.
7. Pop the value (at_1.CONST i_1) from the stack.
8. If ((i_1 + n) > |$mem(z, x_1).BYTES|), then:
  a. Trap.
9. If ((i_2 + n) > |$mem(z, x_2).BYTES|), then:
  a. Trap.

Step_read/memory.init-oob-* x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST j) from the stack.
6. Assert: Due to validation, a value of value type num is on the top of the stack.
7. Pop the value (at.CONST i) from the stack.
8. If ((i + n) > |$mem(z, x).BYTES|), then:
  a. Trap.
9. If ((j + n) > |$data(z, y).BYTES|), then:
  a. Trap.

Step/store-num-* nt ?() x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type nt is on the top of the stack.
3. Pop the value (numtype_0.CONST c) from the stack.
4. Assert: Due to validation, a value of value type num is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. If (((i + ao.OFFSET) + ($size(nt) / 8)) > |$mem(z, x).BYTES|), then:
  a. Trap.
7. Let b* be $nbytes_(nt, c).
8. Perform $with_mem(z, x, (i + ao.OFFSET), ($size(nt) / 8), b*).

Step/store-pack-* Inn ?(n) x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type Inn is on the top of the stack.
3. Pop the value (numtype_0.CONST c) from the stack.
4. Assert: Due to validation, a value of value type num is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, x).BYTES|), then:
  a. Trap.
7. Let b* be $ibytes_(n, $wrap__($size(Inn), n, c)).
8. Perform $with_mem(z, x, (i + ao.OFFSET), (n / 8), b*).

Step_pure/unreachable
1. Trap.

Step_pure/nop
1. Do nothing.

Step_pure/drop
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.

Step_pure/select t*?
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. Assert: Due to validation, a value is on the top of the stack.
4. Pop the value val_2 from the stack.
5. Assert: Due to validation, a value is on the top of the stack.
6. Pop the value val_1 from the stack.
7. If (c =/= 0), then:
  a. Push the value val_1 to the stack.
8. Else:
  a. Push the value val_2 to the stack.

Step_pure/if bt instr_1* instr_2*
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BLOCK bt instr_1*).
4. Else:
  a. Execute the instruction (BLOCK bt instr_2*).

Step_pure/label
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
3. Pop the label (LABEL_ _ { _ }) from the stack.
4. Push the values val* to the stack.

Step_pure/br l
1. If the first non-value entry of the stack is a LABEL_, then:
  a. Let (LABEL_ n { instr'* }) be the topmost LABEL_.
  b. If (l = 0), then:
    1) Assert: Due to validation, there are at least n values on the top of the stack.
    2) Pop the values val^n from the stack.
    3) Pop all values val'* from the top of the stack.
    4) Pop the label (LABEL_ _ { _ }) from the stack.
    5) Push the values val^n to the stack.
    6) Execute the sequence instr'*.
  c. Else:
    1) Pop all values val* from the top of the stack.
    2) Pop the label (LABEL_ _ { _ }) from the stack.
    3) Push the values val* to the stack.
    4) Execute the instruction (BR (l - 1)).
2. Else:
  a. Assert: Due to validation, the first non-value entry of the stack is a HANDLER_.
  b. Pop all values val* from the top of the stack.
  c. Pop the handler (HANDLER_ _ { _ }) from the stack.
  d. Push the values val* to the stack.
  e. Execute the instruction (BR l).

Step_pure/br_if l
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BR l).
4. Else:
  a. Do nothing.

Step_pure/br_table l* l'
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. If (i < |l*|), then:
  a. Execute the instruction (BR l*[i]).
4. Else:
  a. Execute the instruction (BR l').

Step_pure/br_on_null l
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. If val is some REF.NULL, then:
  a. Execute the instruction (BR l).
4. Else:
  a. Push the value val to the stack.

Step_pure/br_on_non_null l
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. If val is some REF.NULL, then:
  a. Do nothing.
4. Else:
  a. Push the value val to the stack.
  b. Execute the instruction (BR l).

Step_pure/call_indirect x yy
1. Execute the instruction (TABLE.GET x).
2. Execute the instruction (REF.CAST (REF ?(NULL) yy)).
3. Execute the instruction (CALL_REF yy).

Step_pure/return_call_indirect x yy
1. Execute the instruction (TABLE.GET x).
2. Execute the instruction (REF.CAST (REF ?(NULL) yy)).
3. Execute the instruction (RETURN_CALL_REF yy).

Step_pure/frame
1. Let (FRAME_ n { f }) be the topmost FRAME_.
2. Assert: Due to validation, there are at least n values on the top of the stack.
3. Assert: Due to validation, there are at least n values on the top of the stack.
4. Pop the values val^n from the stack.
5. Assert: Due to validation, the first non-value entry of the stack is a FRAME_.
6. Pop the frame (FRAME_ _ { _ }) from the stack.
7. Push the values val^n to the stack.

Step_pure/return
1. If the first non-value entry of the stack is a FRAME_, then:
  a. Let (FRAME_ n { f }) be the topmost FRAME_.
  b. Assert: Due to validation, there are at least n values on the top of the stack.
  c. Pop the values val^n from the stack.
  d. Pop all values val'* from the top of the stack.
  e. Pop the frame (FRAME_ _ { _ }) from the stack.
  f. Push the values val^n to the stack.
2. Else if the first non-value entry of the stack is a LABEL_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the label (LABEL_ _ { _ }) from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction RETURN.
3. Else:
  a. Assert: Due to validation, the first non-value entry of the stack is a HANDLER_.
  b. Pop all values val* from the top of the stack.
  c. Pop the handler (HANDLER_ _ { _ }) from the stack.
  d. Push the values val* to the stack.
  e. Execute the instruction RETURN.

Step_pure/handler
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, the first non-value entry of the stack is a HANDLER_.
3. Pop the handler (HANDLER_ _ { _ }) from the stack.
4. Push the values val* to the stack.

Step_pure/local.tee x
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Push the value val to the stack.
4. Push the value val to the stack.
5. Execute the instruction (LOCAL.SET x).

Step_pure/ref.i31
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. Push the value (REF.I31_NUM $wrap__(32, 31, i)) to the stack.

Step_pure/ref.is_null
1. Assert: Due to validation, a value of value type ref is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is some REF.NULL, then:
  a. Push the value (I32.CONST 1) to the stack.
4. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_pure/ref.as_non_null
1. Assert: Due to validation, a value of value type ref is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is some REF.NULL, then:
  a. Trap.
4. Push the value ref to the stack.

Step_pure/ref.eq
1. Assert: Due to validation, a value of value type ref is on the top of the stack.
2. Pop the value ref_2 from the stack.
3. Assert: Due to validation, a value of value type ref is on the top of the stack.
4. Pop the value ref_1 from the stack.
5. If (ref_1 is some REF.NULL /\ ref_2 is some REF.NULL), then:
  a. Push the value (I32.CONST 1) to the stack.
6. Else if (ref_1 = ref_2), then:
  a. Push the value (I32.CONST 1) to the stack.
7. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_pure/i31.get sx
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. If val is some REF.NULL, then:
  a. Trap.
4. Assert: Due to validation, val is some REF.I31_NUM.
5. Let (REF.I31_NUM i) be val.
6. Push the value (I32.CONST $extend__(31, 32, sx, i)) to the stack.

Step_pure/array.new x
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST n) from the stack.
3. Assert: Due to validation, a value is on the top of the stack.
4. Pop the value val from the stack.
5. Push the values val^n to the stack.
6. Execute the instruction (ARRAY.NEW_FIXED x n).

Step_pure/extern.convert_any
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. If val is some REF.NULL, then:
  a. Push the value (REF.NULL EXTERN) to the stack.
4. If val is addrref, then:
  a. Push the value (REF.EXTERN val) to the stack.

Step_pure/any.convert_extern
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. If val is some REF.NULL, then:
  a. Push the value (REF.NULL ANY) to the stack.
4. If val is some REF.EXTERN, then:
  a. Let (REF.EXTERN addrref) be val.
  b. Push the value addrref to the stack.

Step_pure/unop nt unop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. If (|$unop_(nt, unop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $unop_(nt, unop, c_1).
5. Push the value (nt.CONST c) to the stack.

Step_pure/binop nt binop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type num is on the top of the stack.
4. Pop the value (numtype_0.CONST c_1) from the stack.
5. If (|$binop_(nt, binop, c_1, c_2)| <= 0), then:
  a. Trap.
6. Let c be an element of $binop_(nt, binop, c_1, c_2).
7. Push the value (nt.CONST c) to the stack.

Step_pure/testop nt testop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. Let c be $testop_(nt, testop, c_1).
4. Push the value (I32.CONST c) to the stack.

Step_pure/relop nt relop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type num is on the top of the stack.
4. Pop the value (numtype_0.CONST c_1) from the stack.
5. Let c be $relop_(nt, relop, c_1, c_2).
6. Push the value (I32.CONST c) to the stack.

Step_pure/cvtop nt_2 nt_1 cvtop
1. Assert: Due to validation, a value of value type nt_1 is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. If (|$cvtop__(nt_1, nt_2, cvtop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $cvtop__(nt_1, nt_2, cvtop, c_1).
5. Push the value (nt_2.CONST c) to the stack.

Step_pure/vvunop V128 vvunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Assert: Due to validation, (|$vvunop_(V128, vvunop, c_1)| > 0).
4. Let c be an element of $vvunop_(V128, vvunop, c_1).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vvbinop V128 vvbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Assert: Due to validation, (|$vvbinop_(V128, vvbinop, c_1, c_2)| > 0).
6. Let c be an element of $vvbinop_(V128, vvbinop, c_1, c_2).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vvternop V128 vvternop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_3) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_2) from the stack.
5. Assert: Due to validation, a value of value type V128 is on the top of the stack.
6. Pop the value (V128.CONST c_1) from the stack.
7. Assert: Due to validation, (|$vvternop_(V128, vvternop, c_1, c_2, c_3)| > 0).
8. Let c be an element of $vvternop_(V128, vvternop, c_1, c_2, c_3).
9. Push the value (V128.CONST c) to the stack.

Step_pure/vvtestop V128 ANY_TRUE
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $ine_($vsize(V128), c_1, 0).
4. Push the value (I32.CONST c) to the stack.

Step_pure/vunop sh vunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (|$vunop_(sh, vunop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $vunop_(sh, vunop, c_1).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vbinop sh vbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. If (|$vbinop_(sh, vbinop, c_1, c_2)| <= 0), then:
  a. Trap.
6. Let c be an element of $vbinop_(sh, vbinop, c_1, c_2).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vternop sh vternop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_3) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_2) from the stack.
5. Assert: Due to validation, a value of value type V128 is on the top of the stack.
6. Pop the value (V128.CONST c_1) from the stack.
7. If (|$vternop_(sh, vternop, c_1, c_2, c_3)| <= 0), then:
  a. Trap.
8. Let c be an element of $vternop_(sh, vternop, c_1, c_2, c_3).
9. Push the value (V128.CONST c) to the stack.

Step_pure/vtestop sh vtestop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let i be $vtestop_(sh, vtestop, c_1).
4. Push the value (I32.CONST i) to the stack.

Step_pure/vrelop sh vrelop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vrelop_(sh, vrelop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vshiftop sh vshiftop
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vshiftop_(sh, vshiftop, c_1, i).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vbitmask sh
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vbitmaskop_(sh, c_1).
4. Push the value (I32.CONST c) to the stack.

Step_pure/vswizzlop sh swizzlop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vswizzlop_(sh, swizzlop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vshuffle sh i*
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vshufflop_(sh, i*, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vsplat Lnn X M
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. Assert: Due to validation, (numtype_0 = $lunpack(Lnn)).
4. Let c be $inv_lanes_(Lnn X M, $lpacknum_(Lnn, c_1)^M).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vextract_lane lanetype X M sx'? i
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If sx'? is not defined, then:
  a. Assert: Due to validation, lanetype is numtype.
  b. Assert: Due to validation, (i < |$lanes_(lanetype X M, c_1)|).
  c. Let c_2 be $lanes_(lanetype X M, c_1)[i].
  d. Push the value (lanetype.CONST c_2) to the stack.
4. Else:
  a. Assert: Due to validation, lanetype is packtype.
  b. Let ?(sx) be sx'?.
  c. Assert: Due to validation, (i < |$lanes_(lanetype X M, c_1)|).
  d. Let c_2 be $extend__($psize(lanetype), 32, sx, $lanes_(lanetype X M, c_1)[i]).
  e. Push the value (I32.CONST c_2) to the stack.

Step_pure/vreplace_lane Lnn X M i
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, (numtype_0 = $lunpack(Lnn)).
4. Assert: Due to validation, a value of value type V128 is on the top of the stack.
5. Pop the value (V128.CONST c_1) from the stack.
6. Let c be $inv_lanes_(Lnn X M, $lanes_(Lnn X M, c_1) with [i] replaced by $lpacknum_(Lnn, c_2)).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vextunop sh_2 sh_1 vextunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vextunop__(sh_1, sh_2, vextunop, c_1).
4. Push the value (V128.CONST c) to the stack.

Step_pure/vextbinop sh_2 sh_1 vextbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vextbinop__(sh_1, sh_2, vextbinop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vextternop sh_2 sh_1 vextternop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_3) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_2) from the stack.
5. Assert: Due to validation, a value of value type V128 is on the top of the stack.
6. Pop the value (V128.CONST c_1) from the stack.
7. Let c be $vextternop__(sh_1, sh_2, vextternop, c_1, c_2, c_3).
8. Push the value (V128.CONST c) to the stack.

Step_pure/vnarrow sh_2 sh_1 sx
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vnarrowop__(sh_1, sh_2, sx, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vcvtop sh_2 sh_1 vcvtop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vcvtop__(sh_1, sh_2, vcvtop, c_1).
4. Push the value (V128.CONST c) to the stack.

Step_read/block bt instr*
1. Let z be the current state.
2. Let t_1^m ->_ localidx_0* t_2^n be $blocktype_(z, bt).
3. Assert: Due to validation, (localidx_0* = []).
4. Assert: Due to validation, there are at least m values on the top of the stack.
5. Pop the values val^m from the stack.
6. Enter val^m :: instr* with label (LABEL_ n { [] }).

Step_read/loop bt instr*
1. Let z be the current state.
2. Let t_1^m ->_ localidx_0* t_2^n be $blocktype_(z, bt).
3. Assert: Due to validation, (localidx_0* = []).
4. Assert: Due to validation, there are at least m values on the top of the stack.
5. Pop the values val^m from the stack.
6. Enter val^m :: instr* with label (LABEL_ m { [(LOOP bt instr*)] }).

Step_read/br_on_cast l rt_1 rt_2
1. Let (FRAME_ _ { f }) be the topmost FRAME_.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Let rt be $Ref_ok(ref).
5. Push the value ref to the stack.
6. If rt matches $inst_reftype(f.MODULE, rt_2), then:
  a. Execute the instruction (BR l).
7. Else:
  a. Do nothing.

Step_read/br_on_cast_fail l rt_1 rt_2
1. Let (FRAME_ _ { f }) be the topmost FRAME_.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Let rt be $Ref_ok(ref).
5. Push the value ref to the stack.
6. If rt matches $inst_reftype(f.MODULE, rt_2), then:
  a. Do nothing.
7. Else:
  a. Execute the instruction (BR l).

Step_read/call x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$moduleinst(z).FUNCS|).
3. Let a be $moduleinst(z).FUNCS[x].
4. Assert: Due to validation, (a < |$funcinst(z)|).
5. Push the value (REF.FUNC_ADDR a) to the stack.
6. Execute the instruction (CALL_REF $funcinst(z)[a].TYPE).

Step_read/call_ref yy
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val' from the stack.
4. If val' is some REF.NULL, then:
  a. Trap.
5. Assert: Due to validation, val' is some REF.FUNC_ADDR.
6. Let (REF.FUNC_ADDR a) be val'.
7. Assert: Due to validation, (a < |$funcinst(z)|).
8. Let fi be $funcinst(z)[a].
9. Assert: Due to validation, fi.CODE is some FUNC.
10. Let (FUNC x local_0* instr*) be fi.CODE.
11. Let t* be [].
12. For each local_0 in local_0*, do:
  a. Let (LOCAL t) be local_0.
  b. Append t to the t*.
13. Assert: Due to validation, $Expand(fi.TYPE) is some FUNC.
14. Let (FUNC t_1^n -> t_2^m) be $Expand(fi.TYPE).
15. Assert: Due to validation, there are at least n values on the top of the stack.
16. Pop the values val^n from the stack.
17. Let f be { LOCALS: ?(val)^n :: $default_(t)*; MODULE: fi.MODULE }.
18. Push the frame (FRAME_ m { f }) to the stack.
19. Enter instr* with label (LABEL_ m { [] }).

Step_read/return_call x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$moduleinst(z).FUNCS|).
3. Let a be $moduleinst(z).FUNCS[x].
4. Assert: Due to validation, (a < |$funcinst(z)|).
5. Push the value (REF.FUNC_ADDR a) to the stack.
6. Execute the instruction (RETURN_CALL_REF $funcinst(z)[a].TYPE).

Step_read/return_call_ref yy
1. Let z be the current state.
2. If the first non-value entry of the stack is a LABEL_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the label (LABEL_ _ { _ }) from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction (RETURN_CALL_REF yy).
3. Else if the first non-value entry of the stack is a HANDLER_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the handler (HANDLER_ _ { _ }) from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction (RETURN_CALL_REF yy).
4. Else:
  a. Assert: Due to validation, the first non-value entry of the stack is a FRAME_.
  b. Assert: Due to validation, a value is on the top of the stack.
  c. Pop the value val'' from the stack.
  d. If val'' is some REF.NULL, then:
    1) Trap.
  e. Assert: Due to validation, val'' is some REF.FUNC_ADDR.
  f. Let (REF.FUNC_ADDR a) be val''.
  g. Assert: Due to validation, (a < |$funcinst(z)|).
  h. Assert: Due to validation, $Expand($funcinst(z)[a].TYPE) is some FUNC.
  i. Let (FUNC t_1^n -> t_2^m) be $Expand($funcinst(z)[a].TYPE).
  j. Assert: Due to validation, there are at least n values on the top of the stack.
  k. Pop the values val^n from the stack.
  l. Pop all values val'* from the top of the stack.
  m. Pop the frame (FRAME_ _ { _ }) from the stack.
  n. Push the values val^n to the stack.
  o. Push the value (REF.FUNC_ADDR a) to the stack.
  p. Execute the instruction (CALL_REF yy).

Step_read/throw_ref
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val' from the stack.
4. If val' is some REF.NULL, then:
  a. Trap.
5. If val' is some REF.EXN_ADDR, then:
  a. Let (REF.EXN_ADDR a) be val'.
  b. Pop all values val* from the top of the stack.
  c. If (val* =/= []), then:
    1) Push the value (REF.EXN_ADDR a) to the stack.
    2) Execute the instruction THROW_REF.
  d. Else if the first non-value entry of the stack is a LABEL_, then:
    1) Pop the label (LABEL_ _ { _ }) from the stack.
    2) Push the value (REF.EXN_ADDR a) to the stack.
    3) Execute the instruction THROW_REF.
  e. Else if the first non-value entry of the stack is a FRAME_, then:
    1) Pop the frame (FRAME_ _ { _ }) from the stack.
    2) Push the value (REF.EXN_ADDR a) to the stack.
    3) Execute the instruction THROW_REF.
  f. Else if the first non-value entry of the stack is not a HANDLER_, then:
    1) Throw the exception val' as a result.
  g. Else:
    1) Let (HANDLER_ n { catch''* }) be the topmost HANDLER_.
    2) If (catch''* = []), then:
      a) Pop the handler (HANDLER_ _ { _ }) from the stack.
      b) Push the value (REF.EXN_ADDR a) to the stack.
      c) Execute the instruction THROW_REF.
    3) Else if (a >= |$exninst(z)|), then:
      a) Let [catch_0] :: catch'* be catch''*.
      b) If catch_0 is some CATCH_ALL, then:
        1. Let (CATCH_ALL l) be catch_0.
        2. Pop the handler (HANDLER_ _ { _ }) from the stack.
        3. Execute the instruction (BR l).
      c) Else if catch_0 is not CATCH_ALL_REF, then:
        1. Let [catch] :: catch'* be catch''*.
        2. Pop the handler (HANDLER_ _ { _ }) from the stack.
        3. Push the handler (HANDLER_ n { catch'* }) to the stack.
        4. Push the value (REF.EXN_ADDR a) to the stack.
        5. Execute the instruction THROW_REF.
      d) Else:
        1. Let (CATCH_ALL_REF l) be catch_0.
        2. Pop the handler (HANDLER_ _ { _ }) from the stack.
        3. Push the value (REF.EXN_ADDR a) to the stack.
        4. Execute the instruction (BR l).
    4) Else:
      a) Let val* be $exninst(z)[a].FIELDS.
      b) Let [catch_0] :: catch'* be catch''*.
      c) If catch_0 is some CATCH, then:
        1. Let (CATCH x l) be catch_0.
        2. If ((x < |$tagaddr(z)|) /\ ($exninst(z)[a].TAG = $tagaddr(z)[x])), then:
          a. Pop the handler (HANDLER_ _ { _ }) from the stack.
          b. Push the values val* to the stack.
          c. Execute the instruction (BR l).
        3. Else:
          a. Let [catch] :: catch'* be catch''*.
          b. Pop the handler (HANDLER_ _ { _ }) from the stack.
          c. Push the handler (HANDLER_ n { catch'* }) to the stack.
          d. Push the value (REF.EXN_ADDR a) to the stack.
          e. Execute the instruction THROW_REF.
      d) Else if catch_0 is some CATCH_REF, then:
        1. Let (CATCH_REF x l) be catch_0.
        2. If ((x >= |$tagaddr(z)|) \/ ($exninst(z)[a].TAG =/= $tagaddr(z)[x])), then:
          a. Let [catch] :: catch'* be catch''*.
          b. Pop the handler (HANDLER_ _ { _ }) from the stack.
          c. Push the handler (HANDLER_ n { catch'* }) to the stack.
          d. Push the value (REF.EXN_ADDR a) to the stack.
          e. Execute the instruction THROW_REF.
        3. Else:
          a. Pop the handler (HANDLER_ _ { _ }) from the stack.
          b. Push the values val* to the stack.
          c. Push the value (REF.EXN_ADDR a) to the stack.
          d. Execute the instruction (BR l).
      e) Else if catch_0 is some CATCH_ALL, then:
        1. Let (CATCH_ALL l) be catch_0.
        2. Pop the handler (HANDLER_ _ { _ }) from the stack.
        3. Execute the instruction (BR l).
      f) Else if catch_0 is not CATCH_ALL_REF, then:
        1. Let [catch] :: catch'* be catch''*.
        2. Pop the handler (HANDLER_ _ { _ }) from the stack.
        3. Push the handler (HANDLER_ n { catch'* }) to the stack.
        4. Push the value (REF.EXN_ADDR a) to the stack.
        5. Execute the instruction THROW_REF.
      g) Else:
        1. Let (CATCH_ALL_REF l) be catch_0.
        2. Pop the handler (HANDLER_ _ { _ }) from the stack.
        3. Push the value (REF.EXN_ADDR a) to the stack.
        4. Execute the instruction (BR l).
6. Else:
  a. Assert: Due to validation, the first non-value entry of the stack is not a LABEL_.
  b. Assert: Due to validation, the first non-value entry of the stack is not a FRAME_.
  c. Assert: Due to validation, the first non-value entry of the stack is not a HANDLER_.
  d. Throw the exception val' as a result.

Step_read/try_table bt catch* instr*
1. Let z be the current state.
2. Let t_1^m ->_ localidx_0* t_2^n be $blocktype_(z, bt).
3. Assert: Due to validation, (localidx_0* = []).
4. Assert: Due to validation, there are at least m values on the top of the stack.
5. Pop the values val^m from the stack.
6. Push the handler (HANDLER_ n { catch* }) to the stack.
7. Enter val^m :: instr* with label (LABEL_ n { [] }).

Step_read/local.get x
1. Let z be the current state.
2. Assert: Due to validation, $local(z, x) is defined.
3. Let ?(val) be $local(z, x).
4. Push the value val to the stack.

Step_read/global.get x
1. Let z be the current state.
2. Let val be $global(z, x).VALUE.
3. Push the value val to the stack.

Step_read/table.get x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST i) from the stack.
4. If (i >= |$table(z, x).REFS|), then:
  a. Trap.
5. Push the value $table(z, x).REFS[i] to the stack.

Step_read/table.size x
1. Let z be the current state.
2. Let (at lim rt) be $table(z, x).TYPE.
3. Let n be |$table(z, x).REFS|.
4. Push the value (at.CONST n) to the stack.

Step_read/table.fill x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type at is on the top of the stack.
7. Pop the value (numtype_0.CONST i) from the stack.
8. If ((i + n) > |$table(z, x).REFS|), then:
  a. Trap.
9. If (n = 0), then:
  a. Do nothing.
10. Else:
  a. Push the value (at.CONST i) to the stack.
  b. Push the value val to the stack.
  c. Execute the instruction (TABLE.SET x).
  d. Push the value (at.CONST (i + 1)) to the stack.
  e. Push the value val to the stack.
  f. Push the value (at.CONST (n - 1)) to the stack.
  g. Execute the instruction (TABLE.FILL x).

Step_read/table.copy x_1 x_2
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST n) from the stack.
4. Assert: Due to validation, a value of value type num is on the top of the stack.
5. Pop the value (at_2.CONST i_2) from the stack.
6. Assert: Due to validation, a value of value type num is on the top of the stack.
7. Pop the value (at_1.CONST i_1) from the stack.
8. If ((i_1 + n) > |$table(z, x_1).REFS|), then:
  a. Trap.
9. If ((i_2 + n) > |$table(z, x_2).REFS|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else:
  a. If (i_1 <= i_2), then:
    1) Push the value (at_1.CONST i_1) to the stack.
    2) Push the value (at_2.CONST i_2) to the stack.
    3) Execute the instruction (TABLE.GET x_2).
    4) Execute the instruction (TABLE.SET x_1).
    5) Push the value (at_1.CONST (i_1 + 1)) to the stack.
    6) Push the value (at_2.CONST (i_2 + 1)) to the stack.
  b. Else:
    1) Push the value (at_1.CONST ((i_1 + n) - 1)) to the stack.
    2) Push the value (at_2.CONST ((i_2 + n) - 1)) to the stack.
    3) Execute the instruction (TABLE.GET x_2).
    4) Execute the instruction (TABLE.SET x_1).
    5) Push the value (at_1.CONST i_1) to the stack.
    6) Push the value (at_2.CONST i_2) to the stack.
  c. Push the value (at.CONST (n - 1)) to the stack.
  d. Execute the instruction (TABLE.COPY x_1 x_2).

Step_read/table.init x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST j) from the stack.
6. Assert: Due to validation, a value of value type num is on the top of the stack.
7. Pop the value (at.CONST i) from the stack.
8. If ((i + n) > |$table(z, x).REFS|), then:
  a. Trap.
9. If ((j + n) > |$elem(z, y).REFS|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else:
  a. Assert: Due to validation, (j < |$elem(z, y).REFS|).
  b. Push the value (at.CONST i) to the stack.
  c. Push the value $elem(z, y).REFS[j] to the stack.
  d. Execute the instruction (TABLE.SET x).
  e. Push the value (at.CONST (i + 1)) to the stack.
  f. Push the value (I32.CONST (j + 1)) to the stack.
  g. Push the value (I32.CONST (n - 1)) to the stack.
  h. Execute the instruction (TABLE.INIT x y).

Step_read/load nt loadop_? x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST i) from the stack.
4. If loadop_? is not defined, then:
  a. If (((i + ao.OFFSET) + ($size(nt) / 8)) > |$mem(z, x).BYTES|), then:
    1) Trap.
  b. Let c be $nbytes__1^-1(nt, $mem(z, x).BYTES[(i + ao.OFFSET) : ($size(nt) / 8)]).
  c. Push the value (nt.CONST c) to the stack.
5. Else:
  a. Assert: Due to validation, nt is Inn.
  b. Let ?(loadop_0) be loadop_?.
  c. Let n _ sx be loadop_0.
  d. If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, x).BYTES|), then:
    1) Trap.
  e. Let c be $ibytes__1^-1(n, $mem(z, x).BYTES[(i + ao.OFFSET) : (n / 8)]).
  f. Push the value (nt.CONST $extend__(n, $size(nt), sx, c)) to the stack.

Step_read/vload V128 vloadop_? x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST i) from the stack.
4. If vloadop_? is not defined, then:
  a. If (((i + ao.OFFSET) + ($vsize(V128) / 8)) > |$mem(z, x).BYTES|), then:
    1) Trap.
  b. Let c be $vbytes__1^-1(V128, $mem(z, x).BYTES[(i + ao.OFFSET) : ($vsize(V128) / 8)]).
  c. Push the value (V128.CONST c) to the stack.
5. Else:
  a. Let ?(vloadop_0) be vloadop_?.
  b. If vloadop_0 is some SHAPE, then:
    1) Let (SHAPE M X K _ sx) be vloadop_0.
    2) If (((i + ao.OFFSET) + ((M * K) / 8)) > |$mem(z, x).BYTES|), then:
      a) Trap.
    3) Let j^K be $ibytes__1^-1(M, $mem(z, x).BYTES[((i + ao.OFFSET) + ((k * M) / 8)) : (M / 8)])^(k<K).
    4) Let Jnn be $jsizenn^-1((M * 2)).
    5) Let c be $inv_lanes_(Jnn X K, $extend__(M, $jsizenn(Jnn), sx, j)^K).
    6) Push the value (V128.CONST c) to the stack.
  c. If vloadop_0 is some SPLAT, then:
    1) Let (SPLAT N) be vloadop_0.
    2) If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, x).BYTES|), then:
      a) Trap.
    3) Let M be (128 / N).
    4) Let Jnn be $jsize^-1(N).
    5) Let j be $ibytes__1^-1(N, $mem(z, x).BYTES[(i + ao.OFFSET) : (N / 8)]).
    6) Let c be $inv_lanes_(Jnn X M, j^M).
    7) Push the value (V128.CONST c) to the stack.
  d. If vloadop_0 is some ZERO, then:
    1) Let (ZERO N) be vloadop_0.
    2) If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, x).BYTES|), then:
      a) Trap.
    3) Let j be $ibytes__1^-1(N, $mem(z, x).BYTES[(i + ao.OFFSET) : (N / 8)]).
    4) Let c be $extend__(N, 128, U, j).
    5) Push the value (V128.CONST c) to the stack.

Step_read/vload_lane V128 N x ao j
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c_1) from the stack.
4. Assert: Due to validation, a value of value type num is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, x).BYTES|), then:
  a. Trap.
7. Let M be ($vsize(V128) / N).
8. Let Jnn be $jsize^-1(N).
9. Let k be $ibytes__1^-1(N, $mem(z, x).BYTES[(i + ao.OFFSET) : (N / 8)]).
10. Let c be $inv_lanes_(Jnn X M, $lanes_(Jnn X M, c_1) with [j] replaced by k).
11. Push the value (V128.CONST c) to the stack.

Step_read/memory.size x
1. Let z be the current state.
2. Let at lim PAGE be $mem(z, x).TYPE.
3. Let (n * (64 * $Ki())) be |$mem(z, x).BYTES|.
4. Push the value (at.CONST n) to the stack.

Step_read/memory.fill x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type at is on the top of the stack.
7. Pop the value (numtype_0.CONST i) from the stack.
8. If ((i + n) > |$mem(z, x).BYTES|), then:
  a. Trap.
9. If (n = 0), then:
  a. Do nothing.
10. Else:
  a. Push the value (at.CONST i) to the stack.
  b. Push the value val to the stack.
  c. Execute the instruction (STORE I32 ?(8) x $memarg0()).
  d. Push the value (at.CONST (i + 1)) to the stack.
  e. Push the value val to the stack.
  f. Push the value (at.CONST (n - 1)) to the stack.
  g. Execute the instruction (MEMORY.FILL x).

Step_read/memory.copy x_1 x_2
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST n) from the stack.
4. Assert: Due to validation, a value of value type num is on the top of the stack.
5. Pop the value (at_2.CONST i_2) from the stack.
6. Assert: Due to validation, a value of value type num is on the top of the stack.
7. Pop the value (at_1.CONST i_1) from the stack.
8. If ((i_1 + n) > |$mem(z, x_1).BYTES|), then:
  a. Trap.
9. If ((i_2 + n) > |$mem(z, x_2).BYTES|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else:
  a. If (i_1 <= i_2), then:
    1) Push the value (at_1.CONST i_1) to the stack.
    2) Push the value (at_2.CONST i_2) to the stack.
    3) Execute the instruction (LOAD I32 ?(8 _ U) x_2 $memarg0()).
    4) Execute the instruction (STORE I32 ?(8) x_1 $memarg0()).
    5) Push the value (at_1.CONST (i_1 + 1)) to the stack.
    6) Push the value (at_2.CONST (i_2 + 1)) to the stack.
  b. Else:
    1) Push the value (at_1.CONST ((i_1 + n) - 1)) to the stack.
    2) Push the value (at_2.CONST ((i_2 + n) - 1)) to the stack.
    3) Execute the instruction (LOAD I32 ?(8 _ U) x_2 $memarg0()).
    4) Execute the instruction (STORE I32 ?(8) x_1 $memarg0()).
    5) Push the value (at_1.CONST i_1) to the stack.
    6) Push the value (at_2.CONST i_2) to the stack.
  c. Push the value (at.CONST (n - 1)) to the stack.
  d. Execute the instruction (MEMORY.COPY x_1 x_2).

Step_read/memory.init x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST j) from the stack.
6. Assert: Due to validation, a value of value type num is on the top of the stack.
7. Pop the value (at.CONST i) from the stack.
8. If ((i + n) > |$mem(z, x).BYTES|), then:
  a. Trap.
9. If ((j + n) > |$data(z, y).BYTES|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else:
  a. Assert: Due to validation, (j < |$data(z, y).BYTES|).
  b. Push the value (at.CONST i) to the stack.
  c. Push the value (I32.CONST $data(z, y).BYTES[j]) to the stack.
  d. Execute the instruction (STORE I32 ?(8) x $memarg0()).
  e. Push the value (at.CONST (i + 1)) to the stack.
  f. Push the value (I32.CONST (j + 1)) to the stack.
  g. Push the value (I32.CONST (n - 1)) to the stack.
  h. Execute the instruction (MEMORY.INIT x y).

Step_read/ref.null (_IDX x)
1. Let z be the current state.
2. Push the value (REF.NULL $type(z, x)) to the stack.

Step_read/ref.func x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$moduleinst(z).FUNCS|).
3. Push the value (REF.FUNC_ADDR $moduleinst(z).FUNCS[x]) to the stack.

Step_read/ref.test rt
1. Let (FRAME_ _ { f }) be the topmost FRAME_.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Let rt' be $Ref_ok(ref).
5. If rt' matches $inst_reftype(f.MODULE, rt), then:
  a. Push the value (I32.CONST 1) to the stack.
6. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_read/ref.cast rt
1. Let (FRAME_ _ { f }) be the topmost FRAME_.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Let rt' be $Ref_ok(ref).
5. If rt' does not match $inst_reftype(f.MODULE, rt), then:
  a. Trap.
6. Push the value ref to the stack.

Step_read/struct.new_default x
1. Let z be the current state.
2. Assert: Due to validation, $Expand($type(z, x)) is some STRUCT.
3. Let (STRUCT list_0) be $Expand($type(z, x)).
4. Let (mut? zt)* be list_0.
5. Assert: Due to validation, $default_($unpack(zt)) is defined*.
6. Let val* be [].
7. For each zt in zt*, do:
  a. Let ?(val) be $default_($unpack(zt)).
  b. Append val to the val*.
8. Assert: Due to validation, (|val*| = |zt*|).
9. Push the values val* to the stack.
10. Execute the instruction (STRUCT.NEW x).

Step_read/struct.get sx? x i
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. If val is some REF.NULL, then:
  a. Trap.
5. Assert: Due to validation, val is some REF.STRUCT_ADDR.
6. Let (REF.STRUCT_ADDR a) be val.
7. Assert: Due to validation, (i < |$structinst(z)[a].FIELDS|).
8. Assert: Due to validation, (a < |$structinst(z)|).
9. Assert: Due to validation, $Expand($type(z, x)) is some STRUCT.
10. Let (STRUCT list_0) be $Expand($type(z, x)).
11. Let (mut? zt)* be list_0.
12. Assert: Due to validation, (i < |zt*|).
13. Push the value $unpackfield_(zt*[i], sx?, $structinst(z)[a].FIELDS[i]) to the stack.

Step_read/array.new_default x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, $Expand($type(z, x)) is some ARRAY.
5. Let (ARRAY fieldtype_0) be $Expand($type(z, x)).
6. Let (mut? zt) be fieldtype_0.
7. Assert: Due to validation, $default_($unpack(zt)) is defined.
8. Let ?(val) be $default_($unpack(zt)).
9. Push the values val^n to the stack.
10. Execute the instruction (ARRAY.NEW_FIXED x n).

Step_read/array.new_elem x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If ((i + n) > |$elem(z, y).REFS|), then:
  a. Trap.
7. Let ref^n be $elem(z, y).REFS[i : n].
8. Push the values ref^n to the stack.
9. Execute the instruction (ARRAY.NEW_FIXED x n).

Step_read/array.new_data x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, $Expand($type(z, x)) is some ARRAY.
7. Let (ARRAY fieldtype_0) be $Expand($type(z, x)).
8. Let (mut? zt) be fieldtype_0.
9. If ((i + ((n * $zsize(zt)) / 8)) > |$data(z, y).BYTES|), then:
  a. Trap.
10. Let byte** be $concatn__1^-1(`byte, ($zsize(zt) / 8), $data(z, y).BYTES[i : ((n * $zsize(zt)) / 8)]).
11. Let c^n be $zbytes__1^-1(zt, byte*)*.
12. Push the values $const($cunpack(zt), $cunpacknum_(zt, c))^n to the stack.
13. Execute the instruction (ARRAY.NEW_FIXED x n).

Step_read/array.get sx? x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. If val is some REF.NULL, then:
  a. Trap.
7. Assert: Due to validation, val is some REF.ARRAY_ADDR.
8. Let (REF.ARRAY_ADDR a) be val.
9. If ((a < |$arrayinst(z)|) /\ (i >= |$arrayinst(z)[a].FIELDS|)), then:
  a. Trap.
10. If ((i < |$arrayinst(z)[a].FIELDS|) /\ (a < |$arrayinst(z)|)), then:
  a. Assert: Due to validation, $Expand($type(z, x)) is some ARRAY.
  b. Let (ARRAY fieldtype_0) be $Expand($type(z, x)).
  c. Let (mut? zt) be fieldtype_0.
  d. Push the value $unpackfield_(zt, sx?, $arrayinst(z)[a].FIELDS[i]) to the stack.

Step_read/array.len
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. If val is some REF.NULL, then:
  a. Trap.
5. Assert: Due to validation, val is some REF.ARRAY_ADDR.
6. Let (REF.ARRAY_ADDR a) be val.
7. Assert: Due to validation, (a < |$arrayinst(z)|).
8. Push the value (I32.CONST |$arrayinst(z)[a].FIELDS|) to the stack.

Step_read/array.fill x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. Assert: Due to validation, a value is on the top of the stack.
9. Pop the value val' from the stack.
10. If val' is some REF.NULL, then:
  a. Trap.
11. Assert: Due to validation, val' is some REF.ARRAY_ADDR.
12. Let (REF.ARRAY_ADDR a) be val'.
13. If (a >= |$arrayinst(z)|), then:
  a. Do nothing.
14. Else if ((i + n) > |$arrayinst(z)[a].FIELDS|), then:
  a. Trap.
15. If (n = 0), then:
  a. Do nothing.
16. Else:
  a. Push the value (REF.ARRAY_ADDR a) to the stack.
  b. Push the value (I32.CONST i) to the stack.
  c. Push the value val to the stack.
  d. Execute the instruction (ARRAY.SET x).
  e. Push the value (REF.ARRAY_ADDR a) to the stack.
  f. Push the value (I32.CONST (i + 1)) to the stack.
  g. Push the value val to the stack.
  h. Push the value (I32.CONST (n - 1)) to the stack.
  i. Execute the instruction (ARRAY.FILL x).

Step_read/array.copy x_1 x_2
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i_2) from the stack.
6. Assert: Due to validation, a value is on the top of the stack.
7. Pop the value val from the stack.
8. Assert: Due to validation, a value of value type I32 is on the top of the stack.
9. Pop the value (I32.CONST i_1) from the stack.
10. Assert: Due to validation, a value is on the top of the stack.
11. Pop the value val' from the stack.
12. If (val' is some REF.NULL /\ val is ref), then:
  a. Trap.
13. If (val is some REF.NULL /\ val' is ref), then:
  a. Trap.
14. If val' is some REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a_1) be val'.
  b. If val is some REF.ARRAY_ADDR, then:
    1) If ((a_1 < |$arrayinst(z)|) /\ ((i_1 + n) > |$arrayinst(z)[a_1].FIELDS|)), then:
      a) Trap.
    2) Let (REF.ARRAY_ADDR a_2) be val.
    3) If (a_2 >= |$arrayinst(z)|), then:
      a) Do nothing.
    4) Else if ((i_2 + n) > |$arrayinst(z)[a_2].FIELDS|), then:
      a) Trap.
    5) If (n = 0), then:
      a) Do nothing.
    6) Else:
      a) Assert: Due to validation, $Expand($type(z, x_2)) is some ARRAY.
      b) Let (ARRAY fieldtype_0) be $Expand($type(z, x_2)).
      c) Let (mut? zt_2) be fieldtype_0.
      d) Let sx? be $sx(zt_2).
      e) Push the value (REF.ARRAY_ADDR a_1) to the stack.
      f) If (i_1 <= i_2), then:
        1. Push the value (I32.CONST i_1) to the stack.
        2. Push the value (REF.ARRAY_ADDR a_2) to the stack.
        3. Push the value (I32.CONST i_2) to the stack.
        4. Execute the instruction (ARRAY.GET sx? x_2).
        5. Execute the instruction (ARRAY.SET x_1).
        6. Push the value (REF.ARRAY_ADDR a_1) to the stack.
        7. Push the value (I32.CONST (i_1 + 1)) to the stack.
        8. Push the value (REF.ARRAY_ADDR a_2) to the stack.
        9. Push the value (I32.CONST (i_2 + 1)) to the stack.
      g) Else:
        1. Push the value (I32.CONST ((i_1 + n) - 1)) to the stack.
        2. Push the value (REF.ARRAY_ADDR a_2) to the stack.
        3. Push the value (I32.CONST ((i_2 + n) - 1)) to the stack.
        4. Execute the instruction (ARRAY.GET sx? x_2).
        5. Execute the instruction (ARRAY.SET x_1).
        6. Push the value (REF.ARRAY_ADDR a_1) to the stack.
        7. Push the value (I32.CONST i_1) to the stack.
        8. Push the value (REF.ARRAY_ADDR a_2) to the stack.
        9. Push the value (I32.CONST i_2) to the stack.
      h) Push the value (I32.CONST (n - 1)) to the stack.
      i) Execute the instruction (ARRAY.COPY x_1 x_2).

Step_read/array.init_elem x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST j) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. Assert: Due to validation, a value is on the top of the stack.
9. Pop the value val from the stack.
10. If val is some REF.NULL, then:
  a. Trap.
11. Assert: Due to validation, val is some REF.ARRAY_ADDR.
12. Let (REF.ARRAY_ADDR a) be val.
13. If ((a < |$arrayinst(z)|) /\ ((i + n) > |$arrayinst(z)[a].FIELDS|)), then:
  a. Trap.
14. If ((j + n) > |$elem(z, y).REFS|), then:
  a. Trap.
15. If (n = 0), then:
  a. Do nothing.
16. Else if (j < |$elem(z, y).REFS|), then:
  a. Let ref be $elem(z, y).REFS[j].
  b. Push the value (REF.ARRAY_ADDR a) to the stack.
  c. Push the value (I32.CONST i) to the stack.
  d. Push the value ref to the stack.
  e. Execute the instruction (ARRAY.SET x).
  f. Push the value (REF.ARRAY_ADDR a) to the stack.
  g. Push the value (I32.CONST (i + 1)) to the stack.
  h. Push the value (I32.CONST (j + 1)) to the stack.
  i. Push the value (I32.CONST (n - 1)) to the stack.
  j. Execute the instruction (ARRAY.INIT_ELEM x y).

Step_read/array.init_data x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST j) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. Assert: Due to validation, a value is on the top of the stack.
9. Pop the value val from the stack.
10. If val is some REF.NULL, then:
  a. Trap.
11. Assert: Due to validation, val is some REF.ARRAY_ADDR.
12. Let (REF.ARRAY_ADDR a) be val.
13. If ((a < |$arrayinst(z)|) /\ ((i + n) > |$arrayinst(z)[a].FIELDS|)), then:
  a. Trap.
14. If $Expand($type(z, x)) is some ARRAY, then:
  a. Let (ARRAY fieldtype_0) be $Expand($type(z, x)).
  b. Let (mut? zt) be fieldtype_0.
  c. If ((j + ((n * $zsize(zt)) / 8)) > |$data(z, y).BYTES|), then:
    1) Trap.
  d. If (n = 0), then:
    1) Do nothing.
  e. Else:
    1) Let c be $zbytes__1^-1(zt, $data(z, y).BYTES[j : ($zsize(zt) / 8)]).
    2) Push the value (REF.ARRAY_ADDR a) to the stack.
    3) Push the value (I32.CONST i) to the stack.
    4) Push the value $const($cunpack(zt), $cunpacknum_(zt, c)) to the stack.
    5) Execute the instruction (ARRAY.SET x).
    6) Push the value (REF.ARRAY_ADDR a) to the stack.
    7) Push the value (I32.CONST (i + 1)) to the stack.
    8) Push the value (I32.CONST (j + ($zsize(zt) / 8))) to the stack.
    9) Push the value (I32.CONST (n - 1)) to the stack.
    10) Execute the instruction (ARRAY.INIT_DATA x y).
15. Else if (n = 0), then:
  a. Do nothing.

Step/throw x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$tagaddr(z)|).
3. Assert: Due to validation, $Expand($as_deftype($tag(z, x).TYPE)) is some FUNC.
4. Let (FUNC t^n -> resulttype_0) be $Expand($as_deftype($tag(z, x).TYPE)).
5. Assert: Due to validation, (resulttype_0 = []).
6. Let a be |$exninst(z)|.
7. Assert: Due to validation, there are at least n values on the top of the stack.
8. Pop the values val^n from the stack.
9. Let exn be { TAG: $tagaddr(z)[x]; FIELDS: val^n }.
10. Perform $add_exninst(z, [exn]).
11. Push the value (REF.EXN_ADDR a) to the stack.
12. Execute the instruction THROW_REF.

Step/local.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_local(z, x, val).

Step/global.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_global(z, x, val).

Step/table.set x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Assert: Due to validation, a value of value type num is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. If (i >= |$table(z, x).REFS|), then:
  a. Trap.
7. Perform $with_table(z, x, i, ref).

Step/table.grow x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST n) from the stack.
4. Assert: Due to validation, a value of value type ref is on the top of the stack.
5. Pop the value ref from the stack.
6. Either:
  a. Let ti be $growtable($table(z, x), n, ref).
  b. Push the value (at.CONST |$table(z, x).REFS|) to the stack.
  c. Perform $with_tableinst(z, x, ti).
7. Or:
  a. Push the value (at.CONST $inv_signed_($size(at), (- 1))) to the stack.

Step/elem.drop x
1. Let z be the current state.
2. Perform $with_elem(z, x, []).

Step/store nt storeop_? x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (nt'.CONST c) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. Assert: Due to validation, (nt = nt').
7. If storeop_? is not defined, then:
  a. If (((i + ao.OFFSET) + ($size(nt') / 8)) > |$mem(z, x).BYTES|), then:
    1) Trap.
  b. Let b* be $nbytes_(nt', c).
  c. Perform $with_mem(z, x, (i + ao.OFFSET), ($size(nt') / 8), b*).
8. Else:
  a. Assert: Due to validation, nt' is Inn.
  b. Let ?(n) be storeop_?.
  c. If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, x).BYTES|), then:
    1) Trap.
  d. Let b* be $ibytes_(n, $wrap__($size(nt'), n, c)).
  e. Perform $with_mem(z, x, (i + ao.OFFSET), (n / 8), b*).

Step/vstore V128 x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c) from the stack.
4. Assert: Due to validation, a value of value type num is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. If (((i + ao.OFFSET) + ($vsize(V128) / 8)) > |$mem(z, x).BYTES|), then:
  a. Trap.
7. Let b* be $vbytes_(V128, c).
8. Perform $with_mem(z, x, (i + ao.OFFSET), ($vsize(V128) / 8), b*).

Step/vstore_lane V128 N x ao j
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c) from the stack.
4. Assert: Due to validation, a value of value type num is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. If (((i + ao.OFFSET) + N) > |$mem(z, x).BYTES|), then:
  a. Trap.
7. Let M be (128 / N).
8. Let Jnn be $jsize^-1(N).
9. Assert: Due to validation, (j < |$lanes_(Jnn X M, c)|).
10. Let b* be $ibytes_(N, $lanes_(Jnn X M, c)[j]).
11. Perform $with_mem(z, x, (i + ao.OFFSET), (N / 8), b*).

Step/memory.grow x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type num is on the top of the stack.
3. Pop the value (at.CONST n) from the stack.
4. Either:
  a. Let mi be $growmem($mem(z, x), n).
  b. Push the value (at.CONST (|$mem(z, x).BYTES| / (64 * $Ki()))) to the stack.
  c. Perform $with_meminst(z, x, mi).
5. Or:
  a. Push the value (at.CONST $inv_signed_($size(at), (- 1))) to the stack.

Step/data.drop x
1. Let z be the current state.
2. Perform $with_data(z, x, []).

Step/struct.new x
1. Let z be the current state.
2. Assert: Due to validation, $Expand($type(z, x)) is some STRUCT.
3. Let (STRUCT list_0) be $Expand($type(z, x)).
4. Let (mut? zt)^n be list_0.
5. Let a be |$structinst(z)|.
6. Assert: Due to validation, there are at least n values on the top of the stack.
7. Pop the values val^n from the stack.
8. Let si be { TYPE: $type(z, x); FIELDS: $packfield_(zt, val)^n }.
9. Push the value (REF.STRUCT_ADDR a) to the stack.
10. Perform $add_structinst(z, [si]).

Step/struct.set x i
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val' from the stack.
6. If val' is some REF.NULL, then:
  a. Trap.
7. Assert: Due to validation, val' is some REF.STRUCT_ADDR.
8. Let (REF.STRUCT_ADDR a) be val'.
9. Assert: Due to validation, $Expand($type(z, x)) is some STRUCT.
10. Let (STRUCT list_0) be $Expand($type(z, x)).
11. Let (mut? zt)* be list_0.
12. Assert: Due to validation, (i < |zt*|).
13. Perform $with_struct(z, a, i, $packfield_(zt*[i], val)).

Step/array.new_fixed x n
1. Let z be the current state.
2. Assert: Due to validation, $Expand($type(z, x)) is some ARRAY.
3. Let (ARRAY fieldtype_0) be $Expand($type(z, x)).
4. Let (mut? zt) be fieldtype_0.
5. Let a be |$arrayinst(z)|.
6. Assert: Due to validation, there are at least n values on the top of the stack.
7. Pop the values val^n from the stack.
8. Let ai be { TYPE: $type(z, x); FIELDS: $packfield_(zt, val)^n }.
9. Push the value (REF.ARRAY_ADDR a) to the stack.
10. Perform $add_arrayinst(z, [ai]).

Step/array.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value is on the top of the stack.
7. Pop the value val' from the stack.
8. If val' is some REF.NULL, then:
  a. Trap.
9. Assert: Due to validation, val' is some REF.ARRAY_ADDR.
10. Let (REF.ARRAY_ADDR a) be val'.
11. If ((a < |$arrayinst(z)|) /\ (i >= |$arrayinst(z)[a].FIELDS|)), then:
  a. Trap.
12. Assert: Due to validation, $Expand($type(z, x)) is some ARRAY.
13. Let (ARRAY fieldtype_0) be $Expand($type(z, x)).
14. Let (mut? zt) be fieldtype_0.
15. Perform $with_array(z, a, i, $packfield_(zt, val)).

min i j
1. If (i <= j), then:
  a. Return i.
2. Return j.

sum n''*
1. If (n''* = []), then:
  a. Return 0.
2. Let [n] :: n'* be n''*.
3. Return (n + $sum(n'*)).

prod n''*
1. If (n''* = []), then:
  a. Return 1.
2. Let [n] :: n'* be n''*.
3. Return (n * $prod(n'*)).

opt_ `X X*
1. If (X* = []), then:
  a. Return ?().
2. Assert: Due to validation, (|X*| = 1).
3. Let [w] be X*.
4. Return ?(w).

concat_ `X X*
1. If (X* = []), then:
  a. Return [].
2. Let [w*] :: w'** be X*.
3. Return w* :: $concat_(`X, w'**).

concatn_ `X X* n
1. If (X* = []), then:
  a. Return [].
2. Let [w^n] :: w'^n* be X*.
3. Return w^n :: $concatn_(`X, w'^n*, n).

concatopt_ `X X*
1. If (X* = []), then:
  a. Return [].
2. Let [w?] :: w'?* be X*.
3. Return w? :: $concat_(`X, w'?*).

disjoint_ `X X*
1. If (X* = []), then:
  a. Return true.
2. Let [w] :: w'* be X*.
3. Return (w is not contained in w'* /\ $disjoint_(`X, w'*)).

setminus1_ `X w X*
1. If (X* = []), then:
  a. Return [w].
2. Let [w_1] :: w'* be X*.
3. If (w = w_1), then:
  a. Return [].
4. Return $setminus1_(`X, w, w'*).

setminus_ `X X* w*
1. If (X* = []), then:
  a. Return [].
2. Let [w_1] :: w'* be X*.
3. Return $setminus1_(`X, w_1, w*) :: $setminus_(`X, w'*, w*).

setproduct2_ `X w_1 X*
1. If (X* = []), then:
  a. Return [].
2. Let [w'*] :: w** be X*.
3. Return [[w_1] :: w'*] :: $setproduct2_(`X, w_1, w**).

setproduct1_ `X X* w**
1. If (X* = []), then:
  a. Return [].
2. Let [w_1] :: w'* be X*.
3. Return $setproduct2_(`X, w_1, w**) :: $setproduct1_(`X, w'*, w**).

setproduct_ `X X*
1. If (X* = []), then:
  a. Return [[]].
2. Let [w_1*] :: w** be X*.
3. Return $setproduct1_(`X, w_1*, $setproduct_(`X, w**)).

signif N
1. If (N = 32), then:
  a. Return 23.
2. Assert: Due to validation, (N = 64).
3. Return 52.

expon N
1. If (N = 32), then:
  a. Return 8.
2. Assert: Due to validation, (N = 64).
3. Return 11.

M N
1. Return $signif(N).

E N
1. Return $expon(N).

fzero N
1. Return (POS (SUBNORM 0)).

fnat N n
1. Return (POS (NORM n 0)).

fone N
1. Return (POS (NORM 1 0)).

canon_ N
1. Return (2 ^ ($signif(N) - 1)).

cont b
1. Assert: Due to validation, (128 < b).
2. Assert: Due to validation, (b < 192).
3. Return (b - 128).

funcsxx externidx'*
1. If (externidx'* = []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be externidx'*.
3. If externidx_0 is some FUNC, then:
  a. Let (FUNC x) be externidx_0.
  b. Return [x] :: $funcsxx(xx*).
4. Let [externidx] :: xx* be externidx'*.
5. Return $funcsxx(xx*).

globalsxx externidx'*
1. If (externidx'* = []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be externidx'*.
3. If externidx_0 is some GLOBAL, then:
  a. Let (GLOBAL x) be externidx_0.
  b. Return [x] :: $globalsxx(xx*).
4. Let [externidx] :: xx* be externidx'*.
5. Return $globalsxx(xx*).

tablesxx externidx'*
1. If (externidx'* = []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be externidx'*.
3. If externidx_0 is some TABLE, then:
  a. Let (TABLE x) be externidx_0.
  b. Return [x] :: $tablesxx(xx*).
4. Let [externidx] :: xx* be externidx'*.
5. Return $tablesxx(xx*).

memsxx externidx'*
1. If (externidx'* = []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be externidx'*.
3. If externidx_0 is some MEM, then:
  a. Let (MEM x) be externidx_0.
  b. Return [x] :: $memsxx(xx*).
4. Let [externidx] :: xx* be externidx'*.
5. Return $memsxx(xx*).

tagsxx externidx'*
1. If (externidx'* = []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be externidx'*.
3. If externidx_0 is some TAG, then:
  a. Let (TAG x) be externidx_0.
  b. Return [x] :: $tagsxx(xx*).
4. Let [externidx] :: xx* be externidx'*.
5. Return $tagsxx(xx*).

free_opt free'?
1. If free'? is not defined, then:
  a. Return {}.
2. Let ?(free) be free'?.
3. Return free.

free_list free''*
1. If (free''* = []), then:
  a. Return {}.
2. Let [free] :: free'* be free''*.
3. Return free ++ $free_list(free'*).

free_typeidx typeidx
1. Return { TYPES: [typeidx] }.

free_funcidx funcidx
1. Return { FUNCS: [funcidx] }.

free_globalidx globalidx
1. Return { GLOBALS: [globalidx] }.

free_tableidx tableidx
1. Return { TABLES: [tableidx] }.

free_memidx memidx
1. Return { MEMS: [memidx] }.

free_elemidx elemidx
1. Return { ELEMS: [elemidx] }.

free_dataidx dataidx
1. Return { DATAS: [dataidx] }.

free_localidx localidx
1. Return { LOCALS: [localidx] }.

free_labelidx labelidx
1. Return { LABELS: [labelidx] }.

free_externidx externidx
1. If externidx is some FUNC, then:
  a. Let (FUNC funcidx) be externidx.
  b. Return $free_funcidx(funcidx).
2. If externidx is some GLOBAL, then:
  a. Let (GLOBAL globalidx) be externidx.
  b. Return $free_globalidx(globalidx).
3. If externidx is some TABLE, then:
  a. Let (TABLE tableidx) be externidx.
  b. Return $free_tableidx(tableidx).
4. Assert: Due to validation, externidx is some MEM.
5. Let (MEM memidx) be externidx.
6. Return $free_memidx(memidx).

ANYREF
1. Return (REF ?(NULL) ANY).

EQREF
1. Return (REF ?(NULL) EQ).

I31REF
1. Return (REF ?(NULL) I31).

STRUCTREF
1. Return (REF ?(NULL) STRUCT).

ARRAYREF
1. Return (REF ?(NULL) ARRAY).

FUNCREF
1. Return (REF ?(NULL) FUNC).

EXNREF
1. Return (REF ?(NULL) EXN).

EXTERNREF
1. Return (REF ?(NULL) EXTERN).

NULLREF
1. Return (REF ?(NULL) NONE).

NULLFUNCREF
1. Return (REF ?(NULL) NOFUNC).

NULLEXNREF
1. Return (REF ?(NULL) NOEXN).

NULLEXTERNREF
1. Return (REF ?(NULL) NOEXTERN).

IN N
1. If (N = 32), then:
  a. Return I32.
2. Assert: Due to validation, (N = 64).
3. Return I64.

FN N
1. If (N = 32), then:
  a. Return F32.
2. Assert: Due to validation, (N = 64).
3. Return F64.

JN N
1. If (N = 8), then:
  a. Return I8.
2. If (N = 16), then:
  a. Return I16.
3. If (N = 32), then:
  a. Return I32.
4. Assert: Due to validation, (N = 64).
5. Return I64.

size numtype
1. If (numtype = I32), then:
  a. Return 32.
2. If (numtype = I64), then:
  a. Return 64.
3. If (numtype = F32), then:
  a. Return 32.
4. Assert: Due to validation, (numtype = F64).
5. Return 64.

vsize V128
1. Return 128.

psize packtype
1. If (packtype = I8), then:
  a. Return 8.
2. Assert: Due to validation, (packtype = I16).
3. Return 16.

lsize lanetype
1. If lanetype is numtype, then:
  a. Return $size(lanetype).
2. Assert: Due to validation, lanetype is packtype.
3. Return $psize(lanetype).

zsize storagetype
1. If storagetype is numtype, then:
  a. Return $size(storagetype).
2. If storagetype is vectype, then:
  a. Return $vsize(storagetype).
3. Assert: Due to validation, storagetype is packtype.
4. Return $psize(storagetype).

isize Inn
1. Return $size(Inn).

jsize Jnn
1. Return $lsize(Jnn).

fsize Fnn
1. Return $size(Fnn).

inv_isize n
1. If (n = 32), then:
  a. Return I32.
2. If (n = 64), then:
  a. Return I64.
3. Fail.

inv_jsize n
1. If (n = 8), then:
  a. Return I8.
2. If (n = 16), then:
  a. Return I16.
3. Return $inv_isize(n).

inv_fsize n
1. If (n = 32), then:
  a. Return F32.
2. If (n = 64), then:
  a. Return F64.
3. Fail.

sizenn nt
1. Return $size(nt).

sizenn1 nt
1. Return $size(nt).

sizenn2 nt
1. Return $size(nt).

vsizenn vt
1. Return $vsize(vt).

psizenn pt
1. Return $psize(pt).

lsizenn lt
1. Return $lsize(lt).

lsizenn1 lt
1. Return $lsize(lt).

lsizenn2 lt
1. Return $lsize(lt).

jsizenn Jnn
1. Return $lsize(Jnn).

inv_jsizenn n
1. Return $inv_jsize(n).

lunpack lanetype
1. If lanetype is numtype, then:
  a. Return lanetype.
2. Assert: Due to validation, lanetype is packtype.
3. Return I32.

unpack storagetype
1. If storagetype is valtype, then:
  a. Return storagetype.
2. Assert: Due to validation, storagetype is packtype.
3. Return I32.

nunpack storagetype
1. If storagetype is numtype, then:
  a. Return storagetype.
2. If storagetype is packtype, then:
  a. Return I32.
3. Fail.

vunpack vectype
1. Return vectype.

cunpack storagetype
1. If storagetype is consttype, then:
  a. Return storagetype.
2. If storagetype is packtype, then:
  a. Return I32.
3. If storagetype is lanetype, then:
  a. Return $lunpack(storagetype).
4. Fail.

minat at_1 at_2
1. If ($size(at_1) <= $size(at_2)), then:
  a. Return at_1.
2. Return at_2.

diffrt (REF null_1? ht_1) (REF null? ht_2)
1. If (null? = ?(NULL)), then:
  a. Return (REF ?() ht_1).
2. Assert: Due to validation, null? is not defined.
3. Return (REF null_1? ht_1).

as_deftype dt
1. Return dt.

tagsxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some TAG, then:
  a. Let (TAG jt) be externtype_0.
  b. Return [jt] :: $tagsxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $tagsxt(xt*).

globalsxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some GLOBAL, then:
  a. Let (GLOBAL gt) be externtype_0.
  b. Return [gt] :: $globalsxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $globalsxt(xt*).

memsxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some MEM, then:
  a. Let (MEM mt) be externtype_0.
  b. Return [mt] :: $memsxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $memsxt(xt*).

tablesxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some TABLE, then:
  a. Let (TABLE tt) be externtype_0.
  b. Return [tt] :: $tablesxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $tablesxt(xt*).

funcsxt externtype'*
1. If (externtype'* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype'*.
3. If externtype_0 is some FUNC, then:
  a. Let (FUNC dt) be externtype_0.
  b. Return [dt] :: $funcsxt(xt*).
4. Let [externtype] :: xt* be externtype'*.
5. Return $funcsxt(xt*).

subst_typevar tv typevar* typeuse*
1. If (typeuse* = []), then:
  a. Assert: Due to validation, (typevar* = []).
  b. Return tv.
2. Else:
  a. Let [tu_1] :: tu'* be typeuse*.
  b. Assert: Due to validation, (|typevar*| >= 1).
  c. Let [tv_1] :: tv'* be typevar*.
  d. If (tv = tv_1), then:
    1) Return tu_1.
  e. Return $subst_typevar(tv, tv'*, tu'*).

minus_recs typevar* typeuse*
1. If (typevar* = []), then:
  a. If (typeuse* = []), then:
    1) Return ([], []).
2. Else:
  a. Let [typevar_0] :: tv* be typevar*.
  b. If (typevar_0 is some REC /\ (|typeuse*| >= 1)), then:
    1) Let [tu_1] :: tu* be typeuse*.
    2) Return $minus_recs(tv*, tu*).
3. Assert: Due to validation, (|typeuse*| >= 1).
4. Let [tu_1] :: tu* be typeuse*.
5. Assert: Due to validation, (|typevar*| >= 1).
6. Let [typevar_0] :: tv* be typevar*.
7. Assert: Due to validation, typevar_0 is some _IDX.
8. Let (_IDX x) be typevar_0.
9. Let (tv'*, tu'*) be $minus_recs(tv*, tu*).
10. Return ([(_IDX x)] :: tv'*, [tu_1] :: tu'*).

subst_packtype pt tv* tu*
1. Return pt.

subst_numtype nt tv* tu*
1. Return nt.

subst_vectype vt tv* tu*
1. Return vt.

subst_typeuse typeuse tv* tu*
1. If typeuse is typevar, then:
  a. Return $subst_typevar(typeuse, tv*, tu*).
2. Assert: Due to validation, typeuse is deftype.
3. Return $subst_deftype(typeuse, tv*, tu*).

subst_heaptype heaptype tv* tu*
1. If heaptype is typevar, then:
  a. Return $subst_typevar(heaptype, tv*, tu*).
2. If heaptype is deftype, then:
  a. Return $subst_deftype(heaptype, tv*, tu*).
3. Return heaptype.

subst_reftype (REF null? ht) tv* tu*
1. Return (REF null? $subst_heaptype(ht, tv*, tu*)).

subst_valtype valtype tv* tu*
1. If valtype is numtype, then:
  a. Return $subst_numtype(valtype, tv*, tu*).
2. If valtype is vectype, then:
  a. Return $subst_vectype(valtype, tv*, tu*).
3. If valtype is reftype, then:
  a. Return $subst_reftype(valtype, tv*, tu*).
4. Assert: Due to validation, (valtype = BOT).
5. Return BOT.

subst_storagetype storagetype tv* tu*
1. If storagetype is valtype, then:
  a. Return $subst_valtype(storagetype, tv*, tu*).
2. Assert: Due to validation, storagetype is packtype.
3. Return $subst_packtype(storagetype, tv*, tu*).

subst_fieldtype (mut? zt) tv* tu*
1. Return (mut? $subst_storagetype(zt, tv*, tu*)).

subst_comptype comptype tv* tu*
1. If comptype is some STRUCT, then:
  a. Let (STRUCT ft*) be comptype.
  b. Return (STRUCT $subst_fieldtype(ft, tv*, tu*)*).
2. If comptype is some ARRAY, then:
  a. Let (ARRAY ft) be comptype.
  b. Return (ARRAY $subst_fieldtype(ft, tv*, tu*)).
3. Assert: Due to validation, comptype is some FUNC.
4. Let (FUNC t_1* -> t_2*) be comptype.
5. Return (FUNC $subst_valtype(t_1, tv*, tu*)* -> $subst_valtype(t_2, tv*, tu*)*).

subst_subtype (SUB final? tu'* ct) tv* tu*
1. Return (SUB final? $subst_typeuse(tu', tv*, tu*)* $subst_comptype(ct, tv*, tu*)).

subst_rectype (REC st*) tv* tu*
1. Let (tv'*, tu'*) be $minus_recs(tv*, tu*).
2. Return (REC $subst_subtype(st, tv'*, tu'*)*).

subst_deftype (_DEF qt i) tv* tu*
1. Return (_DEF $subst_rectype(qt, tv*, tu*) i).

subst_addrtype at tv* tu*
1. Return at.

subst_tagtype tu' tv* tu*
1. Return $subst_typeuse(tu', tv*, tu*).

subst_globaltype (mut? t) tv* tu*
1. Return (mut? $subst_valtype(t, tv*, tu*)).

subst_memtype at lim PAGE tv* tu*
1. Return at lim PAGE.

subst_tabletype (at lim rt) tv* tu*
1. Return (at lim $subst_reftype(rt, tv*, tu*)).

subst_externtype externtype tv* tu*
1. If externtype is some TAG, then:
  a. Let (TAG jt) be externtype.
  b. Return (TAG $subst_tagtype(jt, tv*, tu*)).
2. If externtype is some GLOBAL, then:
  a. Let (GLOBAL gt) be externtype.
  b. Return (GLOBAL $subst_globaltype(gt, tv*, tu*)).
3. If externtype is some TABLE, then:
  a. Let (TABLE tt) be externtype.
  b. Return (TABLE $subst_tabletype(tt, tv*, tu*)).
4. If externtype is some MEM, then:
  a. Let (MEM mt) be externtype.
  b. Return (MEM $subst_memtype(mt, tv*, tu*)).
5. Assert: Due to validation, externtype is some FUNC.
6. Let (FUNC dt) be externtype.
7. Return (FUNC $subst_deftype(dt, tv*, tu*)).

subst_moduletype xt_1* -> xt_2* tv* tu*
1. Return $subst_externtype(xt_1, tv*, tu*)* -> $subst_externtype(xt_2, tv*, tu*)*.

subst_all_valtype t tu^n
1. Return $subst_valtype(t, (_IDX i)^(i<n), tu^n).

subst_all_reftype rt tu^n
1. Return $subst_reftype(rt, (_IDX i)^(i<n), tu^n).

subst_all_deftype dt tu^n
1. Return $subst_deftype(dt, (_IDX i)^(i<n), tu^n).

subst_all_tagtype jt tu^n
1. Return $subst_tagtype(jt, (_IDX i)^(i<n), tu^n).

subst_all_globaltype gt tu^n
1. Return $subst_globaltype(gt, (_IDX i)^(i<n), tu^n).

subst_all_memtype mt tu^n
1. Return $subst_memtype(mt, (_IDX i)^(i<n), tu^n).

subst_all_tabletype tt tu^n
1. Return $subst_tabletype(tt, (_IDX i)^(i<n), tu^n).

subst_all_externtype xt tu^n
1. Return $subst_externtype(xt, (_IDX i)^(i<n), tu^n).

subst_all_moduletype mmt tu^n
1. Return $subst_moduletype(mmt, (_IDX i)^(i<n), tu^n).

subst_all_deftypes deftype* tu*
1. If (deftype* = []), then:
  a. Return [].
2. Let [dt_1] :: dt* be deftype*.
3. Return [$subst_all_deftype(dt_1, tu*)] :: $subst_all_deftypes(dt*, tu*).

rollrt x rectype
1. Let (REC subtype^n) be rectype.
2. Return (REC $subst_subtype(subtype, (_IDX (x + i))^(i<n), (REC i)^(i<n))^n).

unrollrt rectype
1. Let (REC subtype^n) be rectype.
2. Return (REC $subst_subtype(subtype, (REC i)^(i<n), (_DEF rectype i)^(i<n))^n).

rolldt x rectype
1. Let (REC subtype^n) be $rollrt(x, rectype).
2. Return (_DEF (REC subtype^n) i)^(i<n).

unrolldt (_DEF rectype i)
1. Let (REC subtype*) be $unrollrt(rectype).
2. Return subtype*[i].

expanddt deftype
1. Let (SUB final? typeuse* comptype) be $unrolldt(deftype).
2. Return comptype.

free_addrtype addrtype
1. Return {}.

free_numtype numtype
1. Return {}.

free_packtype packtype
1. Return {}.

free_lanetype lanetype
1. If lanetype is numtype, then:
  a. Return $free_numtype(lanetype).
2. Assert: Due to validation, lanetype is packtype.
3. Return $free_packtype(lanetype).

free_vectype vectype
1. Return {}.

free_consttype consttype
1. If consttype is numtype, then:
  a. Return $free_numtype(consttype).
2. Assert: Due to validation, consttype is vectype.
3. Return $free_vectype(consttype).

free_absheaptype absheaptype
1. Return {}.

free_typevar typevar
1. If typevar is some _IDX, then:
  a. Let (_IDX typeidx) be typevar.
  b. Return $free_typeidx(typeidx).
2. Assert: Due to validation, typevar is some REC.
3. Return {}.

free_heaptype heaptype
1. If heaptype is absheaptype, then:
  a. Return $free_absheaptype(heaptype).
2. Assert: Due to validation, heaptype is typeuse.
3. Return $free_typeuse(heaptype).

free_reftype (REF null? heaptype)
1. Return $free_heaptype(heaptype).

free_typeuse typeuse
1. If typeuse is typevar, then:
  a. Return $free_typevar(typeuse).
2. Assert: Due to validation, typeuse is deftype.
3. Return $free_deftype(typeuse).

free_valtype valtype
1. If valtype is numtype, then:
  a. Return $free_numtype(valtype).
2. If valtype is vectype, then:
  a. Return $free_vectype(valtype).
3. If valtype is reftype, then:
  a. Return $free_reftype(valtype).
4. Assert: Due to validation, (valtype = BOT).
5. Return {}.

free_resulttype valtype*
1. Return $free_list($free_valtype(valtype)*).

free_storagetype storagetype
1. If storagetype is valtype, then:
  a. Return $free_valtype(storagetype).
2. Assert: Due to validation, storagetype is packtype.
3. Return $free_packtype(storagetype).

free_fieldtype (mut? storagetype)
1. Return $free_storagetype(storagetype).

free_comptype comptype
1. If comptype is some STRUCT, then:
  a. Let (STRUCT fieldtype*) be comptype.
  b. Return $free_list($free_fieldtype(fieldtype)*).
2. If comptype is some ARRAY, then:
  a. Let (ARRAY fieldtype) be comptype.
  b. Return $free_fieldtype(fieldtype).
3. Assert: Due to validation, comptype is some FUNC.
4. Let (FUNC resulttype_1 -> resulttype_2) be comptype.
5. Return $free_resulttype(resulttype_1) ++ $free_resulttype(resulttype_2).

free_subtype (SUB final? typeuse* comptype)
1. Return $free_list($free_typeuse(typeuse)*) ++ $free_comptype(comptype).

free_rectype (REC subtype*)
1. Return $free_list($free_subtype(subtype)*).

free_deftype (_DEF rectype n)
1. Return $free_rectype(rectype).

free_tagtype deftype
1. Return $free_deftype(deftype).

free_globaltype (mut? valtype)
1. Return $free_valtype(valtype).

free_memtype addrtype limits PAGE
1. Return $free_addrtype(addrtype).

free_tabletype (addrtype limits reftype)
1. Return $free_addrtype(addrtype) ++ $free_reftype(reftype).

free_datatype OK
1. Return {}.

free_elemtype reftype
1. Return $free_reftype(reftype).

free_externtype externtype
1. If externtype is some TAG, then:
  a. Let (TAG tagtype) be externtype.
  b. Return $free_tagtype(tagtype).
2. If externtype is some GLOBAL, then:
  a. Let (GLOBAL globaltype) be externtype.
  b. Return $free_globaltype(globaltype).
3. If externtype is some MEM, then:
  a. Let (MEM memtype) be externtype.
  b. Return $free_memtype(memtype).
4. If externtype is some TABLE, then:
  a. Let (TABLE tabletype) be externtype.
  b. Return $free_tabletype(tabletype).
5. Assert: Due to validation, externtype is some FUNC.
6. Let (FUNC typeuse) be externtype.
7. Return $free_typeuse(typeuse).

free_moduletype externtype_1* -> externtype_2*
1. Return $free_list($free_externtype(externtype_1)*) ++ $free_list($free_externtype(externtype_2)*).

dim Lnn X N
1. Return N.

lanetype Lnn X N
1. Return Lnn.

unpackshape Lnn X N
1. Return $lunpack(Lnn).

memarg0
1. Return { ALIGN: 0; OFFSET: 0 }.

const consttype c
1. If consttype is numtype, then:
  a. Return (consttype.CONST c).
2. Assert: Due to validation, consttype is vectype.
3. Return (consttype.CONST c).

free_shape lanetype X dim
1. Return $free_lanetype(lanetype).

free_blocktype blocktype
1. If blocktype is some _RESULT, then:
  a. Let (_RESULT valtype?) be blocktype.
  b. Return $free_opt($free_valtype(valtype)?).
2. Assert: Due to validation, blocktype is some _IDX.
3. Let (_IDX funcidx) be blocktype.
4. Return $free_funcidx(funcidx).

shift_labelidxs labelidx''*
1. If (labelidx''* = []), then:
  a. Return [].
2. Let [labelidx_0] :: labelidx'* be labelidx''*.
3. If (labelidx_0 = 0), then:
  a. Return $shift_labelidxs(labelidx'*).
4. Let [labelidx] :: labelidx'* be labelidx''*.
5. Return [(labelidx - 1)] :: $shift_labelidxs(labelidx'*).

free_instr instr'
1. If (instr' = NOP), then:
  a. Return {}.
2. If (instr' = UNREACHABLE), then:
  a. Return {}.
3. If (instr' = DROP), then:
  a. Return {}.
4. If instr' is some SELECT, then:
  a. Let (SELECT valtype*?) be instr'.
  b. Return $free_opt($free_list($free_valtype(valtype)*)?).
5. If instr' is some BLOCK, then:
  a. Let (BLOCK blocktype instr*) be instr'.
  b. Return $free_blocktype(blocktype) ++ $free_block(instr*).
6. If instr' is some LOOP, then:
  a. Let (LOOP blocktype instr*) be instr'.
  b. Return $free_blocktype(blocktype) ++ $free_block(instr*).
7. If instr' is some IF, then:
  a. Let (IF blocktype instr_1* ELSE instr_2*) be instr'.
  b. Return $free_blocktype(blocktype) ++ $free_block(instr_1*) ++ $free_block(instr_2*).
8. If instr' is some BR, then:
  a. Let (BR labelidx) be instr'.
  b. Return $free_labelidx(labelidx).
9. If instr' is some BR_IF, then:
  a. Let (BR_IF labelidx) be instr'.
  b. Return $free_labelidx(labelidx).
10. If instr' is some BR_TABLE, then:
  a. Let (BR_TABLE labelidx* labelidx'') be instr'.
  b. Return $free_list($free_labelidx(labelidx)*) ++ $free_labelidx(labelidx'').
11. If instr' is some BR_ON_NULL, then:
  a. Let (BR_ON_NULL labelidx) be instr'.
  b. Return $free_labelidx(labelidx).
12. If instr' is some BR_ON_NON_NULL, then:
  a. Let (BR_ON_NON_NULL labelidx) be instr'.
  b. Return $free_labelidx(labelidx).
13. If instr' is some BR_ON_CAST, then:
  a. Let (BR_ON_CAST labelidx reftype_1 reftype_2) be instr'.
  b. Return $free_labelidx(labelidx) ++ $free_reftype(reftype_1) ++ $free_reftype(reftype_2).
14. If instr' is some BR_ON_CAST_FAIL, then:
  a. Let (BR_ON_CAST_FAIL labelidx reftype_1 reftype_2) be instr'.
  b. Return $free_labelidx(labelidx) ++ $free_reftype(reftype_1) ++ $free_reftype(reftype_2).
15. If instr' is some CALL, then:
  a. Let (CALL funcidx) be instr'.
  b. Return $free_funcidx(funcidx).
16. If instr' is some CALL_REF, then:
  a. Let (CALL_REF typeuse) be instr'.
  b. Return $free_typeuse(typeuse).
17. If instr' is some CALL_INDIRECT, then:
  a. Let (CALL_INDIRECT tableidx typeuse) be instr'.
  b. Return $free_tableidx(tableidx) ++ $free_typeuse(typeuse).
18. If (instr' = RETURN), then:
  a. Return {}.
19. If instr' is some RETURN_CALL, then:
  a. Let (RETURN_CALL funcidx) be instr'.
  b. Return $free_funcidx(funcidx).
20. If instr' is some RETURN_CALL_REF, then:
  a. Let (RETURN_CALL_REF typeuse) be instr'.
  b. Return $free_typeuse(typeuse).
21. If instr' is some RETURN_CALL_INDIRECT, then:
  a. Let (RETURN_CALL_INDIRECT tableidx typeuse) be instr'.
  b. Return $free_tableidx(tableidx) ++ $free_typeuse(typeuse).
22. If instr' is some CONST, then:
  a. Let (numtype.CONST numlit) be instr'.
  b. Return $free_numtype(numtype).
23. If instr' is some UNOP, then:
  a. Let (UNOP numtype unop) be instr'.
  b. Return $free_numtype(numtype).
24. If instr' is some BINOP, then:
  a. Let (BINOP numtype binop) be instr'.
  b. Return $free_numtype(numtype).
25. If instr' is some TESTOP, then:
  a. Let (TESTOP numtype testop) be instr'.
  b. Return $free_numtype(numtype).
26. If instr' is some RELOP, then:
  a. Let (RELOP numtype relop) be instr'.
  b. Return $free_numtype(numtype).
27. If instr' is some CVTOP, then:
  a. Let (CVTOP numtype_1 numtype_2 cvtop) be instr'.
  b. Return $free_numtype(numtype_1) ++ $free_numtype(numtype_2).
28. If instr' is some VCONST, then:
  a. Let (vectype.CONST veclit) be instr'.
  b. Return $free_vectype(vectype).
29. If instr' is some VVUNOP, then:
  a. Let (VVUNOP vectype vvunop) be instr'.
  b. Return $free_vectype(vectype).
30. If instr' is some VVBINOP, then:
  a. Let (VVBINOP vectype vvbinop) be instr'.
  b. Return $free_vectype(vectype).
31. If instr' is some VVTERNOP, then:
  a. Let (VVTERNOP vectype vvternop) be instr'.
  b. Return $free_vectype(vectype).
32. If instr' is some VVTESTOP, then:
  a. Let (VVTESTOP vectype vvtestop) be instr'.
  b. Return $free_vectype(vectype).
33. If instr' is some VUNOP, then:
  a. Let (VUNOP shape vunop) be instr'.
  b. Return $free_shape(shape).
34. If instr' is some VBINOP, then:
  a. Let (VBINOP shape vbinop) be instr'.
  b. Return $free_shape(shape).
35. If instr' is some VTERNOP, then:
  a. Let (VTERNOP shape vternop) be instr'.
  b. Return $free_shape(shape).
36. If instr' is some VTESTOP, then:
  a. Let (VTESTOP shape vtestop) be instr'.
  b. Return $free_shape(shape).
37. If instr' is some VRELOP, then:
  a. Let (VRELOP shape vrelop) be instr'.
  b. Return $free_shape(shape).
38. If instr' is some VSHIFTOP, then:
  a. Let (VSHIFTOP ishape vshiftop) be instr'.
  b. Return $free_shape(ishape).
39. If instr' is some VBITMASK, then:
  a. Let (VBITMASK ishape) be instr'.
  b. Return $free_shape(ishape).
40. If instr' is some VSWIZZLOP, then:
  a. Let (VSWIZZLOP bshape vswizzlop) be instr'.
  b. Return $free_shape(bshape).
41. If instr' is some VSHUFFLE, then:
  a. Let (VSHUFFLE bshape laneidx*) be instr'.
  b. Return $free_shape(bshape).
42. If instr' is some VEXTUNOP, then:
  a. Let (VEXTUNOP ishape_1 ishape_2 vextunop) be instr'.
  b. Return $free_shape(ishape_1) ++ $free_shape(ishape_2).
43. If instr' is some VEXTBINOP, then:
  a. Let (VEXTBINOP ishape_1 ishape_2 vextbinop) be instr'.
  b. Return $free_shape(ishape_1) ++ $free_shape(ishape_2).
44. If instr' is some VEXTTERNOP, then:
  a. Let (VEXTTERNOP ishape_1 ishape_2 vextternop) be instr'.
  b. Return $free_shape(ishape_1) ++ $free_shape(ishape_2).
45. If instr' is some VNARROW, then:
  a. Let (VNARROW ishape_1 ishape_2 sx) be instr'.
  b. Return $free_shape(ishape_1) ++ $free_shape(ishape_2).
46. If instr' is some VCVTOP, then:
  a. Let (VCVTOP shape_1 shape_2 vcvtop) be instr'.
  b. Return $free_shape(shape_1) ++ $free_shape(shape_2).
47. If instr' is some VSPLAT, then:
  a. Let (VSPLAT shape) be instr'.
  b. Return $free_shape(shape).
48. If instr' is some VEXTRACT_LANE, then:
  a. Let (VEXTRACT_LANE shape sx? laneidx) be instr'.
  b. Return $free_shape(shape).
49. If instr' is some VREPLACE_LANE, then:
  a. Let (VREPLACE_LANE shape laneidx) be instr'.
  b. Return $free_shape(shape).
50. If instr' is some REF.NULL, then:
  a. Let (REF.NULL heaptype) be instr'.
  b. Return $free_heaptype(heaptype).
51. If (instr' = REF.IS_NULL), then:
  a. Return {}.
52. If (instr' = REF.AS_NON_NULL), then:
  a. Return {}.
53. If (instr' = REF.EQ), then:
  a. Return {}.
54. If instr' is some REF.TEST, then:
  a. Let (REF.TEST reftype) be instr'.
  b. Return $free_reftype(reftype).
55. If instr' is some REF.CAST, then:
  a. Let (REF.CAST reftype) be instr'.
  b. Return $free_reftype(reftype).
56. If instr' is some REF.FUNC, then:
  a. Let (REF.FUNC funcidx) be instr'.
  b. Return $free_funcidx(funcidx).
57. If (instr' = REF.I31), then:
  a. Return {}.
58. If instr' is some I31.GET, then:
  a. Return {}.
59. If instr' is some STRUCT.NEW, then:
  a. Return {}.
60. If instr' is some STRUCT.NEW_DEFAULT, then:
  a. Let (STRUCT.NEW_DEFAULT typeidx) be instr'.
  b. Return $free_typeidx(typeidx).
61. If instr' is some STRUCT.GET, then:
  a. Let (STRUCT.GET sx? typeidx u32) be instr'.
  b. Return $free_typeidx(typeidx).
62. If instr' is some STRUCT.SET, then:
  a. Let (STRUCT.SET typeidx u32) be instr'.
  b. Return $free_typeidx(typeidx).
63. If instr' is some ARRAY.NEW, then:
  a. Let (ARRAY.NEW typeidx) be instr'.
  b. Return $free_typeidx(typeidx).
64. If instr' is some ARRAY.NEW_DEFAULT, then:
  a. Let (ARRAY.NEW_DEFAULT typeidx) be instr'.
  b. Return $free_typeidx(typeidx).
65. If instr' is some ARRAY.NEW_FIXED, then:
  a. Let (ARRAY.NEW_FIXED typeidx u32) be instr'.
  b. Return $free_typeidx(typeidx).
66. If instr' is some ARRAY.NEW_DATA, then:
  a. Let (ARRAY.NEW_DATA typeidx dataidx) be instr'.
  b. Return $free_typeidx(typeidx) ++ $free_dataidx(dataidx).
67. If instr' is some ARRAY.NEW_ELEM, then:
  a. Let (ARRAY.NEW_ELEM typeidx elemidx) be instr'.
  b. Return $free_typeidx(typeidx) ++ $free_elemidx(elemidx).
68. If instr' is some ARRAY.GET, then:
  a. Let (ARRAY.GET sx? typeidx) be instr'.
  b. Return $free_typeidx(typeidx).
69. If instr' is some ARRAY.SET, then:
  a. Let (ARRAY.SET typeidx) be instr'.
  b. Return $free_typeidx(typeidx).
70. If (instr' = ARRAY.LEN), then:
  a. Return {}.
71. If instr' is some ARRAY.FILL, then:
  a. Let (ARRAY.FILL typeidx) be instr'.
  b. Return $free_typeidx(typeidx).
72. If instr' is some ARRAY.COPY, then:
  a. Let (ARRAY.COPY typeidx_1 typeidx_2) be instr'.
  b. Return $free_typeidx(typeidx_1) ++ $free_typeidx(typeidx_2).
73. If instr' is some ARRAY.INIT_DATA, then:
  a. Let (ARRAY.INIT_DATA typeidx dataidx) be instr'.
  b. Return $free_typeidx(typeidx) ++ $free_dataidx(dataidx).
74. If instr' is some ARRAY.INIT_ELEM, then:
  a. Let (ARRAY.INIT_ELEM typeidx elemidx) be instr'.
  b. Return $free_typeidx(typeidx) ++ $free_elemidx(elemidx).
75. If (instr' = EXTERN.CONVERT_ANY), then:
  a. Return {}.
76. If (instr' = ANY.CONVERT_EXTERN), then:
  a. Return {}.
77. If instr' is some LOCAL.GET, then:
  a. Let (LOCAL.GET localidx) be instr'.
  b. Return $free_localidx(localidx).
78. If instr' is some LOCAL.SET, then:
  a. Let (LOCAL.SET localidx) be instr'.
  b. Return $free_localidx(localidx).
79. If instr' is some LOCAL.TEE, then:
  a. Let (LOCAL.TEE localidx) be instr'.
  b. Return $free_localidx(localidx).
80. If instr' is some GLOBAL.GET, then:
  a. Let (GLOBAL.GET globalidx) be instr'.
  b. Return $free_globalidx(globalidx).
81. If instr' is some GLOBAL.SET, then:
  a. Let (GLOBAL.SET globalidx) be instr'.
  b. Return $free_globalidx(globalidx).
82. If instr' is some TABLE.GET, then:
  a. Let (TABLE.GET tableidx) be instr'.
  b. Return $free_tableidx(tableidx).
83. If instr' is some TABLE.SET, then:
  a. Let (TABLE.SET tableidx) be instr'.
  b. Return $free_tableidx(tableidx).
84. If instr' is some TABLE.SIZE, then:
  a. Let (TABLE.SIZE tableidx) be instr'.
  b. Return $free_tableidx(tableidx).
85. If instr' is some TABLE.GROW, then:
  a. Let (TABLE.GROW tableidx) be instr'.
  b. Return $free_tableidx(tableidx).
86. If instr' is some TABLE.FILL, then:
  a. Let (TABLE.FILL tableidx) be instr'.
  b. Return $free_tableidx(tableidx).
87. If instr' is some TABLE.COPY, then:
  a. Let (TABLE.COPY tableidx_1 tableidx_2) be instr'.
  b. Return $free_tableidx(tableidx_1) ++ $free_tableidx(tableidx_2).
88. If instr' is some TABLE.INIT, then:
  a. Let (TABLE.INIT tableidx elemidx) be instr'.
  b. Return $free_tableidx(tableidx) ++ $free_elemidx(elemidx).
89. If instr' is some ELEM.DROP, then:
  a. Let (ELEM.DROP elemidx) be instr'.
  b. Return $free_elemidx(elemidx).
90. If instr' is some LOAD, then:
  a. Let (LOAD numtype loadop? memidx memarg) be instr'.
  b. Return $free_numtype(numtype) ++ $free_memidx(memidx).
91. If instr' is some STORE, then:
  a. Let (STORE numtype storeop? memidx memarg) be instr'.
  b. Return $free_numtype(numtype) ++ $free_memidx(memidx).
92. If instr' is some VLOAD, then:
  a. Let (VLOAD vectype vloadop? memidx memarg) be instr'.
  b. Return $free_vectype(vectype) ++ $free_memidx(memidx).
93. If instr' is some VLOAD_LANE, then:
  a. Let (VLOAD_LANE vectype sz memidx memarg laneidx) be instr'.
  b. Return $free_vectype(vectype) ++ $free_memidx(memidx).
94. If instr' is some VSTORE, then:
  a. Let (VSTORE vectype memidx memarg) be instr'.
  b. Return $free_vectype(vectype) ++ $free_memidx(memidx).
95. If instr' is some VSTORE_LANE, then:
  a. Let (VSTORE_LANE vectype sz memidx memarg laneidx) be instr'.
  b. Return $free_vectype(vectype) ++ $free_memidx(memidx).
96. If instr' is some MEMORY.SIZE, then:
  a. Let (MEMORY.SIZE memidx) be instr'.
  b. Return $free_memidx(memidx).
97. If instr' is some MEMORY.GROW, then:
  a. Let (MEMORY.GROW memidx) be instr'.
  b. Return $free_memidx(memidx).
98. If instr' is some MEMORY.FILL, then:
  a. Let (MEMORY.FILL memidx) be instr'.
  b. Return $free_memidx(memidx).
99. If instr' is some MEMORY.COPY, then:
  a. Let (MEMORY.COPY memidx_1 memidx_2) be instr'.
  b. Return $free_memidx(memidx_1) ++ $free_memidx(memidx_2).
100. If instr' is some MEMORY.INIT, then:
  a. Let (MEMORY.INIT memidx dataidx) be instr'.
  b. Return $free_memidx(memidx) ++ $free_dataidx(dataidx).
101. Assert: Due to validation, instr' is some DATA.DROP.
102. Let (DATA.DROP dataidx) be instr'.
103. Return $free_dataidx(dataidx).

free_block instr*
1. Let free be $free_list($free_instr(instr)*).
2. Return free with .LABELS replaced by $shift_labelidxs(free.LABELS).

free_expr instr*
1. Return $free_list($free_instr(instr)*).

free_type (TYPE rectype)
1. Return $free_rectype(rectype).

free_tag (TAG tagtype)
1. Return $free_tagtype(tagtype).

free_global (GLOBAL globaltype expr)
1. Return $free_globaltype(globaltype) ++ $free_expr(expr).

free_mem (MEMORY memtype)
1. Return $free_memtype(memtype).

free_table (TABLE tabletype expr)
1. Return $free_tabletype(tabletype) ++ $free_expr(expr).

free_local (LOCAL t)
1. Return $free_valtype(t).

free_func (FUNC typeidx local* expr)
1. Return $free_typeidx(typeidx) ++ $free_list($free_local(local)*) ++ $free_block(expr) with .LOCALS replaced by [].

free_datamode datamode
1. If datamode is some ACTIVE, then:
  a. Let (ACTIVE memidx expr) be datamode.
  b. Return $free_memidx(memidx) ++ $free_expr(expr).
2. Assert: Due to validation, (datamode = PASSIVE).
3. Return {}.

free_data (DATA byte* datamode)
1. Return $free_datamode(datamode).

free_elemmode elemmode
1. If elemmode is some ACTIVE, then:
  a. Let (ACTIVE tableidx expr) be elemmode.
  b. Return $free_tableidx(tableidx) ++ $free_expr(expr).
2. If (elemmode = PASSIVE), then:
  a. Return {}.
3. Assert: Due to validation, (elemmode = DECLARE).
4. Return {}.

free_elem (ELEM reftype expr* elemmode)
1. Return $free_reftype(reftype) ++ $free_list($free_expr(expr)*) ++ $free_elemmode(elemmode).

free_start (START funcidx)
1. Return $free_funcidx(funcidx).

free_import (IMPORT name_1 name_2 externtype)
1. Return $free_externtype(externtype).

free_export (EXPORT name externidx)
1. Return $free_externidx(externidx).

free_module (MODULE type* import* tag* global* mem* table* func* data* elem* start? export*)
1. Return $free_list($free_type(type)*) ++ $free_list($free_tag(tag)*) ++ $free_list($free_global(global)*) ++ $free_list($free_mem(mem)*) ++ $free_list($free_table(table)*) ++ $free_list($free_func(func)*) ++ $free_list($free_data(data)*) ++ $free_list($free_elem(elem)*) ++ $free_opt($free_start(start)?) ++ $free_list($free_import(import)*) ++ $free_list($free_export(export)*).

funcidx_module module
1. Return $free_module(module).FUNCS.

dataidx_funcs func*
1. Return $free_list($free_func(func)*).DATAS.

with_locals C localidx* localtype*
1. If (localtype* = []), then:
  a. Assert: Due to validation, (localidx* = []).
  b. Return C.
2. Else:
  a. Let [lct_1] :: lct* be localtype*.
  b. Assert: Due to validation, (|localidx*| >= 1).
  c. Let [x_1] :: x* be localidx*.
  d. Return $with_locals(C with .LOCALS[x_1] replaced by lct_1, x*, lct*).

clos_deftypes deftype*
1. If (deftype* = []), then:
  a. Return [].
2. Let dt* :: [dt_n] be deftype*.
3. Let dt'* be $clos_deftypes(dt*).
4. Return dt'* :: [$subst_all_deftype(dt_n, dt'*)].

clos_valtype C t
1. Let dt* be $clos_deftypes(C.TYPES).
2. Return $subst_all_valtype(t, dt*).

clos_deftype C dt
1. Let dt'* be $clos_deftypes(C.TYPES).
2. Return $subst_all_deftype(dt, dt'*).

clos_tagtype C jt
1. Let dt* be $clos_deftypes(C.TYPES).
2. Return $subst_all_tagtype(jt, dt*).

clos_externtype C xt
1. Let dt* be $clos_deftypes(C.TYPES).
2. Return $subst_all_externtype(xt, dt*).

clos_moduletype C mmt
1. Let dt* be $clos_deftypes(C.TYPES).
2. Return $subst_all_moduletype(mmt, dt*).

before typeuse x i
1. If typeuse is deftype, then:
  a. Return true.
2. If typeuse is some _IDX, then:
  a. Let (_IDX typeidx) be typeuse.
  b. Return (typeidx < x).
3. Assert: Due to validation, typeuse is some REC.
4. Let (REC j) be typeuse.
5. Return (j < i).

unrollht C heaptype
1. If heaptype is deftype, then:
  a. Return $unrolldt(heaptype).
2. If heaptype is some _IDX, then:
  a. Let (_IDX typeidx) be heaptype.
  b. Return $unrolldt(C.TYPES[typeidx]).
3. Assert: Due to validation, heaptype is some REC.
4. Let (REC i) be heaptype.
5. Return C.RECS[i].

default_ valtype
1. If valtype is Inn, then:
  a. Return ?((valtype.CONST 0)).
2. If valtype is Fnn, then:
  a. Return ?((valtype.CONST $fzero($size(valtype)))).
3. If valtype is Vnn, then:
  a. Return ?((valtype.CONST 0)).
4. Assert: Due to validation, valtype is some REF.
5. Let (REF NULL_0? ht) be valtype.
6. If (NULL_0? = ?(NULL)), then:
  a. Return ?((REF.NULL ht)).
7. Assert: Due to validation, NULL_0? is not defined.
8. Return ?().

is_packtype zt
1. Return (zt = $unpack(zt)).

funcidx_nonfuncs (global* mem* table* elem*)
1. Return $funcidx_module((MODULE [] [] [] global* mem* table* [] [] elem* ?() [])).

relaxed2 i `X X_1 X_2
1. If $ND(), then:
  a. Return [X_1, X_2][i].
2. Return [X_1, X_2][0].

relaxed4 i `X X_1 X_2 X_3 X_4
1. If $ND(), then:
  a. Return [X_1, X_2, X_3, X_4][i].
2. Return [X_1, X_2, X_3, X_4][0].

signed_ N i
1. If (i < (2 ^ (N - 1))), then:
  a. Return i.
2. Assert: Due to validation, ((2 ^ (N - 1)) <= i).
3. Assert: Due to validation, (i < (2 ^ N)).
4. Return (i - (2 ^ N)).

inv_signed_ N i
1. If ((0 <= i) /\ (i < (2 ^ (N - 1)))), then:
  a. Return i.
2. Assert: Due to validation, ((- (2 ^ (N - 1))) <= i).
3. Assert: Due to validation, (i < 0).
4. Return (i + (2 ^ N)).

sx storagetype
1. If storagetype is consttype, then:
  a. Return ?().
2. Assert: Due to validation, storagetype is packtype.
3. Return ?(S).

zero lanetype
1. If lanetype is Jnn, then:
  a. Return 0.
2. Assert: Due to validation, lanetype is Fnn.
3. Return $fzero($size(lanetype)).

bool b
1. If (b = false), then:
  a. Return 0.
2. Assert: Due to validation, (b = true).
3. Return 1.

sat_u_ N i
1. If (i < 0), then:
  a. Return 0.
2. If (i > ((2 ^ N) - 1)), then:
  a. Return ((2 ^ N) - 1).
3. Return i.

sat_s_ N i
1. If (i < (- (2 ^ (N - 1)))), then:
  a. Return (- (2 ^ (N - 1))).
2. If (i > ((2 ^ (N - 1)) - 1)), then:
  a. Return ((2 ^ (N - 1)) - 1).
3. Return i.

ineg_ N i_1
1. Return (((2 ^ N) - i_1) \ (2 ^ N)).

iabs_ N i_1
1. If ($signed_(N, i_1) >= 0), then:
  a. Return i_1.
2. Return $ineg_(N, i_1).

iextend_ N M sx i
1. If (sx = U), then:
  a. Return (i \ (2 ^ M)).
2. Assert: Due to validation, (sx = S).
3. Return $inv_signed_(N, $signed_(M, (i \ (2 ^ M)))).

iadd_ N i_1 i_2
1. Return ((i_1 + i_2) \ (2 ^ N)).

isub_ N i_1 i_2
1. Return ((((2 ^ N) + i_1) - i_2) \ (2 ^ N)).

imul_ N i_1 i_2
1. Return ((i_1 * i_2) \ (2 ^ N)).

idiv_ N sx i_1 i_2
1. If (sx = U), then:
  a. If (i_2 = 0), then:
    1) Return ?().
  b. Return ?($truncz((i_1 / i_2))).
2. Assert: Due to validation, (sx = S).
3. If (i_2 = 0), then:
  a. Return ?().
4. If (($signed_(N, i_1) / $signed_(N, i_2)) = (2 ^ (N - 1))), then:
  a. Return ?().
5. Return ?($inv_signed_(N, $truncz(($signed_(N, i_1) / $signed_(N, i_2))))).

irem_ N sx i_1 i_2
1. If (sx = U), then:
  a. If (i_2 = 0), then:
    1) Return ?().
  b. Return ?((i_1 - (i_2 * $truncz((i_1 / i_2))))).
2. Assert: Due to validation, (sx = S).
3. If (i_2 = 0), then:
  a. Return ?().
4. Let j_1 be $signed_(N, i_1).
5. Let j_2 be $signed_(N, i_2).
6. Return ?($inv_signed_(N, (j_1 - (j_2 * $truncz((j_1 / j_2)))))).

imin_ N sx i_1 i_2
1. If (sx = U), then:
  a. If (i_1 <= i_2), then:
    1) Return i_1.
  b. Return i_2.
2. Assert: Due to validation, (sx = S).
3. If ($signed_(N, i_1) <= $signed_(N, i_2)), then:
  a. Return i_1.
4. Return i_2.

imax_ N sx i_1 i_2
1. If (sx = U), then:
  a. If (i_1 >= i_2), then:
    1) Return i_1.
  b. Return i_2.
2. Assert: Due to validation, (sx = S).
3. If ($signed_(N, i_1) >= $signed_(N, i_2)), then:
  a. Return i_1.
4. Return i_2.

iadd_sat_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $sat_u_(N, (i_1 + i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $inv_signed_(N, $sat_s_(N, ($signed_(N, i_1) + $signed_(N, i_2)))).

isub_sat_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $sat_u_(N, (i_1 - i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $inv_signed_(N, $sat_s_(N, ($signed_(N, i_1) - $signed_(N, i_2)))).

ieqz_ N i_1
1. Return $bool((i_1 = 0)).

inez_ N i_1
1. Return $bool((i_1 =/= 0)).

ieq_ N i_1 i_2
1. Return $bool((i_1 = i_2)).

ine_ N i_1 i_2
1. Return $bool((i_1 =/= i_2)).

ilt_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 < i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) < $signed_(N, i_2))).

igt_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 > i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) > $signed_(N, i_2))).

ile_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 <= i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) <= $signed_(N, i_2))).

ige_ N sx i_1 i_2
1. If (sx = U), then:
  a. Return $bool((i_1 >= i_2)).
2. Assert: Due to validation, (sx = S).
3. Return $bool(($signed_(N, i_1) >= $signed_(N, i_2))).

lpacknum_ lanetype c
1. If lanetype is numtype, then:
  a. Return c.
2. Assert: Due to validation, lanetype is packtype.
3. Return $wrap__($size($lunpack(lanetype)), $psize(lanetype), c).

cpacknum_ storagetype c
1. If storagetype is consttype, then:
  a. Return c.
2. Assert: Due to validation, storagetype is packtype.
3. Return $wrap__($size($lunpack(storagetype)), $psize(storagetype), c).

lunpacknum_ lanetype c
1. If lanetype is numtype, then:
  a. Return c.
2. Assert: Due to validation, lanetype is packtype.
3. Return $extend__($psize(lanetype), $size($lunpack(lanetype)), U, c).

cunpacknum_ storagetype c
1. If storagetype is consttype, then:
  a. Return c.
2. Assert: Due to validation, storagetype is packtype.
3. Return $extend__($psize(storagetype), $size($lunpack(storagetype)), U, c).

unop_ numtype unop_ i
1. If numtype is Inn, then:
  a. If (unop_ = CLZ), then:
    1) Return [$iclz_($sizenn(numtype), i)].
  b. If (unop_ = CTZ), then:
    1) Return [$ictz_($sizenn(numtype), i)].
  c. If (unop_ = POPCNT), then:
    1) Return [$ipopcnt_($sizenn(numtype), i)].
  d. Assert: Due to validation, unop_ is some EXTEND.
  e. Let (EXTEND M) be unop_.
  f. Return [$iextend_($sizenn(numtype), M, S, i)].
2. Assert: Due to validation, numtype is Fnn.
3. If (unop_ = ABS), then:
  a. Return $fabs_($sizenn(numtype), i).
4. If (unop_ = NEG), then:
  a. Return $fneg_($sizenn(numtype), i).
5. If (unop_ = SQRT), then:
  a. Return $fsqrt_($sizenn(numtype), i).
6. If (unop_ = CEIL), then:
  a. Return $fceil_($sizenn(numtype), i).
7. If (unop_ = FLOOR), then:
  a. Return $ffloor_($sizenn(numtype), i).
8. If (unop_ = TRUNC), then:
  a. Return $ftrunc_($sizenn(numtype), i).
9. Assert: Due to validation, (unop_ = NEAREST).
10. Return $fnearest_($sizenn(numtype), i).

binop_ numtype binop_ i_1 i_2
1. If numtype is Inn, then:
  a. If (binop_ = ADD), then:
    1) Return [$iadd_($sizenn(numtype), i_1, i_2)].
  b. If (binop_ = SUB), then:
    1) Return [$isub_($sizenn(numtype), i_1, i_2)].
  c. If (binop_ = MUL), then:
    1) Return [$imul_($sizenn(numtype), i_1, i_2)].
  d. If binop_ is some DIV, then:
    1) Let (DIV sx) be binop_.
    2) Return $idiv_($sizenn(numtype), sx, i_1, i_2).
  e. If binop_ is some REM, then:
    1) Let (REM sx) be binop_.
    2) Return $irem_($sizenn(numtype), sx, i_1, i_2).
  f. If (binop_ = AND), then:
    1) Return [$iand_($sizenn(numtype), i_1, i_2)].
  g. If (binop_ = OR), then:
    1) Return [$ior_($sizenn(numtype), i_1, i_2)].
  h. If (binop_ = XOR), then:
    1) Return [$ixor_($sizenn(numtype), i_1, i_2)].
  i. If (binop_ = SHL), then:
    1) Return [$ishl_($sizenn(numtype), i_1, i_2)].
  j. If binop_ is some SHR, then:
    1) Let (SHR sx) be binop_.
    2) Return [$ishr_($sizenn(numtype), sx, i_1, i_2)].
  k. If (binop_ = ROTL), then:
    1) Return [$irotl_($sizenn(numtype), i_1, i_2)].
  l. If (binop_ = ROTR), then:
    1) Return [$irotr_($sizenn(numtype), i_1, i_2)].
2. Assert: Due to validation, numtype is Fnn.
3. If (binop_ = ADD), then:
  a. Return $fadd_($sizenn(numtype), i_1, i_2).
4. If (binop_ = SUB), then:
  a. Return $fsub_($sizenn(numtype), i_1, i_2).
5. If (binop_ = MUL), then:
  a. Return $fmul_($sizenn(numtype), i_1, i_2).
6. If (binop_ = DIV), then:
  a. Return $fdiv_($sizenn(numtype), i_1, i_2).
7. If (binop_ = MIN), then:
  a. Return $fmin_($sizenn(numtype), i_1, i_2).
8. If (binop_ = MAX), then:
  a. Return $fmax_($sizenn(numtype), i_1, i_2).
9. Assert: Due to validation, (binop_ = COPYSIGN).
10. Return $fcopysign_($sizenn(numtype), i_1, i_2).

testop_ Inn EQZ i
1. Return $ieqz_($sizenn(Inn), i).

relop_ numtype relop_ i_1 i_2
1. If numtype is Inn, then:
  a. If (relop_ = EQ), then:
    1) Return $ieq_($sizenn(numtype), i_1, i_2).
  b. If (relop_ = NE), then:
    1) Return $ine_($sizenn(numtype), i_1, i_2).
  c. If relop_ is some LT, then:
    1) Let (LT sx) be relop_.
    2) Return $ilt_($sizenn(numtype), sx, i_1, i_2).
  d. If relop_ is some GT, then:
    1) Let (GT sx) be relop_.
    2) Return $igt_($sizenn(numtype), sx, i_1, i_2).
  e. If relop_ is some LE, then:
    1) Let (LE sx) be relop_.
    2) Return $ile_($sizenn(numtype), sx, i_1, i_2).
  f. If relop_ is some GE, then:
    1) Let (GE sx) be relop_.
    2) Return $ige_($sizenn(numtype), sx, i_1, i_2).
2. Assert: Due to validation, numtype is Fnn.
3. If (relop_ = EQ), then:
  a. Return $feq_($sizenn(numtype), i_1, i_2).
4. If (relop_ = NE), then:
  a. Return $fne_($sizenn(numtype), i_1, i_2).
5. If (relop_ = LT), then:
  a. Return $flt_($sizenn(numtype), i_1, i_2).
6. If (relop_ = GT), then:
  a. Return $fgt_($sizenn(numtype), i_1, i_2).
7. If (relop_ = LE), then:
  a. Return $fle_($sizenn(numtype), i_1, i_2).
8. Assert: Due to validation, (relop_ = GE).
9. Return $fge_($sizenn(numtype), i_1, i_2).

cvtop__ numtype numtype' cvtop__ i_1
1. If (numtype is Inn /\ numtype' is Inn), then:
  a. If cvtop__ is some EXTEND, then:
    1) Let (EXTEND sx) be cvtop__.
    2) Return [$extend__($sizenn1(numtype), $sizenn2(numtype'), sx, i_1)].
  b. If (cvtop__ = WRAP), then:
    1) Return [$wrap__($sizenn1(numtype), $sizenn2(numtype'), i_1)].
2. If (numtype is Fnn /\ numtype' is Inn), then:
  a. If cvtop__ is some TRUNC, then:
    1) Let (TRUNC sx) be cvtop__.
    2) Return $trunc__($sizenn1(numtype), $sizenn2(numtype'), sx, i_1).
  b. If cvtop__ is some TRUNC_SAT, then:
    1) Let (TRUNC_SAT sx) be cvtop__.
    2) Return $trunc_sat__($sizenn1(numtype), $sizenn2(numtype'), sx, i_1).
3. If (numtype is Inn /\ (numtype' is Fnn /\ cvtop__ is some CONVERT)), then:
  a. Let (CONVERT sx) be cvtop__.
  b. Return [$convert__($sizenn1(numtype), $sizenn2(numtype'), sx, i_1)].
4. If (numtype is Fnn /\ numtype' is Fnn), then:
  a. If (cvtop__ = PROMOTE), then:
    1) Return $promote__($sizenn1(numtype), $sizenn2(numtype'), i_1).
  b. If (cvtop__ = DEMOTE), then:
    1) Return $demote__($sizenn1(numtype), $sizenn2(numtype'), i_1).
5. If (numtype is Inn /\ (numtype' is Fnn /\ ((cvtop__ = REINTERPRET) /\ ($size(numtype) = $size(numtype'))))), then:
  a. Return [$reinterpret__(numtype, numtype', i_1)].
6. Assert: Due to validation, numtype is Fnn.
7. Assert: Due to validation, numtype' is Inn.
8. Assert: Due to validation, (cvtop__ = REINTERPRET).
9. Assert: Due to validation, ($size(numtype) = $size(numtype')).
10. Return [$reinterpret__(numtype, numtype', i_1)].

zeroop lanetype' X M_1 lanetype X M_2 vcvtop__
1. If lanetype' is Jnn, then:
  a. If (lanetype is Jnn /\ vcvtop__ is some EXTEND), then:
    1) Return ?().
  b. If (lanetype is Fnn /\ vcvtop__ is some CONVERT), then:
    1) Return ?().
2. Assert: Due to validation, lanetype' is Fnn.
3. If lanetype is Jnn, then:
  a. If vcvtop__ is some TRUNC_SAT, then:
    1) Let (TRUNC_SAT sx zero?) be vcvtop__.
    2) Return zero?.
  b. If vcvtop__ is some RELAXED_TRUNC, then:
    1) Let (RELAXED_TRUNC sx zero?) be vcvtop__.
    2) Return zero?.
4. Assert: Due to validation, lanetype is Fnn.
5. If vcvtop__ is some DEMOTE, then:
  a. Let (DEMOTE zero) be vcvtop__.
  b. Return ?(zero).
6. Assert: Due to validation, (vcvtop__ = PROMOTELOW).
7. Return ?().

halfop lanetype' X M_1 lanetype X M_2 vcvtop__
1. If lanetype' is Jnn, then:
  a. If (lanetype is Jnn /\ vcvtop__ is some EXTEND), then:
    1) Let (EXTEND half sx) be vcvtop__.
    2) Return ?(half).
  b. If (lanetype is Fnn /\ vcvtop__ is some CONVERT), then:
    1) Let (CONVERT half? sx) be vcvtop__.
    2) Return half?.
2. Assert: Due to validation, lanetype' is Fnn.
3. If lanetype is Jnn, then:
  a. If vcvtop__ is some TRUNC_SAT, then:
    1) Return ?().
  b. If vcvtop__ is some RELAXED_TRUNC, then:
    1) Return ?().
4. Assert: Due to validation, lanetype is Fnn.
5. If vcvtop__ is some DEMOTE, then:
  a. Return ?().
6. Assert: Due to validation, (vcvtop__ = PROMOTELOW).
7. Return ?(LOW).

half half i j
1. If (half = LOW), then:
  a. Return i.
2. Assert: Due to validation, (half = HIGH).
3. Return j.

iswizzle_lane_ N c* i
1. If (i < |c*|), then:
  a. Return c*[i].
2. Return 0.

irelaxed_swizzle_lane_ N c* i
1. If (i < |c*|), then:
  a. Return c*[i].
2. If ($signed_(N, i) < 0), then:
  a. Return 0.
3. Return $relaxed2($R_swizzle(), `iN(N), 0, c*[(i \ |c*|)]).

ivunop_ Jnn X M $f_ v_1
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c* be [].
3. For each c_1 in c_1*, do:
  a. Let c be $f_($lsizenn(Jnn), c_1).
  b. Append c to the c*.
4. Return [$inv_lanes_(Jnn X M, c*)].

fvunop_ Fnn X M $f_ v_1
1. Let c_1* be $lanes_(Fnn X M, v_1).
2. Let c** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $f_($sizenn(Fnn), c_1)*).
3. Return $inv_lanes_(Fnn X M, c*)*.

ivbinop_ Jnn X M $f_ v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be [].
4. For each c_1 in c_1* and c_2 in c_2*, do:
  a. Let c be $f_($lsizenn(Jnn), c_1, c_2).
  b. Append c to the c*.
5. Return [$inv_lanes_(Jnn X M, c*)].

ivbinopsx_ Jnn X M $f_ sx v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be [].
4. For each c_1 in c_1* and c_2 in c_2*, do:
  a. Let c be $f_($lsizenn(Jnn), sx, c_1, c_2).
  b. Append c to the c*.
5. Return [$inv_lanes_(Jnn X M, c*)].

ivbinopsxnd_ Jnn X M $f_ sx v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c** be $setproduct_(`lane_((Jnn : Jnn <: lanetype)), $f_($lsizenn(Jnn), sx, c_1, c_2)*).
4. Return $inv_lanes_(Jnn X M, c*)*.

fvbinop_ Fnn X M $f_ v_1 v_2
1. Let c_1* be $lanes_(Fnn X M, v_1).
2. Let c_2* be $lanes_(Fnn X M, v_2).
3. Let c** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $f_($sizenn(Fnn), c_1, c_2)*).
4. Return $inv_lanes_(Fnn X M, c*)*.

ivternopnd_ Jnn X M $f_ v_1 v_2 v_3
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c_3* be $lanes_(Jnn X M, v_3).
4. Let c** be $setproduct_(`lane_((Jnn : Jnn <: lanetype)), $f_($lsizenn(Jnn), c_1, c_2, c_3)*).
5. Return $inv_lanes_(Jnn X M, c*)*.

fvternop_ Fnn X M $f_ v_1 v_2 v_3
1. Let c_1* be $lanes_(Fnn X M, v_1).
2. Let c_2* be $lanes_(Fnn X M, v_2).
3. Let c_3* be $lanes_(Fnn X M, v_3).
4. Let c** be $setproduct_(`lane_((Fnn : Fnn <: lanetype)), $f_($sizenn(Fnn), c_1, c_2, c_3)*).
5. Return $inv_lanes_(Fnn X M, c*)*.

ivtestop_ Jnn X M $f_ v_1
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c* be [].
3. For each c_1 in c_1*, do:
  a. Let c be $f_($lsizenn(Jnn), c_1).
  b. Append c to the c*.
4. Return $prod(c*).

fvtestop_ Fnn X M $f_ v_1
1. Let c_1* be $lanes_(Fnn X M, v_1).
2. Let c* be [].
3. For each c_1 in c_1*, do:
  a. Let c be $f_($sizenn(Fnn), c_1).
  b. Append c to the c*.
4. Return $prod(c*).

ivrelop_ Jnn X M $f_ v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be [].
4. For each c_1 in c_1* and c_2 in c_2*, do:
  a. Let c be $extend__(1, $lsizenn(Jnn), S, $f_($lsizenn(Jnn), c_1, c_2)).
  b. Append c to the c*.
5. Return $inv_lanes_(Jnn X M, c*).

ivrelopsx_ Jnn X M $f_ sx v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be [].
4. For each c_1 in c_1* and c_2 in c_2*, do:
  a. Let c be $extend__(1, $lsizenn(Jnn), S, $f_($lsizenn(Jnn), sx, c_1, c_2)).
  b. Append c to the c*.
5. Return $inv_lanes_(Jnn X M, c*).

fvrelop_ Fnn X M $f_ v_1 v_2
1. Let c_1* be $lanes_(Fnn X M, v_1).
2. Let c_2* be $lanes_(Fnn X M, v_2).
3. Let Inn be $isize^-1($fsize(Fnn)).
4. Let c* be [].
5. For each c_1 in c_1* and c_2 in c_2*, do:
  a. Let c be $extend__(1, $sizenn(Fnn), S, $f_($sizenn(Fnn), c_1, c_2)).
  b. Append c to the c*.
6. Return $inv_lanes_(Inn X M, c*).

ivshiftop_ Jnn X M $f_ v_1 i
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c* be [].
3. For each c_1 in c_1*, do:
  a. Let c be $f_($lsizenn(Jnn), c_1, i).
  b. Append c to the c*.
4. Return $inv_lanes_(Jnn X M, c*).

ivshiftopsx_ Jnn X M $f_ sx v_1 i
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c* be [].
3. For each c_1 in c_1*, do:
  a. Let c be $f_($lsizenn(Jnn), sx, c_1, i).
  b. Append c to the c*.
4. Return $inv_lanes_(Jnn X M, c*).

ivbitmaskop_ Jnn X M v_1
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c be $ibits__1^-1(32, $ilt_($lsizenn(Jnn), S, c_1, 0)* :: 0^(32 - M)).
3. Return $irev_(32, c).

ivswizzlop_ Jnn X M $f_ v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be [].
4. For each c_2 in c_2*, do:
  a. Let c be $f_($lsizenn(Jnn), c_1*, c_2).
  b. Append c to the c*.
5. Return $inv_lanes_(Jnn X M, c*).

ivshufflop_ Jnn X M i* v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be [].
4. For each i in i*, do:
  a. Let c be c_1* :: c_2*[i].
  b. Append c to the c*.
5. Return $inv_lanes_(Jnn X M, c*).

vvunop_ Vnn NOT v
1. Return [$inot_($vsizenn(Vnn), v)].

vvbinop_ Vnn vvbinop v_1 v_2
1. If (vvbinop = AND), then:
  a. Return [$iand_($vsizenn(Vnn), v_1, v_2)].
2. If (vvbinop = ANDNOT), then:
  a. Return [$iandnot_($vsizenn(Vnn), v_1, v_2)].
3. If (vvbinop = OR), then:
  a. Return [$ior_($vsizenn(Vnn), v_1, v_2)].
4. Assert: Due to validation, (vvbinop = XOR).
5. Return [$ixor_($vsizenn(Vnn), v_1, v_2)].

vvternop_ Vnn BITSELECT v_1 v_2 v_3
1. Return [$ibitselect_($vsizenn(Vnn), v_1, v_2, v_3)].

vunop_ lanetype X M vunop_ v
1. If lanetype is Fnn, then:
  a. If (vunop_ = ABS), then:
    1) Return $fvunop_(lanetype X M, $fabs_, v).
  b. If (vunop_ = NEG), then:
    1) Return $fvunop_(lanetype X M, $fneg_, v).
  c. If (vunop_ = SQRT), then:
    1) Return $fvunop_(lanetype X M, $fsqrt_, v).
  d. If (vunop_ = CEIL), then:
    1) Return $fvunop_(lanetype X M, $fceil_, v).
  e. If (vunop_ = FLOOR), then:
    1) Return $fvunop_(lanetype X M, $ffloor_, v).
  f. If (vunop_ = TRUNC), then:
    1) Return $fvunop_(lanetype X M, $ftrunc_, v).
  g. If (vunop_ = NEAREST), then:
    1) Return $fvunop_(lanetype X M, $fnearest_, v).
2. Assert: Due to validation, lanetype is Jnn.
3. If (vunop_ = ABS), then:
  a. Return $ivunop_(lanetype X M, $iabs_, v).
4. If (vunop_ = NEG), then:
  a. Return $ivunop_(lanetype X M, $ineg_, v).
5. Assert: Due to validation, (vunop_ = POPCNT).
6. Return $ivunop_(lanetype X M, $ipopcnt_, v).

vbinop_ lanetype X M vbinop_ v_1 v_2
1. If lanetype is Jnn, then:
  a. If (vbinop_ = ADD), then:
    1) Return $ivbinop_(lanetype X M, $iadd_, v_1, v_2).
  b. If (vbinop_ = SUB), then:
    1) Return $ivbinop_(lanetype X M, $isub_, v_1, v_2).
  c. If (vbinop_ = MUL), then:
    1) Return $ivbinop_(lanetype X M, $imul_, v_1, v_2).
  d. If vbinop_ is some ADD_SAT, then:
    1) Let (ADD_SAT sx) be vbinop_.
    2) Return $ivbinopsx_(lanetype X M, $iadd_sat_, sx, v_1, v_2).
  e. If vbinop_ is some SUB_SAT, then:
    1) Let (SUB_SAT sx) be vbinop_.
    2) Return $ivbinopsx_(lanetype X M, $isub_sat_, sx, v_1, v_2).
  f. If vbinop_ is some MIN, then:
    1) Let (MIN sx) be vbinop_.
    2) Return $ivbinopsx_(lanetype X M, $imin_, sx, v_1, v_2).
  g. If vbinop_ is some MAX, then:
    1) Let (MAX sx) be vbinop_.
    2) Return $ivbinopsx_(lanetype X M, $imax_, sx, v_1, v_2).
  h. If (vbinop_ = AVGRU), then:
    1) Return $ivbinopsx_(lanetype X M, $iavgr_, U, v_1, v_2).
  i. If (vbinop_ = Q15MULR_SATS), then:
    1) Return $ivbinopsx_(lanetype X M, $iq15mulr_sat_, S, v_1, v_2).
  j. If (vbinop_ = RELAXED_Q15MULRS), then:
    1) Return $ivbinopsxnd_(lanetype X M, $irelaxed_q15mulr_, S, v_1, v_2).
2. Assert: Due to validation, lanetype is Fnn.
3. If (vbinop_ = ADD), then:
  a. Return $fvbinop_(lanetype X M, $fadd_, v_1, v_2).
4. If (vbinop_ = SUB), then:
  a. Return $fvbinop_(lanetype X M, $fsub_, v_1, v_2).
5. If (vbinop_ = MUL), then:
  a. Return $fvbinop_(lanetype X M, $fmul_, v_1, v_2).
6. If (vbinop_ = DIV), then:
  a. Return $fvbinop_(lanetype X M, $fdiv_, v_1, v_2).
7. If (vbinop_ = MIN), then:
  a. Return $fvbinop_(lanetype X M, $fmin_, v_1, v_2).
8. If (vbinop_ = MAX), then:
  a. Return $fvbinop_(lanetype X M, $fmax_, v_1, v_2).
9. If (vbinop_ = PMIN), then:
  a. Return $fvbinop_(lanetype X M, $fpmin_, v_1, v_2).
10. If (vbinop_ = PMAX), then:
  a. Return $fvbinop_(lanetype X M, $fpmax_, v_1, v_2).
11. If (vbinop_ = RELAXED_MIN), then:
  a. Return $fvbinop_(lanetype X M, $frelaxed_min_, v_1, v_2).
12. Assert: Due to validation, (vbinop_ = RELAXED_MAX).
13. Return $fvbinop_(lanetype X M, $frelaxed_max_, v_1, v_2).

vternop_ lanetype X M vternop_ v_1 v_2 v_3
1. If (lanetype is Jnn /\ (vternop_ = RELAXED_LANESELECT)), then:
  a. Return $ivternopnd_(lanetype X M, $irelaxed_laneselect_, v_1, v_2, v_3).
2. Assert: Due to validation, lanetype is Fnn.
3. If (vternop_ = RELAXED_MADD), then:
  a. Return $fvternop_(lanetype X M, $frelaxed_madd_, v_1, v_2, v_3).
4. Assert: Due to validation, (vternop_ = RELAXED_NMADD).
5. Return $fvternop_(lanetype X M, $frelaxed_nmadd_, v_1, v_2, v_3).

vtestop_ Jnn X M ALL_TRUE v
1. Return $ivtestop_(Jnn X M, $inez_, v).

vrelop_ lanetype X M vrelop_ v_1 v_2
1. If lanetype is Jnn, then:
  a. If (vrelop_ = EQ), then:
    1) Return $ivrelop_(lanetype X M, $ieq_, v_1, v_2).
  b. If (vrelop_ = NE), then:
    1) Return $ivrelop_(lanetype X M, $ine_, v_1, v_2).
  c. If vrelop_ is some LT, then:
    1) Let (LT sx) be vrelop_.
    2) Return $ivrelopsx_(lanetype X M, $ilt_, sx, v_1, v_2).
  d. If vrelop_ is some GT, then:
    1) Let (GT sx) be vrelop_.
    2) Return $ivrelopsx_(lanetype X M, $igt_, sx, v_1, v_2).
  e. If vrelop_ is some LE, then:
    1) Let (LE sx) be vrelop_.
    2) Return $ivrelopsx_(lanetype X M, $ile_, sx, v_1, v_2).
  f. If vrelop_ is some GE, then:
    1) Let (GE sx) be vrelop_.
    2) Return $ivrelopsx_(lanetype X M, $ige_, sx, v_1, v_2).
2. Assert: Due to validation, lanetype is Fnn.
3. If (vrelop_ = EQ), then:
  a. Return $fvrelop_(lanetype X M, $feq_, v_1, v_2).
4. If (vrelop_ = NE), then:
  a. Return $fvrelop_(lanetype X M, $fne_, v_1, v_2).
5. If (vrelop_ = LT), then:
  a. Return $fvrelop_(lanetype X M, $flt_, v_1, v_2).
6. If (vrelop_ = GT), then:
  a. Return $fvrelop_(lanetype X M, $fgt_, v_1, v_2).
7. If (vrelop_ = LE), then:
  a. Return $fvrelop_(lanetype X M, $fle_, v_1, v_2).
8. Assert: Due to validation, (vrelop_ = GE).
9. Return $fvrelop_(lanetype X M, $fge_, v_1, v_2).

lcvtop__ lanetype' X M_1 lanetype X M_2 vcvtop__ c_1
1. If lanetype' is Jnn, then:
  a. If (lanetype is Jnn /\ vcvtop__ is some EXTEND), then:
    1) Let (EXTEND half sx) be vcvtop__.
    2) Let c be $extend__($lsizenn1(lanetype'), $lsizenn2(lanetype), sx, c_1).
    3) Return [c].
  b. If (lanetype is Fnn /\ vcvtop__ is some CONVERT), then:
    1) Let (CONVERT half? sx) be vcvtop__.
    2) Let c be $convert__($lsizenn1(lanetype'), $lsizenn2(lanetype), sx, c_1).
    3) Return [c].
2. Assert: Due to validation, lanetype' is Fnn.
3. If lanetype is Inn, then:
  a. If vcvtop__ is some TRUNC_SAT, then:
    1) Let (TRUNC_SAT sx zero?) be vcvtop__.
    2) Let c? be $trunc_sat__($lsizenn1(lanetype'), $lsizenn2(lanetype), sx, c_1).
    3) Return c?.
  b. If vcvtop__ is some RELAXED_TRUNC, then:
    1) Let (RELAXED_TRUNC sx zero?) be vcvtop__.
    2) Let c? be $relaxed_trunc__($lsizenn1(lanetype'), $lsizenn2(lanetype), sx, c_1).
    3) Return c?.
4. Assert: Due to validation, lanetype is Fnn.
5. If (vcvtop__ = (DEMOTE ZERO)), then:
  a. Let c* be $demote__($lsizenn1(lanetype'), $lsizenn2(lanetype), c_1).
  b. Return c*.
6. Assert: Due to validation, (vcvtop__ = PROMOTELOW).
7. Let c* be $promote__($lsizenn1(lanetype'), $lsizenn2(lanetype), c_1).
8. Return c*.

vcvtop__ Lnn_1 X M Lnn_2 X M' vcvtop v_1
1. If ((M = M') /\ ($halfop(Lnn_1 X M', Lnn_2 X M', vcvtop) is not defined /\ $zeroop(Lnn_1 X M', Lnn_2 X M', vcvtop) is not defined)), then:
  a. Let c_1* be $lanes_(Lnn_1 X M', v_1).
  b. Let c** be $setproduct_(`lane_(Lnn_2), $lcvtop__(Lnn_1 X M', Lnn_2 X M', vcvtop, c_1)*).
  c. Let v be an element of $inv_lanes_(Lnn_2 X M', c*)*.
  d. Return v.
2. If $halfop(Lnn_1 X M, Lnn_2 X M', vcvtop) is defined, then:
  a. Let ?(half) be $halfop(Lnn_1 X M, Lnn_2 X M', vcvtop).
  b. Let c_1* be $lanes_(Lnn_1 X M, v_1)[$half(half, 0, M') : M'].
  c. Let c** be $setproduct_(`lane_(Lnn_2), $lcvtop__(Lnn_1 X M, Lnn_2 X M', vcvtop, c_1)*).
  d. Let v be an element of $inv_lanes_(Lnn_2 X M', c*)*.
  e. Return v.
3. Assert: Due to validation, ($zeroop(Lnn_1 X M, Lnn_2 X M', vcvtop) = ?(ZERO)).
4. Let c_1* be $lanes_(Lnn_1 X M, v_1).
5. Let c** be $setproduct_(`lane_(Lnn_2), $lcvtop__(Lnn_1 X M, Lnn_2 X M', vcvtop, c_1)* :: [$zero(Lnn_2)]^M).
6. Let v be an element of $inv_lanes_(Lnn_2 X M', c*)*.
7. Return v.

vshiftop_ Jnn X M vshiftop_ v i
1. If (vshiftop_ = SHL), then:
  a. Return $ivshiftop_(Jnn X M, $ishl_, v, i).
2. Assert: Due to validation, vshiftop_ is some SHR.
3. Let (SHR sx) be vshiftop_.
4. Return $ivshiftopsx_(Jnn X M, $ishr_, sx, v, i).

vbitmaskop_ Jnn X M v
1. Return $ivbitmaskop_(Jnn X M, v).

vswizzlop_ I8 X M vswizzlop_ v_1 v_2
1. If (vswizzlop_ = SWIZZLE), then:
  a. Return $ivswizzlop_(I8 X M, $iswizzle_lane_, v_1, v_2).
2. Assert: Due to validation, (vswizzlop_ = RELAXED_SWIZZLE).
3. Return $ivswizzlop_(I8 X M, $irelaxed_swizzle_lane_, v_1, v_2).

vshufflop_ I8 X M i* v_1 v_2
1. Return $ivshufflop_(I8 X M, i*, v_1, v_2).

vnarrowop__ Jnn_1 X M_1 Jnn_2 X M_2 sx v_1 v_2
1. Let c_1* be $lanes_(Jnn_1 X M_1, v_1).
2. Let c_2* be $lanes_(Jnn_1 X M_1, v_2).
3. Let c'_1* be [].
4. For each c_1 in c_1*, do:
  a. Let c'_1 be $narrow__($lsize(Jnn_1), $lsize(Jnn_2), sx, c_1).
  b. Append c'_1 to the c'_1*.
5. Let c'_2* be [].
6. For each c_2 in c_2*, do:
  a. Let c'_2 be $narrow__($lsize(Jnn_1), $lsize(Jnn_2), sx, c_2).
  b. Append c'_2 to the c'_2*.
7. Let v be $inv_lanes_(Jnn_2 X M_2, c'_1* :: c'_2*).
8. Return v.

ivadd_pairwise_ N i*
1. Let [j_1, j_2]* be $concat__1^-1(`N, i*).
2. Return $iadd_(N, j_1, j_2)*.

ivextunop__ Jnn_1 X M_1 Jnn_2 X M_2 $f_ sx v_1
1. Let c_1* be $lanes_(Jnn_1 X M_1, v_1).
2. Let c'_1* be [].
3. For each c_1 in c_1*, do:
  a. Let c'_1 be $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), sx, c_1).
  b. Append c'_1 to the c'_1*.
4. Let c* be $f_($lsizenn2(Jnn_2), c'_1*).
5. Return $inv_lanes_(Jnn_2 X M_2, c*).

vextunop__ Jnn_1 X M_1 Jnn_2 X M_2 (EXTADD_PAIRWISE sx) v_1
1. Return $ivextunop__(Jnn_1 X M_1, Jnn_2 X M_2, $ivadd_pairwise_, sx, v_1).

ivdot_ N i_1* i_2*
1. Let [j_1, j_2]* be $concat__1^-1(`iN(N), $imul_(N, i_1, i_2)*).
2. Return $iadd_(N, j_1, j_2)*.

ivdot_sat_ N i_1* i_2*
1. Let [j_1, j_2]* be $concat__1^-1(`iN(N), $imul_(N, i_1, i_2)*).
2. Return $iadd_sat_(N, S, j_1, j_2)*.

ivextbinop__ Jnn_1 X M_1 Jnn_2 X M_2 $f_ sx_1 sx_2 i k v_1 v_2
1. Let c_1* be $lanes_(Jnn_1 X M_1, v_1)[i : k].
2. Let c_2* be $lanes_(Jnn_1 X M_1, v_2)[i : k].
3. Let c'_1* be [].
4. For each c_1 in c_1*, do:
  a. Let c'_1 be $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), sx_1, c_1).
  b. Append c'_1 to the c'_1*.
5. Let c'_2* be [].
6. For each c_2 in c_2*, do:
  a. Let c'_2 be $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), sx_2, c_2).
  b. Append c'_2 to the c'_2*.
7. Let c* be $f_($lsizenn2(Jnn_2), c'_1*, c'_2*).
8. Return $inv_lanes_(Jnn_2 X M_2, c*).

ivmul_ N i_1* i_2*
1. Return $imul_(N, i_1, i_2)*.

vextbinop__ Jnn_1 X M_1 Jnn_2 X M_2 vextbinop__ v_1 v_2
1. If vextbinop__ is some EXTMUL, then:
  a. Let (EXTMUL half sx) be vextbinop__.
  b. Return $ivextbinop__(Jnn_1 X M_1, Jnn_2 X M_2, $ivmul_, sx, sx, $half(half, 0, M_2), M_2, v_1, v_2).
2. If (vextbinop__ = DOTS), then:
  a. Return $ivextbinop__(Jnn_1 X M_1, Jnn_2 X M_2, $ivdot_, S, S, 0, M_1, v_1, v_2).
3. Assert: Due to validation, (vextbinop__ = RELAXED_DOTS).
4. Return $ivextbinop__(Jnn_1 X M_1, Jnn_2 X M_2, $ivdot_sat_, S, $relaxed2($R_idot(), `sx, S, U), 0, M_1, v_1, v_2).

vextternop__ Jnn_1 X M_1 Jnn_2 X M_2 RELAXED_DOT_ADDS c_1 c_2 c_3
1. Let M be (2 * M_2).
2. Let Jnn be $jsizenn^-1((2 * $lsizenn1(Jnn_1))).
3. Let c' be $vextbinop__(Jnn_1 X M_1, Jnn X M, RELAXED_DOTS, c_1, c_2).
4. Let c'' be $vextunop__(Jnn X M, Jnn_2 X M_2, (EXTADD_PAIRWISE S), c').
5. Let c be an element of $vbinop_(Jnn_2 X M_2, ADD, c'', c_3).
6. Return c.

Ki
1. Return 1024.

packfield_ storagetype val
1. If storagetype is valtype, then:
  a. Return val.
2. Assert: Due to validation, storagetype is packtype.
3. Assert: Due to validation, val is some CONST.
4. Let (numtype_0.CONST i) be val.
5. Assert: Due to validation, (numtype_0 = I32).
6. Return (PACK storagetype $wrap__(32, $psize(storagetype), i)).

unpackfield_ storagetype sx'? fieldval
1. If (storagetype is valtype /\ (fieldval is val /\ sx'? is not defined)), then:
  a. Return fieldval.
2. Assert: Due to validation, fieldval is some PACK.
3. Let (PACK packtype i) be fieldval.
4. Assert: Due to validation, sx'? is defined.
5. Let ?(sx) be sx'?.
6. Assert: Due to validation, (storagetype = packtype).
7. Return (I32.CONST $extend__($psize(packtype), 32, sx, i)).

tagsxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be externaddr'*.
3. If externaddr_0 is some TAG, then:
  a. Let (TAG a) be externaddr_0.
  b. Return [a] :: $tagsxa(xa*).
4. Let [externaddr] :: xa* be externaddr'*.
5. Return $tagsxa(xa*).

globalsxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be externaddr'*.
3. If externaddr_0 is some GLOBAL, then:
  a. Let (GLOBAL a) be externaddr_0.
  b. Return [a] :: $globalsxa(xa*).
4. Let [externaddr] :: xa* be externaddr'*.
5. Return $globalsxa(xa*).

memsxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be externaddr'*.
3. If externaddr_0 is some MEM, then:
  a. Let (MEM a) be externaddr_0.
  b. Return [a] :: $memsxa(xa*).
4. Let [externaddr] :: xa* be externaddr'*.
5. Return $memsxa(xa*).

tablesxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be externaddr'*.
3. If externaddr_0 is some TABLE, then:
  a. Let (TABLE a) be externaddr_0.
  b. Return [a] :: $tablesxa(xa*).
4. Let [externaddr] :: xa* be externaddr'*.
5. Return $tablesxa(xa*).

funcsxa externaddr'*
1. If (externaddr'* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be externaddr'*.
3. If externaddr_0 is some FUNC, then:
  a. Let (FUNC a) be externaddr_0.
  b. Return [a] :: $funcsxa(xa*).
4. Let [externaddr] :: xa* be externaddr'*.
5. Return $funcsxa(xa*).

store (s, f)
1. Return.

frame (s, f)
1. Return f.

tagaddr (s, f)
1. Return f.MODULE.TAGS.

moduleinst (s, f)
1. Return f.MODULE.

taginst (s, f)
1. Return s.TAGS.

globalinst (s, f)
1. Return s.GLOBALS.

meminst (s, f)
1. Return s.MEMS.

tableinst (s, f)
1. Return s.TABLES.

funcinst (s, f)
1. Return s.FUNCS.

datainst (s, f)
1. Return s.DATAS.

eleminst (s, f)
1. Return s.ELEMS.

structinst (s, f)
1. Return s.STRUCTS.

arrayinst (s, f)
1. Return s.ARRAYS.

exninst (s, f)
1. Return s.EXNS.

type (s, f) x
1. Return f.MODULE.TYPES[x].

tag (s, f) x
1. Return s.TAGS[f.MODULE.TAGS[x]].

global (s, f) x
1. Return s.GLOBALS[f.MODULE.GLOBALS[x]].

mem (s, f) x
1. Return s.MEMS[f.MODULE.MEMS[x]].

table (s, f) x
1. Return s.TABLES[f.MODULE.TABLES[x]].

func (s, f) x
1. Return s.FUNCS[f.MODULE.FUNCS[x]].

data (s, f) x
1. Return s.DATAS[f.MODULE.DATAS[x]].

elem (s, f) x
1. Return s.ELEMS[f.MODULE.ELEMS[x]].

local (s, f) x
1. Return f.LOCALS[x].

with_local (s, f) x v
1. Replace f.LOCALS[x] with ?(v).

with_global (s, f) x v
1. Replace s.GLOBALS[f.MODULE.GLOBALS[x]].VALUE with v.

with_table (s, f) x i r
1. Replace s.TABLES[f.MODULE.TABLES[x]].REFS[i] with r.

with_tableinst (s, f) x ti
1. Replace s.TABLES[f.MODULE.TABLES[x]] with ti.

with_mem (s, f) x i j b*
1. Replace s.MEMS[f.MODULE.MEMS[x]].BYTES[i : j] with b*.

with_meminst (s, f) x mi
1. Replace s.MEMS[f.MODULE.MEMS[x]] with mi.

with_elem (s, f) x r*
1. Replace s.ELEMS[f.MODULE.ELEMS[x]].REFS with r*.

with_data (s, f) x b*
1. Replace s.DATAS[f.MODULE.DATAS[x]].BYTES with b*.

with_struct (s, f) a i fv
1. Replace s.STRUCTS[a].FIELDS[i] with fv.

with_array (s, f) a i fv
1. Replace s.ARRAYS[a].FIELDS[i] with fv.

add_structinst (s, f) si*
1. Append si* to the s.STRUCTS.

add_arrayinst (s, f) ai*
1. Append ai* to the s.ARRAYS.

add_exninst (s, f) exn*
1. Append exn* to the s.EXNS.

growtable tableinst n r
1. Let { TYPE: (at ([ i .. j? ]) rt); REFS: r'* } be tableinst.
2. Let i' be (|r'*| + n).
3. If (i' <= j)?, then:
  a. Let tableinst' be { TYPE: (at ([ i' .. j? ]) rt); REFS: r'* :: r^n }.
  b. Return tableinst'.
4. Fail.

growmem meminst n
1. Let { TYPE: at ([ i .. j? ]) PAGE; BYTES: b* } be meminst.
2. Let i' be ((|b*| / (64 * $Ki())) + n).
3. If (i' <= j)?, then:
  a. Let meminst' be { TYPE: at ([ i' .. j? ]) PAGE; BYTES: b* :: 0^(n * (64 * $Ki())) }.
  b. Return meminst'.
4. Fail.

inst_valtype moduleinst t
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_valtype(t, dt*).

inst_reftype moduleinst rt
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_reftype(rt, dt*).

inst_globaltype moduleinst gt
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_globaltype(gt, dt*).

inst_memtype moduleinst mt
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_memtype(mt, dt*).

inst_tabletype moduleinst tt
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_tabletype(tt, dt*).

blocktype_ z blocktype
1. If blocktype is some _IDX, then:
  a. Let (_IDX x) be blocktype.
  b. Assert: Due to validation, $Expand($type(z, x)) is some FUNC.
  c. Let (FUNC t_1* -> t_2*) be $Expand($type(z, x)).
  d. Return t_1* ->_ [] t_2*.
2. Assert: Due to validation, blocktype is some _RESULT.
3. Let (_RESULT t?) be blocktype.
4. Return [] ->_ [] t?.

alloctypes type''*
1. If (type''* = []), then:
  a. Return [].
2. Let type'* :: [type] be type''*.
3. Let (TYPE rectype) be type.
4. Let deftype'* be $alloctypes(type'*).
5. Let x be |deftype'*|.
6. Let deftype* be $subst_all_deftypes($rolldt(x, rectype), deftype'*).
7. Return deftype'* :: deftype*.

alloctag s tagtype
1. Let taginst be { TYPE: tagtype }.
2. Let a be |s.TAGS|.
3. Append taginst to the s.TAGS.
4. Return a.

alloctags s tagtype''*
1. If (tagtype''* = []), then:
  a. Return [].
2. Let [tagtype] :: tagtype'* be tagtype''*.
3. Let ja be $alloctag(s, tagtype).
4. Let ja'* be $alloctags(s, tagtype'*).
5. Return [ja] :: ja'*.

allocglobal s globaltype val
1. Let globalinst be { TYPE: globaltype; VALUE: val }.
2. Let a be |s.GLOBALS|.
3. Append globalinst to the s.GLOBALS.
4. Return a.

allocglobals s globaltype''* val''*
1. If (globaltype''* = []), then:
  a. Assert: Due to validation, (val''* = []).
  b. Return [].
2. Else:
  a. Let [globaltype] :: globaltype'* be globaltype''*.
  b. Assert: Due to validation, (|val''*| >= 1).
  c. Let [val] :: val'* be val''*.
  d. Let ga be $allocglobal(s, globaltype, val).
  e. Let ga'* be $allocglobals(s, globaltype'*, val'*).
  f. Return [ga] :: ga'*.

allocmem s at ([ i .. j? ]) PAGE
1. Let meminst be { TYPE: at ([ i .. j? ]) PAGE; BYTES: 0^(i * (64 * $Ki())) }.
2. Let a be |s.MEMS|.
3. Append meminst to the s.MEMS.
4. Return a.

allocmems s memtype''*
1. If (memtype''* = []), then:
  a. Return [].
2. Let [memtype] :: memtype'* be memtype''*.
3. Let ma be $allocmem(s, memtype).
4. Let ma'* be $allocmems(s, memtype'*).
5. Return [ma] :: ma'*.

alloctable s (at ([ i .. j? ]) rt) ref
1. Let tableinst be { TYPE: (at ([ i .. j? ]) rt); REFS: ref^i }.
2. Let a be |s.TABLES|.
3. Append tableinst to the s.TABLES.
4. Return a.

alloctables s tabletype''* ref''*
1. If (ref''* = []), then:
  a. Assert: Due to validation, (tabletype''* = []).
  b. Return [].
2. Else:
  a. Let [ref] :: ref'* be ref''*.
  b. Assert: Due to validation, (|tabletype''*| >= 1).
  c. Let [tabletype] :: tabletype'* be tabletype''*.
  d. Let ta be $alloctable(s, tabletype, ref).
  e. Let ta'* be $alloctables(s, tabletype'*, ref'*).
  f. Return [ta] :: ta'*.

allocfunc s deftype funccode moduleinst
1. Let funcinst be { TYPE: deftype; MODULE: moduleinst; CODE: funccode }.
2. Let a be |s.FUNCS|.
3. Append funcinst to the s.FUNCS.
4. Return a.

allocfuncs s deftype* funccode''* moduleinst''*
1. If (deftype* = []), then:
  a. Assert: Due to validation, (funccode''* = []).
  b. Assert: Due to validation, (moduleinst''* = []).
  c. Return [].
2. Else:
  a. Let [dt] :: dt'* be deftype*.
  b. Assert: Due to validation, (|funccode''*| >= 1).
  c. Let [funccode] :: funccode'* be funccode''*.
  d. Assert: Due to validation, (|moduleinst''*| >= 1).
  e. Let [moduleinst] :: moduleinst'* be moduleinst''*.
  f. Let fa be $allocfunc(s, dt, funccode, moduleinst).
  g. Let fa'* be $allocfuncs(s, dt'*, funccode'*, moduleinst'*).
  h. Return [fa] :: fa'*.

allocdata s OK byte*
1. Let datainst be { BYTES: byte* }.
2. Let a be |s.DATAS|.
3. Append datainst to the s.DATAS.
4. Return a.

allocdatas s datatype* byte*
1. If (byte* = []), then:
  a. Assert: Due to validation, (datatype* = []).
  b. Return [].
2. Else:
  a. Let [b*] :: b'** be byte*.
  b. Assert: Due to validation, (|datatype*| >= 1).
  c. Let [ok] :: ok'* be datatype*.
  d. Let da be $allocdata(s, ok, b*).
  e. Let da'* be $allocdatas(s, ok'*, b'**).
  f. Return [da] :: da'*.

allocelem s elemtype ref*
1. Let eleminst be { TYPE: elemtype; REFS: ref* }.
2. Let a be |s.ELEMS|.
3. Append eleminst to the s.ELEMS.
4. Return a.

allocelems s elemtype* ref''*
1. If (ref''* = []), then:
  a. Assert: Due to validation, (elemtype* = []).
  b. Return [].
2. Else:
  a. Let [ref*] :: ref'** be ref''*.
  b. Assert: Due to validation, (|elemtype*| >= 1).
  c. Let [rt] :: rt'* be elemtype*.
  d. Let ea be $allocelem(s, rt, ref*).
  e. Let ea'* be $allocelems(s, rt'*, ref'**).
  f. Return [ea] :: ea'*.

allocexport moduleinst (EXPORT name externidx)
1. If externidx is some TAG, then:
  a. Let (TAG x) be externidx.
  b. Return { NAME: name; ADDR: (TAG moduleinst.TAGS[x]) }.
2. If externidx is some GLOBAL, then:
  a. Let (GLOBAL x) be externidx.
  b. Return { NAME: name; ADDR: (GLOBAL moduleinst.GLOBALS[x]) }.
3. If externidx is some MEM, then:
  a. Let (MEM x) be externidx.
  b. Return { NAME: name; ADDR: (MEM moduleinst.MEMS[x]) }.
4. If externidx is some TABLE, then:
  a. Let (TABLE x) be externidx.
  b. Return { NAME: name; ADDR: (TABLE moduleinst.TABLES[x]) }.
5. Assert: Due to validation, externidx is some FUNC.
6. Let (FUNC x) be externidx.
7. Return { NAME: name; ADDR: (FUNC moduleinst.FUNCS[x]) }.

allocexports moduleinst export*
1. Return $allocexport(moduleinst, export)*.

allocmodule s module externaddr* val_G* ref_T* ref_E**
1. Let (MODULE type* import* tag* global* mem* table* func* data* elem* start? export*) be module.
2. Let aa_I* be $tagsxa(externaddr*).
3. Let ga_I* be $globalsxa(externaddr*).
4. Let fa_I* be $funcsxa(externaddr*).
5. Let ma_I* be $memsxa(externaddr*).
6. Let ta_I* be $tablesxa(externaddr*).
7. Let fa* be (|s.FUNCS| + i_F)^(i_F<|func*|).
8. Let tagtype* be [].
9. For each tag in tag*, do:
  a. Let (TAG tagtype) be tag.
  b. Append tagtype to the tagtype*.
10. Let byte** be [].
11. For each data in data*, do:
  a. Let (DATA byte* datamode) be data.
  b. Append byte* to the byte**.
12. Let globaltype* be [].
13. For each global in global*, do:
  a. Let (GLOBAL globaltype expr_G) be global.
  b. Append globaltype to the globaltype*.
14. Let tabletype* be [].
15. For each table in table*, do:
  a. Let (TABLE tabletype expr_T) be table.
  b. Append tabletype to the tabletype*.
16. Let memtype* be [].
17. For each mem in mem*, do:
  a. Let (MEMORY memtype) be mem.
  b. Append memtype to the memtype*.
18. Let dt* be $alloctypes(type*).
19. Let elemtype* be [].
20. For each elem in elem*, do:
  a. Let (ELEM elemtype expr_E* elemmode) be elem.
  b. Append elemtype to the elemtype*.
21. Let expr_F* be [].
22. Let local** be [].
23. Let x* be [].
24. For each func in func*, do:
  a. Let (FUNC x local* expr_F) be func.
  b. Append expr_F to the expr_F*.
  c. Append local* to the local**.
  d. Append x to the x*.
25. Let aa* be [].
26. For each tagtype in tagtype*, do:
  a. Let aa be $alloctag(s, $subst_all_tagtype(tagtype, dt*)).
  b. Append aa to the aa*.
27. Let ga* be [].
28. For each globaltype in globaltype* and val_G in val_G*, do:
  a. Let ga be $allocglobal(s, $subst_all_globaltype(globaltype, dt*), val_G).
  b. Append ga to the ga*.
29. Let ma* be [].
30. For each memtype in memtype*, do:
  a. Let ma be $allocmem(s, $subst_all_memtype(memtype, dt*)).
  b. Append ma to the ma*.
31. Let ta* be [].
32. For each tabletype in tabletype* and ref_T in ref_T*, do:
  a. Let ta be $alloctable(s, $subst_all_tabletype(tabletype, dt*), ref_T).
  b. Append ta to the ta*.
33. Let xi* be [].
34. For each export in export*, do:
  a. Let xi be $allocexport({ TAGS: aa_I* :: aa*; GLOBALS: ga_I* :: ga*; MEMS: ma_I* :: ma*; TABLES: ta_I* :: ta*; FUNCS: fa_I* :: fa* }, export).
  b. Append xi to the xi*.
35. Let da* be [].
36. For each byte* in byte**, do:
  a. Let da be $allocdata(s, OK, byte*).
  b. Append da to the da*.
37. Let ea* be [].
38. For each elemtype in elemtype* and ref_E* in ref_E**, do:
  a. Let ea be $allocelem(s, $subst_all_reftype(elemtype, dt*), ref_E*).
  b. Append ea to the ea*.
39. Let moduleinst be { TYPES: dt*; TAGS: aa_I* :: aa*; GLOBALS: ga_I* :: ga*; MEMS: ma_I* :: ma*; TABLES: ta_I* :: ta*; FUNCS: fa_I* :: fa*; DATAS: da*; ELEMS: ea*; EXPORTS: xi* }.
40. Let funcaddr_0* be [].
41. For each expr_F in expr_F* and local* in local** and x in x*, do:
  a. Let funcaddr_0 be $allocfunc(s, dt*[x], (FUNC x local* expr_F), moduleinst).
  b. Append funcaddr_0 to the funcaddr_0*.
42. Assert: Due to validation, (funcaddr_0* = fa*).
43. Return moduleinst.

rundata_ x (DATA b^n datamode)
1. If (datamode = PASSIVE), then:
  a. Return [].
2. Assert: Due to validation, datamode is some ACTIVE.
3. Let (ACTIVE y instr*) be datamode.
4. Return instr* :: [(I32.CONST 0), (I32.CONST n), (MEMORY.INIT y x), (DATA.DROP x)].

runelem_ x (ELEM rt e^n elemmode)
1. If (elemmode = PASSIVE), then:
  a. Return [].
2. If (elemmode = DECLARE), then:
  a. Return [(ELEM.DROP x)].
3. Assert: Due to validation, elemmode is some ACTIVE.
4. Let (ACTIVE y instr*) be elemmode.
5. Return instr* :: [(I32.CONST 0), (I32.CONST n), (TABLE.INIT y x), (ELEM.DROP x)].

evalglobals z globaltype* expr''*
1. If (expr''* = []), then:
  a. Assert: Due to validation, (globaltype* = []).
  b. Return [].
2. Else:
  a. Let [expr] :: expr'* be expr''*.
  b. Assert: Due to validation, (|globaltype*| >= 1).
  c. Let [gt] :: gt'* be globaltype*.
  d. Let (s, f) be z.
  e. Let [val] be $Eval_expr(z, expr).
  f. Let a be $allocglobal(s, gt, val).
  g. Append a to the f.MODULE.GLOBALS.
  h. Let val'* be $evalglobals((s, f), gt'*, expr'*).
  i. Return [val] :: val'*.

instantiate s module externaddr*
1. Let xt_I* -> xt_E* be $Module_ok(module).
2. Let (MODULE type* import* tag* global* mem* table* func* data* elem* start? export*) be module.
3. If not $Externaddr_ok(externaddr, xt_I)*, then:
  a. Fail.
4. Let instr_D* be $concat_(`instr, $rundata_(i_D, data*[i_D])^(i_D<|data*|)).
5. Let instr_E* be $concat_(`instr, $runelem_(i_E, elem*[i_E])^(i_E<|elem*|)).
6. Let moduleinst_0 be { TYPES: $alloctypes(type*); GLOBALS: $globalsxa(externaddr*); FUNCS: $funcsxa(externaddr*) :: (|s.FUNCS| + i_F)^(i_F<|func*|) }.
7. Let expr_T* be [].
8. For each table in table*, do:
  a. Let (TABLE tabletype expr_T) be table.
  b. Append expr_T to the expr_T*.
9. Let expr_G* be [].
10. Let globaltype* be [].
11. For each global in global*, do:
  a. Let (GLOBAL globaltype expr_G) be global.
  b. Append expr_G to the expr_G*.
  c. Append globaltype to the globaltype*.
12. Let expr_E** be [].
13. For each elem in elem*, do:
  a. Let (ELEM reftype expr_E* elemmode) be elem.
  b. Append expr_E* to the expr_E**.
14. Let z be (s, { MODULE: moduleinst_0 }).
15. Push the frame (FRAME_ 0 { $frame(z) }) to the stack.
16. Let val_G* be $evalglobals(z, globaltype*, expr_G*).
17. Let ref_T* be [].
18. For each expr_T in expr_T*, do:
  a. Let [ref_T] be $Eval_expr(z, expr_T).
  b. Append ref_T to the ref_T*.
19. Let ref_E** be [].
20. For each expr_E* in expr_E**, do:
  a. Let ref_E* be [].
  b. For each expr_E in expr_E*, do:
    1) Let [ref_E] be $Eval_expr(z, expr_E).
    2) Append ref_E to the ref_E*.
  c. Append ref_E* to the ref_E**.
21. Pop the frame (FRAME_ 0 { f }) from the stack.
22. Let moduleinst be $allocmodule(s, module, externaddr*, val_G*, ref_T*, ref_E**).
23. Push the frame (FRAME_ 0 { { MODULE: moduleinst } }) to the stack.
24. Execute the sequence instr_E*.
25. Execute the sequence instr_D*.
26. If start? is defined, then:
  a. Let ?((START x)) be start?.
  b. Let instr_S be (CALL x).
  c. Execute the instruction instr_S.
27. Pop the frame (FRAME_ 0 { { MODULE: moduleinst } }) from the stack.
28. Return moduleinst.

invoke s funcaddr val*
1. Assert: Due to validation, $Expand(s.FUNCS[funcaddr].TYPE) is some FUNC.
2. Let (FUNC t_1* -> t_2*) be $Expand(s.FUNCS[funcaddr].TYPE).
3. If not $Val_ok(val, t_1)*, then:
  a. Fail.
4. Let k be |t_2*|.
5. Push the frame (FRAME_ k { { MODULE: {} } }) to the stack.
6. Push the values val* to the stack.
7. Push the value (REF.FUNC_ADDR funcaddr) to the stack.
8. Execute the instruction (CALL_REF s.FUNCS[funcaddr].TYPE).
9. Pop the values val'^k from the stack.
10. Pop the frame (FRAME_ k { { MODULE: {} } }) from the stack.
11. Return val'^k.

concat_idctxt idctxt*
1. If (idctxt* = []), then:
  a. Return {}.
2. Let [I, I'] be idctxt*.
3. Return I ++ $concat_idctxt(I'*).

typesd decl'*
1. If (decl'* = []), then:
  a. Return [].
2. Let [type] :: decl'* be decl'*.
3. Return [type] :: $typesd(decl'*).

importsd decl'*
1. If (decl'* = []), then:
  a. Return [].
2. Let [import] :: decl'* be decl'*.
3. Return [import] :: $importsd(decl'*).

tagsd decl'*
1. If (decl'* = []), then:
  a. Return [].
2. Let [tag] :: decl'* be decl'*.
3. Return [tag] :: $tagsd(decl'*).

globalsd decl'*
1. If (decl'* = []), then:
  a. Return [].
2. Let [global] :: decl'* be decl'*.
3. Return [global] :: $globalsd(decl'*).

memsd decl'*
1. If (decl'* = []), then:
  a. Return [].
2. Let [mem] :: decl'* be decl'*.
3. Return [mem] :: $memsd(decl'*).

tablesd decl'*
1. If (decl'* = []), then:
  a. Return [].
2. Let [table] :: decl'* be decl'*.
3. Return [table] :: $tablesd(decl'*).

funcsd decl'*
1. If (decl'* = []), then:
  a. Return [].
2. Let [func] :: decl'* be decl'*.
3. Return [func] :: $funcsd(decl'*).

datasd decl'*
1. If (decl'* = []), then:
  a. Return [].
2. Let [data] :: decl'* be decl'*.
3. Return [data] :: $datasd(decl'*).

elemsd decl'*
1. If (decl'* = []), then:
  a. Return [].
2. Let [elem] :: decl'* be decl'*.
3. Return [elem] :: $elemsd(decl'*).

startsd decl'*
1. If (decl'* = []), then:
  a. Return [].
2. Let [start] :: decl'* be decl'*.
3. Return [start] :: $startsd(decl'*).

exportsd decl'*
1. If (decl'* = []), then:
  a. Return [].
2. Let [export] :: decl'* be decl'*.
3. Return [export] :: $exportsd(decl'*).

ordered decl*
1. If (decl* = []), then:
  a. Return true.
2. Return ($importsd(decl*) = []).
3. Assert: Due to validation, YetE (Nondeterministic assignment target: decl_1*{decl_1 <- decl_1*} :: [import] :: decl_2*{decl_2 <- decl_2*}).
4. Let decl_1* :: [import] :: decl_2* be decl*.
5. Return (((((($importsd(decl_1*) = []) /\ ($tagsd(decl_1*) = [])) /\ ($globalsd(decl_1*) = [])) /\ ($memsd(decl_1*) = [])) /\ ($tablesd(decl_1*) = [])) /\ ($funcsd(decl_1*) = [])).

allocXs `X `Y s X''* Y''*
1. If (X''* = []), then:
  a. Assert: Due to validation, (Y''* = []).
  b. Return [].
2. Else:
  a. Let [X] :: X'* be X''*.
  b. Assert: Due to validation, (|Y''*| >= 1).
  c. Let [Y] :: Y'* be Y''*.
  d. Let a be $allocX(`X, `Y, s, X, Y).
  e. Let a'* be $allocXs(`X, `Y, s, X'*, Y'*).
  f. Return [a] :: a'*.

var `X
1. Return 0.

Eval_expr instr*
1. Execute the sequence instr*.
2. Pop the value val from the stack.
3. Return [val].

== Complete.
```
