# Preview

```sh
$ for v in 1 2 3; do ( \
>   echo "Generating prose for Wasm $v.0..." && \
>   cd ../spec/wasm-$v.0 && \
>   ../../src/exe-watsup/main.exe *.watsup -v -l --prose-rst && \
>   ../../src/exe-watsup/main.exe *.watsup -v -l --prose \
> ) done
Generating prose for Wasm 1.0...
watsup 0.4 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...



The limits :math:`{}[~n~..~m~]` is valid with :math:`k` if:


   * :math:`n` is less than or equal to :math:`m`.

   * :math:`m` is less than or equal to :math:`k`.




The function type :math:`{t_1^\ast}~\rightarrow~{t_2^?}` is valid.




The global type :math:`({\mathsf{mut}^?}~t)` is valid.




The table type :math:`{\mathit{limits}}` is valid if:


   * The limits :math:`{\mathit{limits}}` is valid with :math:`{2^{32}} - 1`.




The memory type :math:`{\mathit{limits}}` is valid if:


   * The limits :math:`{\mathit{limits}}` is valid with :math:`{2^{16}}`.




The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid if:


   * Either:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{functype}})`.

      * The function type :math:`{\mathit{functype}}` is valid.

   * Or:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~{\mathit{globaltype}})`.

      * The global type :math:`{\mathit{globaltype}}` is valid.
   * Or:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~{\mathit{tabletype}})`.

      * The table type :math:`{\mathit{tabletype}}` is valid.
   * Or:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~{\mathit{memtype}})`.

      * The memory type :math:`{\mathit{memtype}}` is valid.




The external type :math:`(\mathsf{func}~{\mathit{functype}})` is valid if:


   * The function type :math:`{\mathit{functype}}` is valid.




The external type :math:`(\mathsf{global}~{\mathit{globaltype}})` is valid if:


   * The global type :math:`{\mathit{globaltype}}` is valid.




The external type :math:`(\mathsf{table}~{\mathit{tabletype}})` is valid if:


   * The table type :math:`{\mathit{tabletype}}` is valid.




The external type :math:`(\mathsf{mem}~{\mathit{memtype}})` is valid if:


   * The memory type :math:`{\mathit{memtype}}` is valid.




The limits :math:`{}[~n_{11}~..~n_{12}~]` matches the limits :math:`{}[~n_{21}~..~n_{22}~]` if:


   * :math:`n_{11}` is greater than or equal to :math:`n_{21}`.

   * :math:`n_{12}` is less than or equal to :math:`n_{22}`.




The function type :math:`{\mathit{ft}}` matches itself.




The global type :math:`{\mathit{gt}}` matches itself.




The table type :math:`{\mathit{lim}}_1` matches the table type :math:`{\mathit{lim}}_2` if:


   * The limits :math:`{\mathit{lim}}_1` matches the limits :math:`{\mathit{lim}}_2`.




The memory type :math:`{\mathit{lim}}_1` matches the memory type :math:`{\mathit{lim}}_2` if:


   * The limits :math:`{\mathit{lim}}_1` matches the limits :math:`{\mathit{lim}}_2`.




The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` matches the external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` if:


   * Either:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{ft}}_1)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{func}~{\mathit{ft}}_2)`.

      * The function type :math:`{\mathit{ft}}_1` matches the function type :math:`{\mathit{ft}}_2`.

   * Or:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~{\mathit{gt}}_1)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{global}~{\mathit{gt}}_2)`.

      * The global type :math:`{\mathit{gt}}_1` matches the global type :math:`{\mathit{gt}}_2`.
   * Or:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~{\mathit{tt}}_1)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{table}~{\mathit{tt}}_2)`.

      * The table type :math:`{\mathit{tt}}_1` matches the table type :math:`{\mathit{tt}}_2`.
   * Or:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~{\mathit{mt}}_1)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{mem}~{\mathit{mt}}_2)`.

      * The memory type :math:`{\mathit{mt}}_1` matches the memory type :math:`{\mathit{mt}}_2`.




The external type :math:`(\mathsf{func}~{\mathit{ft}}_1)` matches the external type :math:`(\mathsf{func}~{\mathit{ft}}_2)` if:


   * The function type :math:`{\mathit{ft}}_1` matches the function type :math:`{\mathit{ft}}_2`.




The external type :math:`(\mathsf{global}~{\mathit{gt}}_1)` matches the external type :math:`(\mathsf{global}~{\mathit{gt}}_2)` if:


   * The global type :math:`{\mathit{gt}}_1` matches the global type :math:`{\mathit{gt}}_2`.




The external type :math:`(\mathsf{table}~{\mathit{tt}}_1)` matches the external type :math:`(\mathsf{table}~{\mathit{tt}}_2)` if:


   * The table type :math:`{\mathit{tt}}_1` matches the table type :math:`{\mathit{tt}}_2`.




The external type :math:`(\mathsf{mem}~{\mathit{mt}}_1)` matches the external type :math:`(\mathsf{mem}~{\mathit{mt}}_2)` if:


   * The memory type :math:`{\mathit{mt}}_1` matches the memory type :math:`{\mathit{mt}}_2`.




The instruction :math:`\mathsf{nop}` is valid with the function type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction :math:`\mathsf{unreachable}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`\mathsf{drop}` is valid with the function type :math:`t~\rightarrow~\epsilon`.




The instruction :math:`\mathsf{select}` is valid with the function type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t`.




The instruction :math:`(\mathsf{block}~{t^?}~{{\mathit{instr}}^\ast})` is valid with the function type :math:`\epsilon~\rightarrow~{t^?}` if:


   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t^?}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`\epsilon~\rightarrow~{t^?}`.




The instruction :math:`(\mathsf{loop}~{t^?}~{{\mathit{instr}}^\ast})` is valid with the function type :math:`\epsilon~\rightarrow~{t^?}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction :math:`(\mathsf{if}~{t^?}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{t^?}` if:


   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t^?}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_1^\ast}` is valid with the function type :math:`\epsilon~\rightarrow~{t^?}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the function type :math:`\epsilon~\rightarrow~{t^?}`.




The instruction :math:`(\mathsf{br}~l)` is valid with the function type :math:`{t_1^\ast}~{t^?}~\rightarrow~{t_2^\ast}` if:


   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The :ref:`number type <syntax-numtype>` :math:`C{.}\mathsf{labels}{}[l]` is equal to :math:`{t^?}`.




The instruction :math:`(\mathsf{br\_if}~l)` is valid with the function type :math:`{t^?}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t^?}` if:


   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The :ref:`number type <syntax-numtype>` :math:`C{.}\mathsf{labels}{}[l]` is equal to :math:`{t^?}`.




The instruction :math:`(\mathsf{br\_table}~{l^\ast}~{l'})` is valid with the function type :math:`{t_1^\ast}~{t^?}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


   * The result type :math:`C{.}\mathsf{labels}{}[{l'}]` exists.

   * The result type :math:`{t^?}` is equal to :math:`C{.}\mathsf{labels}{}[{l'}]`.

   * For all :math:`l` in :math:`{l^\ast}`:

      * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * For all :math:`l` in :math:`{l^\ast}`:

      * The result type :math:`{t^?}` is equal to :math:`C{.}\mathsf{labels}{}[l]`.




The instruction :math:`(\mathsf{call}~x)` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^?}` if:


   * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{t_1^\ast}~\rightarrow~{t_2^?}`.




The instruction :math:`(\mathsf{call\_indirect}~x)` is valid with the function type :math:`{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^?}` if:


   * The function type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{types}{}[x]` is equal to :math:`{t_1^\ast}~\rightarrow~{t_2^?}`.




The instruction :math:`\mathsf{return}` is valid with the function type :math:`{t_1^\ast}~{t^?}~\rightarrow~{t_2^\ast}` if:


   * The result type :math:`C{.}\mathsf{return}` is equal to :math:`{t^?}`.




The instruction :math:`(t{.}\mathsf{const}~c_t)` is valid with the function type :math:`\epsilon~\rightarrow~t`.




The instruction :math:`(t {.} {\mathit{unop}}_t)` is valid with the function type :math:`t~\rightarrow~t`.




The instruction :math:`(t {.} {\mathit{binop}}_t)` is valid with the function type :math:`t~t~\rightarrow~t`.




The instruction :math:`(t {.} {\mathit{testop}}_t)` is valid with the function type :math:`t~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`(t {.} {\mathit{relop}}_t)` is valid with the function type :math:`t~t~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{nt}}_1 {.} {{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{\_}}{{\mathit{nt}}_2})` is valid with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1` if:


   * Either:

      * :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{reinterpret}`.

      * :math:`{|{\mathit{nt}}_1|}` is equal to :math:`{|{\mathit{nt}}_2|}`.

   * Or:

      * :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{cvtop}}`.




The instruction :math:`(\mathsf{local{.}get}~x)` is valid with the function type :math:`\epsilon~\rightarrow~t` if:


   * The :ref:`number type <syntax-numtype>` :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The :ref:`number type <syntax-numtype>` :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`t`.




The instruction :math:`(\mathsf{local{.}set}~x)` is valid with the function type :math:`t~\rightarrow~\epsilon` if:


   * The :ref:`number type <syntax-numtype>` :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The :ref:`number type <syntax-numtype>` :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`t`.




The instruction :math:`(\mathsf{local{.}tee}~x)` is valid with the function type :math:`t~\rightarrow~t` if:


   * The :ref:`number type <syntax-numtype>` :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The :ref:`number type <syntax-numtype>` :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`t`.




The instruction :math:`(\mathsf{global{.}get}~x)` is valid with the function type :math:`\epsilon~\rightarrow~t` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`({\mathit{mut}}~t)`.




The instruction :math:`(\mathsf{global{.}set}~x)` is valid with the function type :math:`t~\rightarrow~\epsilon` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`(\mathsf{mut}~t)`.




The instruction :math:`\mathsf{memory{.}size}` is valid with the function type :math:`\epsilon~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.




The instruction :math:`\mathsf{memory{.}grow}` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.




The instruction :math:`({t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{load}}{{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~t_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

   * Either:

      * The :ref:`number type <syntax-numtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`t`.

      * :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}` is absent.

      * The :ref:`number type <syntax-numtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is equal to :math:`t`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|t|} / 8`.

   * Or:

      * The :ref:`number type <syntax-numtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{i}}{n}`.

      * :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`{M}{\mathsf{\_}}{{\mathit{sx}}}`.

      * The :ref:`number type <syntax-numtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is equal to :math:`{\mathsf{i}}{n}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{store}}{{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

   * Either:

      * The :ref:`number type <syntax-numtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`t`.

      * The pack size :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is absent.

      * The :ref:`number type <syntax-numtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`t`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|t|} / 8`.

   * Or:

      * The :ref:`number type <syntax-numtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{i}}{n}`.

      * The pack size :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`M`.

      * The :ref:`number type <syntax-numtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathsf{i}}{n}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({\mathit{nt}}_1 {.} {\mathsf{reinterpret}}{\mathsf{\_}}{{\mathit{nt}}_2})` is valid with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1` if:


   * :math:`{|{\mathit{nt}}_1|}` is equal to :math:`{|{\mathit{nt}}_2|}`.




The instruction :math:`({\mathit{nt}}_1 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_2})` is valid with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1`.




The instruction :math:`({t{.}\mathsf{load}}{\epsilon}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|t|} / 8`.




The instruction :math:`({{\mathsf{i}}{n}{.}\mathsf{load}}{{M}{\mathsf{\_}}{{\mathit{sx}}}}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathsf{i}}{n}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({t{.}\mathsf{store}}{\epsilon}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~t~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|t|} / 8`.




The instruction :math:`({{\mathsf{i}}{n}{.}\mathsf{store}}{M}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathsf{i}}{n}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction sequence :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is valid with the function type :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}~\rightarrow~{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` if:


   * Either:

      * The instruction sequence :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

      * The number type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

      * The number type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`\epsilon`.

   * Or:

      * The instruction sequence :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}`.

      * The number type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{t_1^\ast}`.

      * The number type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`{t_3^\ast}`.

      * The instruction :math:`{\mathit{instr}}_1` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

      * The instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the function type :math:`{t_2^\ast}~\rightarrow~{t_3^\ast}`.
   * Or:

      * The instruction sequence :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{{\mathit{instr}}^\ast}`.

      * The number type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{t^\ast}~{t_1^\ast}`.

      * The number type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`{t^\ast}~{t_2^\ast}`.

      * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction sequence :math:`\epsilon` is valid with the function type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction sequence :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_3^\ast}` if:


   * The instruction :math:`{\mathit{instr}}_1` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * The instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the function type :math:`{t_2^\ast}~\rightarrow~{t_3^\ast}`.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t^\ast}~{t_1^\ast}~\rightarrow~{t^\ast}~{t_2^\ast}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The expression :math:`{{\mathit{instr}}^\ast}` is valid with the result type :math:`{t^?}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`\epsilon~\rightarrow~{t^?}`.




:math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is constant if:


   * Either:

      * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(t{.}\mathsf{const}~c)`.

   * Or:

      * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global{.}get}~x)`.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`(\epsilon~t)`.




:math:`(t{.}\mathsf{const}~c)` is constant.




:math:`(\mathsf{global{.}get}~x)` is constant if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`(\epsilon~t)`.




:math:`{{\mathit{instr}}^\ast}` is constant if:


   * For all :math:`{\mathit{instr}}` in :math:`{{\mathit{instr}}^\ast}`:

      * :math:`{\mathit{instr}}` is constant.




The type :math:`(\mathsf{type}~{\mathit{ft}})` is valid with the function type :math:`{\mathit{ft}}` if:


   * The function type :math:`{\mathit{ft}}` is valid.




The function :math:`(\mathsf{func}~x~{(\mathsf{local}~t)^\ast}~{\mathit{expr}})` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^?}` if:


   * The function type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{types}{}[x]` is equal to :math:`{t_1^\ast}~\rightarrow~{t_2^?}`.

   * Under the context :math:`C{}[{.}\mathsf{locals} \mathrel{{=}{\oplus}} {t_1^\ast}~{t^\ast}]{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_2^?}]{}[{.}\mathsf{return} \mathrel{{=}{\oplus}} {t_2^?}]`, the expression :math:`{\mathit{expr}}` is valid with the result type :math:`{t_2^?}`.




The global :math:`(\mathsf{global}~{\mathit{gt}}~{\mathit{expr}})` is valid with the global type :math:`{\mathit{gt}}` if:


   * The global type :math:`{\mathit{gt}}` is valid.

   * The global type :math:`{\mathit{gt}}` is equal to :math:`({\mathit{mut}}~t)`.

   * The expression :math:`{\mathit{expr}}` is valid with the :ref:`number type <syntax-numtype>` :math:`t`.

   * :math:`{\mathit{expr}}` is constant.




The table :math:`(\mathsf{table}~{\mathit{tt}})` is valid with the table type :math:`{\mathit{tt}}` if:


   * The table type :math:`{\mathit{tt}}` is valid.




The memory :math:`(\mathsf{memory}~{\mathit{mt}})` is valid with the memory type :math:`{\mathit{mt}}` if:


   * The memory type :math:`{\mathit{mt}}` is valid.




The table segment :math:`(\mathsf{elem}~{\mathit{expr}}~{x^\ast})` is valid if:


   * The limits :math:`C{.}\mathsf{tables}{}[0]` is equal to :math:`{\mathit{lim}}`.

   * The expression :math:`{\mathit{expr}}` is valid with the :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}`.

   * :math:`{\mathit{expr}}` is constant.

   * :math:`{|{{\mathit{ft}}^\ast}|}` is equal to :math:`{|{x^\ast}|}`.

   * For all :math:`x` in :math:`{x^\ast}`:

      * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * For all :math:`{\mathit{ft}}` in :math:`{{\mathit{ft}}^\ast}` and :math:`x` in :math:`{x^\ast}`:

      * The function type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{\mathit{ft}}`.




The memory segment :math:`(\mathsf{data}~{\mathit{expr}}~{b^\ast})` is valid if:


   * The limits :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{lim}}`.

   * The expression :math:`{\mathit{expr}}` is valid with the :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}`.

   * :math:`{\mathit{expr}}` is constant.




The start function :math:`(\mathsf{start}~x)` is valid if:


   * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`\epsilon~\rightarrow~\epsilon`.




The import :math:`(\mathsf{import}~{\mathit{name}}_1~{\mathit{name}}_2~{\mathit{xt}})` is valid with the external type :math:`{\mathit{xt}}` if:


   * The external type :math:`{\mathit{xt}}` is valid.




The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid with the external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


   * Either:

      * The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~x)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{ft}})`.

      * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

      * The function type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{\mathit{ft}}`.

   * Or:

      * The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~x)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~{\mathit{gt}})`.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`{\mathit{gt}}`.
   * Or:

      * The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~x)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~{\mathit{tt}})`.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`{\mathit{tt}}`.
   * Or:

      * The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~x)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~{\mathit{mt}})`.

      * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

      * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`{\mathit{mt}}`.




The external index :math:`(\mathsf{func}~x)` is valid with the external type :math:`(\mathsf{func}~{\mathit{ft}})` if:


   * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{\mathit{ft}}`.




The external index :math:`(\mathsf{global}~x)` is valid with the external type :math:`(\mathsf{global}~{\mathit{gt}})` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`{\mathit{gt}}`.




The external index :math:`(\mathsf{table}~x)` is valid with the external type :math:`(\mathsf{table}~{\mathit{tt}})` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`{\mathit{tt}}`.




The external index :math:`(\mathsf{mem}~x)` is valid with the external type :math:`(\mathsf{mem}~{\mathit{mt}})` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`{\mathit{mt}}`.




The export :math:`(\mathsf{export}~{\mathit{name}}~{\mathit{externidx}})` is valid with the external type :math:`{\mathit{xt}}` if:


   * The external index :math:`{\mathit{externidx}}` is valid with the external type :math:`{\mathit{xt}}`.




The module :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` is valid if:


   * :math:`{|{{\mathit{ft}'}^\ast}|}` is equal to :math:`{|{{\mathit{type}}^\ast}|}`.

   * For all :math:`{\mathit{ft}'}` in :math:`{{\mathit{ft}'}^\ast}` and :math:`{\mathit{type}}` in :math:`{{\mathit{type}}^\ast}`:

      * The type :math:`{\mathit{type}}` is valid with the function type :math:`{\mathit{ft}'}`.

   * :math:`{|{{\mathit{import}}^\ast}|}` is equal to :math:`{|{{\mathit{ixt}}^\ast}|}`.

   * For all :math:`{\mathit{import}}` in :math:`{{\mathit{import}}^\ast}` and :math:`{\mathit{ixt}}` in :math:`{{\mathit{ixt}}^\ast}`:

      * Under the context :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{return}~\epsilon \}\end{array}`, the import :math:`{\mathit{import}}` is valid with the external type :math:`{\mathit{ixt}}`.

   * :math:`{|{{\mathit{global}}^\ast}|}` is equal to :math:`{|{{\mathit{gt}}^\ast}|}`.

   * For all :math:`{\mathit{global}}` in :math:`{{\mathit{global}}^\ast}` and :math:`{\mathit{gt}}` in :math:`{{\mathit{gt}}^\ast}`:

      * Under the context :math:`{C'}`, the global :math:`{\mathit{global}}` is valid with the global type :math:`{\mathit{gt}}`.

   * :math:`{|{{\mathit{ft}}^\ast}|}` is equal to :math:`{|{{\mathit{func}}^\ast}|}`.

   * For all :math:`{\mathit{ft}}` in :math:`{{\mathit{ft}}^\ast}` and :math:`{\mathit{func}}` in :math:`{{\mathit{func}}^\ast}`:

      * The function :math:`{\mathit{func}}` is valid with the function type :math:`{\mathit{ft}}`.

   * :math:`{|{{\mathit{table}}^\ast}|}` is equal to :math:`{|{{\mathit{tt}}^\ast}|}`.

   * For all :math:`{\mathit{table}}` in :math:`{{\mathit{table}}^\ast}` and :math:`{\mathit{tt}}` in :math:`{{\mathit{tt}}^\ast}`:

      * The table :math:`{\mathit{table}}` is valid with the table type :math:`{\mathit{tt}}`.

   * :math:`{|{{\mathit{mem}}^\ast}|}` is equal to :math:`{|{{\mathit{mt}}^\ast}|}`.

   * For all :math:`{\mathit{mem}}` in :math:`{{\mathit{mem}}^\ast}` and :math:`{\mathit{mt}}` in :math:`{{\mathit{mt}}^\ast}`:

      * The memory :math:`{\mathit{mem}}` is valid with the memory type :math:`{\mathit{mt}}`.

   * For all :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}`:

      * The table segment :math:`{\mathit{elem}}` is valid.

   * For all :math:`{\mathit{data}}` in :math:`{{\mathit{data}}^\ast}`:

      * The memory segment :math:`{\mathit{data}}` is valid.

   * If :math:`{\mathit{start}}` is defined, then:

      * The start function :math:`{\mathit{start}}` is valid.

   * :math:`{|{{\mathit{export}}^\ast}|}` is equal to :math:`{|{{\mathit{xt}}^\ast}|}`.

   * For all :math:`{\mathit{export}}` in :math:`{{\mathit{export}}^\ast}` and :math:`{\mathit{xt}}` in :math:`{{\mathit{xt}}^\ast}`:

      * The export :math:`{\mathit{export}}` is valid with the external type :math:`{\mathit{xt}}`.

   * :math:`{|{{\mathit{tt}}^\ast}|}` is less than or equal to :math:`1`.

   * :math:`{|{{\mathit{mt}}^\ast}|}` is less than or equal to :math:`1`.

   * The context :math:`C` is equal to :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{funcs}~{{\mathit{ift}}^\ast}~{{\mathit{ft}}^\ast},\; \mathsf{globals}~{{\mathit{igt}}^\ast}~{{\mathit{gt}}^\ast},\; \mathsf{tables}~{{\mathit{itt}}^\ast}~{{\mathit{tt}}^\ast},\; \mathsf{mems}~{{\mathit{imt}}^\ast}~{{\mathit{mt}}^\ast},\; \mathsf{return}~\epsilon \}\end{array}`.

   * The context :math:`{C'}` is equal to :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{funcs}~{{\mathit{ift}}^\ast}~{{\mathit{ft}}^\ast},\; \mathsf{globals}~{{\mathit{igt}}^\ast},\; \mathsf{return}~\epsilon \}\end{array}`.

   * The function type sequence :math:`{{\mathit{ift}}^\ast}` is equal to :math:`{\mathrm{funcs}}({{\mathit{ixt}}^\ast})`.

   * The global type sequence :math:`{{\mathit{igt}}^\ast}` is equal to :math:`{\mathrm{globals}}({{\mathit{ixt}}^\ast})`.

   * The table type sequence :math:`{{\mathit{itt}}^\ast}` is equal to :math:`{\mathrm{tables}}({{\mathit{ixt}}^\ast})`.

   * The memory type sequence :math:`{{\mathit{imt}}^\ast}` is equal to :math:`{\mathrm{mems}}({{\mathit{ixt}}^\ast})`.


:math:`\mathsf{unreachable}`
............................


1. Trap.


:math:`\mathsf{nop}`
....................


1. Do nothing.


:math:`\mathsf{drop}`
.....................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Do nothing.


:math:`\mathsf{select}`
.......................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_2` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_1` from the stack.

#. If :math:`c \neq 0`, then:

   a. Push the value :math:`{\mathit{val}}_1` to the stack.

#. Else:

   a. Push the value :math:`{\mathit{val}}_2` to the stack.


:math:`\mathsf{if}~{t^?}~{{\mathit{instr}}_1^\ast}~{{\mathit{instr}}_2^\ast}`
.............................................................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

   a. Execute the instruction :math:`(\mathsf{block}~{t^?}~{{\mathit{instr}}_1^\ast})`.

#. Else:

   a. Execute the instruction :math:`(\mathsf{block}~{t^?}~{{\mathit{instr}}_2^\ast})`.


:math:`\mathsf{label}`
......................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

#. Pop the current :math:`\mathsf{label}` context from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.


:math:`\mathsf{br}~n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`
.............................................................


1. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

#. Let :math:`({{\mathsf{label}}_{n}}{\{}~{{\mathit{instr}'}^\ast}~\})` be the current :math:`\mathsf{label}` context.

#. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 0`, then:

   a. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

   #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

   #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

   #. Pop the current :math:`\mathsf{label}` context from the stack.

   #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

   #. Execute the instruction :math:`{{\mathit{instr}'}^\ast}`.

#. Else:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}} \geq 1`, then:

      1) Let :math:`l` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}} - 1`.

      #) Pop the current :math:`\mathsf{label}` context from the stack.

      #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

      #) Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{br\_if}~l`
.........................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

   a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

   a. Do nothing.


:math:`\mathsf{br\_table}~{l^\ast}~{l'}`
........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i < {|{l^\ast}|}`, then:

   a. Execute the instruction :math:`(\mathsf{br}~{l^\ast}{}[i])`.

#. Else:

   a. Execute the instruction :math:`(\mathsf{br}~{l'})`.


:math:`\mathsf{frame}`
......................


1. Let :math:`({{\mathsf{frame}}_{n}}{\{}~f~\})` be the current :math:`\mathsf{frame}` context.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{frame}`.

#. Pop the current :math:`\mathsf{frame}` context from the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.


:math:`\mathsf{return}`
.......................


1. If the first non-value entry of the stack is a :math:`\mathsf{frame}`, then:

   a. Let :math:`({{\mathsf{frame}}_{n}}{\{}~f~\})` be the current :math:`\mathsf{frame}` context.

   #. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

   #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

   #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

   #. Pop the current :math:`\mathsf{frame}` context from the stack.

   #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Else if the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Pop the current :math:`\mathsf{label}` context from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`\mathsf{return}`.


:math:`t {.} {\mathit{unop}}`
.............................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`t` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{unop}}}{{}_{t}}{(c_1)}|} \leq 0`, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{unop}}}{{}_{t}}{(c_1)}`.

#. Push the value :math:`(t{.}\mathsf{const}~c)` to the stack.


:math:`t {.} {\mathit{binop}}`
..............................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`t` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{valtype}}_0` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{binop}}}{{}_{t}}{(c_1, c_2)}|} \leq 0`, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{binop}}}{{}_{t}}{(c_1, c_2)}`.

#. Push the value :math:`(t{.}\mathsf{const}~c)` to the stack.


:math:`t {.} {\mathit{testop}}`
...............................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`t` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{testop}}}{{}_{t}}{(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`t {.} {\mathit{relop}}`
..............................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`t` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{valtype}}_0` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{relop}}}{{}_{t}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`t_2 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{t_1}`
....................................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`t_1` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{cvtop}}}{{}_{t_1, t_2}}{(c_1)}|} \leq 0`, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{cvtop}}}{{}_{t_1, t_2}}{(c_1)}`.

#. Push the value :math:`(t_2{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{local{.}tee}~x`
..............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Execute the instruction :math:`(\mathsf{local{.}set}~x)`.


:math:`\mathsf{block}~{t^?}~{{\mathit{instr}}^\ast}`
....................................................


1. Let :math:`n` be :math:`0`.

#. If :math:`{t^?}` is not defined, then:

   a. Enter :math:`{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{n}}{\{}~\epsilon~\})`.

#. Let :math:`n` be :math:`1`.

#. If :math:`{t^?} \neq \epsilon`, then:

   a. Enter :math:`{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{n}}{\{}~\epsilon~\})`.


:math:`\mathsf{loop}~{t^?}~{{\mathit{instr}}^\ast}`
...................................................


1. Enter :math:`{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{0}}{\{}~(\mathsf{loop}~{t^?}~{{\mathit{instr}}^\ast})~\})`.


:math:`\mathsf{call}~x`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Execute the instruction :math:`(\mathsf{call}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x])`.


:math:`\mathsf{call\_indirect}~x`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[0]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`z{.}\mathsf{tables}{}[0]{.}\mathsf{refs}{}[i]` is not defined, then:

   a. Trap.

#. Let :math:`a` be :math:`z{.}\mathsf{tables}{}[0]{.}\mathsf{refs}{}[i]`.

#. If :math:`a \geq {|z{.}\mathsf{funcs}|}`, then:

   a. Trap.

#. If :math:`z{.}\mathsf{types}{}[x] \neq z{.}\mathsf{funcs}{}[a]{.}\mathsf{type}`, then:

   a. Trap.

#. Execute the instruction :math:`(\mathsf{call}~a)`.


:math:`\mathsf{call}~a`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`a < {|z{.}\mathsf{funcs}|}`.

#. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{t_1^{k}}~\rightarrow~{t_2^{n}},\; \mathsf{module}~{\mathit{mm}},\; \mathsf{code}~{\mathit{func}} \}\end{array}` be :math:`z{.}\mathsf{funcs}{}[a]`.

#. Let :math:`(\mathsf{func}~x~{{\mathit{local}}_0^\ast}~{{\mathit{instr}}^\ast})` be :math:`{\mathit{func}}`.

#. Let :math:`{(\mathsf{local}~t)^\ast}` be :math:`{{\mathit{local}}_0^\ast}`.

#. Assert: Due to validation, there are at least :math:`k` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~{{\mathit{val}}^{k}}~{{{\mathrm{default}}}_{t}^\ast},\; \mathsf{module}~{\mathit{mm}} \}\end{array}`.

#. Push the :ref:`frame <syntax-frame>` :math:`({{\mathsf{frame}}_{n}}{\{}~f~\})` to the stack.

#. Enter :math:`{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{n}}{\{}~\epsilon~\})`.


:math:`\mathsf{local{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Push the value :math:`z{.}\mathsf{locals}{}[x]` to the stack.


:math:`\mathsf{global{.}get}~x`
...............................


1. Let :math:`z` be the current state.

#. Push the value :math:`z{.}\mathsf{globals}{}[x]{.}\mathsf{value}` to the stack.


:math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{load}}{{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}}~{\mathit{ao}}`
......................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

   a. Let :math:`t` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|t|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{t}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|t|} / 8]`.

   #. Push the value :math:`(t{.}\mathsf{const}~c)` to the stack.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

      1) Let :math:`{\mathit{loadop\_{\scriptstyle 0}}}` be :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}`.

      #) Let :math:`{n}{\mathsf{\_}}{{\mathit{sx}}}` be :math:`{\mathit{loadop\_{\scriptstyle 0}}}`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

         a) Trap.

   #. Let :math:`{\mathsf{i}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

      1) Let :math:`{\mathit{loadop\_{\scriptstyle 0}}}` be :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}`.

      #) Let :math:`{n}{\mathsf{\_}}{{\mathit{sx}}}` be :math:`{\mathit{loadop\_{\scriptstyle 0}}}`.

      #) Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8]`.

      #) Push the value :math:`({\mathsf{i}}{n}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{n, {|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{(c)})` to the stack.


:math:`\mathsf{memory{.}size}`
..............................


1. Let :math:`z` be the current state.

#. Let :math:`n \cdot 64 \cdot {\mathrm{Ki}}` be :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{local{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{locals}{}[x] = {\mathit{val}}]`.


:math:`\mathsf{global{.}set}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = {\mathit{val}}]`.


:math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{store}}{{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~{\mathit{ao}}`
.............................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is on the top of the stack.

#. Pop the value :math:`(t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Let :math:`t` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|t|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}` and :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = t` and :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

   a. Trap.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = t` and :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

   a. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{t}(c)`.

   #. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|t|} / 8] = {b^\ast}]`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is :math:`{\mathsf{i}}{n}`, then:

   a. Let :math:`{\mathsf{i}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

   #. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = {\mathsf{i}}{n}` and :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

      1) Let :math:`n` be :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}({{\mathrm{wrap}}}_{{|{\mathsf{i}}{n}|}, n}(c))`.

      #) Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8] = {b^\ast}]`.


:math:`\mathsf{memory{.}grow}`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Either:

   a. Let :math:`{\mathit{mi}}` be :math:`{\mathrm{growmemory}}(z{.}\mathsf{mems}{}[0], n)`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|} / (64 \, {\mathrm{Ki}}))` to the stack.

   #. Perform :math:`z{}[{.}\mathsf{mems}{}[0] = {\mathit{mi}}]`.

#. Or:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{32}^{{-1}}}}{({-1})})` to the stack.


:math:`{\mathrm{Ki}}`
.....................


1. Return :math:`1024`.


:math:`{\mathrm{min}}(i, j)`
............................


1. If :math:`i \leq j`, then:

   a. Return :math:`i`.

#. Return :math:`j`.


:math:`{\mathrm{sum}}({n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................


1. If :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`0`.

#. Let :math:`n~{{n'}^\ast}` be :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`n + {\mathrm{sum}}({{n'}^\ast})`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`
........................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} = 1`.

#. Let :math:`w` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`w`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`
.....................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

   a. Return :math:`\epsilon`.

#. Let :math:`w` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

#. Return :math:`w`.


:math:`{\mathrm{concat}}({X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
...........................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{w^\ast}~{{{w'}^\ast}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{w^\ast}~{\mathrm{concat}}({{{w'}^\ast}^\ast})`.


:math:`{\mathrm{signif}}(N_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
....................................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 32`, then:

   a. Return :math:`23`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 64`.

#. Return :math:`52`.


:math:`{\mathrm{expon}}(N_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
...................................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 32`, then:

   a. Return :math:`8`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 64`.

#. Return :math:`11`.


:math:`M`
.........


1. Return :math:`{\mathrm{signif}}(N)`.


:math:`E`
.........


1. Return :math:`{\mathrm{expon}}(N)`.


:math:`{+0}`
............


1. Return :math:`({+((0 + 0 \cdot {2^{{-M}}}) \cdot {2^{e}})})`.


:math:`{+1}`
............


1. Return :math:`({+((1 + 1 \cdot {2^{{-M}}}) \cdot {2^{0}})})`.


:math:`{{\mathrm{canon}}}_{N}`
..............................


1. Return :math:`{2^{{\mathrm{signif}}(N) - 1}}`.


:math:`{|t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}|}`
.....................................................


1. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 32}}`, then:

   a. Return :math:`32`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 64}}`, then:

   a. Return :math:`64`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 32}}`, then:

   a. Return :math:`32`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 64}}`, then:

   a. Return :math:`64`.


:math:`{\mathrm{funcs}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
......................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is :math:`\mathsf{func}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{ft}})` be :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{ft}}~{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is :math:`\mathsf{global}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{gt}})` be :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{gt}}~{\mathrm{globals}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is :math:`\mathsf{table}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{tt}})` be :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{tt}}~{\mathrm{tables}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is :math:`\mathsf{mem}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{mt}})` be :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{mt}}~{\mathrm{mems}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xt}}^\ast})`.






1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{align}~0,\; \mathsf{offset}~0 \}\end{array}`.


:math:`{{\mathrm{signed}}}_{N}(i)`
..................................


1. If :math:`i < {2^{N - 1}}`, then:

   a. Return :math:`i`.

#. Assert: Due to validation, :math:`{2^{N - 1}} \leq i`.

#. Assert: Due to validation, :math:`i < {2^{N}}`.

#. Return :math:`i - {2^{N}}`.


:math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{(i)}`
...............................................


1. Let :math:`j` be the result for which :math:`{{\mathrm{signed}}}_{N}(j)` :math:`=` :math:`i`.

#. Return :math:`j`.


:math:`{{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}{(c_{\mathit{u{\kern-0.1em\scriptstyle 1}}})}`
..............................................................................................................................................................


1. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{n}`, then:

   a. Let :math:`{\mathsf{i}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Let :math:`{\mathit{iN}}` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{clz}`, then:

      1) Return :math:`{{\mathrm{iclz}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}})`.

   #. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ctz}`, then:

      1) Return :math:`{{\mathrm{ictz}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}})`.

   #. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{popcnt}`, then:

      1) Return :math:`{{\mathrm{ipopcnt}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}})`.

#. Assert: Due to validation, :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{n}`.

#. Let :math:`{\mathsf{f}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{abs}`, then:

   a. Return :math:`{{\mathrm{fabs}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}})`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{neg}`, then:

   a. Return :math:`{{\mathrm{fneg}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}})`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sqrt}`, then:

   a. Return :math:`{{\mathrm{fsqrt}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}})`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ceil}`, then:

   a. Return :math:`{{\mathrm{fceil}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}})`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{floor}`, then:

   a. Return :math:`{{\mathrm{ffloor}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}})`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{trunc}`, then:

   a. Return :math:`{{\mathrm{ftrunc}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}})`.

#. Assert: Due to validation, :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{nearest}`.

#. Return :math:`{{\mathrm{fnearest}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}})`.


:math:`{{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}{(c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, c_{\mathit{u{\kern-0.1em\scriptstyle 2}}})}`
..........................................................................................................................................................................................................


1. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{n}`, then:

   a. Let :math:`{\mathsf{i}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Let :math:`{\mathit{iN}}_1` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Let :math:`{\mathit{iN}}_2` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{add}`, then:

      1) Return :math:`{{\mathrm{iadd}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sub}`, then:

      1) Return :math:`{{\mathrm{isub}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{mul}`, then:

      1) Return :math:`{{\mathrm{imul}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{div}`, then:

      1) Let :math:`({\mathsf{div}}{{\mathit{sx}}})` be :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{idiv}}}_{{|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{rem}`, then:

      1) Let :math:`({\mathsf{rem}}{{\mathit{sx}}})` be :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{irem}}}_{{|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{and}`, then:

      1) Return :math:`{{\mathrm{iand}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{or}`, then:

      1) Return :math:`{{\mathrm{ior}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{xor}`, then:

      1) Return :math:`{{\mathrm{ixor}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{shl}`, then:

      1) Return :math:`{{\mathrm{ishl}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{shr}`, then:

      1) Let :math:`({\mathsf{shr}}{{\mathit{sx}}})` be :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{ishr}}}_{{|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{rotl}`, then:

      1) Return :math:`{{\mathrm{irotl}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{rotr}`, then:

      1) Return :math:`{{\mathrm{irotr}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. Assert: Due to validation, :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{n}`.

#. Let :math:`{\mathsf{f}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_2` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{add}`, then:

   a. Return :math:`{{\mathrm{fadd}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sub}`, then:

   a. Return :math:`{{\mathrm{fsub}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{mul}`, then:

   a. Return :math:`{{\mathrm{fmul}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{div}`, then:

   a. Return :math:`{{\mathrm{fdiv}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{min}`, then:

   a. Return :math:`{{\mathrm{fmin}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{max}`, then:

   a. Return :math:`{{\mathrm{fmax}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{copysign}`.

#. Return :math:`{{\mathrm{fcopysign}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.


:math:`{\mathsf{eqz}}{{}_{{\mathsf{i}}{n}}}{({\mathit{iN}})}`
.............................................................


1. Return :math:`{{\mathrm{ieqz}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}})`.


:math:`{{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}{(c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, c_{\mathit{u{\kern-0.1em\scriptstyle 2}}})}`
..........................................................................................................................................................................................................


1. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{n}`, then:

   a. Let :math:`{\mathsf{i}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Let :math:`{\mathit{iN}}_1` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Let :math:`{\mathit{iN}}_2` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

   #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{eq}`, then:

      1) Return :math:`{{\mathrm{ieq}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ne}`, then:

      1) Return :math:`{{\mathrm{ine}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{lt}`, then:

      1) Let :math:`({\mathsf{lt}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{ilt}}}_{{|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{gt}`, then:

      1) Let :math:`({\mathsf{gt}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{igt}}}_{{|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{le}`, then:

      1) Let :math:`({\mathsf{le}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{ile}}}_{{|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ge}`, then:

      1) Let :math:`({\mathsf{ge}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{ige}}}_{{|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

#. Assert: Due to validation, :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{n}`.

#. Let :math:`{\mathsf{f}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_2` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{eq}`, then:

   a. Return :math:`{{\mathrm{feq}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ne}`, then:

   a. Return :math:`{{\mathrm{fne}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{lt}`, then:

   a. Return :math:`{{\mathrm{flt}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{gt}`, then:

   a. Return :math:`{{\mathrm{fgt}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{le}`, then:

   a. Return :math:`{{\mathrm{fle}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ge}`.

#. Return :math:`{{\mathrm{fge}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.


:math:`{{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}}}{(c_{\mathit{u{\kern-0.1em\scriptstyle 1}}})}`
..........................................................................................................................................................................................................


1. If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{extend}`, then:

   a. Let :math:`(\mathsf{extend}~{\mathit{sx}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Let :math:`{\mathit{iN}}` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 32}}` and :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}} = \mathsf{i{\scriptstyle 64}}`, then:

      1) Return :math:`{{{{\mathrm{extend}}}_{32, 64}^{{\mathit{sx}}}}}{({\mathit{iN}})}`.

#. Let :math:`{\mathit{iN}}` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 64}}` and :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}} = \mathsf{i{\scriptstyle 32}}` and :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{wrap}`, then:

   a. Return :math:`{{\mathrm{wrap}}}_{64, 32}({\mathit{iN}})`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{n}`, then:

   a. Let :math:`{\mathsf{f}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is :math:`{\mathsf{i}}{n}`, then:

      1) Let :math:`{\mathsf{i}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

      #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{trunc}`, then:

         a) Let :math:`(\mathsf{trunc}~{\mathit{sx}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Let :math:`{\mathit{fN}}` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Return :math:`{{{{\mathrm{trunc}}}_{{|{\mathsf{f}}{n}|}, {|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{fN}})}`.

#. Let :math:`{\mathit{fN}}` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 32}}` and :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}} = \mathsf{f{\scriptstyle 64}}` and :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{promote}`, then:

   a. Return :math:`{{\mathrm{promote}}}_{32, 64}({\mathit{fN}})`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 64}}` and :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}} = \mathsf{f{\scriptstyle 32}}` and :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{demote}`, then:

   a. Return :math:`{{\mathrm{demote}}}_{64, 32}({\mathit{fN}})`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{n}`, then:

   a. Let :math:`{\mathsf{i}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is :math:`{\mathsf{f}}{n}`, then:

      1) Let :math:`{\mathsf{f}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

      #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{convert}`, then:

         a) Let :math:`(\mathsf{convert}~{\mathit{sx}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Return :math:`{{{{\mathrm{convert}}}_{{|{\mathsf{i}}{n}|}, {|{\mathsf{f}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}})}`.

      #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{reinterpret}` and :math:`{|{\mathsf{i}}{n}|} = {|{\mathsf{f}}{n}|}`, then:

         a) Return :math:`{{\mathrm{reinterpret}}}_{{\mathsf{i}}{n}, {\mathsf{f}}{n}}({\mathit{iN}})`.

#. Assert: Due to validation, :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{n}`.

#. Let :math:`{\mathsf{f}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Assert: Due to validation, :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is :math:`{\mathsf{i}}{n}`.

#. Let :math:`{\mathsf{i}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. Assert: Due to validation, :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{reinterpret}`.

#. Assert: Due to validation, :math:`{|{\mathsf{i}}{n}|} = {|{\mathsf{f}}{n}|}`.

#. Return :math:`{{\mathrm{reinterpret}}}_{{\mathsf{f}}{n}, {\mathsf{i}}{n}}({\mathit{fN}})`.


:math:`{{\mathrm{invibytes}}}_{N}({b^\ast})`
............................................


1. Let :math:`n` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(n)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`n`.


:math:`{{\mathrm{invfbytes}}}_{N}({b^\ast})`
............................................


1. Let :math:`p` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{f}}{N}}(p)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`p`.


:math:`{{\mathrm{default}}}_{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}`
........................................................................


1. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 32}}`, then:

   a. Return :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 64}}`, then:

   a. Return :math:`(\mathsf{i{\scriptstyle 64}}{.}\mathsf{const}~0)`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 32}}`, then:

   a. Return :math:`(\mathsf{f{\scriptstyle 32}}{.}\mathsf{const}~{+0})`.

#. Assert: Due to validation, :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 64}}`.

#. Return :math:`(\mathsf{f{\scriptstyle 64}}{.}\mathsf{const}~{+0})`.


:math:`{\mathrm{funcs}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
......................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is :math:`\mathsf{func}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{fa}})` be :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{fa}}~{\mathrm{funcs}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is :math:`\mathsf{global}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{ga}})` be :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ga}}~{\mathrm{globals}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is :math:`\mathsf{table}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{ta}})` be :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ta}}~{\mathrm{tables}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is :math:`\mathsf{mem}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{ma}})` be :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ma}}~{\mathrm{mems}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xv}}^\ast})`.


:math:`(s, f){.}\mathsf{store}`
...............................


1. Return.


:math:`(s, f){.}\mathsf{frame}`
...............................


1. Return :math:`f`.


:math:`(s, f){.}\mathsf{module}{.}\mathsf{funcs}`
.................................................


1. Return :math:`f{.}\mathsf{module}{.}\mathsf{funcs}`.


:math:`(s, f){.}\mathsf{funcs}`
...............................


1. Return :math:`s{.}\mathsf{funcs}`.


:math:`(s, f){.}\mathsf{globals}`
.................................


1. Return :math:`s{.}\mathsf{globals}`.


:math:`(s, f){.}\mathsf{tables}`
................................


1. Return :math:`s{.}\mathsf{tables}`.


:math:`(s, f){.}\mathsf{mems}`
..............................


1. Return :math:`s{.}\mathsf{mems}`.


:math:`(s, f){.}\mathsf{module}`
................................


1. Return :math:`f{.}\mathsf{module}`.


:math:`(s, f){.}\mathsf{types}{}[x]`
....................................


1. Return :math:`f{.}\mathsf{module}{.}\mathsf{types}{}[x]`.


:math:`(s, f){.}\mathsf{funcs}{}[x]`
....................................


1. Return :math:`s{.}\mathsf{funcs}{}[f{.}\mathsf{module}{.}\mathsf{funcs}{}[x]]`.


:math:`(s, f){.}\mathsf{globals}{}[x]`
......................................


1. Return :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]`.


:math:`(s, f){.}\mathsf{tables}{}[x]`
.....................................


1. Return :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]`.


:math:`(s, f){.}\mathsf{mems}{}[x]`
...................................


1. Return :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]`.


:math:`(s, f){.}\mathsf{locals}{}[x]`
.....................................


1. Return :math:`f{.}\mathsf{locals}{}[x]`.


:math:`(s, f){}[{.}\mathsf{locals}{}[x] = v]`
.............................................


1. Replace :math:`f{.}\mathsf{locals}{}[x]` with :math:`v`.


:math:`(s, f){}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = v]`
...............................................................


1. Replace :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]{.}\mathsf{value}` with :math:`v`.


:math:`(s, f){}[{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i] = a]`
..................................................................


1. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]{.}\mathsf{refs}{}[i]` with :math:`a`.


:math:`(s, f){}[{.}\mathsf{tables}{}[x] = {\mathit{ti}}]`
.........................................................


1. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]` with :math:`{\mathit{ti}}`.


:math:`(s, f){}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i : j] = {b^\ast}]`
............................................................................


1. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]{.}\mathsf{bytes}{}[i : j]` with :math:`{b^\ast}`.


:math:`(s, f){}[{.}\mathsf{mems}{}[x] = {\mathit{mi}}]`
.......................................................


1. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]` with :math:`{\mathit{mi}}`.


:math:`{\mathrm{growtable}}({\mathit{ti}}, n)`
..............................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{}[~i~..~j~],\; \mathsf{refs}~{a^\ast} \}\end{array}` be :math:`{\mathit{ti}}`.

#. Let :math:`{i'}` be :math:`{|{a^\ast}|} + n`.

#. If :math:`{i'} \leq j`, then:

   a. Let :math:`{\mathit{ti}'}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{}[~{i'}~..~j~],\; \mathsf{refs}~{a^\ast}~{\epsilon^{n}} \}\end{array}`.

   #. Return :math:`{\mathit{ti}'}`.


:math:`{\mathrm{growmemory}}({\mathit{mi}}, n)`
...............................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{}[~i~..~j~],\; \mathsf{bytes}~{b^\ast} \}\end{array}` be :math:`{\mathit{mi}}`.

#. Let :math:`{i'}` be :math:`{|{b^\ast}|} / (64 \, {\mathrm{Ki}}) + n`.

#. If :math:`{i'} \leq j`, then:

   a. Let :math:`{\mathit{mi}'}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{}[~{i'}~..~j~],\; \mathsf{bytes}~{b^\ast}~{\mathtt{0x00}^{n \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

   #. Return :math:`{\mathit{mi}'}`.


:math:`{\mathrm{funcs}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
......................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is :math:`\mathsf{func}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{fa}})` be :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{fa}}~{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is :math:`\mathsf{global}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{ga}})` be :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ga}}~{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is :math:`\mathsf{table}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{ta}})` be :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ta}}~{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is :math:`\mathsf{mem}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{ma}})` be :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ma}}~{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{allocfunc}}(s, {\mathit{moduleinst}}, {\mathit{func}})`
.......................................................................


1. Let :math:`(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}})` be :math:`{\mathit{func}}`.

#. Let :math:`{\mathit{fi}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{moduleinst}}{.}\mathsf{types}{}[x],\; \mathsf{module}~{\mathit{moduleinst}},\; \mathsf{code}~{\mathit{func}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{funcs}|}`.

#. Append :math:`{\mathit{fi}}` to :math:`s{.}\mathsf{funcs}`.

#. Return :math:`a`.


:math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................................................


1. If :math:`{{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{func}}~{{\mathit{func}'}^\ast}` be :math:`{{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{fa}}` be :math:`{\mathrm{allocfunc}}(s, {\mathit{moduleinst}}, {\mathit{func}})`.

#. Let :math:`{{\mathit{fa}'}^\ast}` be :math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}'}^\ast})`.

#. Return :math:`{\mathit{fa}}~{{\mathit{fa}'}^\ast}`.


:math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`
........................................................................


1. Let :math:`{\mathit{gi}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{globaltype}},\; \mathsf{value}~{\mathit{val}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{globals}|}`.

#. Append :math:`{\mathit{gi}}` to :math:`s{.}\mathsf{globals}`.

#. Return :math:`a`.


:math:`{\mathrm{allocglobals}}(s, {{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
..................................................................................................................................................


1. If :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Assert: Due to validation, :math:`{v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`.

   #. Return :math:`\epsilon`.

#. Else:

   a. Let :math:`{\mathit{globaltype}}~{{\mathit{globaltype}'}^\ast}` be :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

   #. Assert: Due to validation, :math:`{|{v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

   #. Let :math:`{\mathit{val}}~{{\mathit{val}'}^\ast}` be :math:`{v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

   #. Let :math:`{\mathit{ga}}` be :math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`.

   #. Let :math:`{{\mathit{ga}'}^\ast}` be :math:`{\mathrm{allocglobals}}(s, {{\mathit{globaltype}'}^\ast}, {{\mathit{val}'}^\ast})`.

   #. Return :math:`{\mathit{ga}}~{{\mathit{ga}'}^\ast}`.


:math:`{\mathrm{alloctable}}(s, {}[~i~..~j~])`
..............................................


1. Let :math:`{\mathit{ti}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{}[~i~..~j~],\; \mathsf{refs}~{\epsilon^{i}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{tables}|}`.

#. Append :math:`{\mathit{ti}}` to :math:`s{.}\mathsf{tables}`.

#. Return :math:`a`.


:math:`{\mathrm{alloctables}}(s, {{\mathit{tt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
...............................................................................................


1. If :math:`{{\mathit{tt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{tabletype}}~{{\mathit{tabletype}'}^\ast}` be :math:`{{\mathit{tt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{ta}}` be :math:`{\mathrm{alloctable}}(s, {\mathit{tabletype}})`.

#. Let :math:`{{\mathit{ta}'}^\ast}` be :math:`{\mathrm{alloctables}}(s, {{\mathit{tabletype}'}^\ast})`.

#. Return :math:`{\mathit{ta}}~{{\mathit{ta}'}^\ast}`.


:math:`{\mathrm{allocmem}}(s, {}[~i~..~j~])`
............................................


1. Let :math:`{\mathit{mi}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{}[~i~..~j~],\; \mathsf{bytes}~{\mathtt{0x00}^{i \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{mems}|}`.

#. Append :math:`{\mathit{mi}}` to :math:`s{.}\mathsf{mems}`.

#. Return :math:`a`.


:math:`{\mathrm{allocmems}}(s, {{\mathit{mt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.............................................................................................


1. If :math:`{{\mathit{mt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{memtype}}~{{\mathit{memtype}'}^\ast}` be :math:`{{\mathit{mt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{ma}}` be :math:`{\mathrm{allocmem}}(s, {\mathit{memtype}})`.

#. Let :math:`{{\mathit{ma}'}^\ast}` be :math:`{\mathrm{allocmems}}(s, {{\mathit{memtype}'}^\ast})`.

#. Return :math:`{\mathit{ma}}~{{\mathit{ma}'}^\ast}`.


:math:`{\mathrm{instexport}}({{\mathit{fa}}^\ast}, {{\mathit{ga}}^\ast}, {{\mathit{ta}}^\ast}, {{\mathit{ma}}^\ast}, \mathsf{export}~{\mathit{name}}~{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
...................................................................................................................................................................................................................


1. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{func}`, then:

   a. Let :math:`(\mathsf{func}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{func}~{{\mathit{fa}}^\ast}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{global}`, then:

   a. Let :math:`(\mathsf{global}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{global}~{{\mathit{ga}}^\ast}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{table}`, then:

   a. Let :math:`(\mathsf{table}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{table}~{{\mathit{ta}}^\ast}{}[x]) \}\end{array}`.

#. Assert: Due to validation, :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{mem}`.

#. Let :math:`(\mathsf{mem}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{mem}~{{\mathit{ma}}^\ast}{}[x]) \}\end{array}`.


:math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}^\ast})`
.........................................................................................................


1. Let :math:`(\mathsf{module}~{{\mathit{type}}_0^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^{n_{\mathit{func}}}}~{{\mathit{global}}_1^\ast}~{{\mathit{table}}_2^\ast}~{{\mathit{mem}}_3^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be :math:`{\mathit{module}}`.

#. Let :math:`{(\mathsf{memory}~{\mathit{memtype}})^{n_{\mathit{mem}}}}` be :math:`{{\mathit{mem}}_3^\ast}`.

#. Let :math:`{(\mathsf{table}~{\mathit{tabletype}})^{n_{\mathit{table}}}}` be :math:`{{\mathit{table}}_2^\ast}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_1)^{n_{\mathit{global}}}}` be :math:`{{\mathit{global}}_1^\ast}`.

#. Let :math:`{(\mathsf{type}~{\mathit{ft}})^\ast}` be :math:`{{\mathit{type}}_0^\ast}`.

#. Let :math:`{{\mathit{fa}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ga}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{globals}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ma}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{mems}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ta}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{tables}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{fa}}^\ast}` be :math:`{({|s{.}\mathsf{funcs}|} + i_{\mathit{func}})^{i_{\mathit{func}}<n_{\mathit{func}}}}`.

#. Let :math:`{{\mathit{ga}}^\ast}` be :math:`{({|s{.}\mathsf{globals}|} + i_{\mathit{global}})^{i_{\mathit{global}}<n_{\mathit{global}}}}`.

#. Let :math:`{{\mathit{ta}}^\ast}` be :math:`{({|s{.}\mathsf{tables}|} + i_{\mathit{table}})^{i_{\mathit{table}}<n_{\mathit{table}}}}`.

#. Let :math:`{{\mathit{ma}}^\ast}` be :math:`{({|s{.}\mathsf{mems}|} + i_{\mathit{mem}})^{i_{\mathit{mem}}<n_{\mathit{mem}}}}`.

#. Let :math:`{{\mathit{xi}}^\ast}` be :math:`{{\mathrm{instexport}}({{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast}, {{\mathit{ga}}_{\mathit{ex}}^\ast}~{{\mathit{ga}}^\ast}, {{\mathit{ta}}_{\mathit{ex}}^\ast}~{{\mathit{ta}}^\ast}, {{\mathit{ma}}_{\mathit{ex}}^\ast}~{{\mathit{ma}}^\ast}, {\mathit{export}})^\ast}`.

#. Let :math:`{\mathit{moduleinst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}}^\ast},\; \mathsf{funcs}~{{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast},\; \mathsf{globals}~{{\mathit{ga}}_{\mathit{ex}}^\ast}~{{\mathit{ga}}^\ast},\; \mathsf{tables}~{{\mathit{ta}}_{\mathit{ex}}^\ast}~{{\mathit{ta}}^\ast},\; \mathsf{mems}~{{\mathit{ma}}_{\mathit{ex}}^\ast}~{{\mathit{ma}}^\ast},\; \mathsf{exports}~{{\mathit{xi}}^\ast} \}\end{array}`.

#. Let :math:`{{\mathit{funcaddr}}_0^\ast}` be :math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}}^{n_{\mathit{func}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{funcaddr}}_0^\ast} = {{\mathit{fa}}^\ast}`.

#. Let :math:`{{\mathit{globaladdr}}_0^\ast}` be :math:`{\mathrm{allocglobals}}(s, {{\mathit{globaltype}}^{n_{\mathit{global}}}}, {{\mathit{val}}^\ast})`.

#. Assert: Due to validation, :math:`{{\mathit{globaladdr}}_0^\ast} = {{\mathit{ga}}^\ast}`.

#. Let :math:`{{\mathit{tableaddr}}_0^\ast}` be :math:`{\mathrm{alloctables}}(s, {{\mathit{tabletype}}^{n_{\mathit{table}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{tableaddr}}_0^\ast} = {{\mathit{ta}}^\ast}`.

#. Let :math:`{{\mathit{memaddr}}_0^\ast}` be :math:`{\mathrm{allocmems}}(s, {{\mathit{memtype}}^{n_{\mathit{mem}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{memaddr}}_0^\ast} = {{\mathit{ma}}^\ast}`.

#. Return :math:`{\mathit{moduleinst}}`.


:math:`{\mathrm{initelem}}(s, {\mathit{moduleinst}}, {i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {{\mathit{fa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................................................................................................


1. If :math:`{i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon` and :math:`{{\mathit{fa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return.

#. Assert: Due to validation, :math:`{|{{\mathit{fa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{a^\ast}~{{{a'}^\ast}^\ast}` be :math:`{{\mathit{fa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`i~{{i'}^\ast}` be :math:`{i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Replace :math:`s{.}\mathsf{tables}{}[{\mathit{moduleinst}}{.}\mathsf{tables}{}[0]]{.}\mathsf{refs}{}[i : {|{a^\ast}|}]` with :math:`{a^\ast}`.

#. Perform :math:`{\mathrm{initelem}}(s, {\mathit{moduleinst}}, {{i'}^\ast}, {{{a'}^\ast}^\ast})`.

#. Return.


:math:`{\mathrm{initdata}}(s, {\mathit{moduleinst}}, {i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.........................................................................................................................................................


1. If :math:`{i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon` and :math:`{b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return.

#. Assert: Due to validation, :math:`{|{b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{b^\ast}~{{{b'}^\ast}^\ast}` be :math:`{b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`i~{{i'}^\ast}` be :math:`{i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Replace :math:`s{.}\mathsf{mems}{}[{\mathit{moduleinst}}{.}\mathsf{mems}{}[0]]{.}\mathsf{bytes}{}[i : {|{b^\ast}|}]` with :math:`{b^\ast}`.

#. Perform :math:`{\mathrm{initdata}}(s, {\mathit{moduleinst}}, {{i'}^\ast}, {{{b'}^\ast}^\ast})`.

#. Return.


:math:`{\mathrm{instantiate}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast})`
..................................................................................


1. Let :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be :math:`{\mathit{module}}`.

#. Let :math:`{(\mathsf{type}~{\mathit{functype}})^\ast}` be :math:`{{\mathit{type}}^\ast}`.

#. Let :math:`n_{\mathsf{f}}` be :math:`{|{{\mathit{func}}^\ast}|}`.

#. Let :math:`{(\mathsf{start}~{x'})^?}` be :math:`{{\mathit{start}}^?}`.

#. Let :math:`{(\mathsf{data}~{\mathit{expr}}_{\mathsf{d}}~{b^\ast})^\ast}` be :math:`{{\mathit{data}}^\ast}`.

#. Let :math:`{(\mathsf{elem}~{\mathit{expr}}_{\mathsf{e}}~{x^\ast})^\ast}` be :math:`{{\mathit{elem}}^\ast}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_{\mathsf{g}})^\ast}` be :math:`{{\mathit{global}}^\ast}`.

#. Let :math:`{\mathit{moduleinst}}_{\mathit{init}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{functype}}^\ast},\; \mathsf{funcs}~{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})~{({|s{.}\mathsf{funcs}|} + i_{\mathsf{f}})^{i_{\mathsf{f}}<n_{\mathsf{f}}}},\; \mathsf{globals}~{\mathrm{globals}}({{\mathit{externaddr}}^\ast}) \}\end{array}`.

#. Let :math:`f_{\mathit{init}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{module}~{\mathit{moduleinst}}_{\mathit{init}} \}\end{array}`.

#. Let :math:`z` be :math:`(s, f_{\mathit{init}})`.

#. Push the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~z{.}\mathsf{frame}~\})` to the stack.

#. Let :math:`{(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_{\mathsf{d}})^\ast}` be the result of :ref:`evaluating <exec-expr>` :math:`{{\mathit{expr}}_{\mathsf{d}}^\ast}` with state :math:`z`.

#. Pop the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~z{.}\mathsf{frame}~\})` from the stack.

#. Push the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~z{.}\mathsf{frame}~\})` to the stack.

#. Let :math:`{(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_{\mathsf{e}})^\ast}` be the result of :ref:`evaluating <exec-expr>` :math:`{{\mathit{expr}}_{\mathsf{e}}^\ast}` with state :math:`z`.

#. Pop the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~z{.}\mathsf{frame}~\})` from the stack.

#. Push the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~z{.}\mathsf{frame}~\})` to the stack.

#. Let :math:`{{\mathit{val}}^\ast}` be the result of :ref:`evaluating <exec-expr>` :math:`{{\mathit{expr}}_{\mathsf{g}}^\ast}` with state :math:`z`.

#. Pop the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~z{.}\mathsf{frame}~\})` from the stack.

#. Let :math:`{\mathit{moduleinst}}` be :math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}^\ast})`.

#. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{module}~{\mathit{moduleinst}} \}\end{array}`.

#. Perform :math:`{\mathrm{initelem}}(s, {\mathit{moduleinst}}, {i_{\mathsf{e}}^\ast}, {{{\mathit{moduleinst}}{.}\mathsf{funcs}{}[x]^\ast}^\ast})`.

#. Perform :math:`{\mathrm{initdata}}(s, {\mathit{moduleinst}}, {i_{\mathsf{d}}^\ast}, {{b^\ast}^\ast})`.

#. Push the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~f~\})` to the stack.

#. Execute the sequence :math:`{(\mathsf{call}~{x'})^?}`.

#. Pop the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~f~\})` from the stack.

#. Return :math:`f{.}\mathsf{module}`.


:math:`{\mathrm{invoke}}(s, {\mathit{fa}}, {{\mathit{val}}^{n}})`
.................................................................


1. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{module}~\{ \begin{array}[t]{@{}l@{}} \}\end{array} \}\end{array}`.

#. Push the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~(s, f)~\})` to the stack.

#. Let :math:`{t_1^{n}}~\rightarrow~{t_2^\ast}` be :math:`(s, f){.}\mathsf{funcs}{}[{\mathit{fa}}]{.}\mathsf{type}`.

#. Pop the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~f~\})` from the stack.

#. Let :math:`k` be :math:`{|{t_2^\ast}|}`.

#. Push the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{k}\,\{~f~\})` to the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{call}~{\mathit{fa}})`.

#. Pop all values :math:`{{\mathit{val}}_0^\ast}` from the top of the stack.

#. Pop the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{k}\,\{~f~\})` from the stack.

#. Push the values :math:`{{\mathit{val}}_0^\ast}` to the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Return :math:`{{\mathit{val}}^{k}}`.


:math:`\mathsf{eval\_expr}~{{\mathit{instr}}^\ast}`
...................................................


1. Execute the instruction :math:`{{\mathit{instr}}^\ast}`.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Return :math:`{\mathit{val}}`.


== Complete.
watsup 0.4 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...
Limits_ok
- the limits ([ n .. m ]) is valid with k if:
  - n is less than or equal to m.
  - m is less than or equal to k.

Functype_ok
- the function type t_1* -> t_2? is valid.

Globaltype_ok
- the global type (MUT? t) is valid.

Tabletype_ok
- the table type limits is valid if:
  - limits is valid with ((2 ^ 32) - 1).

Memtype_ok
- the memory type limits is valid if:
  - limits is valid with (2 ^ 16).

Externtype_ok
- the external type xt_u1 is valid if:
  - Either:
    - xt_u1 is (FUNC functype).
    - the function type functype is valid.
  - Or:
    - xt_u1 is (GLOBAL globaltype).
    - the global type globaltype is valid.
  - Or:
    - xt_u1 is (TABLE tabletype).
    - the table type tabletype is valid.
  - Or:
    - xt_u1 is (MEM memtype).
    - the memory type memtype is valid.

Externtype_ok/func
- the external type (FUNC functype) is valid if:
  - the function type functype is valid.

Externtype_ok/global
- the external type (GLOBAL globaltype) is valid if:
  - the global type globaltype is valid.

Externtype_ok/table
- the external type (TABLE tabletype) is valid if:
  - the table type tabletype is valid.

Externtype_ok/mem
- the external type (MEM memtype) is valid if:
  - the memory type memtype is valid.

Limits_sub
- the limits ([ n_11 .. n_12 ]) matches the limits ([ n_21 .. n_22 ]) if:
  - n_11 is greater than or equal to n_21.
  - n_12 is less than or equal to n_22.

Functype_sub
- the function type ft matches itself.

Globaltype_sub
- the global type gt matches itself.

Tabletype_sub
- the table type lim_1 matches the table type lim_2 if:
  - lim_1 matches lim_2.

Memtype_sub
- the memory type lim_1 matches the memory type lim_2 if:
  - lim_1 matches lim_2.

Externtype_sub
- the external type xt_u1 matches the external type xt_u2 if:
  - Either:
    - xt_u1 is (FUNC ft_1).
    - xt_u2 is (FUNC ft_2).
    - the function type ft_1 matches the function type ft_2.
  - Or:
    - xt_u1 is (GLOBAL gt_1).
    - xt_u2 is (GLOBAL gt_2).
    - the global type gt_1 matches the global type gt_2.
  - Or:
    - xt_u1 is (TABLE tt_1).
    - xt_u2 is (TABLE tt_2).
    - the table type tt_1 matches the table type tt_2.
  - Or:
    - xt_u1 is (MEM mt_1).
    - xt_u2 is (MEM mt_2).
    - the memory type mt_1 matches the memory type mt_2.

Externtype_sub/func
- the external type (FUNC ft_1) matches the external type (FUNC ft_2) if:
  - the function type ft_1 matches the function type ft_2.

Externtype_sub/global
- the external type (GLOBAL gt_1) matches the external type (GLOBAL gt_2) if:
  - the global type gt_1 matches the global type gt_2.

Externtype_sub/table
- the external type (TABLE tt_1) matches the external type (TABLE tt_2) if:
  - the table type tt_1 matches the table type tt_2.

Externtype_sub/mem
- the external type (MEM mt_1) matches the external type (MEM mt_2) if:
  - the memory type mt_1 matches the memory type mt_2.

Instr_ok/nop
- the instruction NOP is valid with the function type [] -> [].

Instr_ok/unreachable
- the instruction UNREACHABLE is valid with the function type t_1* -> t_2*.

Instr_ok/drop
- the instruction DROP is valid with the function type [t] -> [].

Instr_ok/select
- the instruction SELECT is valid with the function type [t, t, I32] -> [t].

Instr_ok/block
- the instruction (BLOCK t? instr*) is valid with the function type [] -> t? if:
  - the context C' is the context C with .LABELS prepended by [t?].
  - Under the context C', the instruction sequence instr* is valid with [] -> t?.

Instr_ok/loop
- the instruction (LOOP t? instr*) is valid with the function type [] -> t? if:
  - the instruction sequence instr* is valid with the function type [] -> [].

Instr_ok/if
- the instruction (IF t? instr_1* ELSE instr_2*) is valid with the function type [I32] -> t? if:
  - the context C' is the context C with .LABELS prepended by [t?].
  - Under the context C', the instruction sequence instr_1* is valid with the function type [] -> t?.
  - Under the context C', the instruction sequence instr_2* is valid with [] -> t?.

Instr_ok/br
- the instruction (BR l) is valid with the function type t_1* :: t? -> t_2* if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t?.

Instr_ok/br_if
- the instruction (BR_IF l) is valid with the function type t? :: [I32] -> t? if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t?.

Instr_ok/br_table
- the instruction (BR_TABLE l* l') is valid with the function type t_1* :: t? :: [I32] -> t_2* if:
  - the result type C.LABELS[l'] exists.
  - the result type t? is C.LABELS[l'].
  - For all l in l*:
    - the result type C.LABELS[l] exists.
  - For all l in l*:
    - t? is C.LABELS[l].

Instr_ok/call
- the instruction (CALL x) is valid with the function type t_1* -> t_2? if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is t_1* -> t_2?.

Instr_ok/call_indirect
- the instruction (CALL_INDIRECT x) is valid with the function type t_1* :: [I32] -> t_2? if:
  - the function type C.TYPES[x] exists.
  - C.TYPES[x] is t_1* -> t_2?.

Instr_ok/return
- the instruction RETURN is valid with the function type t_1* :: t? -> t_2* if:
  - the result type C.RETURN is ?(t?).

Instr_ok/const
- the instruction (t.CONST c_t) is valid with the function type [] -> [t].

Instr_ok/unop
- the instruction (UNOP t unop_t) is valid with the function type [t] -> [t].

Instr_ok/binop
- the instruction (BINOP t binop_t) is valid with the function type [t, t] -> [t].

Instr_ok/testop
- the instruction (TESTOP t testop_t) is valid with the function type [t] -> [I32].

Instr_ok/relop
- the instruction (RELOP t relop_t) is valid with the function type [t, t] -> [I32].

Instr_ok/cvtop
- the instruction (CVTOP nt_1 nt_2 cvtop_u1) is valid with the function type [nt_2] -> [nt_1] if:
  - Either:
    - cvtop_u1 is REINTERPRET.
    - $size(nt_1) is $size(nt_2).
  - Or:
    - cvtop_u1 is cvtop.

Instr_ok/local.get
- the instruction (LOCAL.GET x) is valid with the function type [] -> [t] if:
  - the number type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/local.set
- the instruction (LOCAL.SET x) is valid with the function type [t] -> [] if:
  - the number type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/local.tee
- the instruction (LOCAL.TEE x) is valid with the function type [t] -> [t] if:
  - the number type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/global.get
- the instruction (GLOBAL.GET x) is valid with the function type [] -> [t] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (mut t).

Instr_ok/global.set
- the instruction (GLOBAL.SET x) is valid with the function type [t] -> [] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?(MUT) t).

Instr_ok/memory.size
- the instruction MEMORY.SIZE is valid with the function type [] -> [I32] if:
  - the memory type C.MEMS[0] is mt.

Instr_ok/memory.grow
- the instruction MEMORY.GROW is valid with the function type [I32] -> [I32] if:
  - the memory type C.MEMS[0] is mt.

Instr_ok/load
- the instruction (LOAD t_u1 loadop__u1? memarg) is valid with the function type [I32] -> [t_u3] if:
  - the memory type C.MEMS[0] is mt.
  - Either:
    - the number type t_u1 is t.
    - loadop__u1? is ?().
    - the number type t_u3 is t.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(t) / 8).
  - Or:
    - t_u1 is Inn.
    - loadop__u1? is ?(M _ sx).
    - t_u3 is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store
- the instruction (STORE t_u1 sz_u1? memarg) is valid with the function type [I32, t_u2] -> [] if:
  - the memory type C.MEMS[0] is mt.
  - Either:
    - the number type t_u1 is t.
    - the pack size sz_u1? is ?().
    - the number type t_u2 is t.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(t) / 8).
  - Or:
    - t_u1 is Inn.
    - sz_u1? is ?(M).
    - t_u2 is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/cvtop-reinterpret
- the instruction (CVTOP nt_1 nt_2 REINTERPRET) is valid with the function type [nt_2] -> [nt_1] if:
  - $size(nt_1) is $size(nt_2).

Instr_ok/cvtop-convert
- the instruction (CVTOP nt_1 nt_2 cvtop) is valid with [nt_2] -> [nt_1].

Instr_ok/load-val
- the instruction (LOAD t ?() memarg) is valid with the function type [I32] -> [t] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(t) / 8).

Instr_ok/load-pack
- the instruction (LOAD Inn ?(M _ sx) memarg) is valid with the function type [I32] -> [Inn] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store-val
- the instruction (STORE t ?() memarg) is valid with the function type [I32, t] -> [] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(t) / 8).

Instr_ok/store-pack
- the instruction (STORE Inn ?(M) memarg) is valid with the function type [I32, Inn] -> [] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instrs_ok
- the instruction sequence instr_u1* is valid with the function type t_u1* -> t_u2* if:
  - Either:
    - instr_u1* is [].
    - the number type sequence t_u1* is [].
    - the number type sequence t_u2* is [].
  - Or:
    - instr_u1* is [instr_1] :: instr_2*.
    - t_u1* is t_1*.
    - t_u2* is t_3*.
    - the instruction instr_1 is valid with the function type t_1* -> t_2*.
    - the instruction sequence instr_2* is valid with the function type t_2* -> t_3*.
  - Or:
    - instr_u1* is instr*.
    - t_u1* is t* :: t_1*.
    - t_u2* is t* :: t_2*.
    - the instruction sequence instr* is valid with t_1* -> t_2*.

Instrs_ok/empty
- the instruction sequence [] is valid with the function type [] -> [].

Instrs_ok/seq
- the instruction sequence [instr_1] :: instr_2* is valid with the function type t_1* -> t_3* if:
  - the instruction instr_1 is valid with the function type t_1* -> t_2*.
  - the instruction sequence instr_2* is valid with the function type t_2* -> t_3*.

Instrs_ok/frame
- the instruction sequence instr* is valid with the function type t* :: t_1* -> t* :: t_2* if:
  - instr* is valid with the function type t_1* -> t_2*.

Expr_ok
- the expression instr* is valid with the result type t? if:
  - instr* is valid with the function type [] -> t?.

Instr_const
- the instruction instr_u1 is constant if:
  - Either:
    - instr_u1 is (t.CONST c).
  - Or:
    - instr_u1 is (GLOBAL.GET x).
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is (?() t).

Instr_const/const
- the instruction (t.CONST c) is constant.

Instr_const/global.get
- the instruction (GLOBAL.GET x) is constant if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?() t).

Expr_const
- the expression instr* is constant if:
  - For all instr in instr*:
    - the instruction instr is constant.

Type_ok
- the type (TYPE ft) is valid with the function type ft if:
  - ft is valid.

Func_ok
- the function (FUNC x (LOCAL t)* expr) is valid with the function type t_1* -> t_2? if:
  - the function type C.TYPES[x] exists.
  - C.TYPES[x] is t_1* -> t_2?.
  - Under the context C with .LOCALS appended by t_1* :: t* with .LABELS appended by [t_2?] with .RETURN appended by ?(t_2?), the expression expr is valid with the result type t_2?.

Global_ok
- the global (GLOBAL gt expr) is valid with the global type gt if:
  - gt is valid.
  - gt is (mut t).
  - the expression expr is valid with the number type ?(t).
  - expr is constant.

Table_ok
- the table (TABLE tt) is valid with the table type tt if:
  - tt is valid.

Mem_ok
- the memory (MEMORY mt) is valid with the memory type mt if:
  - mt is valid.

Elem_ok
- the table segment (ELEM expr x*) is valid if:
  - the limits C.TABLES[0] is lim.
  - the expression expr is valid with the number type ?(I32).
  - expr is constant.
  - |ft*| is |x*|.
  - For all x in x*:
    - the function type C.FUNCS[x] exists.
  - For all ft in ft* and x in x*:
    - C.FUNCS[x] is ft.

Data_ok
- the memory segment (DATA expr b*) is valid if:
  - the limits C.MEMS[0] is lim.
  - the expression expr is valid with the number type ?(I32).
  - expr is constant.

Start_ok
- the start function (START x) is valid if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is [] -> [].

Import_ok
- the import (IMPORT name_1 name_2 xt) is valid with the external type xt if:
  - xt is valid.

Externidx_ok
- the external index externidx_u1 is valid with the external type xt_u1 if:
  - Either:
    - externidx_u1 is (FUNC x).
    - xt_u1 is (FUNC ft).
    - the function type C.FUNCS[x] exists.
    - C.FUNCS[x] is ft.
  - Or:
    - externidx_u1 is (GLOBAL x).
    - xt_u1 is (GLOBAL gt).
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is gt.
  - Or:
    - externidx_u1 is (TABLE x).
    - xt_u1 is (TABLE tt).
    - the table type C.TABLES[x] exists.
    - C.TABLES[x] is tt.
  - Or:
    - externidx_u1 is (MEM x).
    - xt_u1 is (MEM mt).
    - the memory type C.MEMS[x] exists.
    - C.MEMS[x] is mt.

Externidx_ok/func
- the external index (FUNC x) is valid with the external type (FUNC ft) if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is ft.

Externidx_ok/global
- the external index (GLOBAL x) is valid with the external type (GLOBAL gt) if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is gt.

Externidx_ok/table
- the external index (TABLE x) is valid with the external type (TABLE tt) if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is tt.

Externidx_ok/mem
- the external index (MEM x) is valid with the external type (MEM mt) if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is mt.

Export_ok
- the export (EXPORT name externidx) is valid with the external type xt if:
  - the external index externidx is valid with xt.

Module_ok
- the module (MODULE type* import* func* global* table* mem* elem* data* start? export*) is valid if:
  - |ft'*| is |type*|.
  - For all ft' in ft'* and type in type*:
    - the type type is valid with the function type ft'.
  - |import*| is |ixt*|.
  - For all import in import* and ixt in ixt*:
    - Under the context { TYPES: ft'*; RETURN: ?() }, the import import is valid with the external type ixt.
  - |global*| is |gt*|.
  - For all global in global* and gt in gt*:
    - Under the context C', the global global is valid with the global type gt.
  - |ft*| is |func*|.
  - For all ft in ft* and func in func*:
    - the function func is valid with the function type ft.
  - |table*| is |tt*|.
  - For all table in table* and tt in tt*:
    - the table table is valid with the table type tt.
  - |mem*| is |mt*|.
  - For all mem in mem* and mt in mt*:
    - the memory mem is valid with the memory type mt.
  - For all elem in elem*:
    - the table segment elem is valid.
  - For all data in data*:
    - the memory segment data is valid.
  - If start is defined, then:
    - the start function start is valid.
  - |export*| is |xt*|.
  - For all export in export* and xt in xt*:
    - the export export is valid with the external type xt.
  - |tt*| is less than or equal to 1.
  - |mt*| is less than or equal to 1.
  - the context C is { TYPES: ft'*; FUNCS: ift* :: ft*; GLOBALS: igt* :: gt*; TABLES: itt* :: tt*; MEMS: imt* :: mt*; RETURN: ?() }.
  - the context C' is { TYPES: ft'*; FUNCS: ift* :: ft*; GLOBALS: igt*; RETURN: ?() }.
  - the function type sequence ift* is $funcsxt(ixt*).
  - the global type sequence igt* is $globalsxt(ixt*).
  - the table type sequence itt* is $tablesxt(ixt*).
  - the memory type sequence imt* is $memsxt(ixt*).

Step_pure/unreachable
1. Trap.

Step_pure/nop
1. Do nothing.

Step_pure/drop
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Do nothing.

Step_pure/select
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. Assert: Due to validation, a value is on the top of the stack.
4. Pop the value val_2 from the stack.
5. Assert: Due to validation, a value is on the top of the stack.
6. Pop the value val_1 from the stack.
7. If (c =/= 0), then:
  a. Push the value val_1 to the stack.
8. Else:
  a. Push the value val_2 to the stack.

Step_pure/if t? instr_1* instr_2*
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BLOCK t? instr_1*).
4. Else:
  a. Execute the instruction (BLOCK t? instr_2*).

Step_pure/label
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
3. Pop the current LABEL_ context from the stack.
4. Push the values val* to the stack.

Step_pure/br n_u1
1. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
2. Let (LABEL_ n { instr'* }) be the current LABEL_ context.
3. If (n_u1 = 0), then:
  a. Assert: Due to validation, there are at least n values on the top of the stack.
  b. Pop the values val^n from the stack.
  c. Pop all values val'* from the top of the stack.
  d. Pop the current LABEL_ context from the stack.
  e. Push the values val^n to the stack.
  f. Execute the instruction instr'*.
4. Else:
  a. Pop all values val* from the top of the stack.
  b. If (n_u1 >= 1), then:
    1) Let l be (n_u1 - 1).
    2) Pop the current LABEL_ context from the stack.
    3) Push the values val* to the stack.
    4) Execute the instruction (BR l).

Step_pure/br_if l
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BR l).
4. Else:
  a. Do nothing.

Step_pure/br_table l* l'
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. If (i < |l*|), then:
  a. Execute the instruction (BR l*[i]).
4. Else:
  a. Execute the instruction (BR l').

Step_pure/frame
1. Let (FRAME_ n { f }) be the current FRAME_ context.
2. Assert: Due to validation, there are at least n values on the top of the stack.
3. Assert: Due to validation, there are at least n values on the top of the stack.
4. Pop the values val^n from the stack.
5. Assert: Due to validation, the first non-value entry of the stack is a FRAME_.
6. Pop the current FRAME_ context from the stack.
7. Push the values val^n to the stack.

Step_pure/return
1. If the first non-value entry of the stack is a FRAME_, then:
  a. Let (FRAME_ n { f }) be the current FRAME_ context.
  b. Assert: Due to validation, there are at least n values on the top of the stack.
  c. Pop the values val^n from the stack.
  d. Pop all values val'* from the top of the stack.
  e. Pop the current FRAME_ context from the stack.
  f. Push the values val^n to the stack.
2. Else if the first non-value entry of the stack is a LABEL_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the current LABEL_ context from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction RETURN.

Step_pure/unop t unop
1. Assert: Due to validation, a value of value type t is on the top of the stack.
2. Pop the value (valtype_0.CONST c_1) from the stack.
3. If (|$unop_(t, unop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $unop_(t, unop, c_1).
5. Push the value (t.CONST c) to the stack.

Step_pure/binop t binop
1. Assert: Due to validation, a value of value type t is on the top of the stack.
2. Pop the value (valtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type valtype_0 is on the top of the stack.
4. Pop the value (valtype_0.CONST c_1) from the stack.
5. If (|$binop_(t, binop, c_1, c_2)| <= 0), then:
  a. Trap.
6. Let c be an element of $binop_(t, binop, c_1, c_2).
7. Push the value (t.CONST c) to the stack.

Step_pure/testop t testop
1. Assert: Due to validation, a value of value type t is on the top of the stack.
2. Pop the value (valtype_0.CONST c_1) from the stack.
3. Let c be $testop_(t, testop, c_1).
4. Push the value (I32.CONST c) to the stack.

Step_pure/relop t relop
1. Assert: Due to validation, a value of value type t is on the top of the stack.
2. Pop the value (valtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type valtype_0 is on the top of the stack.
4. Pop the value (valtype_0.CONST c_1) from the stack.
5. Let c be $relop_(t, relop, c_1, c_2).
6. Push the value (I32.CONST c) to the stack.

Step_pure/cvtop t_2 t_1 cvtop
1. Assert: Due to validation, a value of value type t_1 is on the top of the stack.
2. Pop the value (valtype_0.CONST c_1) from the stack.
3. If (|$cvtop__(t_1, t_2, cvtop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $cvtop__(t_1, t_2, cvtop, c_1).
5. Push the value (t_2.CONST c) to the stack.

Step_pure/local.tee x
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Push the value val to the stack.
4. Push the value val to the stack.
5. Execute the instruction (LOCAL.SET x).

Step_read/block t? instr*
1. Let n be 0.
2. If t? is not defined, then:
  a. Enter instr* with label (LABEL_ n { [] }).
3. Let n be 1.
4. If (t? =/= ?()), then:
  a. Enter instr* with label (LABEL_ n { [] }).

Step_read/loop t? instr*
1. Enter instr* with label (LABEL_ 0 { [(LOOP t? instr*)] }).

Step_read/call x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$funcaddr(z)|).
3. Execute the instruction (CALL_ADDR $funcaddr(z)[x]).

Step_read/call_indirect x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (i >= |$table(z, 0).REFS|), then:
  a. Trap.
5. If $table(z, 0).REFS[i] is not defined, then:
  a. Trap.
6. Let ?(a) be $table(z, 0).REFS[i].
7. If (a >= |$funcinst(z)|), then:
  a. Trap.
8. If ($type(z, x) =/= $funcinst(z)[a].TYPE), then:
  a. Trap.
9. Execute the instruction (CALL_ADDR a).

Step_read/call_addr a
1. Let z be the current state.
2. Assert: Due to validation, (a < |$funcinst(z)|).
3. Let { TYPE: t_1^k -> t_2^n; MODULE: mm; CODE: func } be $funcinst(z)[a].
4. Let (FUNC x local_0* instr*) be func.
5. Let (LOCAL t)* be local_0*.
6. Assert: Due to validation, there are at least k values on the top of the stack.
7. Pop the values val^k from the stack.
8. Let f be { LOCALS: val^k :: $default_(t)*; MODULE: mm }.
9. Push the :ref:`frame <syntax-frame>` (FRAME_ n { f }) to the stack.
10. Enter instr* with label (LABEL_ n { [] }).

Step_read/local.get x
1. Let z be the current state.
2. Push the value $local(z, x) to the stack.

Step_read/global.get x
1. Let z be the current state.
2. Push the value $global(z, x).VALUE to the stack.

Step_read/load t_u1 loadop__u1? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If loadop__u1? is not defined, then:
  a. Let t be t_u1.
  b. If (((i + ao.OFFSET) + ($size(t) / 8)) > |$mem(z, 0).BYTES|), then:
    1) Trap.
  c. Let c be $bytes__1^-1(t, $mem(z, 0).BYTES[(i + ao.OFFSET) : ($size(t) / 8)]).
  d. Push the value (t.CONST c) to the stack.
5. If t_u1 is Inn, then:
  a. If loadop__u1? is defined, then:
    1) Let ?(loadop__0) be loadop__u1?.
    2) Let n _ sx be loadop__0.
    3) If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
  b. Let Inn be t_u1.
  c. If loadop__u1? is defined, then:
    1) Let ?(loadop__0) be loadop__u1?.
    2) Let n _ sx be loadop__0.
    3) Let c be $ibytes__1^-1(n, $mem(z, 0).BYTES[(i + ao.OFFSET) : (n / 8)]).
    4) Push the value (Inn.CONST $extend__(n, $size(Inn), sx, c)) to the stack.

Step_read/memory.size
1. Let z be the current state.
2. Let ((n * 64) * $Ki()) be |$mem(z, 0).BYTES|.
3. Push the value (I32.CONST n) to the stack.

Step/local.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_local(z, x, val).

Step/global.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_global(z, x, val).

Step/store t_u1 sz_u1? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type t_u2 is on the top of the stack.
3. Pop the value (t_u2.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Let t be t_u2.
7. If ((((i + ao.OFFSET) + ($size(t) / 8)) > |$mem(z, 0).BYTES|) /\ ((t_u1 = t) /\ sz_u1? is not defined)), then:
  a. Trap.
8. If ((t_u1 = t) /\ sz_u1? is not defined), then:
  a. Let b* be $bytes_(t, c).
  b. Perform $with_mem(z, 0, (i + ao.OFFSET), ($size(t) / 8), b*).
9. If t_u2 is Inn, then:
  a. Let Inn be t_u2.
  b. If ((t_u1 = Inn) /\ sz_u1? is defined), then:
    1) Let ?(n) be sz_u1?.
    2) If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
    3) Let b* be $ibytes_(n, $wrap__($size(Inn), n, c)).
    4) Perform $with_mem(z, 0, (i + ao.OFFSET), (n / 8), b*).

Step/memory.grow
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Either:
  a. Let mi be $growmemory($mem(z, 0), n).
  b. Push the value (I32.CONST (|$mem(z, 0).BYTES| / (64 * $Ki()))) to the stack.
  c. Perform $with_meminst(z, 0, mi).
5. Or:
  a. Push the value (I32.CONST $invsigned_(32, (- 1))) to the stack.

Ki
1. Return 1024.

min i j
1. If (i <= j), then:
  a. Return i.
2. Return j.

sum n_u1*
1. If (n_u1* = []), then:
  a. Return 0.
2. Let [n] :: n'* be n_u1*.
3. Return (n + $sum(n'*)).

opt_ X X_u1*
1. If (X_u1* = []), then:
  a. Return ?().
2. Assert: Due to validation, (|X_u1*| = 1).
3. Let [w] be X_u1*.
4. Return ?(w).

list_ X X_u1?
1. If X_u1? is not defined, then:
  a. Return [].
2. Let ?(w) be X_u1?.
3. Return [w].

concat_ X X_u1*
1. If (X_u1* = []), then:
  a. Return [].
2. Let [w*] :: w'** be X_u1*.
3. Return w* :: $concat_(X, w'**).

signif N_u1
1. If (N_u1 = 32), then:
  a. Return 23.
2. Assert: Due to validation, (N_u1 = 64).
3. Return 52.

expon N_u1
1. If (N_u1 = 32), then:
  a. Return 8.
2. Assert: Due to validation, (N_u1 = 64).
3. Return 11.

M N
1. Return $signif(N).

E N
1. Return $expon(N).

fzero N
1. Return (POS (SUBNORM 0)).

fone N
1. Return (POS (NORM 1 0)).

canon_ N
1. Return (2 ^ ($signif(N) - 1)).

size t_u1
1. If (t_u1 = I32), then:
  a. Return 32.
2. If (t_u1 = I64), then:
  a. Return 64.
3. If (t_u1 = F32), then:
  a. Return 32.
4. If (t_u1 = F64), then:
  a. Return 64.

funcsxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is FUNC, then:
  a. Let (FUNC ft) be externtype_0.
  b. Return [ft] :: $funcsxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $funcsxt(xt*).

globalsxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is GLOBAL, then:
  a. Let (GLOBAL gt) be externtype_0.
  b. Return [gt] :: $globalsxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $globalsxt(xt*).

tablesxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is TABLE, then:
  a. Let (TABLE tt) be externtype_0.
  b. Return [tt] :: $tablesxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $tablesxt(xt*).

memsxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is MEM, then:
  a. Let (MEM mt) be externtype_0.
  b. Return [mt] :: $memsxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $memsxt(xt*).

memarg0
1. Return { ALIGN: 0; OFFSET: 0 }.

signed_ N i
1. If (i < (2 ^ (N - 1))), then:
  a. Return i.
2. Assert: Due to validation, ((2 ^ (N - 1)) <= i).
3. Assert: Due to validation, (i < (2 ^ N)).
4. Return (i - (2 ^ N)).

invsigned_ N i
1. Let j be $signed__1^-1(N, i).
2. Return j.

unop_ t_u1 unop_u1 c_u1
1. If t_u1 is Inn, then:
  a. Let Inn be t_u1.
  b. Let iN be c_u1.
  c. If (unop_u1 = CLZ), then:
    1) Return [$iclz_($size(Inn), iN)].
  d. If (unop_u1 = CTZ), then:
    1) Return [$ictz_($size(Inn), iN)].
  e. If (unop_u1 = POPCNT), then:
    1) Return [$ipopcnt_($size(Inn), iN)].
2. Assert: Due to validation, t_u1 is Fnn.
3. Let Fnn be t_u1.
4. Let fN be c_u1.
5. If (unop_u1 = ABS), then:
  a. Return $fabs_($size(Fnn), fN).
6. If (unop_u1 = NEG), then:
  a. Return $fneg_($size(Fnn), fN).
7. If (unop_u1 = SQRT), then:
  a. Return $fsqrt_($size(Fnn), fN).
8. If (unop_u1 = CEIL), then:
  a. Return $fceil_($size(Fnn), fN).
9. If (unop_u1 = FLOOR), then:
  a. Return $ffloor_($size(Fnn), fN).
10. If (unop_u1 = TRUNC), then:
  a. Return $ftrunc_($size(Fnn), fN).
11. Assert: Due to validation, (unop_u1 = NEAREST).
12. Return $fnearest_($size(Fnn), fN).

binop_ t_u1 binop_u1 c_u1 c_u2
1. If t_u1 is Inn, then:
  a. Let Inn be t_u1.
  b. Let iN_1 be c_u1.
  c. Let iN_2 be c_u2.
  d. If (binop_u1 = ADD), then:
    1) Return [$iadd_($size(Inn), iN_1, iN_2)].
  e. If (binop_u1 = SUB), then:
    1) Return [$isub_($size(Inn), iN_1, iN_2)].
  f. If (binop_u1 = MUL), then:
    1) Return [$imul_($size(Inn), iN_1, iN_2)].
  g. If binop_u1 is DIV, then:
    1) Let (DIV sx) be binop_u1.
    2) Return $list_(val_((Inn : Inn <: valtype)), $idiv_($size(Inn), sx, iN_1, iN_2)).
  h. If binop_u1 is REM, then:
    1) Let (REM sx) be binop_u1.
    2) Return $list_(val_((Inn : Inn <: valtype)), $irem_($size(Inn), sx, iN_1, iN_2)).
  i. If (binop_u1 = AND), then:
    1) Return [$iand_($size(Inn), iN_1, iN_2)].
  j. If (binop_u1 = OR), then:
    1) Return [$ior_($size(Inn), iN_1, iN_2)].
  k. If (binop_u1 = XOR), then:
    1) Return [$ixor_($size(Inn), iN_1, iN_2)].
  l. If (binop_u1 = SHL), then:
    1) Return [$ishl_($size(Inn), iN_1, iN_2)].
  m. If binop_u1 is SHR, then:
    1) Let (SHR sx) be binop_u1.
    2) Return [$ishr_($size(Inn), sx, iN_1, iN_2)].
  n. If (binop_u1 = ROTL), then:
    1) Return [$irotl_($size(Inn), iN_1, iN_2)].
  o. If (binop_u1 = ROTR), then:
    1) Return [$irotr_($size(Inn), iN_1, iN_2)].
2. Assert: Due to validation, t_u1 is Fnn.
3. Let Fnn be t_u1.
4. Let fN_1 be c_u1.
5. Let fN_2 be c_u2.
6. If (binop_u1 = ADD), then:
  a. Return $fadd_($size(Fnn), fN_1, fN_2).
7. If (binop_u1 = SUB), then:
  a. Return $fsub_($size(Fnn), fN_1, fN_2).
8. If (binop_u1 = MUL), then:
  a. Return $fmul_($size(Fnn), fN_1, fN_2).
9. If (binop_u1 = DIV), then:
  a. Return $fdiv_($size(Fnn), fN_1, fN_2).
10. If (binop_u1 = MIN), then:
  a. Return $fmin_($size(Fnn), fN_1, fN_2).
11. If (binop_u1 = MAX), then:
  a. Return $fmax_($size(Fnn), fN_1, fN_2).
12. Assert: Due to validation, (binop_u1 = COPYSIGN).
13. Return $fcopysign_($size(Fnn), fN_1, fN_2).

testop_ Inn EQZ iN
1. Return $ieqz_($size(Inn), iN).

relop_ t_u1 relop_u1 c_u1 c_u2
1. If t_u1 is Inn, then:
  a. Let Inn be t_u1.
  b. Let iN_1 be c_u1.
  c. Let iN_2 be c_u2.
  d. If (relop_u1 = EQ), then:
    1) Return $ieq_($size(Inn), iN_1, iN_2).
  e. If (relop_u1 = NE), then:
    1) Return $ine_($size(Inn), iN_1, iN_2).
  f. If relop_u1 is LT, then:
    1) Let (LT sx) be relop_u1.
    2) Return $ilt_($size(Inn), sx, iN_1, iN_2).
  g. If relop_u1 is GT, then:
    1) Let (GT sx) be relop_u1.
    2) Return $igt_($size(Inn), sx, iN_1, iN_2).
  h. If relop_u1 is LE, then:
    1) Let (LE sx) be relop_u1.
    2) Return $ile_($size(Inn), sx, iN_1, iN_2).
  i. If relop_u1 is GE, then:
    1) Let (GE sx) be relop_u1.
    2) Return $ige_($size(Inn), sx, iN_1, iN_2).
2. Assert: Due to validation, t_u1 is Fnn.
3. Let Fnn be t_u1.
4. Let fN_1 be c_u1.
5. Let fN_2 be c_u2.
6. If (relop_u1 = EQ), then:
  a. Return $feq_($size(Fnn), fN_1, fN_2).
7. If (relop_u1 = NE), then:
  a. Return $fne_($size(Fnn), fN_1, fN_2).
8. If (relop_u1 = LT), then:
  a. Return $flt_($size(Fnn), fN_1, fN_2).
9. If (relop_u1 = GT), then:
  a. Return $fgt_($size(Fnn), fN_1, fN_2).
10. If (relop_u1 = LE), then:
  a. Return $fle_($size(Fnn), fN_1, fN_2).
11. Assert: Due to validation, (relop_u1 = GE).
12. Return $fge_($size(Fnn), fN_1, fN_2).

cvtop__ t_u1 t_u2 cvtop_u1 c_u1
1. If cvtop_u1 is EXTEND, then:
  a. Let (EXTEND sx) be cvtop_u1.
  b. Let iN be c_u1.
  c. If ((t_u1 = I32) /\ (t_u2 = I64)), then:
    1) Return [$extend__(32, 64, sx, iN)].
2. Let iN be c_u1.
3. If ((t_u1 = I64) /\ ((t_u2 = I32) /\ (cvtop_u1 = WRAP))), then:
  a. Return [$wrap__(64, 32, iN)].
4. If t_u1 is Fnn, then:
  a. Let Fnn be t_u1.
  b. If t_u2 is Inn, then:
    1) Let Inn be t_u2.
    2) If cvtop_u1 is TRUNC, then:
      a) Let (TRUNC sx) be cvtop_u1.
      b) Let fN be c_u1.
      c) Return $list_(val_((Inn : Inn <: valtype)), $trunc__($size(Fnn), $size(Inn), sx, fN)).
5. Let fN be c_u1.
6. If ((t_u1 = F32) /\ ((t_u2 = F64) /\ (cvtop_u1 = PROMOTE))), then:
  a. Return $promote__(32, 64, fN).
7. If ((t_u1 = F64) /\ ((t_u2 = F32) /\ (cvtop_u1 = DEMOTE))), then:
  a. Return $demote__(64, 32, fN).
8. If t_u1 is Inn, then:
  a. Let Inn be t_u1.
  b. If t_u2 is Fnn, then:
    1) Let Fnn be t_u2.
    2) If cvtop_u1 is CONVERT, then:
      a) Let (CONVERT sx) be cvtop_u1.
      b) Return [$convert__($size(Inn), $size(Fnn), sx, iN)].
    3) If ((cvtop_u1 = REINTERPRET) /\ ($size(Inn) = $size(Fnn))), then:
      a) Return [$reinterpret__(Inn, Fnn, iN)].
9. Assert: Due to validation, t_u1 is Fnn.
10. Let Fnn be t_u1.
11. Assert: Due to validation, t_u2 is Inn.
12. Let Inn be t_u2.
13. Assert: Due to validation, (cvtop_u1 = REINTERPRET).
14. Assert: Due to validation, ($size(Inn) = $size(Fnn)).
15. Return [$reinterpret__(Fnn, Inn, fN)].

invibytes_ N b*
1. Let n be $ibytes__1^-1(N, b*).
2. Return n.

invfbytes_ N b*
1. Let p be $fbytes__1^-1(N, b*).
2. Return p.

default_ t_u1
1. If (t_u1 = I32), then:
  a. Return (I32.CONST 0).
2. If (t_u1 = I64), then:
  a. Return (I64.CONST 0).
3. If (t_u1 = F32), then:
  a. Return (F32.CONST $fzero(32)).
4. Assert: Due to validation, (t_u1 = F64).
5. Return (F64.CONST $fzero(64)).

funcsxa xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be xv_u1*.
3. If externaddr_0 is FUNC, then:
  a. Let (FUNC fa) be externaddr_0.
  b. Return [fa] :: $funcsxa(xv*).
4. Let [externaddr] :: xv* be xv_u1*.
5. Return $funcsxa(xv*).

globalsxa xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be xv_u1*.
3. If externaddr_0 is GLOBAL, then:
  a. Let (GLOBAL ga) be externaddr_0.
  b. Return [ga] :: $globalsxa(xv*).
4. Let [externaddr] :: xv* be xv_u1*.
5. Return $globalsxa(xv*).

tablesxa xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be xv_u1*.
3. If externaddr_0 is TABLE, then:
  a. Let (TABLE ta) be externaddr_0.
  b. Return [ta] :: $tablesxa(xv*).
4. Let [externaddr] :: xv* be xv_u1*.
5. Return $tablesxa(xv*).

memsxa xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be xv_u1*.
3. If externaddr_0 is MEM, then:
  a. Let (MEM ma) be externaddr_0.
  b. Return [ma] :: $memsxa(xv*).
4. Let [externaddr] :: xv* be xv_u1*.
5. Return $memsxa(xv*).

store (s, f)
1. Return.

frame (s, f)
1. Return f.

funcaddr (s, f)
1. Return f.MODULE.FUNCS.

funcinst (s, f)
1. Return s.FUNCS.

globalinst (s, f)
1. Return s.GLOBALS.

tableinst (s, f)
1. Return s.TABLES.

meminst (s, f)
1. Return s.MEMS.

moduleinst (s, f)
1. Return f.MODULE.

type (s, f) x
1. Return f.MODULE.TYPES[x].

func (s, f) x
1. Return s.FUNCS[f.MODULE.FUNCS[x]].

global (s, f) x
1. Return s.GLOBALS[f.MODULE.GLOBALS[x]].

table (s, f) x
1. Return s.TABLES[f.MODULE.TABLES[x]].

mem (s, f) x
1. Return s.MEMS[f.MODULE.MEMS[x]].

local (s, f) x
1. Return f.LOCALS[x].

with_local (s, f) x v
1. Replace f.LOCALS[x] with v.

with_global (s, f) x v
1. Replace s.GLOBALS[f.MODULE.GLOBALS[x]].VALUE with v.

with_table (s, f) x i a
1. Replace s.TABLES[f.MODULE.TABLES[x]].REFS[i] with ?(a).

with_tableinst (s, f) x ti
1. Replace s.TABLES[f.MODULE.TABLES[x]] with ti.

with_mem (s, f) x i j b*
1. Replace s.MEMS[f.MODULE.MEMS[x]].BYTES[i : j] with b*.

with_meminst (s, f) x mi
1. Replace s.MEMS[f.MODULE.MEMS[x]] with mi.

growtable ti n
1. Let { TYPE: ([ i .. j ]); REFS: ?(a)* } be ti.
2. Let i' be (|a*| + n).
3. If (i' <= j), then:
  a. Let ti' be { TYPE: ([ i' .. j ]); REFS: ?(a)* :: ?()^n }.
  b. Return ti'.

growmemory mi n
1. Let { TYPE: ([ i .. j ]); BYTES: b* } be mi.
2. Let i' be ((|b*| / (64 * $Ki())) + n).
3. If (i' <= j), then:
  a. Let mi' be { TYPE: ([ i' .. j ]); BYTES: b* :: 0^(n * (64 * $Ki())) }.
  b. Return mi'.

funcs xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be xv_u1*.
3. If externaddr_0 is FUNC, then:
  a. Let (FUNC fa) be externaddr_0.
  b. Return [fa] :: $funcs(externaddr'*).
4. Let [externaddr] :: externaddr'* be xv_u1*.
5. Return $funcs(externaddr'*).

globals xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be xv_u1*.
3. If externaddr_0 is GLOBAL, then:
  a. Let (GLOBAL ga) be externaddr_0.
  b. Return [ga] :: $globals(externaddr'*).
4. Let [externaddr] :: externaddr'* be xv_u1*.
5. Return $globals(externaddr'*).

tables xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be xv_u1*.
3. If externaddr_0 is TABLE, then:
  a. Let (TABLE ta) be externaddr_0.
  b. Return [ta] :: $tables(externaddr'*).
4. Let [externaddr] :: externaddr'* be xv_u1*.
5. Return $tables(externaddr'*).

mems xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be xv_u1*.
3. If externaddr_0 is MEM, then:
  a. Let (MEM ma) be externaddr_0.
  b. Return [ma] :: $mems(externaddr'*).
4. Let [externaddr] :: externaddr'* be xv_u1*.
5. Return $mems(externaddr'*).

allocfunc s moduleinst func
1. Let (FUNC x local* expr) be func.
2. Let fi be { TYPE: moduleinst.TYPES[x]; MODULE: moduleinst; CODE: func }.
3. Let a be |s.FUNCS|.
4. Append fi to the s.FUNCS.
5. Return a.

allocfuncs s moduleinst func_u1*
1. If (func_u1* = []), then:
  a. Return [].
2. Let [func] :: func'* be func_u1*.
3. Let fa be $allocfunc(s, moduleinst, func).
4. Let fa'* be $allocfuncs(s, moduleinst, func'*).
5. Return [fa] :: fa'*.

allocglobal s globaltype val
1. Let gi be { TYPE: globaltype; VALUE: val }.
2. Let a be |s.GLOBALS|.
3. Append gi to the s.GLOBALS.
4. Return a.

allocglobals s gt_u1* v_u1*
1. If (gt_u1* = []), then:
  a. Assert: Due to validation, (v_u1* = []).
  b. Return [].
2. Else:
  a. Let [globaltype] :: globaltype'* be gt_u1*.
  b. Assert: Due to validation, (|v_u1*| >= 1).
  c. Let [val] :: val'* be v_u1*.
  d. Let ga be $allocglobal(s, globaltype, val).
  e. Let ga'* be $allocglobals(s, globaltype'*, val'*).
  f. Return [ga] :: ga'*.

alloctable s ([ i .. j ])
1. Let ti be { TYPE: ([ i .. j ]); REFS: ?()^i }.
2. Let a be |s.TABLES|.
3. Append ti to the s.TABLES.
4. Return a.

alloctables s tt_u1*
1. If (tt_u1* = []), then:
  a. Return [].
2. Let [tabletype] :: tabletype'* be tt_u1*.
3. Let ta be $alloctable(s, tabletype).
4. Let ta'* be $alloctables(s, tabletype'*).
5. Return [ta] :: ta'*.

allocmem s ([ i .. j ])
1. Let mi be { TYPE: ([ i .. j ]); BYTES: 0^(i * (64 * $Ki())) }.
2. Let a be |s.MEMS|.
3. Append mi to the s.MEMS.
4. Return a.

allocmems s mt_u1*
1. If (mt_u1* = []), then:
  a. Return [].
2. Let [memtype] :: memtype'* be mt_u1*.
3. Let ma be $allocmem(s, memtype).
4. Let ma'* be $allocmems(s, memtype'*).
5. Return [ma] :: ma'*.

instexport fa* ga* ta* ma* (EXPORT name externidx_u1)
1. If externidx_u1 is FUNC, then:
  a. Let (FUNC x) be externidx_u1.
  b. Return { NAME: name; ADDR: (FUNC fa*[x]) }.
2. If externidx_u1 is GLOBAL, then:
  a. Let (GLOBAL x) be externidx_u1.
  b. Return { NAME: name; ADDR: (GLOBAL ga*[x]) }.
3. If externidx_u1 is TABLE, then:
  a. Let (TABLE x) be externidx_u1.
  b. Return { NAME: name; ADDR: (TABLE ta*[x]) }.
4. Assert: Due to validation, externidx_u1 is MEM.
5. Let (MEM x) be externidx_u1.
6. Return { NAME: name; ADDR: (MEM ma*[x]) }.

allocmodule s module externaddr* val*
1. Let (MODULE type_0* import* func^n_func global_1* table_2* mem_3* elem* data* start? export*) be module.
2. Let (MEMORY memtype)^n_mem be mem_3*.
3. Let (TABLE tabletype)^n_table be table_2*.
4. Let (GLOBAL globaltype expr_1)^n_global be global_1*.
5. Let (TYPE ft)* be type_0*.
6. Let fa_ex* be $funcs(externaddr*).
7. Let ga_ex* be $globals(externaddr*).
8. Let ma_ex* be $mems(externaddr*).
9. Let ta_ex* be $tables(externaddr*).
10. Let fa* be (|s.FUNCS| + i_func)^(i_func<n_func).
11. Let ga* be (|s.GLOBALS| + i_global)^(i_global<n_global).
12. Let ta* be (|s.TABLES| + i_table)^(i_table<n_table).
13. Let ma* be (|s.MEMS| + i_mem)^(i_mem<n_mem).
14. Let xi* be $instexport(fa_ex* :: fa*, ga_ex* :: ga*, ta_ex* :: ta*, ma_ex* :: ma*, export)*.
15. Let moduleinst be { TYPES: ft*; FUNCS: fa_ex* :: fa*; GLOBALS: ga_ex* :: ga*; TABLES: ta_ex* :: ta*; MEMS: ma_ex* :: ma*; EXPORTS: xi* }.
16. Let funcaddr_0* be $allocfuncs(s, moduleinst, func^n_func).
17. Assert: Due to validation, (funcaddr_0* = fa*).
18. Let globaladdr_0* be $allocglobals(s, globaltype^n_global, val*).
19. Assert: Due to validation, (globaladdr_0* = ga*).
20. Let tableaddr_0* be $alloctables(s, tabletype^n_table).
21. Assert: Due to validation, (tableaddr_0* = ta*).
22. Let memaddr_0* be $allocmems(s, memtype^n_mem).
23. Assert: Due to validation, (memaddr_0* = ma*).
24. Return moduleinst.

initelem s moduleinst i_u1* fa_u1*
1. If ((i_u1* = []) /\ (fa_u1* = [])), then:
  a. Return.
2. Assert: Due to validation, (|fa_u1*| >= 1).
3. Let [a*] :: a'** be fa_u1*.
4. Assert: Due to validation, (|i_u1*| >= 1).
5. Let [i] :: i'* be i_u1*.
6. Replace s.TABLES[moduleinst.TABLES[0]].REFS[i : |a*|] with ?(a)*.
7. Perform $initelem(s, moduleinst, i'*, a'**).
8. Return.

initdata s moduleinst i_u1* b_u1*
1. If ((i_u1* = []) /\ (b_u1* = [])), then:
  a. Return.
2. Assert: Due to validation, (|b_u1*| >= 1).
3. Let [b*] :: b'** be b_u1*.
4. Assert: Due to validation, (|i_u1*| >= 1).
5. Let [i] :: i'* be i_u1*.
6. Replace s.MEMS[moduleinst.MEMS[0]].BYTES[i : |b*|] with b*.
7. Perform $initdata(s, moduleinst, i'*, b'**).
8. Return.

instantiate s module externaddr*
1. Let (MODULE type* import* func* global* table* mem* elem* data* start? export*) be module.
2. Let (TYPE functype)* be type*.
3. Let n_F be |func*|.
4. Let (START x')? be start?.
5. Let (DATA expr_D b*)* be data*.
6. Let (ELEM expr_E x*)* be elem*.
7. Let (GLOBAL globaltype expr_G)* be global*.
8. Let moduleinst_init be { TYPES: functype*; FUNCS: $funcs(externaddr*) :: (|s.FUNCS| + i_F)^(i_F<n_F); GLOBALS: $globals(externaddr*) }.
9. Let f_init be { MODULE: moduleinst_init }.
10. Let z be (s, f_init).
11. Push the :ref:`frame <syntax-frame>` (FRAME_ 0 { $frame(z) }) to the stack.
12. Let [(I32.CONST i_D)]* be $Eval_expr(z, expr_D)*.
13. Pop the :ref:`frame <syntax-frame>` (FRAME_ 0 { $frame(z) }) from the stack.
14. Push the :ref:`frame <syntax-frame>` (FRAME_ 0 { $frame(z) }) to the stack.
15. Let [(I32.CONST i_E)]* be $Eval_expr(z, expr_E)*.
16. Pop the :ref:`frame <syntax-frame>` (FRAME_ 0 { $frame(z) }) from the stack.
17. Push the :ref:`frame <syntax-frame>` (FRAME_ 0 { $frame(z) }) to the stack.
18. Let [val]* be $Eval_expr(z, expr_G)*.
19. Pop the :ref:`frame <syntax-frame>` (FRAME_ 0 { $frame(z) }) from the stack.
20. Let moduleinst be $allocmodule(s, module, externaddr*, val*).
21. Let f be { MODULE: moduleinst }.
22. Perform $initelem(s, moduleinst, i_E*, moduleinst.FUNCS[x]**).
23. Perform $initdata(s, moduleinst, i_D*, b**).
24. Push the :ref:`frame <syntax-frame>` (FRAME_ 0 { f }) to the stack.
25. Execute the sequence ((CALL x')?).
26. Pop the :ref:`frame <syntax-frame>` (FRAME_ 0 { f }) from the stack.
27. Return f.MODULE.

invoke s fa val^n
1. Let f be { MODULE: {} }.
2. Push the :ref:`frame <syntax-frame>` (FRAME_ 0 { (s, f) }) to the stack.
3. Let t_1^n -> t_2* be $funcinst((s, f))[fa].TYPE.
4. Pop the :ref:`frame <syntax-frame>` (FRAME_ 0 { _f }) from the stack.
5. Let k be |t_2*|.
6. Push the :ref:`frame <syntax-frame>` (FRAME_ k { f }) to the stack.
7. Push the values val^n to the stack.
8. Execute the instruction (CALL_ADDR fa).
9. Pop all values val_0* from the top of the stack.
10. Pop the :ref:`frame <syntax-frame>` (FRAME_ k { f }) from the stack.
11. Push the values val_0* to the stack.
12. Pop the values val^k from the stack.
13. Return val^k.

Eval_expr instr*
1. Execute the instruction instr*.
2. Pop the value val from the stack.
3. Return [val].

== Complete.
Generating prose for Wasm 2.0...
watsup 0.4 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...



The limits :math:`{}[~n~..~m~]` is valid with :math:`k` if:


   * :math:`n` is less than or equal to :math:`m`.

   * :math:`m` is less than or equal to :math:`k`.




The function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid.




The global type :math:`({\mathsf{mut}^?}~t)` is valid.




The table type :math:`({\mathit{limits}}~{\mathit{reftype}})` is valid if:


   * The limits :math:`{\mathit{limits}}` is valid with :math:`{2^{32}} - 1`.




The memory type :math:`{\mathit{limits}}~\mathsf{page}` is valid if:


   * The limits :math:`{\mathit{limits}}` is valid with :math:`{2^{16}}`.




The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid if:


   * Either:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{functype}})`.

      * The function type :math:`{\mathit{functype}}` is valid.

   * Or:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~{\mathit{globaltype}})`.

      * The global type :math:`{\mathit{globaltype}}` is valid.
   * Or:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~{\mathit{tabletype}})`.

      * The table type :math:`{\mathit{tabletype}}` is valid.
   * Or:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~{\mathit{memtype}})`.

      * The memory type :math:`{\mathit{memtype}}` is valid.




The external type :math:`(\mathsf{func}~{\mathit{functype}})` is valid if:


   * The function type :math:`{\mathit{functype}}` is valid.




The external type :math:`(\mathsf{global}~{\mathit{globaltype}})` is valid if:


   * The global type :math:`{\mathit{globaltype}}` is valid.




The external type :math:`(\mathsf{table}~{\mathit{tabletype}})` is valid if:


   * The table type :math:`{\mathit{tabletype}}` is valid.




The external type :math:`(\mathsf{mem}~{\mathit{memtype}})` is valid if:


   * The memory type :math:`{\mathit{memtype}}` is valid.




The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` matches the :ref:`value type <syntax-valtype>` :math:`t` if:


   * Either:

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`t`.

   * Or:

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{bot}`.




The :ref:`value type <syntax-valtype>` :math:`t` matches itself.




The :ref:`value type <syntax-valtype>` :math:`\mathsf{bot}` matches the :ref:`value type <syntax-valtype>` :math:`t`.




The value type sequence :math:`{t_1^\ast}` matches the value type sequence :math:`{t_2^\ast}` if:


   * :math:`{|{t_1^\ast}|}` is equal to :math:`{|{t_2^\ast}|}`.

   * For all :math:`t_1` in :math:`{t_1^\ast}` and :math:`t_2` in :math:`{t_2^\ast}`:

      * The :ref:`value type <syntax-valtype>` :math:`t_1` matches the :ref:`value type <syntax-valtype>` :math:`t_2`.




The limits :math:`{}[~n_{11}~..~n_{12}~]` matches the limits :math:`{}[~n_{21}~..~n_{22}~]` if:


   * :math:`n_{11}` is greater than or equal to :math:`n_{21}`.

   * :math:`n_{12}` is less than or equal to :math:`n_{22}`.




The function type :math:`{\mathit{ft}}` matches itself.




The global type :math:`{\mathit{gt}}` matches itself.




The table type :math:`({\mathit{lim}}_1~{\mathit{rt}})` matches the table type :math:`({\mathit{lim}}_2~{\mathit{rt}})` if:


   * The limits :math:`{\mathit{lim}}_1` matches the limits :math:`{\mathit{lim}}_2`.




The memory type :math:`{\mathit{lim}}_1~\mathsf{page}` matches the memory type :math:`{\mathit{lim}}_2~\mathsf{page}` if:


   * The limits :math:`{\mathit{lim}}_1` matches the limits :math:`{\mathit{lim}}_2`.




The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` matches the external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` if:


   * Either:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{ft}}_1)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{func}~{\mathit{ft}}_2)`.

      * The function type :math:`{\mathit{ft}}_1` matches the function type :math:`{\mathit{ft}}_2`.

   * Or:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~{\mathit{gt}}_1)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{global}~{\mathit{gt}}_2)`.

      * The global type :math:`{\mathit{gt}}_1` matches the global type :math:`{\mathit{gt}}_2`.
   * Or:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~{\mathit{tt}}_1)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{table}~{\mathit{tt}}_2)`.

      * The table type :math:`{\mathit{tt}}_1` matches the table type :math:`{\mathit{tt}}_2`.
   * Or:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~{\mathit{mt}}_1)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{mem}~{\mathit{mt}}_2)`.

      * The memory type :math:`{\mathit{mt}}_1` matches the memory type :math:`{\mathit{mt}}_2`.




The external type :math:`(\mathsf{func}~{\mathit{ft}}_1)` matches the external type :math:`(\mathsf{func}~{\mathit{ft}}_2)` if:


   * The function type :math:`{\mathit{ft}}_1` matches the function type :math:`{\mathit{ft}}_2`.




The external type :math:`(\mathsf{global}~{\mathit{gt}}_1)` matches the external type :math:`(\mathsf{global}~{\mathit{gt}}_2)` if:


   * The global type :math:`{\mathit{gt}}_1` matches the global type :math:`{\mathit{gt}}_2`.




The external type :math:`(\mathsf{table}~{\mathit{tt}}_1)` matches the external type :math:`(\mathsf{table}~{\mathit{tt}}_2)` if:


   * The table type :math:`{\mathit{tt}}_1` matches the table type :math:`{\mathit{tt}}_2`.




The external type :math:`(\mathsf{mem}~{\mathit{mt}}_1)` matches the external type :math:`(\mathsf{mem}~{\mathit{mt}}_2)` if:


   * The memory type :math:`{\mathit{mt}}_1` matches the memory type :math:`{\mathit{mt}}_2`.




The block type :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid with the function type :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}~\rightarrow~{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` if:


   * Either:

      * The block type :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{{\mathit{valtype}}^?}`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`{{\mathit{valtype}}^?}`.

   * Or:

      * The block type :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{typeidx}}`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{t_1^\ast}`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`{t_2^\ast}`.

      * The function type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

      * The function type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is equal to :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The block type :math:`{{\mathit{valtype}}^?}` is valid with the function type :math:`\epsilon~\rightarrow~{{\mathit{valtype}}^?}`.




The block type :math:`{\mathit{typeidx}}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The function type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

   * The function type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is equal to :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`\mathsf{nop}` is valid with the function type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction :math:`\mathsf{unreachable}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`\mathsf{drop}` is valid with the function type :math:`t~\rightarrow~\epsilon`.




The instruction :math:`(\mathsf{select}~{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?})` is valid with the function type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


   * Either:

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`t`.

   * Or:

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is absent.

      * The :ref:`value type <syntax-valtype>` :math:`t` matches the :ref:`value type <syntax-valtype>` :math:`{t'}`.

      * The :ref:`value type <syntax-valtype>` :math:`{t'}` is equal to :math:`{\mathit{numtype}}` or :math:`{t'}` is equal to :math:`{\mathit{vectype}}`.




The instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}^\ast})` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{bt}}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`(\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast})` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{bt}}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_1^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`(\mathsf{if}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast})` is valid with the function type :math:`{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{bt}}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_1^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`(\mathsf{br}~l)` is valid with the function type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The result type :math:`C{.}\mathsf{labels}{}[l]` is equal to :math:`{t^\ast}`.




The instruction :math:`(\mathsf{br\_if}~l)` is valid with the function type :math:`{t^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t^\ast}` if:


   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The result type :math:`C{.}\mathsf{labels}{}[l]` is equal to :math:`{t^\ast}`.




The instruction :math:`(\mathsf{br\_table}~{l^\ast}~{l'})` is valid with the function type :math:`{t_1^\ast}~{t^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


   * For all :math:`l` in :math:`{l^\ast}`:

      * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * For all :math:`l` in :math:`{l^\ast}`:

      * The value type sequence :math:`{t^\ast}` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.

   * The result type :math:`C{.}\mathsf{labels}{}[{l'}]` exists.

   * The value type sequence :math:`{t^\ast}` matches the result type :math:`C{.}\mathsf{labels}{}[{l'}]`.




The instruction :math:`(\mathsf{call}~x)` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`(\mathsf{call\_indirect}~x~y)` is valid with the function type :math:`{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{lim}}~\mathsf{funcref})`.

   * The function type :math:`C{.}\mathsf{types}{}[y]` exists.

   * The function type :math:`C{.}\mathsf{types}{}[y]` is equal to :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`\mathsf{return}` is valid with the function type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


   * The result type :math:`C{.}\mathsf{return}` is equal to :math:`{t^\ast}`.




The instruction :math:`({\mathit{nt}}{.}\mathsf{const}~c_{\mathit{nt}})` is valid with the function type :math:`\epsilon~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{unop}}_{\mathit{nt}})` is valid with the function type :math:`{\mathit{nt}}~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{binop}}_{\mathit{nt}})` is valid with the function type :math:`{\mathit{nt}}~{\mathit{nt}}~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{testop}}_{\mathit{nt}})` is valid with the function type :math:`{\mathit{nt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{relop}}_{\mathit{nt}})` is valid with the function type :math:`{\mathit{nt}}~{\mathit{nt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{nt}}_1 {.} {{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{\_}}{{\mathit{nt}}_2})` is valid with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1` if:


   * Either:

      * :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{reinterpret}`.

      * :math:`{|{\mathit{nt}}_1|}` is equal to :math:`{|{\mathit{nt}}_2|}`.

   * Or:

      * :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{cvtop}}`.




The instruction :math:`(\mathsf{ref{.}null}~{\mathit{rt}})` is valid with the function type :math:`\epsilon~\rightarrow~{\mathit{rt}}`.




The instruction :math:`(\mathsf{ref{.}func}~x)` is valid with the function type :math:`\epsilon~\rightarrow~\mathsf{funcref}` if:


   * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{\mathit{ft}}`.




The instruction :math:`\mathsf{ref{.}is\_null}` is valid with the function type :math:`{\mathit{rt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` is valid with the function type :math:`\epsilon~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvunop}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvbinop}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvternop}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvtestop}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vunop}}_{\mathit{sh}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vbinop}}_{\mathit{sh}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vtestop}}_{\mathit{sh}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vrelop}}_{\mathit{sh}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vshiftop}}_{\mathit{sh}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{bitmask})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{swizzle})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{shuffle}~{i^\ast})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * For all :math:`i` in :math:`{i^\ast}`:

      * The lane index :math:`i` is less than :math:`2 \cdot {\mathrm{dim}}({\mathit{sh}})`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{splat})` is valid with the function type :math:`t~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * Let :math:`t` be the :ref:`number type <syntax-numtype>` :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`({{\mathit{sh}}{.}\mathsf{extract\_lane}}{{{\mathit{sx}}^?}}~i)` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~t` if:


   * The lane index :math:`i` is less than :math:`{\mathrm{dim}}({\mathit{sh}})`.

   * Let :math:`t` be the :ref:`number type <syntax-numtype>` :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{replace\_lane}~i)` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~t~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The lane index :math:`i` is less than :math:`{\mathrm{dim}}({\mathit{sh}})`.

   * Let :math:`t` be the :ref:`number type <syntax-numtype>` :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`(\mathsf{vextunop}~{\mathit{sh}}_1~{\mathit{sh}}_2~{\mathit{vextunop}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{vextbinop}~{\mathit{sh}}_1~{\mathit{sh}}_2~{\mathit{vextbinop}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({{\mathit{sh}}_1{.}\mathsf{narrow}}{\mathsf{\_}}{{\mathit{sh}}_2}{\mathsf{\_}}{{\mathit{sx}}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}_1 {.} {{\mathit{sh}}_2}{\mathsf{\_}}{{\mathit{vcvtop}}}{\mathsf{\_}}{{{\mathit{hf}}^?}}{\mathsf{\_}}{{{\mathit{zero}}^?}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{local{.}get}~x)` is valid with the function type :math:`\epsilon~\rightarrow~t` if:


   * The :ref:`value type <syntax-valtype>` :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The :ref:`value type <syntax-valtype>` :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`t`.




The instruction :math:`(\mathsf{local{.}set}~x)` is valid with the function type :math:`t~\rightarrow~\epsilon` if:


   * The :ref:`value type <syntax-valtype>` :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The :ref:`value type <syntax-valtype>` :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`t`.




The instruction :math:`(\mathsf{local{.}tee}~x)` is valid with the function type :math:`t~\rightarrow~t` if:


   * The :ref:`value type <syntax-valtype>` :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The :ref:`value type <syntax-valtype>` :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`t`.




The instruction :math:`(\mathsf{global{.}get}~x)` is valid with the function type :math:`\epsilon~\rightarrow~t` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`({\mathit{mut}}~t)`.




The instruction :math:`(\mathsf{global{.}set}~x)` is valid with the function type :math:`t~\rightarrow~\epsilon` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`(\mathsf{mut}~t)`.




The instruction :math:`(\mathsf{table{.}get}~x)` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathit{rt}}` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}set}~x)` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathit{rt}}~\rightarrow~\epsilon` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}size}~x)` is valid with the function type :math:`\epsilon~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}grow}~x)` is valid with the function type :math:`{\mathit{rt}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}fill}~x)` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathit{rt}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}copy}~x_1~x_2)` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x_1]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x_1]` is equal to :math:`({\mathit{lim}}_1~{\mathit{rt}})`.

   * The table type :math:`C{.}\mathsf{tables}{}[x_2]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x_2]` is equal to :math:`({\mathit{lim}}_2~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}init}~x_1~x_2)` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x_1]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x_1]` is equal to :math:`({\mathit{lim}}~{\mathit{rt}})`.

   * The element type :math:`C{.}\mathsf{elems}{}[x_2]` exists.

   * The reference type :math:`C{.}\mathsf{elems}{}[x_2]` is equal to :math:`{\mathit{rt}}`.




The instruction :math:`(\mathsf{elem{.}drop}~x)` is valid with the function type :math:`\epsilon~\rightarrow~\epsilon` if:


   * The element type :math:`C{.}\mathsf{elems}{}[x]` exists.

   * The reference type :math:`C{.}\mathsf{elems}{}[x]` is equal to :math:`{\mathit{rt}}`.




The instruction :math:`\mathsf{memory{.}size}` is valid with the function type :math:`\epsilon~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.




The instruction :math:`\mathsf{memory{.}grow}` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.




The instruction :math:`\mathsf{memory{.}fill}` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.




The instruction :math:`\mathsf{memory{.}copy}` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.




The instruction :math:`(\mathsf{memory{.}init}~x)` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

   * The data type :math:`C{.}\mathsf{datas}{}[x]` exists.

   * The data type :math:`C{.}\mathsf{datas}{}[x]` is equal to :math:`\mathsf{ok}`.




The instruction :math:`(\mathsf{data{.}drop}~x)` is valid with the function type :math:`\epsilon~\rightarrow~\epsilon` if:


   * The data type :math:`C{.}\mathsf{datas}{}[x]` exists.

   * The data type :math:`C{.}\mathsf{datas}{}[x]` is equal to :math:`\mathsf{ok}`.




The instruction :math:`({{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{load}}{{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

   * Either:

      * The :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{nt}}`.

      * :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}` is absent.

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{nt}}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

   * Or:

      * The :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{i}}{n}`.

      * :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`{M}{\mathsf{\_}}{{\mathit{sx}}}`.

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{i}}{n}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{store}}{{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

   * Either:

      * The :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{nt}}`.

      * The pack size :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is absent.

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{nt}}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

   * Or:

      * The :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{i}}{n}`.

      * The pack size :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`M`.

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{i}}{n}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

   * Either:

      * :math:`{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`({M}{\mathsf{x}}{N}{\mathsf{\_}}{{\mathit{sx}}})`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8 \cdot N`.

   * Or:

      * :math:`{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`({n}{\mathsf{\_}}{\mathsf{splat}})`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.
   * Or:

      * :math:`{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`({n}{\mathsf{\_}}{\mathsf{zero}})`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.




The instruction :math:`(\mathsf{vload\_lane}~\mathsf{v{\scriptstyle 128}}~n~{\mathit{memarg}}~{\mathit{laneidx}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.

   * :math:`{\mathit{laneidx}}` is less than :math:`128 / n`.




The instruction :math:`(\mathsf{vstore}~\mathsf{v{\scriptstyle 128}}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|\mathsf{v{\scriptstyle 128}}|} / 8`.




The instruction :math:`(\mathsf{vstore\_lane}~\mathsf{v{\scriptstyle 128}}~n~{\mathit{memarg}}~{\mathit{laneidx}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.

   * :math:`{\mathit{laneidx}}` is less than :math:`128 / n`.




The instruction :math:`(\mathsf{select}~t)` is valid with the function type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t`.




The instruction :math:`(\mathsf{select}~\epsilon)` is valid with the function type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


   * The :ref:`value type <syntax-valtype>` :math:`t` matches the :ref:`value type <syntax-valtype>` :math:`{t'}`.

   * The :ref:`value type <syntax-valtype>` :math:`{t'}` is equal to :math:`{\mathit{numtype}}` or :math:`{t'}` is equal to :math:`{\mathit{vectype}}`.




The instruction :math:`({\mathit{nt}}_1 {.} {\mathsf{reinterpret}}{\mathsf{\_}}{{\mathit{nt}}_2})` is valid with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1` if:


   * :math:`{|{\mathit{nt}}_1|}` is equal to :math:`{|{\mathit{nt}}_2|}`.




The instruction :math:`({\mathit{nt}}_1 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_2})` is valid with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1`.




The instruction :math:`({{\mathit{nt}}{.}\mathsf{load}}{\epsilon}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathit{nt}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.




The instruction :math:`({{\mathsf{i}}{n}{.}\mathsf{load}}{{M}{\mathsf{\_}}{{\mathit{sx}}}}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathsf{i}}{n}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({{\mathit{nt}}{.}\mathsf{store}}{\epsilon}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathit{nt}}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.




The instruction :math:`({{\mathsf{i}}{n}{.}\mathsf{store}}{M}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathsf{i}}{n}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~({M}{\mathsf{x}}{N}{\mathsf{\_}}{{\mathit{sx}}})~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8 \cdot N`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~({n}{\mathsf{\_}}{\mathsf{splat}})~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~({n}{\mathsf{\_}}{\mathsf{zero}})~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.




The instruction sequence :math:`{{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is valid with the function type :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}~\rightarrow~{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` if:


   * Either:

      * The instruction sequence :math:`{{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`\epsilon`.

   * Or:

      * The instruction sequence :math:`{{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{t_1^\ast}`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`{t_3^\ast}`.

      * The instruction :math:`{\mathit{instr}}_1` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

      * The instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the function type :math:`{t_2^\ast}~\rightarrow~{t_3^\ast}`.
   * Or:

      * The instruction sequence :math:`{{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{{\mathit{instr}}^\ast}`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{{t'}_1^\ast}`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`{{t'}_2^\ast}`.

      * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

      * The value type sequence :math:`{{t'}_1^\ast}` matches the value type sequence :math:`{t_1^\ast}`.

      * The value type sequence :math:`{t_2^\ast}` matches the value type sequence :math:`{{t'}_2^\ast}`.
   * Or:

      * The instruction sequence :math:`{{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{{\mathit{instr}}^\ast}`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{t^\ast}~{t_1^\ast}`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`{t^\ast}~{t_2^\ast}`.

      * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction sequence :math:`\epsilon` is valid with the function type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction sequence :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_3^\ast}` if:


   * The instruction :math:`{\mathit{instr}}_1` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * The instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the function type :math:`{t_2^\ast}~\rightarrow~{t_3^\ast}`.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{{t'}_1^\ast}~\rightarrow~{{t'}_2^\ast}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * The value type sequence :math:`{{t'}_1^\ast}` matches the value type sequence :math:`{t_1^\ast}`.

   * The value type sequence :math:`{t_2^\ast}` matches the value type sequence :math:`{{t'}_2^\ast}`.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t^\ast}~{t_1^\ast}~\rightarrow~{t^\ast}~{t_2^\ast}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The expression :math:`{{\mathit{instr}}^\ast}` is valid with the result type :math:`{t^\ast}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`\epsilon~\rightarrow~{t^\ast}`.




:math:`{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is constant if:


   * Either:

      * The instruction :math:`{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`({\mathit{nt}}{.}\mathsf{const}~c)`.

   * Or:

      * The instruction :math:`{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`({\mathit{vt}}{.}\mathsf{const}~{\mathit{vc}})`.
   * Or:

      * The instruction :math:`{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref{.}null}~{\mathit{rt}})`.
   * Or:

      * The instruction :math:`{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref{.}func}~x)`.
   * Or:

      * The instruction :math:`{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global{.}get}~x)`.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`(\epsilon~t)`.




:math:`({\mathit{nt}}{.}\mathsf{const}~c)` is constant.




:math:`({\mathit{vt}}{.}\mathsf{const}~{\mathit{vc}})` is constant.




:math:`(\mathsf{ref{.}null}~{\mathit{rt}})` is constant.




:math:`(\mathsf{ref{.}func}~x)` is constant.




:math:`(\mathsf{global{.}get}~x)` is constant if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`(\epsilon~t)`.




:math:`{{\mathit{instr}}^\ast}` is constant if:


   * For all :math:`{\mathit{instr}}` in :math:`{{\mathit{instr}}^\ast}`:

      * :math:`{\mathit{instr}}` is constant.




The type :math:`(\mathsf{type}~{\mathit{ft}})` is valid with the function type :math:`{\mathit{ft}}` if:


   * The function type :math:`{\mathit{ft}}` is valid.




The function :math:`(\mathsf{func}~x~{(\mathsf{local}~t)^\ast}~{\mathit{expr}})` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The function type :math:`C{.}\mathsf{types}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{types}{}[x]` is equal to :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Under the context :math:`C{}[{.}\mathsf{locals} \mathrel{{=}{\oplus}} {t_1^\ast}~{t^\ast}]{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_2^\ast}]{}[{.}\mathsf{return} \mathrel{{=}{\oplus}} {t_2^\ast}]`, the expression :math:`{\mathit{expr}}` is valid with the result type :math:`{t_2^\ast}`.




The global :math:`(\mathsf{global}~{\mathit{gt}}~{\mathit{expr}})` is valid with the global type :math:`{\mathit{gt}}` if:


   * The global type :math:`{\mathit{gt}}` is valid.

   * The global type :math:`{\mathit{gt}}` is equal to :math:`({\mathit{mut}}~t)`.

   * The expression :math:`{\mathit{expr}}` is valid with the :ref:`value type <syntax-valtype>` :math:`t`.

   * :math:`{\mathit{expr}}` is constant.




The table :math:`(\mathsf{table}~{\mathit{tt}})` is valid with the table type :math:`{\mathit{tt}}` if:


   * The table type :math:`{\mathit{tt}}` is valid.




The memory :math:`(\mathsf{memory}~{\mathit{mt}})` is valid with the memory type :math:`{\mathit{mt}}` if:


   * The memory type :math:`{\mathit{mt}}` is valid.




:math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid with the reference type :math:`{\mathit{rt}}` if:


   * Either:

      * :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{active}~x~{\mathit{expr}})`.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{lim}}~{\mathit{rt}})`.

      * The expression :math:`{\mathit{expr}}` is valid with the :ref:`value type <syntax-valtype>` :math:`\mathsf{i{\scriptstyle 32}}`.

      * :math:`{\mathit{expr}}` is constant.

   * Or:

      * :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{passive}`.
   * Or:

      * :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{declare}`.




:math:`(\mathsf{active}~x~{\mathit{expr}})` is valid with the reference type :math:`{\mathit{rt}}` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{lim}}~{\mathit{rt}})`.

   * The expression :math:`{\mathit{expr}}` is valid with the :ref:`value type <syntax-valtype>` :math:`\mathsf{i{\scriptstyle 32}}`.

   * :math:`{\mathit{expr}}` is constant.




:math:`\mathsf{passive}` is valid with the reference type :math:`{\mathit{rt}}`.




:math:`\mathsf{declare}` is valid with the reference type :math:`{\mathit{rt}}`.




The table segment :math:`(\mathsf{elem}~{\mathit{rt}}~{{\mathit{expr}}^\ast}~{\mathit{elemmode}})` is valid with the reference type :math:`{\mathit{rt}}` if:


   * For all :math:`{\mathit{expr}}` in :math:`{{\mathit{expr}}^\ast}`:

      * The expression :math:`{\mathit{expr}}` is valid with the :ref:`value type <syntax-valtype>` :math:`{\mathit{rt}}`.

      * :math:`{\mathit{expr}}` is constant.

   * :math:`{\mathit{elemmode}}` is valid with the reference type :math:`{\mathit{rt}}`.




:math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid if:


   * Either:

      * :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{active}~0~{\mathit{expr}})`.

      * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

      * The expression :math:`{\mathit{expr}}` is valid with the :ref:`value type <syntax-valtype>` :math:`\mathsf{i{\scriptstyle 32}}`.

      * :math:`{\mathit{expr}}` is constant.

   * Or:

      * :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{passive}`.




:math:`(\mathsf{active}~0~{\mathit{expr}})` is valid if:


   * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

   * The expression :math:`{\mathit{expr}}` is valid with the :ref:`value type <syntax-valtype>` :math:`\mathsf{i{\scriptstyle 32}}`.

   * :math:`{\mathit{expr}}` is constant.




:math:`\mathsf{passive}` is valid.




The memory segment :math:`(\mathsf{data}~{b^\ast}~{\mathit{datamode}})` is valid if:


   * :math:`{\mathit{datamode}}` is valid.




The start function :math:`(\mathsf{start}~x)` is valid if:


   * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`\epsilon~\rightarrow~\epsilon`.




The import :math:`(\mathsf{import}~{\mathit{name}}_1~{\mathit{name}}_2~{\mathit{xt}})` is valid with the external type :math:`{\mathit{xt}}` if:


   * The external type :math:`{\mathit{xt}}` is valid.




The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid with the external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


   * Either:

      * The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~x)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{ft}})`.

      * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

      * The function type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{\mathit{ft}}`.

   * Or:

      * The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~x)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~{\mathit{gt}})`.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`{\mathit{gt}}`.
   * Or:

      * The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~x)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~{\mathit{tt}})`.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`{\mathit{tt}}`.
   * Or:

      * The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~x)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~{\mathit{mt}})`.

      * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

      * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`{\mathit{mt}}`.




The external index :math:`(\mathsf{func}~x)` is valid with the external type :math:`(\mathsf{func}~{\mathit{ft}})` if:


   * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The function type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{\mathit{ft}}`.




The external index :math:`(\mathsf{global}~x)` is valid with the external type :math:`(\mathsf{global}~{\mathit{gt}})` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`{\mathit{gt}}`.




The external index :math:`(\mathsf{table}~x)` is valid with the external type :math:`(\mathsf{table}~{\mathit{tt}})` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`{\mathit{tt}}`.




The external index :math:`(\mathsf{mem}~x)` is valid with the external type :math:`(\mathsf{mem}~{\mathit{mt}})` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`{\mathit{mt}}`.




The export :math:`(\mathsf{export}~{\mathit{name}}~{\mathit{externidx}})` is valid with the external type :math:`{\mathit{xt}}` if:


   * The external index :math:`{\mathit{externidx}}` is valid with the external type :math:`{\mathit{xt}}`.




The module :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^{n}}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` is valid if:


   * :math:`{|{{\mathit{ft}'}^\ast}|}` is equal to :math:`{|{{\mathit{type}}^\ast}|}`.

   * For all :math:`{\mathit{ft}'}` in :math:`{{\mathit{ft}'}^\ast}` and :math:`{\mathit{type}}` in :math:`{{\mathit{type}}^\ast}`:

      * The type :math:`{\mathit{type}}` is valid with the function type :math:`{\mathit{ft}'}`.

   * :math:`{|{{\mathit{import}}^\ast}|}` is equal to :math:`{|{{\mathit{ixt}}^\ast}|}`.

   * For all :math:`{\mathit{import}}` in :math:`{{\mathit{import}}^\ast}` and :math:`{\mathit{ixt}}` in :math:`{{\mathit{ixt}}^\ast}`:

      * Under the context :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{return}~\epsilon \}\end{array}`, the import :math:`{\mathit{import}}` is valid with the external type :math:`{\mathit{ixt}}`.

   * :math:`{|{{\mathit{global}}^\ast}|}` is equal to :math:`{|{{\mathit{gt}}^\ast}|}`.

   * For all :math:`{\mathit{global}}` in :math:`{{\mathit{global}}^\ast}` and :math:`{\mathit{gt}}` in :math:`{{\mathit{gt}}^\ast}`:

      * Under the context :math:`{C'}`, the global :math:`{\mathit{global}}` is valid with the global type :math:`{\mathit{gt}}`.

   * :math:`{|{{\mathit{table}}^\ast}|}` is equal to :math:`{|{{\mathit{tt}}^\ast}|}`.

   * For all :math:`{\mathit{table}}` in :math:`{{\mathit{table}}^\ast}` and :math:`{\mathit{tt}}` in :math:`{{\mathit{tt}}^\ast}`:

      * Under the context :math:`{C'}`, the table :math:`{\mathit{table}}` is valid with the table type :math:`{\mathit{tt}}`.

   * :math:`{|{{\mathit{mem}}^\ast}|}` is equal to :math:`{|{{\mathit{mt}}^\ast}|}`.

   * For all :math:`{\mathit{mem}}` in :math:`{{\mathit{mem}}^\ast}` and :math:`{\mathit{mt}}` in :math:`{{\mathit{mt}}^\ast}`:

      * Under the context :math:`{C'}`, the memory :math:`{\mathit{mem}}` is valid with the memory type :math:`{\mathit{mt}}`.

   * :math:`{|{{\mathit{elem}}^\ast}|}` is equal to :math:`{|{{\mathit{rt}}^\ast}|}`.

   * For all :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}` and :math:`{\mathit{rt}}` in :math:`{{\mathit{rt}}^\ast}`:

      * Under the context :math:`{C'}`, the table segment :math:`{\mathit{elem}}` is valid with the reference type :math:`{\mathit{rt}}`.

   * For all :math:`{\mathit{data}}` in :math:`{{\mathit{data}}^\ast}`:

      * Under the context :math:`{C'}`, the memory segment :math:`{\mathit{data}}` is valid.

   * :math:`{|{{\mathit{ft}}^\ast}|}` is equal to :math:`{|{{\mathit{func}}^\ast}|}`.

   * For all :math:`{\mathit{ft}}` in :math:`{{\mathit{ft}}^\ast}` and :math:`{\mathit{func}}` in :math:`{{\mathit{func}}^\ast}`:

      * The function :math:`{\mathit{func}}` is valid with the function type :math:`{\mathit{ft}}`.

   * If :math:`{\mathit{start}}` is defined, then:

      * The start function :math:`{\mathit{start}}` is valid.

   * :math:`{|{{\mathit{export}}^\ast}|}` is equal to :math:`{|{{\mathit{xt}}^\ast}|}`.

   * For all :math:`{\mathit{export}}` in :math:`{{\mathit{export}}^\ast}` and :math:`{\mathit{xt}}` in :math:`{{\mathit{xt}}^\ast}`:

      * The export :math:`{\mathit{export}}` is valid with the external type :math:`{\mathit{xt}}`.

   * :math:`{|{{\mathit{mt}}^\ast}|}` is less than or equal to :math:`1`.

   * The context :math:`C` is equal to :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{funcs}~{{\mathit{ift}}^\ast}~{{\mathit{ft}}^\ast},\; \mathsf{globals}~{{\mathit{igt}}^\ast}~{{\mathit{gt}}^\ast},\; \mathsf{tables}~{{\mathit{itt}}^\ast}~{{\mathit{tt}}^\ast},\; \mathsf{mems}~{{\mathit{imt}}^\ast}~{{\mathit{mt}}^\ast},\; \mathsf{elems}~{{\mathit{rt}}^\ast},\; \mathsf{datas}~{\mathsf{ok}^{n}},\; \mathsf{return}~\epsilon \}\end{array}`.

   * The context :math:`{C'}` is equal to :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{funcs}~{{\mathit{ift}}^\ast}~{{\mathit{ft}}^\ast},\; \mathsf{globals}~{{\mathit{igt}}^\ast},\; \mathsf{tables}~{{\mathit{itt}}^\ast}~{{\mathit{tt}}^\ast},\; \mathsf{mems}~{{\mathit{imt}}^\ast}~{{\mathit{mt}}^\ast},\; \mathsf{return}~\epsilon \}\end{array}`.

   * The function type sequence :math:`{{\mathit{ift}}^\ast}` is equal to :math:`{\mathrm{funcs}}({{\mathit{ixt}}^\ast})`.

   * The global type sequence :math:`{{\mathit{igt}}^\ast}` is equal to :math:`{\mathrm{globals}}({{\mathit{ixt}}^\ast})`.

   * The table type sequence :math:`{{\mathit{itt}}^\ast}` is equal to :math:`{\mathrm{tables}}({{\mathit{ixt}}^\ast})`.

   * The memory type sequence :math:`{{\mathit{imt}}^\ast}` is equal to :math:`{\mathrm{mems}}({{\mathit{ixt}}^\ast})`.


:math:`\mathsf{unreachable}`
............................


1. Trap.


:math:`\mathsf{nop}`
....................


1. Do nothing.


:math:`\mathsf{drop}`
.....................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Do nothing.


:math:`\mathsf{select}~{({t^\ast})^?}`
......................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_2` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_1` from the stack.

#. If :math:`c \neq 0`, then:

   a. Push the value :math:`{\mathit{val}}_1` to the stack.

#. Else:

   a. Push the value :math:`{\mathit{val}}_2` to the stack.


:math:`\mathsf{if}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast}~{{\mathit{instr}}_2^\ast}`
.....................................................................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

   a. Execute the instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast})`.

#. Else:

   a. Execute the instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}_2^\ast})`.


:math:`\mathsf{label}`
......................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

#. Pop the current :math:`\mathsf{label}` context from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.


:math:`\mathsf{br}~n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`
.............................................................


1. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

#. Let :math:`({{\mathsf{label}}_{n}}{\{}~{{\mathit{instr}'}^\ast}~\})` be the current :math:`\mathsf{label}` context.

#. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 0`, then:

   a. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

   #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

   #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

   #. Pop the current :math:`\mathsf{label}` context from the stack.

   #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

   #. Execute the instruction :math:`{{\mathit{instr}'}^\ast}`.

#. Else:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}} \geq 1`, then:

      1) Let :math:`l` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}} - 1`.

      #) Pop the current :math:`\mathsf{label}` context from the stack.

      #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

      #) Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{br\_if}~l`
.........................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

   a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

   a. Do nothing.


:math:`\mathsf{br\_table}~{l^\ast}~{l'}`
........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i < {|{l^\ast}|}`, then:

   a. Execute the instruction :math:`(\mathsf{br}~{l^\ast}{}[i])`.

#. Else:

   a. Execute the instruction :math:`(\mathsf{br}~{l'})`.


:math:`\mathsf{frame}`
......................


1. Let :math:`({{\mathsf{frame}}_{n}}{\{}~f~\})` be the current :math:`\mathsf{frame}` context.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{frame}`.

#. Pop the current :math:`\mathsf{frame}` context from the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.


:math:`\mathsf{return}`
.......................


1. If the first non-value entry of the stack is a :math:`\mathsf{frame}`, then:

   a. Let :math:`({{\mathsf{frame}}_{n}}{\{}~f~\})` be the current :math:`\mathsf{frame}` context.

   #. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

   #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

   #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

   #. Pop the current :math:`\mathsf{frame}` context from the stack.

   #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Else if the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Pop the current :math:`\mathsf{label}` context from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`\mathsf{return}`.


:math:`{\mathit{nt}} {.} {\mathit{unop}}`
.........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{unop}}}{{}_{{\mathit{nt}}}}{(c_1)}|} \leq 0`, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{unop}}}{{}_{{\mathit{nt}}}}{(c_1)}`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{binop}}`
..........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{numtype}}_0` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{binop}}}{{}_{{\mathit{nt}}}}{(c_1, c_2)}|} \leq 0`, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{binop}}}{{}_{{\mathit{nt}}}}{(c_1, c_2)}`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{testop}}`
...........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{testop}}}{{}_{{\mathit{nt}}}}{(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{relop}}`
..........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{numtype}}_0` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{relop}}}{{}_{{\mathit{nt}}}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}}_2 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_1}`
............................................................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}_1` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{cvtop}}}{{}_{{\mathit{nt}}_1, {\mathit{nt}}_2}}{(c_1)}|} \leq 0`, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{cvtop}}}{{}_{{\mathit{nt}}_1, {\mathit{nt}}_2}}{(c_1)}`.

#. Push the value :math:`({\mathit{nt}}_2{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{ref{.}is\_null}`
...............................


1. Assert: Due to validation, a :ref:`reference <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. If :math:`{\mathit{ref}}` is :math:`\mathsf{ref{.}null}`, then:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvunop}}`
..........................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vvunop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvbinop}}`
...........................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vvbinop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvternop}}`
............................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_3)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vvternop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2, c_3)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} \mathsf{any\_true}`
...........................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{ine}}}_{{|\mathsf{v{\scriptstyle 128}}|}}(c_1, 0)`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vunop}}`
..........................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{vunop}}}{{}_{{\mathit{sh}}}}{(c_1)}|} \leq 0`, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vunop}}}{{}_{{\mathit{sh}}}}{(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vbinop}}`
...........................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{vbinop}}}{{}_{{\mathit{sh}}}}{(c_1, c_2)}|} \leq 0`, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vbinop}}}{{}_{{\mathit{sh}}}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N} {.} \mathsf{all\_true}`
...............................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c)`.

#. If :math:`{({\mathit{ci}}_1 \neq 0)^\ast}`, then:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vrelop}}`
...........................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vrelop}}}{{}_{{\mathit{sh}}}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N} {.} {\mathit{vshiftop}}`
................................................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`{{c'}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c_1)`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{{{\mathit{vshiftop}}}{\mathsf{\_}}~{{\mathsf{i}}{n}}{\mathsf{x}}{N}}{({c'}, n)}^\ast})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}{.}\mathsf{bitmask}`
...........................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c)`.

#. Let :math:`{\mathit{ci}}` be the result for which :math:`{{\mathrm{bits}}}_{{\mathsf{i}}{32}}({\mathit{ci}})` :math:`=` :math:`{{{{{\mathrm{ilt}}}_{{|{\mathsf{i}}{n}|}}^{\mathsf{s}}}}{({\mathit{ci}}_1, 0)}^\ast}~{0^{32 - N}}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{\mathrm{irev}}}_{32}({\mathit{ci}}))` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{M}{.}\mathsf{swizzle}`
...........................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`{{c'}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c_1)~{0^{256 - M}}`.

#. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c_2)`.

#. Assert: Due to validation, :math:`{({{\mathit{ci}}^\ast}{}[k] < {|{{c'}^\ast}|})^{k<M}}`.

#. Assert: Due to validation, :math:`{(k < {|{{\mathit{ci}}^\ast}|})^{k<M}}`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{c'}^\ast}{}[{{\mathit{ci}}^\ast}{}[k]]^{k<M}})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}{.}\mathsf{shuffle}~{i^\ast}`
....................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{(k < {|{i^\ast}|})^{k<N}}`.

#. Let :math:`{{c'}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c_1)~{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c_2)`.

#. Assert: Due to validation, :math:`{({i^\ast}{}[k] < {|{{c'}^\ast}|})^{k<N}}`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{{c'}^\ast}{}[{i^\ast}{}[k]]^{k<N}})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}{.}\mathsf{splat}`
.........................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0 = {\mathrm{unpack}}({\mathsf{i}}{n})`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{{\mathrm{pack}}}_{{\mathsf{i}}{n}}(c_1)^{N}})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{N}{.}\mathsf{extract\_lane}}{{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~i`
......................................................................................................................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined and :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

   a. Let :math:`{\mathit{nt}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`i < {|{{\mathrm{lanes}}}_{{{\mathit{nt}}}{\mathsf{x}}{N}}(c_1)|}`, then:

      1) Let :math:`c_2` be :math:`{{\mathrm{lanes}}}_{{{\mathit{nt}}}{\mathsf{x}}{N}}(c_1){}[i]`.

      #) Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c_2)` to the stack.

#. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type, then:

   a. Let :math:`{\mathit{pt}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

      1) Let :math:`{\mathit{sx}}` be :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

      #) If :math:`i < {|{{\mathrm{lanes}}}_{{{\mathit{pt}}}{\mathsf{x}}{N}}(c_1)|}`, then:

         a) Let :math:`c_2` be :math:`{{{{\mathrm{extend}}}_{{|{\mathit{pt}}|}, 32}^{{\mathit{sx}}}}}{({{\mathrm{lanes}}}_{{{\mathit{pt}}}{\mathsf{x}}{N}}(c_1){}[i])}`.

         #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c_2)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}{.}\mathsf{replace\_lane}~i`
...................................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0 = {\mathrm{unpack}}({\mathsf{i}}{n})`.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c_1){}[{}[i] = {{\mathrm{pack}}}_{{\mathsf{i}}{n}}(c_2)])`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{vextunop}~{\mathit{sh}}_1~{\mathit{sh}}_2~{\mathit{vextunop}}`
.............................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{vextunop}}}_{{\mathit{sh}}_1, {\mathit{sh}}_2}({\mathit{vextunop}}, c_1)`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{vextbinop}~{\mathit{sh}}_1~{\mathit{sh}}_2~{\mathit{vextbinop}}`
...............................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{vextbinop}}}_{{\mathit{sh}}_1, {\mathit{sh}}_2}({\mathit{vextbinop}}, c_1, c_2)`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{N_2}{.}\mathsf{narrow}}{\mathsf{\_}}{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{N_1}}{\mathsf{\_}}{{\mathit{sx}}}`
...................................................................................................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{N_1}}(c_1)`.

#. Let :math:`{{\mathit{ci}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{N_1}}(c_2)`.

#. Let :math:`{{\mathit{cj}}_1^\ast}` be :math:`{{{{{\mathrm{narrow}}}_{{|{{\mathsf{i}}{n}}_1|}, {|{{\mathsf{i}}{n}}_2|}}^{{\mathit{sx}}}}}{{\mathit{ci}}_1}^\ast}`.

#. Let :math:`{{\mathit{cj}}_2^\ast}` be :math:`{{{{{\mathrm{narrow}}}_{{|{{\mathsf{i}}{n}}_1|}, {|{{\mathsf{i}}{n}}_2|}}^{{\mathit{sx}}}}}{{\mathit{ci}}_2}^\ast}`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{N_2}}({{\mathit{cj}}_1^\ast}~{{\mathit{cj}}_2^\ast})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}} {.} {{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}}{\mathsf{x}}{n_{\mathit{u{\kern-0.1em\scriptstyle 2}}}}}{\mathsf{\_}}{{\mathit{vcvtop}}}{\mathsf{\_}}{{{\mathit{hf}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}{\mathsf{\_}}{{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}`
.............................................................................................................................................................................................................................................................................................................................................................................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{hf}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined and :math:`{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

   a. Let :math:`{{\mathsf{i}}{n}}_1` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

   #. Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Let :math:`M` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

   #. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = M`, then:

      1) Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M}}(c_1)`.

      #) Let :math:`{{{\mathit{cj}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{vcvtop}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M}, {{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M}}({\mathit{vcvtop}}, {\mathit{ci}})^\ast}`.

      #) If :math:`{|{{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M}}({{\mathit{cj}}^\ast})^\ast}|} > 0`, then:

         a) Let :math:`c` be an element of :math:`{{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M}}({{\mathit{cj}}^\ast})^\ast}`.

         #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. If :math:`{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

   a. Let :math:`{{\mathsf{i}}{n}}_1` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

   #. Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Let :math:`M_1` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

   #. Let :math:`M_2` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{{\mathit{hf}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

      1) Let :math:`{\mathit{half}}` be :math:`{{\mathit{hf}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

      #) Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}}(c_1){}[{\mathrm{half}}({\mathit{half}}, 0, M_2) : M_2]`.

      #) Let :math:`{{{\mathit{cj}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{vcvtop}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}, {\mathit{ci}})^\ast}`.

      #) If :math:`{|{{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}({{\mathit{cj}}^\ast})^\ast}|} > 0`, then:

         a) Let :math:`c` be an element of :math:`{{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}({{\mathit{cj}}^\ast})^\ast}`.

         #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. If :math:`{{\mathit{hf}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

   a. Let :math:`M_1` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

   #. Let :math:`M_2` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is number type, then:

      1) Let :math:`{\mathit{nt}}_1` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

      #) If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

         a) Let :math:`{\mathit{nt}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) If :math:`{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

            1. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{nt}}_1}{\mathsf{x}}{M_1}}(c_1)`.

            #. Let :math:`{{{\mathit{cj}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{vcvtop}}}_{{{\mathit{nt}}_1}{\mathsf{x}}{M_1}, {{\mathit{nt}}_2}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}, {\mathit{ci}})^\ast}~{{\mathrm{zero}}({\mathit{nt}}_2)^{M_1}}`.

            #. If :math:`{|{{{\mathrm{invlanes}}}_{{{\mathit{nt}}_2}{\mathsf{x}}{M_2}}({{\mathit{cj}}^\ast})^\ast}|} > 0`, then:

               a. Let :math:`c` be an element of :math:`{{{\mathrm{invlanes}}}_{{{\mathit{nt}}_2}{\mathsf{x}}{M_2}}({{\mathit{cj}}^\ast})^\ast}`.

               #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{local{.}tee}~x`
..............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Execute the instruction :math:`(\mathsf{local{.}set}~x)`.


:math:`\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}^\ast}`
............................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{k}}~\rightarrow~{t_2^{n}}` be :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`k` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Enter :math:`{{\mathit{val}}^{k}}~{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{n}}{\{}~\epsilon~\})`.


:math:`\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast}`
...........................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{k}}~\rightarrow~{t_2^{n}}` be :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`k` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Enter :math:`{{\mathit{val}}^{k}}~{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{k}}{\{}~(\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast})~\})`.


:math:`\mathsf{call}~x`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Execute the instruction :math:`(\mathsf{call}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x])`.


:math:`\mathsf{call\_indirect}~x~y`
...................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i]` is not :math:`\mathsf{ref{.}func\_addr}`, then:

   a. Trap.

#. Let :math:`(\mathsf{ref{.}func\_addr}~a)` be :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i]`.

#. If :math:`a \geq {|z{.}\mathsf{funcs}|}`, then:

   a. Trap.

#. If :math:`z{.}\mathsf{types}{}[y] \neq z{.}\mathsf{funcs}{}[a]{.}\mathsf{type}`, then:

   a. Trap.

#. Execute the instruction :math:`(\mathsf{call}~a)`.


:math:`\mathsf{call}~a`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`a < {|z{.}\mathsf{funcs}|}`.

#. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{t_1^{k}}~\rightarrow~{t_2^{n}},\; \mathsf{module}~{\mathit{mm}},\; \mathsf{code}~{\mathit{func}} \}\end{array}` be :math:`z{.}\mathsf{funcs}{}[a]`.

#. Let :math:`(\mathsf{func}~x~{{\mathit{local}}_0^\ast}~{{\mathit{instr}}^\ast})` be :math:`{\mathit{func}}`.

#. Let :math:`{(\mathsf{local}~t)^\ast}` be :math:`{{\mathit{local}}_0^\ast}`.

#. Assert: Due to validation, there are at least :math:`k` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~{{\mathit{val}}^{k}}~{{{\mathrm{default}}}_{t}^\ast},\; \mathsf{module}~{\mathit{mm}} \}\end{array}`.

#. Push the :ref:`frame <syntax-frame>` :math:`({{\mathsf{frame}}_{n}}{\{}~f~\})` to the stack.

#. Enter :math:`{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{n}}{\{}~\epsilon~\})`.


:math:`\mathsf{ref{.}func}~x`
.............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Push the value :math:`(\mathsf{ref{.}func}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x])` to the stack.


:math:`\mathsf{local{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Push the value :math:`z{.}\mathsf{locals}{}[x]` to the stack.


:math:`\mathsf{global{.}get}~x`
...............................


1. Let :math:`z` be the current state.

#. Push the value :math:`z{.}\mathsf{globals}{}[x]{.}\mathsf{value}` to the stack.


:math:`\mathsf{table{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. Push the value :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i]` to the stack.


:math:`\mathsf{table{.}size}~x`
...............................


1. Let :math:`z` be the current state.

#. Let :math:`n` be :math:`{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{table{.}fill}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}fill}~x)`.


:math:`\mathsf{table{.}copy}~x~y`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{tables}{}[y]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. If :math:`j \leq i`, then:

      1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

      #) Execute the instruction :math:`(\mathsf{table{.}get}~y)`.

      #) Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Else:

      1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + n - 1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + n - 1)` to the stack.

      #) Execute the instruction :math:`(\mathsf{table{.}get}~y)`.

      #) Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}copy}~x~y)`.


:math:`\mathsf{table{.}init}~x~y`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else if :math:`i < {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

   #. Push the value :math:`z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[i]` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}init}~x~y)`.


:math:`{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{load}}{{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}}~{\mathit{ao}}`
..................................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

   a. Let :math:`{\mathit{nt}}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}}|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathit{nt}}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}}|} / 8]`.

   #. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.

#. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{n}`, then:

   a. If :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

      1) Let :math:`{\mathit{loadop\_{\scriptstyle 0}}}` be :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}`.

      #) Let :math:`{n}{\mathsf{\_}}{{\mathit{sx}}}` be :math:`{\mathit{loadop\_{\scriptstyle 0}}}`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

         a) Trap.

   #. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

      1) Let :math:`{\mathit{loadop\_{\scriptstyle 0}}}` be :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}`.

      #) Let :math:`{n}{\mathsf{\_}}{{\mathit{sx}}}` be :math:`{\mathit{loadop\_{\scriptstyle 0}}}`.

      #) Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8]`.

      #) Push the value :math:`({\mathsf{i}}{n}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{n, {|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{(c)})` to the stack.


:math:`\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}~{\mathit{ao}}`
.................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|\mathsf{v{\scriptstyle 128}}|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}` and :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

   a. Trap.

#. If :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

   a. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{\mathsf{v{\scriptstyle 128}}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|\mathsf{v{\scriptstyle 128}}|} / 8]`.

   #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. Else:

   a. Let :math:`{\mathit{vloadop}}_0` be :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

   #. If :math:`{\mathit{vloadop}}_0` is :math:`\mathsf{shape}`, then:

      1) Let :math:`({M}{\mathsf{x}}{N}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vloadop}}_0`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + M \cdot N / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) Let :math:`{j^{N}}` be the result for which :math:`{({{\mathrm{bytes}}}_{{\mathsf{i}}{M}}({j^{N}}) = z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} + k \cdot M / 8 : M / 8])^{k<N}}`.

      #) If :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`M \cdot 2` is :math:`{\mathsf{i}}{n}`, then:

         a) Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`M \cdot 2`.

         #) Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{{{{\mathrm{extend}}}_{M, {|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{(j)}^{N}})`.

         #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

   #. If :math:`{\mathit{vloadop}}_0` is :math:`\mathsf{splat}`, then:

      1) Let :math:`({N}{\mathsf{\_}}{\mathsf{splat}})` be :math:`{\mathit{vloadop}}_0`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) Let :math:`M` be :math:`128 / N`.

      #) If :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`N` is :math:`{\mathsf{i}}{n}`, then:

         a) Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`N`.

         #) Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

         #) Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({j^{M}})`.

         #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

   #. If :math:`{\mathit{vloadop}}_0` is :math:`\mathsf{zero}`, then:

      1) Let :math:`({N}{\mathsf{\_}}{\mathsf{zero}})` be :math:`{\mathit{vloadop}}_0`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

      #) Let :math:`c` be :math:`{{{{\mathrm{extend}}}_{N, 128}^{\mathsf{u}}}}{(j)}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{vload\_lane}~\mathsf{v{\scriptstyle 128}}~N~{\mathit{ao}}~j`
...........................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`M` be :math:`128 / N`.

#. If :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`N` is :math:`{\mathsf{i}}{n}`, then:

   a. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`N`.

   #. Let :math:`k` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(k)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

   #. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c_1){}[{}[j] = k])`.

   #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{memory{.}size}`
..............................


1. Let :math:`z` be the current state.

#. Let :math:`n \cdot 64 \cdot {\mathrm{Ki}}` be :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{memory{.}fill}`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8})`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`\mathsf{memory{.}fill}`.


:math:`\mathsf{memory{.}copy}`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. If :math:`j \leq i`, then:

      1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{load}}{{8}{\mathsf{\_}}{\mathsf{u}}})`.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8})`.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Else:

      1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + n - 1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + n - 1)` to the stack.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{load}}{{8}{\mathsf{\_}}{\mathsf{u}}})`.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8})`.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`\mathsf{memory{.}copy}`.


:math:`\mathsf{memory{.}init}~x`
................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{datas}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else if :math:`i < {|z{.}\mathsf{datas}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~z{.}\mathsf{datas}{}[x]{.}\mathsf{bytes}{}[i])` to the stack.

   #. Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8})`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{memory{.}init}~x)`.


:math:`\mathsf{local{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{locals}{}[x] = {\mathit{val}}]`.


:math:`\mathsf{global{.}set}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = {\mathit{val}}]`.


:math:`\mathsf{table{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a :ref:`reference <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. Perform :math:`z{}[{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i] = {\mathit{ref}}]`.


:math:`\mathsf{table{.}grow}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a :ref:`reference <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Either:

   a. Let :math:`{\mathit{ti}}` be :math:`{\mathrm{growtable}}(z{.}\mathsf{tables}{}[x], n, {\mathit{ref}})`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|})` to the stack.

   #. Perform :math:`z{}[{.}\mathsf{tables}{}[x] = {\mathit{ti}}]`.

#. Or:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{32}^{{-1}}}}{({-1})})` to the stack.


:math:`\mathsf{elem{.}drop}~x`
..............................


1. Let :math:`z` be the current state.

#. Perform :math:`z{}[{.}\mathsf{elems}{}[x]{.}\mathsf{refs} = \epsilon]`.


:math:`{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{store}}{{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~{\mathit{ao}}`
.........................................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Let :math:`{\mathit{nt}}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}}|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}` and :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = {\mathit{nt}}` and :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

   a. Trap.

#. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = {\mathit{nt}}` and :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

   a. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathit{nt}}}(c)`.

   #. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}}|} / 8] = {b^\ast}]`.

#. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is :math:`{\mathsf{i}}{n}`, then:

   a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

   #. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = {\mathsf{i}}{n}` and :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

      1) Let :math:`n` be :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}({{\mathrm{wrap}}}_{{|{\mathsf{i}}{n}|}, n}(c))`.

      #) Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8] = {b^\ast}]`.


:math:`\mathsf{vstore}~\mathsf{v{\scriptstyle 128}}~{\mathit{ao}}`
..................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|\mathsf{v{\scriptstyle 128}}|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{\mathsf{v{\scriptstyle 128}}}(c)`.

#. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|\mathsf{v{\scriptstyle 128}}|} / 8] = {b^\ast}]`.


:math:`\mathsf{vstore\_lane}~\mathsf{v{\scriptstyle 128}}~N~{\mathit{ao}}~j`
............................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`M` be :math:`128 / N`.

#. If :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`N` is :math:`{\mathsf{i}}{n}`, then:

   a. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`N`.

   #. If :math:`j < {|{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c)|}`, then:

      1) Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}({{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c){}[j])`.

      #) Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8] = {b^\ast}]`.


:math:`\mathsf{memory{.}grow}`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Either:

   a. Let :math:`{\mathit{mi}}` be :math:`{\mathrm{growmemory}}(z{.}\mathsf{mems}{}[0], n)`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|} / (64 \, {\mathrm{Ki}}))` to the stack.

   #. Perform :math:`z{}[{.}\mathsf{mems}{}[0] = {\mathit{mi}}]`.

#. Or:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{32}^{{-1}}}}{({-1})})` to the stack.


:math:`\mathsf{data{.}drop}~x`
..............................


1. Let :math:`z` be the current state.

#. Perform :math:`z{}[{.}\mathsf{datas}{}[x]{.}\mathsf{bytes} = \epsilon]`.


:math:`{\mathrm{Ki}}`
.....................


1. Return :math:`1024`.


:math:`{\mathrm{min}}(i, j)`
............................


1. If :math:`i \leq j`, then:

   a. Return :math:`i`.

#. Return :math:`j`.


:math:`{\mathrm{sum}}({n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................


1. If :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`0`.

#. Let :math:`n~{{n'}^\ast}` be :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`n + {\mathrm{sum}}({{n'}^\ast})`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`
........................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} = 1`.

#. Let :math:`w` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`w`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`
.....................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

   a. Return :math:`\epsilon`.

#. Let :math:`w` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

#. Return :math:`w`.


:math:`{\mathrm{concat}}({X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
...........................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{w^\ast}~{{{w'}^\ast}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{w^\ast}~{\mathrm{concat}}({{{w'}^\ast}^\ast})`.


:math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{X}(w_1, {X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{{w'}^\ast}~{{w^\ast}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`w_1~{{w'}^\ast}~{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{X}(w_1, {{w^\ast}^\ast})`.


:math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{X}({X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {{w^\ast}^\ast})`
.................................................................................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`w_1~{{w'}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{X}(w_1, {{w^\ast}^\ast})~{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{X}({{w'}^\ast}, {{w^\ast}^\ast})`.


:math:`\Large\times~{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`
.....................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{w_1^\ast}~{{w^\ast}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{X}({w_1^\ast}, \Large\times~{{w^\ast}^\ast})`.


:math:`{\mathrm{signif}}(N_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
....................................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 32`, then:

   a. Return :math:`23`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 64`.

#. Return :math:`52`.


:math:`{\mathrm{expon}}(N_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
...................................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 32`, then:

   a. Return :math:`8`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 64`.

#. Return :math:`11`.


:math:`M`
.........


1. Return :math:`{\mathrm{signif}}(N)`.


:math:`E`
.........


1. Return :math:`{\mathrm{expon}}(N)`.


:math:`{+0}`
............


1. Return :math:`({+((0 + 0 \cdot {2^{{-M}}}) \cdot {2^{e}})})`.


:math:`{+1}`
............


1. Return :math:`({+((1 + 1 \cdot {2^{{-M}}}) \cdot {2^{0}})})`.


:math:`{{\mathrm{canon}}}_{N}`
..............................


1. Return :math:`{2^{{\mathrm{signif}}(N) - 1}}`.


:math:`{|t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}|}`
.....................................................


1. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 32}}`, then:

   a. Return :math:`32`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 64}}`, then:

   a. Return :math:`64`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 32}}`, then:

   a. Return :math:`32`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 64}}`, then:

   a. Return :math:`64`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{v{\scriptstyle 128}}`, then:

   a. Return :math:`128`.


:math:`{|{\mathsf{i}}{n}|}`
...........................


1. Return :math:`{|{\mathsf{i}}{n}|}`.


:math:`{|{\mathit{pt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}|}`
.................................................................


1. If :math:`{\mathit{pt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 8}}`, then:

   a. Return :math:`8`.

#. Assert: Due to validation, :math:`{\mathit{pt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 16}}`.

#. Return :math:`16`.


:math:`{|{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}|}`
.................................................................


1. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

   a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{|{\mathit{numtype}}|}`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{|{\mathit{packtype}}|}`.


:math:`{\mathrm{lanetype}}({{\mathsf{i}}{n}}{\mathsf{x}}{N})`
.............................................................


1. Return :math:`{\mathsf{i}}{n}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N_1`
...........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N_2`
...........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`N_1`
...........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`N_2`
...........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`{\mathrm{zero}}({\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
..............................................................................


1. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{n}`, then:

   a. Return :math:`0`.

#. Assert: Due to validation, :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{n}`.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{+0}`.


:math:`{\mathrm{dim}}({{\mathsf{i}}{n}}{\mathsf{x}}{N})`
........................................................


1. Return :math:`N`.


:math:`{|{{\mathsf{i}}{n}}{\mathsf{x}}{N}|}`
............................................


1. Return :math:`{|{\mathsf{i}}{n}|} \cdot N`.


:math:`{\mathrm{concat}}({b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
...........................................................................


1. If :math:`{b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{b^\ast}~{{{b'}^\ast}^\ast}` be :math:`{b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{b^\ast}~{\mathrm{concat}}({{{b'}^\ast}^\ast})`.


:math:`{\mathrm{unpack}}({\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
................................................................................


1. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

   a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathit{numtype}}`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Return :math:`\mathsf{i{\scriptstyle 32}}`.


:math:`{\mathrm{unpack}}({{\mathsf{i}}{n}}{\mathsf{x}}{N})`
...........................................................


1. Return :math:`{\mathrm{unpack}}({\mathsf{i}}{n})`.


:math:`{\mathrm{funcs}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
......................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is :math:`\mathsf{func}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{ft}})` be :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{ft}}~{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is :math:`\mathsf{global}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{gt}})` be :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{gt}}~{\mathrm{globals}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is :math:`\mathsf{table}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{tt}})` be :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{tt}}~{\mathrm{tables}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is :math:`\mathsf{mem}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{mt}})` be :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{mt}}~{\mathrm{mems}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{dataidx}}({\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
.................................................................................


1. If :math:`{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{memory{.}init}`, then:

   a. Let :math:`(\mathsf{memory{.}init}~x)` be :math:`{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`x`.

#. If :math:`{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{data{.}drop}`, then:

   a. Let :math:`(\mathsf{data{.}drop}~x)` be :math:`{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`x`.

#. Return :math:`\epsilon`.


:math:`{\mathrm{dataidx}}({{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................................


1. If :math:`{{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{instr}}~{{\mathit{instr}'}^\ast}` be :math:`{{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{dataidx}}({\mathit{instr}})~{\mathrm{dataidx}}({{\mathit{instr}'}^\ast})`.


:math:`{\mathrm{dataidx}}({{\mathit{in}}^\ast})`
................................................


1. Return :math:`{\mathrm{dataidx}}({{\mathit{in}}^\ast})`.


:math:`{\mathrm{dataidx}}(\mathsf{func}~x~{{\mathit{loc}}^\ast}~e)`
...................................................................


1. Return :math:`{\mathrm{dataidx}}(e)`.


:math:`{\mathrm{dataidx}}({{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
..........................................................................................


1. If :math:`{{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{func}}~{{\mathit{func}'}^\ast}` be :math:`{{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{dataidx}}({\mathit{func}})~{\mathrm{dataidx}}({{\mathit{func}'}^\ast})`.






1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{align}~0,\; \mathsf{offset}~0 \}\end{array}`.


:math:`{{\mathrm{signed}}}_{N}(i)`
..................................


1. If :math:`i < {2^{N - 1}}`, then:

   a. Return :math:`i`.

#. Assert: Due to validation, :math:`{2^{N - 1}} \leq i`.

#. Assert: Due to validation, :math:`i < {2^{N}}`.

#. Return :math:`i - {2^{N}}`.


:math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{(i)}`
...............................................


1. Let :math:`j` be the result for which :math:`{{\mathrm{signed}}}_{N}(j)` :math:`=` :math:`i`.

#. Return :math:`j`.


:math:`{{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}{(i_{\mathit{u{\kern-0.1em\scriptstyle 1}}})}`
..........................................................................................................................................................................


1. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{n}`, then:

   a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Let :math:`{\mathit{iN}}` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{clz}`, then:

      1) Return :math:`{{\mathrm{iclz}}}_{N}({\mathit{iN}})`.

   #. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ctz}`, then:

      1) Return :math:`{{\mathrm{ictz}}}_{N}({\mathit{iN}})`.

   #. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{popcnt}`, then:

      1) Return :math:`{{\mathrm{ipopcnt}}}_{N}({\mathit{iN}})`.

   #. Assert: Due to validation, :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{extend}`.

   #. Let :math:`(\mathsf{extend}~M)` be :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{{{{\mathrm{extend}}}_{M, N}^{\mathsf{s}}}}{({{\mathrm{wrap}}}_{N, M}({\mathit{iN}}))}`.

#. Assert: Due to validation, :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{n}`.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{abs}`, then:

   a. Return :math:`{{\mathrm{fabs}}}_{N}({\mathit{fN}})`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{neg}`, then:

   a. Return :math:`{{\mathrm{fneg}}}_{N}({\mathit{fN}})`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sqrt}`, then:

   a. Return :math:`{{\mathrm{fsqrt}}}_{N}({\mathit{fN}})`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ceil}`, then:

   a. Return :math:`{{\mathrm{fceil}}}_{N}({\mathit{fN}})`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{floor}`, then:

   a. Return :math:`{{\mathrm{ffloor}}}_{N}({\mathit{fN}})`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{trunc}`, then:

   a. Return :math:`{{\mathrm{ftrunc}}}_{N}({\mathit{fN}})`.

#. Assert: Due to validation, :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{nearest}`.

#. Return :math:`{{\mathrm{fnearest}}}_{N}({\mathit{fN}})`.


:math:`{{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}{(i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, i_{\mathit{u{\kern-0.1em\scriptstyle 2}}})}`
......................................................................................................................................................................................................................


1. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{n}`, then:

   a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Let :math:`{\mathit{iN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Let :math:`{\mathit{iN}}_2` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{add}`, then:

      1) Return :math:`{{\mathrm{iadd}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sub}`, then:

      1) Return :math:`{{\mathrm{isub}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{mul}`, then:

      1) Return :math:`{{\mathrm{imul}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{div}`, then:

      1) Let :math:`({\mathsf{div}}{{\mathit{sx}}})` be :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{idiv}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{rem}`, then:

      1) Let :math:`({\mathsf{rem}}{{\mathit{sx}}})` be :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{irem}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{and}`, then:

      1) Return :math:`{{\mathrm{iand}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{or}`, then:

      1) Return :math:`{{\mathrm{ior}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{xor}`, then:

      1) Return :math:`{{\mathrm{ixor}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{shl}`, then:

      1) Return :math:`{{\mathrm{ishl}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{shr}`, then:

      1) Let :math:`({\mathsf{shr}}{{\mathit{sx}}})` be :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{ishr}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{rotl}`, then:

      1) Return :math:`{{\mathrm{irotl}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{rotr}`, then:

      1) Return :math:`{{\mathrm{irotr}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{n}`.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_2` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{add}`, then:

   a. Return :math:`{{\mathrm{fadd}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sub}`, then:

   a. Return :math:`{{\mathrm{fsub}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{mul}`, then:

   a. Return :math:`{{\mathrm{fmul}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{div}`, then:

   a. Return :math:`{{\mathrm{fdiv}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{min}`, then:

   a. Return :math:`{{\mathrm{fmin}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{max}`, then:

   a. Return :math:`{{\mathrm{fmax}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{copysign}`.

#. Return :math:`{{\mathrm{fcopysign}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.


:math:`{\mathsf{eqz}}{{}_{{\mathsf{i}}{n}}}{({\mathit{iN}})}`
.............................................................


1. Return :math:`{{\mathrm{ieqz}}}_{N}({\mathit{iN}})`.


:math:`{{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}{(i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, i_{\mathit{u{\kern-0.1em\scriptstyle 2}}})}`
......................................................................................................................................................................................................................


1. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{n}`, then:

   a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Let :math:`{\mathit{iN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Let :math:`{\mathit{iN}}_2` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

   #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{eq}`, then:

      1) Return :math:`{{\mathrm{ieq}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ne}`, then:

      1) Return :math:`{{\mathrm{ine}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

   #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{lt}`, then:

      1) Let :math:`({\mathsf{lt}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{ilt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{gt}`, then:

      1) Let :math:`({\mathsf{gt}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{igt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{le}`, then:

      1) Let :math:`({\mathsf{le}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{ile}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

   #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ge}`, then:

      1) Let :math:`({\mathsf{ge}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{ige}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

#. Assert: Due to validation, :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{n}`.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_2` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{eq}`, then:

   a. Return :math:`{{\mathrm{feq}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ne}`, then:

   a. Return :math:`{{\mathrm{fne}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{lt}`, then:

   a. Return :math:`{{\mathrm{flt}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{gt}`, then:

   a. Return :math:`{{\mathrm{fgt}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{le}`, then:

   a. Return :math:`{{\mathrm{fle}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ge}`.

#. Return :math:`{{\mathrm{fge}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.


:math:`{{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, {\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}}}{(i_{\mathit{u{\kern-0.1em\scriptstyle 1}}})}`
..................................................................................................................................................................................................................................


1. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{n}`, then:

   a. Let :math:`{{\mathsf{i}}{n}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is :math:`{\mathsf{i}}{n}`, then:

      1) Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

      #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{extend}`, then:

         a) Let :math:`(\mathsf{extend}~{\mathit{sx}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Let :math:`{\mathit{iN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Return :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

      #) Let :math:`{\mathit{iN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{wrap}`, then:

         a) Return :math:`{{\mathrm{wrap}}}_{N_1, N_2}({\mathit{iN}}_1)`.

#. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{n}`, then:

   a. Let :math:`{{\mathsf{f}}{n}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is :math:`{\mathsf{i}}{n}`, then:

      1) Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

      #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{trunc}`, then:

         a) Let :math:`(\mathsf{trunc}~{\mathit{sx}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Let :math:`{\mathit{fN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Return :math:`{{{{\mathrm{trunc}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{fN}}_1)}`.

      #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{trunc\_sat}`, then:

         a) Let :math:`(\mathsf{trunc\_sat}~{\mathit{sx}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Let :math:`{\mathit{fN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Return :math:`{{{{\mathrm{trunc\_sat}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{fN}}_1)}`.

#. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{n}`, then:

   a. Let :math:`{{\mathsf{i}}{n}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is :math:`{\mathsf{f}}{n}`, then:

      1) Let :math:`{{\mathsf{f}}{n}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

      #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{convert}`, then:

         a) Let :math:`(\mathsf{convert}~{\mathit{sx}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Let :math:`{\mathit{iN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Return :math:`{{{{\mathrm{convert}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

#. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{n}`, then:

   a. Let :math:`{{\mathsf{f}}{n}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is :math:`{\mathsf{f}}{n}`, then:

      1) Let :math:`{{\mathsf{f}}{n}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

      #) Let :math:`{\mathit{fN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{promote}`, then:

         a) Return :math:`{{\mathrm{promote}}}_{N_1, N_2}({\mathit{fN}}_1)`.

      #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{demote}`, then:

         a) Return :math:`{{\mathrm{demote}}}_{N_1, N_2}({\mathit{fN}}_1)`.

#. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{n}`, then:

   a. Let :math:`{{\mathsf{i}}{n}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is :math:`{\mathsf{f}}{n}`, then:

      1) Let :math:`{{\mathsf{f}}{n}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

      #) Let :math:`{\mathit{iN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{reinterpret}` and :math:`{|{{\mathsf{i}}{n}}_1|} = {|{{\mathsf{f}}{n}}_2|}`, then:

         a) Return :math:`{{\mathrm{reinterpret}}}_{{{\mathsf{i}}{n}}_1, {{\mathsf{f}}{n}}_2}({\mathit{iN}}_1)`.

#. Assert: Due to validation, :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{n}`.

#. Let :math:`{{\mathsf{f}}{n}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Assert: Due to validation, :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is :math:`{\mathsf{i}}{n}`.

#. Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Assert: Due to validation, :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{reinterpret}`.

#. Assert: Due to validation, :math:`{|{{\mathsf{f}}{n}}_1|} = {|{{\mathsf{i}}{n}}_2|}`.

#. Return :math:`{{\mathrm{reinterpret}}}_{{{\mathsf{f}}{n}}_1, {{\mathsf{i}}{n}}_2}({\mathit{fN}}_1)`.


:math:`{{\mathrm{invibytes}}}_{N}({b^\ast})`
............................................


1. Let :math:`n` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(n)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`n`.


:math:`{{\mathrm{invfbytes}}}_{N}({b^\ast})`
............................................


1. Let :math:`p` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{f}}{N}}(p)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`p`.


:math:`{{\mathrm{pack}}}_{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}(c)`
....................................................................................


1. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

   a. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{\mathrm{wrap}}}_{{|{\mathrm{unpack}}({\mathit{packtype}})|}, {|{\mathit{packtype}}|}}(c)`.


:math:`{{\mathrm{unpack}}}_{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}(c)`
......................................................................................


1. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

   a. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{{{\mathrm{extend}}}_{{|{\mathit{packtype}}|}, {|{\mathrm{unpack}}({\mathit{packtype}})|}}^{\mathsf{u}}}}{(c)}`.


:math:`{{\mathrm{invlanes}}}_{{\mathit{sh}}}({c^\ast})`
.......................................................


1. Let :math:`{\mathit{vc}}` be the result for which :math:`{{\mathrm{lanes}}}_{{\mathit{sh}}}({\mathit{vc}})` :math:`=` :math:`{c^\ast}`.

#. Return :math:`{\mathit{vc}}`.


:math:`{\mathrm{half}}({\mathit{hf}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, i, j)`
....................................................................................


1. If :math:`{\mathit{hf}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{low}`, then:

   a. Return :math:`i`.

#. Assert: Due to validation, :math:`{\mathit{hf}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{high}`.

#. Return :math:`j`.


:math:`{\mathsf{not}}{{}_{\mathsf{v{\scriptstyle 128}}}({\mathit{v{\kern-0.1em\scriptstyle 128}}})}`
....................................................................................................


1. Return :math:`{{\mathrm{inot}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}})`.


:math:`{{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{\mathsf{v{\scriptstyle 128}}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)}`
.................................................................................................................................................................................................


1. If :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{and}`, then:

   a. Return :math:`{{\mathrm{iand}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. If :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{andnot}`, then:

   a. Return :math:`{{\mathrm{iandnot}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. If :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{or}`, then:

   a. Return :math:`{{\mathrm{ior}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{xor}`.

#. Return :math:`{{\mathrm{ixor}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.


:math:`{\mathsf{bitselect}}{{}_{\mathsf{v{\scriptstyle 128}}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_3)}`
......................................................................................................................................................................................................


1. Return :math:`{{\mathrm{ibitselect}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_3)`.


:math:`{{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}}}{({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)}`
..............................................................................................................................................................................................


1. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{n}`, then:

   a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{abs}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{iabs}}}_{N}({\mathit{lane}}_1)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{neg}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{ineg}}}_{N}({\mathit{lane}}_1)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{popcnt}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{ipopcnt}}}_{N}({\mathit{lane}}_1)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{n}`.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{abs}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fabs}}}_{N}({\mathit{lane}}_1)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{neg}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fneg}}}_{N}({\mathit{lane}}_1)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sqrt}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fsqrt}}}_{N}({\mathit{lane}}_1)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ceil}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fceil}}}_{N}({\mathit{lane}}_1)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{floor}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{ffloor}}}_{N}({\mathit{lane}}_1)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{trunc}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{ftrunc}}}_{N}({\mathit{lane}}_1)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{nearest}`.

#. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

#. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fnearest}}}_{N}({\mathit{lane}}_1)^\ast}`.

#. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

#. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.


:math:`{{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}}}{({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)}`
............................................................................................................................................................................................................................................


1. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{n}`, then:

   a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{add}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{iadd}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sub}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{isub}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{min}`, then:

      1) Let :math:`({\mathsf{min}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{imin}}}_{N}({\mathit{sx}}, {\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{max}`, then:

      1) Let :math:`({\mathsf{max}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{imax}}}_{N}({\mathit{sx}}, {\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{add\_sat}`, then:

      1) Let :math:`({\mathsf{add\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{{{\mathrm{iadd\_sat}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)}^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{sub\_sat}`, then:

      1) Let :math:`({\mathsf{sub\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{{{\mathrm{isub\_sat}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)}^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{mul}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{imul}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = `, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{{{\mathrm{iavgr}}}_{N}^{\mathsf{u}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)}^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = `, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{{{\mathrm{iq{\kern-0.1em\scriptstyle 15\kern-0.1em}mulr\_sat}}}_{N}^{\mathsf{s}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)}^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{n}`.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{add}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fadd}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sub}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fsub}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{mul}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fmul}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{div}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fdiv}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{min}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fmin}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{max}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fmax}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{pmin}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fpmin}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

   #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

   #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{pmax}`.

#. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

#. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fpmax}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

#. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

#. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.


:math:`{{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}}}{({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)}`
............................................................................................................................................................................................................................................


1. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{n}`, then:

   a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{eq}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{ieq}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ne}`, then:

      1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{ine}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{lt}`, then:

      1) Let :math:`(\mathsf{lt}~{\mathit{sx}})` be :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{{{\mathrm{ilt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)})}^\ast}`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{gt}`, then:

      1) Let :math:`(\mathsf{gt}~{\mathit{sx}})` be :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{{{\mathrm{igt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)})}^\ast}`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{le}`, then:

      1) Let :math:`(\mathsf{le}~{\mathit{sx}})` be :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{{{\mathrm{ile}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)})}^\ast}`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

   #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ge}`, then:

      1) Let :math:`(\mathsf{ge}~{\mathit{sx}})` be :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

      #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

      #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{{{\mathrm{ige}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)})}^\ast}`.

      #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

      #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{n}`.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{eq}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathsf{f}}{n}|}`.

   #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{feq}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

   #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

   #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ne}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathsf{f}}{n}|}`.

   #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{fne}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

   #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

   #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{lt}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathsf{f}}{n}|}`.

   #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{flt}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

   #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

   #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{gt}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathsf{f}}{n}|}`.

   #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{fgt}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

   #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

   #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{le}`, then:

   a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

   #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

   #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathsf{f}}{n}|}`.

   #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{fle}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

   #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

   #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. Assert: Due to validation, :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ge}`.

#. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

#. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathsf{f}}{n}|}`.

#. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{fge}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

#. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

#. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.


:math:`{{\mathrm{vcvtop}}}_{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}}{\mathsf{x}}{M_1}, {{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, c_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
......................................................................................................................................................................................................................................................................................


1. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is :math:`{\mathsf{i}}{n}`, then:

   a. Let :math:`{{\mathsf{i}}{n}}_1` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

   #. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{n}`, then:

      1) Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{extend}`, then:

         a) Let :math:`(\mathsf{extend}~{\mathit{sx}})` be :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Let :math:`{\mathit{iN}}_1` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Let :math:`{\mathit{iN}}_2` be :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

         #) Return :math:`{\mathit{iN}}_2`.

   #. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{n}`, then:

      1) Let :math:`{{\mathsf{f}}{n}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{convert}`, then:

         a) Let :math:`(\mathsf{convert}~{\mathit{sx}})` be :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Let :math:`{\mathit{iN}}_1` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Let :math:`{\mathit{fN}}_2` be :math:`{{{{\mathrm{convert}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

         #) Return :math:`{\mathit{fN}}_2`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is :math:`{\mathsf{f}}{n}`.

#. Let :math:`{{\mathsf{f}}{n}}_1` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{n}`, then:

   a. Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{trunc\_sat}`, then:

      1) Let :math:`(\mathsf{trunc\_sat}~{\mathit{sx}})` be :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{\mathit{fN}}_1` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{{\mathit{iN}}_2^?}` be :math:`{{{{\mathrm{trunc\_sat}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{fN}}_1)}`.

      #) Return :math:`{{\mathit{iN}}_2^?}`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{n}`.

#. Let :math:`{{\mathsf{f}}{n}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{demote}`, then:

   a. Let :math:`{{\mathit{fN}}_2^\ast}` be :math:`{{\mathrm{demote}}}_{N_1, N_2}({\mathit{fN}}_1)`.

   #. Return :math:`{{\mathit{fN}}_2^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{promote}`.

#. Let :math:`{{\mathit{fN}}_2^\ast}` be :math:`{{\mathrm{promote}}}_{N_1, N_2}({\mathit{fN}}_1)`.

#. Return :math:`{{\mathit{fN}}_2^\ast}`.


:math:`{{\mathrm{vextunop}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(\mathsf{extadd\_pairwise}~{\mathit{sx}}, c_1)`
............................................................................................................................................................


1. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_1)`.

#. Let :math:`{{\mathit{cj}}_1~{\mathit{cj}}_2^\ast}` be the result for which :math:`{\mathrm{concat}}({{\mathit{cj}}_1~{\mathit{cj}}_2^\ast})` :math:`=` :math:`{{{{{\mathrm{extend}}}_{N_2, N_1}^{{\mathit{sx}}}}}{({\mathit{ci}})}^\ast}`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}}({{{\mathrm{iadd}}}_{N_1}({\mathit{cj}}_1, {\mathit{cj}}_2)^\ast})`.

#. Return :math:`c`.


:math:`{{\mathrm{vextbinop}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}({\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, c_1, c_2)`
.......................................................................................................................................................................................


1. If :math:`{\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{extmul}`, then:

   a. Let :math:`({\mathsf{extmul}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_1){}[{\mathrm{half}}({\mathit{hf}}, 0, M_1) : M_1]`.

   #. Let :math:`{{\mathit{ci}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_2){}[{\mathrm{half}}({\mathit{hf}}, 0, M_1) : M_1]`.

   #. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}}({{{\mathrm{imul}}}_{N_1}({{{{\mathrm{extend}}}_{N_2, N_1}^{{\mathit{sx}}}}}{({\mathit{ci}}_1)}, {{{{\mathrm{extend}}}_{N_2, N_1}^{{\mathit{sx}}}}}{({\mathit{ci}}_2)})^\ast})`.

   #. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = `.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_1)`.

#. Let :math:`{{\mathit{ci}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_2)`.

#. Let :math:`{{\mathit{cj}}_1~{\mathit{cj}}_2^\ast}` be the result for which :math:`{\mathrm{concat}}({{\mathit{cj}}_1~{\mathit{cj}}_2^\ast})` :math:`=` :math:`{{{\mathrm{imul}}}_{N_1}({{{{\mathrm{extend}}}_{N_2, N_1}^{\mathsf{s}}}}{({\mathit{ci}}_1)}, {{{{\mathrm{extend}}}_{N_2, N_1}^{\mathsf{s}}}}{({\mathit{ci}}_2)})^\ast}`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}}({{{\mathrm{iadd}}}_{N_1}({\mathit{cj}}_1, {\mathit{cj}}_2)^\ast})`.

#. Return :math:`c`.


:math:`{{{\mathit{vshiftop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{\_}}~{{\mathsf{i}}{n}}{\mathsf{x}}{M}}{({\mathit{lane}}, n)}`
...........................................................................................................................................


1. If :math:`{\mathit{vshiftop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{shl}`, then:

   a. Return :math:`{{\mathrm{ishl}}}_{N}({\mathit{lane}}, n)`.

#. Assert: Due to validation, :math:`{\mathit{vshiftop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{shr}`.

#. Let :math:`(\mathsf{shr}~{\mathit{sx}})` be :math:`{\mathit{vshiftop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{{{\mathrm{ishr}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}, n)}`.


:math:`{{\mathrm{default}}}_{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}`
........................................................................


1. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 32}}`, then:

   a. Return :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 64}}`, then:

   a. Return :math:`(\mathsf{i{\scriptstyle 64}}{.}\mathsf{const}~0)`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 32}}`, then:

   a. Return :math:`(\mathsf{f{\scriptstyle 32}}{.}\mathsf{const}~{+0})`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 64}}`, then:

   a. Return :math:`(\mathsf{f{\scriptstyle 64}}{.}\mathsf{const}~{+0})`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{v{\scriptstyle 128}}`, then:

   a. Return :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~0)`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{funcref}`, then:

   a. Return :math:`(\mathsf{ref{.}null}~\mathsf{funcref})`.

#. Assert: Due to validation, :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{externref}`.

#. Return :math:`(\mathsf{ref{.}null}~\mathsf{externref})`.


:math:`{\mathrm{funcs}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
......................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is :math:`\mathsf{func}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{fa}})` be :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{fa}}~{\mathrm{funcs}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is :math:`\mathsf{global}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{ga}})` be :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ga}}~{\mathrm{globals}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is :math:`\mathsf{table}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{ta}})` be :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ta}}~{\mathrm{tables}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is :math:`\mathsf{mem}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{ma}})` be :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ma}}~{\mathrm{mems}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xv}}^\ast})`.


:math:`(s, f){.}\mathsf{store}`
...............................


1. Return.


:math:`(s, f){.}\mathsf{frame}`
...............................


1. Return :math:`f`.


:math:`(s, f){.}\mathsf{module}{.}\mathsf{funcs}`
.................................................


1. Return :math:`f{.}\mathsf{module}{.}\mathsf{funcs}`.


:math:`(s, f){.}\mathsf{funcs}`
...............................


1. Return :math:`s{.}\mathsf{funcs}`.


:math:`(s, f){.}\mathsf{globals}`
.................................


1. Return :math:`s{.}\mathsf{globals}`.


:math:`(s, f){.}\mathsf{tables}`
................................


1. Return :math:`s{.}\mathsf{tables}`.


:math:`(s, f){.}\mathsf{mems}`
..............................


1. Return :math:`s{.}\mathsf{mems}`.


:math:`(s, f){.}\mathsf{elems}`
...............................


1. Return :math:`s{.}\mathsf{elems}`.


:math:`(s, f){.}\mathsf{datas}`
...............................


1. Return :math:`s{.}\mathsf{datas}`.


:math:`(s, f){.}\mathsf{module}`
................................


1. Return :math:`f{.}\mathsf{module}`.


:math:`(s, f){.}\mathsf{types}{}[x]`
....................................


1. Return :math:`f{.}\mathsf{module}{.}\mathsf{types}{}[x]`.


:math:`(s, f){.}\mathsf{funcs}{}[x]`
....................................


1. Return :math:`s{.}\mathsf{funcs}{}[f{.}\mathsf{module}{.}\mathsf{funcs}{}[x]]`.


:math:`(s, f){.}\mathsf{globals}{}[x]`
......................................


1. Return :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]`.


:math:`(s, f){.}\mathsf{tables}{}[x]`
.....................................


1. Return :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]`.


:math:`(s, f){.}\mathsf{mems}{}[x]`
...................................


1. Return :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]`.


:math:`(s, f){.}\mathsf{elems}{}[x]`
....................................


1. Return :math:`s{.}\mathsf{elems}{}[f{.}\mathsf{module}{.}\mathsf{elems}{}[x]]`.


:math:`(s, f){.}\mathsf{datas}{}[x]`
....................................


1. Return :math:`s{.}\mathsf{datas}{}[f{.}\mathsf{module}{.}\mathsf{datas}{}[x]]`.


:math:`(s, f){.}\mathsf{locals}{}[x]`
.....................................


1. Return :math:`f{.}\mathsf{locals}{}[x]`.


:math:`(s, f){}[{.}\mathsf{locals}{}[x] = v]`
.............................................


1. Replace :math:`f{.}\mathsf{locals}{}[x]` with :math:`v`.


:math:`(s, f){}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = v]`
...............................................................


1. Replace :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]{.}\mathsf{value}` with :math:`v`.


:math:`(s, f){}[{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i] = r]`
..................................................................


1. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]{.}\mathsf{refs}{}[i]` with :math:`r`.


:math:`(s, f){}[{.}\mathsf{tables}{}[x] = {\mathit{ti}}]`
.........................................................


1. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]` with :math:`{\mathit{ti}}`.


:math:`(s, f){}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i : j] = {b^\ast}]`
............................................................................


1. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]{.}\mathsf{bytes}{}[i : j]` with :math:`{b^\ast}`.


:math:`(s, f){}[{.}\mathsf{mems}{}[x] = {\mathit{mi}}]`
.......................................................


1. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]` with :math:`{\mathit{mi}}`.


:math:`(s, f){}[{.}\mathsf{elems}{}[x]{.}\mathsf{refs} = {r^\ast}]`
...................................................................


1. Replace :math:`s{.}\mathsf{elems}{}[f{.}\mathsf{module}{.}\mathsf{elems}{}[x]]{.}\mathsf{refs}` with :math:`{r^\ast}`.


:math:`(s, f){}[{.}\mathsf{datas}{}[x]{.}\mathsf{bytes} = {b^\ast}]`
....................................................................


1. Replace :math:`s{.}\mathsf{datas}{}[f{.}\mathsf{module}{.}\mathsf{datas}{}[x]]{.}\mathsf{bytes}` with :math:`{b^\ast}`.


:math:`{\mathrm{growtable}}({\mathit{ti}}, n, r)`
.................................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({}[~i~..~j~]~{\mathit{rt}}),\; \mathsf{refs}~{{r'}^\ast} \}\end{array}` be :math:`{\mathit{ti}}`.

#. Let :math:`{i'}` be :math:`{|{{r'}^\ast}|} + n`.

#. If :math:`{i'} \leq j`, then:

   a. Let :math:`{\mathit{ti}'}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({}[~{i'}~..~j~]~{\mathit{rt}}),\; \mathsf{refs}~{{r'}^\ast}~{r^{n}} \}\end{array}`.

   #. Return :math:`{\mathit{ti}'}`.


:math:`{\mathrm{growmemory}}({\mathit{mi}}, n)`
...............................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{}[~i~..~j~]~\mathsf{page},\; \mathsf{bytes}~{b^\ast} \}\end{array}` be :math:`{\mathit{mi}}`.

#. Let :math:`{i'}` be :math:`{|{b^\ast}|} / (64 \, {\mathrm{Ki}}) + n`.

#. If :math:`{i'} \leq j`, then:

   a. Let :math:`{\mathit{mi}'}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{}[~{i'}~..~j~]~\mathsf{page},\; \mathsf{bytes}~{b^\ast}~{\mathtt{0x00}^{n \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

   #. Return :math:`{\mathit{mi}'}`.


:math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
.........................................................................................


1. If :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \epsilon`, then:

   a. Return :math:`\epsilon~\rightarrow~\epsilon`.

#. If :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is , then:

   a. Let :math:`{{\mathit{valtype}}_0^?}` be :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{{\mathit{valtype}}_0^?}` is defined, then:

      1) Let :math:`t` be :math:`{{\mathit{valtype}}_0^?}`.

      #) Return :math:`\epsilon~\rightarrow~t`.

#. Assert: Due to validation, :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is .

#. Let :math:`x` be :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`z{.}\mathsf{types}{}[x]`.


:math:`{\mathrm{funcs}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
......................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is :math:`\mathsf{func}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{fa}})` be :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{fa}}~{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is :math:`\mathsf{global}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{ga}})` be :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ga}}~{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is :math:`\mathsf{table}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{ta}})` be :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ta}}~{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is :math:`\mathsf{mem}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{ma}})` be :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`{\mathit{ma}}~{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{allocfunc}}(s, {\mathit{moduleinst}}, {\mathit{func}})`
.......................................................................


1. Let :math:`(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}})` be :math:`{\mathit{func}}`.

#. Let :math:`{\mathit{fi}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{moduleinst}}{.}\mathsf{types}{}[x],\; \mathsf{module}~{\mathit{moduleinst}},\; \mathsf{code}~{\mathit{func}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{funcs}|}`.

#. Append :math:`{\mathit{fi}}` to :math:`s{.}\mathsf{funcs}`.

#. Return :math:`a`.


:math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................................................


1. If :math:`{{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{func}}~{{\mathit{func}'}^\ast}` be :math:`{{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{fa}}` be :math:`{\mathrm{allocfunc}}(s, {\mathit{moduleinst}}, {\mathit{func}})`.

#. Let :math:`{{\mathit{fa}'}^\ast}` be :math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}'}^\ast})`.

#. Return :math:`{\mathit{fa}}~{{\mathit{fa}'}^\ast}`.


:math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`
........................................................................


1. Let :math:`{\mathit{gi}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{globaltype}},\; \mathsf{value}~{\mathit{val}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{globals}|}`.

#. Append :math:`{\mathit{gi}}` to :math:`s{.}\mathsf{globals}`.

#. Return :math:`a`.


:math:`{\mathrm{allocglobals}}(s, {{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
..................................................................................................................................................


1. If :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Assert: Due to validation, :math:`{v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`.

   #. Return :math:`\epsilon`.

#. Else:

   a. Let :math:`{\mathit{globaltype}}~{{\mathit{globaltype}'}^\ast}` be :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

   #. Assert: Due to validation, :math:`{|{v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

   #. Let :math:`{\mathit{val}}~{{\mathit{val}'}^\ast}` be :math:`{v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

   #. Let :math:`{\mathit{ga}}` be :math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`.

   #. Let :math:`{{\mathit{ga}'}^\ast}` be :math:`{\mathrm{allocglobals}}(s, {{\mathit{globaltype}'}^\ast}, {{\mathit{val}'}^\ast})`.

   #. Return :math:`{\mathit{ga}}~{{\mathit{ga}'}^\ast}`.


:math:`{\mathrm{alloctable}}(s, {}[~i~..~j~]~{\mathit{rt}})`
............................................................


1. Let :math:`{\mathit{ti}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({}[~i~..~j~]~{\mathit{rt}}),\; \mathsf{refs}~{(\mathsf{ref{.}null}~{\mathit{rt}})^{i}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{tables}|}`.

#. Append :math:`{\mathit{ti}}` to :math:`s{.}\mathsf{tables}`.

#. Return :math:`a`.


:math:`{\mathrm{alloctables}}(s, {{\mathit{tt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
...............................................................................................


1. If :math:`{{\mathit{tt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{tabletype}}~{{\mathit{tabletype}'}^\ast}` be :math:`{{\mathit{tt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{ta}}` be :math:`{\mathrm{alloctable}}(s, {\mathit{tabletype}})`.

#. Let :math:`{{\mathit{ta}'}^\ast}` be :math:`{\mathrm{alloctables}}(s, {{\mathit{tabletype}'}^\ast})`.

#. Return :math:`{\mathit{ta}}~{{\mathit{ta}'}^\ast}`.


:math:`{\mathrm{allocmem}}(s, {}[~i~..~j~]~\mathsf{page})`
..........................................................


1. Let :math:`{\mathit{mi}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{}[~i~..~j~]~\mathsf{page},\; \mathsf{bytes}~{\mathtt{0x00}^{i \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{mems}|}`.

#. Append :math:`{\mathit{mi}}` to :math:`s{.}\mathsf{mems}`.

#. Return :math:`a`.


:math:`{\mathrm{allocmems}}(s, {{\mathit{mt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.............................................................................................


1. If :math:`{{\mathit{mt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{memtype}}~{{\mathit{memtype}'}^\ast}` be :math:`{{\mathit{mt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{ma}}` be :math:`{\mathrm{allocmem}}(s, {\mathit{memtype}})`.

#. Let :math:`{{\mathit{ma}'}^\ast}` be :math:`{\mathrm{allocmems}}(s, {{\mathit{memtype}'}^\ast})`.

#. Return :math:`{\mathit{ma}}~{{\mathit{ma}'}^\ast}`.


:math:`{\mathrm{allocelem}}(s, {\mathit{rt}}, {{\mathit{ref}}^\ast})`
.....................................................................


1. Let :math:`{\mathit{ei}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{rt}},\; \mathsf{refs}~{{\mathit{ref}}^\ast} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{elems}|}`.

#. Append :math:`{\mathit{ei}}` to :math:`s{.}\mathsf{elems}`.

#. Return :math:`a`.


:math:`{\mathrm{allocelems}}(s, {{\mathit{rt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
................................................................................................................................................


1. If :math:`{{\mathit{rt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon` and :math:`{r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{{\mathit{ref}}^\ast}~{{{\mathit{ref}'}^\ast}^\ast}` be :math:`{r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{rt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{rt}}~{{\mathit{rt}'}^\ast}` be :math:`{{\mathit{rt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{ea}}` be :math:`{\mathrm{allocelem}}(s, {\mathit{rt}}, {{\mathit{ref}}^\ast})`.

#. Let :math:`{{\mathit{ea}'}^\ast}` be :math:`{\mathrm{allocelems}}(s, {{\mathit{rt}'}^\ast}, {{{\mathit{ref}'}^\ast}^\ast})`.

#. Return :math:`{\mathit{ea}}~{{\mathit{ea}'}^\ast}`.


:math:`{\mathrm{allocdata}}(s, {{\mathit{byte}}^\ast})`
.......................................................


1. Let :math:`{\mathit{di}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{bytes}~{{\mathit{byte}}^\ast} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{datas}|}`.

#. Append :math:`{\mathit{di}}` to :math:`s{.}\mathsf{datas}`.

#. Return :math:`a`.


:math:`{\mathrm{allocdatas}}(s, {b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
..................................................................................


1. If :math:`{b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{{\mathit{byte}}^\ast}~{{{\mathit{byte}'}^\ast}^\ast}` be :math:`{b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{da}}` be :math:`{\mathrm{allocdata}}(s, {{\mathit{byte}}^\ast})`.

#. Let :math:`{{\mathit{da}'}^\ast}` be :math:`{\mathrm{allocdatas}}(s, {{{\mathit{byte}'}^\ast}^\ast})`.

#. Return :math:`{\mathit{da}}~{{\mathit{da}'}^\ast}`.


:math:`{\mathrm{instexport}}({{\mathit{fa}}^\ast}, {{\mathit{ga}}^\ast}, {{\mathit{ta}}^\ast}, {{\mathit{ma}}^\ast}, \mathsf{export}~{\mathit{name}}~{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
...................................................................................................................................................................................................................


1. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{func}`, then:

   a. Let :math:`(\mathsf{func}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{func}~{{\mathit{fa}}^\ast}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{global}`, then:

   a. Let :math:`(\mathsf{global}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{global}~{{\mathit{ga}}^\ast}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{table}`, then:

   a. Let :math:`(\mathsf{table}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{table}~{{\mathit{ta}}^\ast}{}[x]) \}\end{array}`.

#. Assert: Due to validation, :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{mem}`.

#. Let :math:`(\mathsf{mem}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{mem}~{{\mathit{ma}}^\ast}{}[x]) \}\end{array}`.


:math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}^\ast}, {{{\mathit{ref}}^\ast}^\ast})`
.......................................................................................................................................


1. Let :math:`(\mathsf{module}~{{\mathit{type}}_0^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^{n_{\mathit{func}}}}~{{\mathit{global}}_1^\ast}~{{\mathit{table}}_2^\ast}~{{\mathit{mem}}_3^\ast}~{{\mathit{elem}}_4^\ast}~{{\mathit{data}}_5^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be :math:`{\mathit{module}}`.

#. Let :math:`{(\mathsf{data}~{{\mathit{byte}}^\ast}~{\mathit{datamode}})^{n_{\mathit{data}}}}` be :math:`{{\mathit{data}}_5^\ast}`.

#. Let :math:`{(\mathsf{elem}~{\mathit{rt}}~{{\mathit{expr}}_2^\ast}~{\mathit{elemmode}})^{n_{\mathit{elem}}}}` be :math:`{{\mathit{elem}}_4^\ast}`.

#. Let :math:`{(\mathsf{memory}~{\mathit{memtype}})^{n_{\mathit{mem}}}}` be :math:`{{\mathit{mem}}_3^\ast}`.

#. Let :math:`{(\mathsf{table}~{\mathit{tabletype}})^{n_{\mathit{table}}}}` be :math:`{{\mathit{table}}_2^\ast}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_1)^{n_{\mathit{global}}}}` be :math:`{{\mathit{global}}_1^\ast}`.

#. Let :math:`{(\mathsf{type}~{\mathit{ft}})^\ast}` be :math:`{{\mathit{type}}_0^\ast}`.

#. Let :math:`{{\mathit{fa}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ga}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{globals}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ma}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{mems}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ta}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{tables}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{fa}}^\ast}` be :math:`{({|s{.}\mathsf{funcs}|} + i_{\mathit{func}})^{i_{\mathit{func}}<n_{\mathit{func}}}}`.

#. Let :math:`{{\mathit{ga}}^\ast}` be :math:`{({|s{.}\mathsf{globals}|} + i_{\mathit{global}})^{i_{\mathit{global}}<n_{\mathit{global}}}}`.

#. Let :math:`{{\mathit{ta}}^\ast}` be :math:`{({|s{.}\mathsf{tables}|} + i_{\mathit{table}})^{i_{\mathit{table}}<n_{\mathit{table}}}}`.

#. Let :math:`{{\mathit{ma}}^\ast}` be :math:`{({|s{.}\mathsf{mems}|} + i_{\mathit{mem}})^{i_{\mathit{mem}}<n_{\mathit{mem}}}}`.

#. Let :math:`{{\mathit{ea}}^\ast}` be :math:`{({|s{.}\mathsf{elems}|} + i_{\mathit{elem}})^{i_{\mathit{elem}}<n_{\mathit{elem}}}}`.

#. Let :math:`{{\mathit{da}}^\ast}` be :math:`{({|s{.}\mathsf{datas}|} + i_{\mathit{data}})^{i_{\mathit{data}}<n_{\mathit{data}}}}`.

#. Let :math:`{{\mathit{xi}}^\ast}` be :math:`{{\mathrm{instexport}}({{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast}, {{\mathit{ga}}_{\mathit{ex}}^\ast}~{{\mathit{ga}}^\ast}, {{\mathit{ta}}_{\mathit{ex}}^\ast}~{{\mathit{ta}}^\ast}, {{\mathit{ma}}_{\mathit{ex}}^\ast}~{{\mathit{ma}}^\ast}, {\mathit{export}})^\ast}`.

#. Let :math:`{\mathit{moduleinst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}}^\ast},\; \mathsf{funcs}~{{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast},\; \mathsf{globals}~{{\mathit{ga}}_{\mathit{ex}}^\ast}~{{\mathit{ga}}^\ast},\; \mathsf{tables}~{{\mathit{ta}}_{\mathit{ex}}^\ast}~{{\mathit{ta}}^\ast},\; \mathsf{mems}~{{\mathit{ma}}_{\mathit{ex}}^\ast}~{{\mathit{ma}}^\ast},\; \mathsf{elems}~{{\mathit{ea}}^\ast},\; \mathsf{datas}~{{\mathit{da}}^\ast},\; \mathsf{exports}~{{\mathit{xi}}^\ast} \}\end{array}`.

#. Let :math:`{{\mathit{funcaddr}}_0^\ast}` be :math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}}^{n_{\mathit{func}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{funcaddr}}_0^\ast} = {{\mathit{fa}}^\ast}`.

#. Let :math:`{{\mathit{globaladdr}}_0^\ast}` be :math:`{\mathrm{allocglobals}}(s, {{\mathit{globaltype}}^{n_{\mathit{global}}}}, {{\mathit{val}}^\ast})`.

#. Assert: Due to validation, :math:`{{\mathit{globaladdr}}_0^\ast} = {{\mathit{ga}}^\ast}`.

#. Let :math:`{{\mathit{tableaddr}}_0^\ast}` be :math:`{\mathrm{alloctables}}(s, {{\mathit{tabletype}}^{n_{\mathit{table}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{tableaddr}}_0^\ast} = {{\mathit{ta}}^\ast}`.

#. Let :math:`{{\mathit{memaddr}}_0^\ast}` be :math:`{\mathrm{allocmems}}(s, {{\mathit{memtype}}^{n_{\mathit{mem}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{memaddr}}_0^\ast} = {{\mathit{ma}}^\ast}`.

#. Let :math:`{{\mathit{elemaddr}}_0^\ast}` be :math:`{\mathrm{allocelems}}(s, {{\mathit{rt}}^{n_{\mathit{elem}}}}, {{{\mathit{ref}}^\ast}^\ast})`.

#. Assert: Due to validation, :math:`{{\mathit{elemaddr}}_0^\ast} = {{\mathit{ea}}^\ast}`.

#. Let :math:`{{\mathit{dataaddr}}_0^\ast}` be :math:`{\mathrm{allocdatas}}(s, {({{\mathit{byte}}^\ast})^{n_{\mathit{data}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{dataaddr}}_0^\ast} = {{\mathit{da}}^\ast}`.

#. Return :math:`{\mathit{moduleinst}}`.


:math:`{\mathrm{runelem}}(\mathsf{elem}~{\mathit{reftype}}~{{\mathit{expr}}^\ast}~{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, i)`
..................................................................................................................................................


1. If :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{passive}`, then:

   a. Return :math:`\epsilon`.

#. If :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{declare}`, then:

   a. Return :math:`(\mathsf{elem{.}drop}~i)`.

#. Assert: Due to validation, :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{active}`.

#. Let :math:`(\mathsf{active}~x~{{\mathit{instr}}^\ast})` be :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`n` be :math:`{|{{\mathit{expr}}^\ast}|}`.

#. Return :math:`{{\mathit{instr}}^\ast}~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)~(\mathsf{table{.}init}~x~i)~(\mathsf{elem{.}drop}~i)`.


:math:`{\mathrm{rundata}}(\mathsf{data}~{{\mathit{byte}}^\ast}~{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, i)`
...............................................................................................................................


1. If :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{passive}`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{active}`.

#. Let :math:`(\mathsf{active}~{\mathit{memidx}}_0~{{\mathit{instr}}^\ast})` be :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Assert: Due to validation, :math:`{\mathit{memidx}}_0 = 0`.

#. Let :math:`n` be :math:`{|{{\mathit{byte}}^\ast}|}`.

#. Return :math:`{{\mathit{instr}}^\ast}~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)~(\mathsf{memory{.}init}~i)~(\mathsf{data{.}drop}~i)`.


:math:`{\mathrm{instantiate}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast})`
..................................................................................


1. Let :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be :math:`{\mathit{module}}`.

#. Let :math:`{(\mathsf{type}~{\mathit{functype}})^\ast}` be :math:`{{\mathit{type}}^\ast}`.

#. Let :math:`n_{\mathsf{d}}` be :math:`{|{{\mathit{data}}^\ast}|}`.

#. Let :math:`n_{\mathsf{e}}` be :math:`{|{{\mathit{elem}}^\ast}|}`.

#. Let :math:`n_{\mathsf{f}}` be :math:`{|{{\mathit{func}}^\ast}|}`.

#. Let :math:`{(\mathsf{start}~x)^?}` be :math:`{{\mathit{start}}^?}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_{\mathsf{g}})^\ast}` be :math:`{{\mathit{global}}^\ast}`.

#. Let :math:`{(\mathsf{elem}~{\mathit{reftype}}~{{\mathit{expr}}_{\mathsf{e}}^\ast}~{\mathit{elemmode}})^\ast}` be :math:`{{\mathit{elem}}^\ast}`.

#. Let :math:`{{\mathit{instr}}_{\mathsf{d}}^\ast}` be the concatenation of :math:`{{\mathrm{rundata}}({{\mathit{data}}^\ast}{}[j], j)^{j<n_{\mathsf{d}}}}`.

#. Let :math:`{{\mathit{instr}}_{\mathsf{e}}^\ast}` be the concatenation of :math:`{{\mathrm{runelem}}({{\mathit{elem}}^\ast}{}[i], i)^{i<n_{\mathsf{e}}}}`.

#. Let :math:`{\mathit{moduleinst}}_{\mathit{init}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{functype}}^\ast},\; \mathsf{funcs}~{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})~{({|s{.}\mathsf{funcs}|} + i_{\mathsf{f}})^{i_{\mathsf{f}}<n_{\mathsf{f}}}},\; \mathsf{globals}~{\mathrm{globals}}({{\mathit{externaddr}}^\ast}) \}\end{array}`.

#. Let :math:`f_{\mathit{init}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{module}~{\mathit{moduleinst}}_{\mathit{init}} \}\end{array}`.

#. Let :math:`z` be :math:`(s, f_{\mathit{init}})`.

#. Push the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~z{.}\mathsf{frame}~\})` to the stack.

#. Let :math:`{{\mathit{val}}^\ast}` be the result of :ref:`evaluating <exec-expr>` :math:`{{\mathit{expr}}_{\mathsf{g}}^\ast}` with state :math:`z`.

#. Pop the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~z{.}\mathsf{frame}~\})` from the stack.

#. Push the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~z{.}\mathsf{frame}~\})` to the stack.

#. Let :math:`{{{\mathit{ref}}^\ast}^\ast}` be the result of :ref:`evaluating <exec-expr>` :math:`{{{\mathit{expr}}_{\mathsf{e}}^\ast}^\ast}` with state :math:`z`.

#. Pop the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~z{.}\mathsf{frame}~\})` from the stack.

#. Let :math:`{\mathit{moduleinst}}` be :math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}^\ast}, {{{\mathit{ref}}^\ast}^\ast})`.

#. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{module}~{\mathit{moduleinst}} \}\end{array}`.

#. Push the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~f~\})` to the stack.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{e}}^\ast}`.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{d}}^\ast}`.

#. Execute the sequence :math:`{(\mathsf{call}~x)^?}`.

#. Pop the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~f~\})` from the stack.

#. Return :math:`f{.}\mathsf{module}`.


:math:`{\mathrm{invoke}}(s, {\mathit{fa}}, {{\mathit{val}}^{n}})`
.................................................................


1. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{module}~\{ \begin{array}[t]{@{}l@{}} \}\end{array} \}\end{array}`.

#. Push the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~(s, f)~\})` to the stack.

#. Let :math:`{t_1^{n}}~\rightarrow~{t_2^\ast}` be :math:`(s, f){.}\mathsf{funcs}{}[{\mathit{fa}}]{.}\mathsf{type}`.

#. Pop the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~f~\})` from the stack.

#. Let :math:`k` be :math:`{|{t_2^\ast}|}`.

#. Push the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{k}\,\{~f~\})` to the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{call}~{\mathit{fa}})`.

#. Pop all values :math:`{{\mathit{val}}_0^\ast}` from the top of the stack.

#. Pop the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{k}\,\{~f~\})` from the stack.

#. Push the values :math:`{{\mathit{val}}_0^\ast}` to the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Return :math:`{{\mathit{val}}^{k}}`.


:math:`\mathsf{eval\_expr}~{{\mathit{instr}}^\ast}`
...................................................


1. Execute the instruction :math:`{{\mathit{instr}}^\ast}`.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Return :math:`{\mathit{val}}`.


== Complete.
watsup 0.4 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...
Limits_ok
- the limits ([ n .. m ]) is valid with k if:
  - n is less than or equal to m.
  - m is less than or equal to k.

Functype_ok
- the function type t_1* -> t_2* is valid.

Globaltype_ok
- the global type (MUT? t) is valid.

Tabletype_ok
- the table type (limits reftype) is valid if:
  - the limits limits is valid with ((2 ^ 32) - 1).

Memtype_ok
- the memory type limits PAGE is valid if:
  - the limits limits is valid with (2 ^ 16).

Externtype_ok
- the external type xt_u1 is valid if:
  - Either:
    - xt_u1 is (FUNC functype).
    - the function type functype is valid.
  - Or:
    - xt_u1 is (GLOBAL globaltype).
    - the global type globaltype is valid.
  - Or:
    - xt_u1 is (TABLE tabletype).
    - the table type tabletype is valid.
  - Or:
    - xt_u1 is (MEM memtype).
    - the memory type memtype is valid.

Externtype_ok/func
- the external type (FUNC functype) is valid if:
  - the function type functype is valid.

Externtype_ok/global
- the external type (GLOBAL globaltype) is valid if:
  - the global type globaltype is valid.

Externtype_ok/table
- the external type (TABLE tabletype) is valid if:
  - the table type tabletype is valid.

Externtype_ok/mem
- the external type (MEM memtype) is valid if:
  - the memory type memtype is valid.

Valtype_sub
- the value type t_u1 matches the value type t if:
  - Either:
    - t_u1 is t.
  - Or:
    - t_u1 is BOT.

Valtype_sub/refl
- t matches itself.

Valtype_sub/bot
- the value type BOT matches t.

Resulttype_sub
- the value type sequence t_1* matches the value type sequence t_2* if:
  - |t_1*| is |t_2*|.
  - For all t_1 in t_1* and t_2 in t_2*:
    - the value type t_1 matches the value type t_2.

Limits_sub
- the limits ([ n_11 .. n_12 ]) matches the limits ([ n_21 .. n_22 ]) if:
  - n_11 is greater than or equal to n_21.
  - n_12 is less than or equal to n_22.

Functype_sub
- the function type ft matches itself.

Globaltype_sub
- the global type gt matches itself.

Tabletype_sub
- the table type (lim_1 rt) matches the table type (lim_2 rt) if:
  - the limits lim_1 matches the limits lim_2.

Memtype_sub
- the memory type lim_1 PAGE matches the memory type lim_2 PAGE if:
  - the limits lim_1 matches the limits lim_2.

Externtype_sub
- the external type xt_u1 matches the external type xt_u2 if:
  - Either:
    - xt_u1 is (FUNC ft_1).
    - xt_u2 is (FUNC ft_2).
    - the function type ft_1 matches the function type ft_2.
  - Or:
    - xt_u1 is (GLOBAL gt_1).
    - xt_u2 is (GLOBAL gt_2).
    - the global type gt_1 matches the global type gt_2.
  - Or:
    - xt_u1 is (TABLE tt_1).
    - xt_u2 is (TABLE tt_2).
    - the table type tt_1 matches the table type tt_2.
  - Or:
    - xt_u1 is (MEM mt_1).
    - xt_u2 is (MEM mt_2).
    - the memory type mt_1 matches the memory type mt_2.

Externtype_sub/func
- the external type (FUNC ft_1) matches the external type (FUNC ft_2) if:
  - the function type ft_1 matches the function type ft_2.

Externtype_sub/global
- the external type (GLOBAL gt_1) matches the external type (GLOBAL gt_2) if:
  - the global type gt_1 matches the global type gt_2.

Externtype_sub/table
- the external type (TABLE tt_1) matches the external type (TABLE tt_2) if:
  - the table type tt_1 matches the table type tt_2.

Externtype_sub/mem
- the external type (MEM mt_1) matches the external type (MEM mt_2) if:
  - the memory type mt_1 matches the memory type mt_2.

Blocktype_ok
- the block type bt_u1 is valid with the function type t_u1* -> t_u2* if:
  - Either:
    - bt_u1 is (_RESULT valtype?).
    - the value type sequence t_u1* is [].
    - the value type sequence t_u2* is valtype?.
  - Or:
    - bt_u1 is (_IDX typeidx).
    - t_u1* is t_1*.
    - t_u2* is t_2*.
    - the function type C.TYPES[typeidx] exists.
    - C.TYPES[typeidx] is t_1* -> t_2*.

Blocktype_ok/valtype
- the block type (_RESULT valtype?) is valid with the function type [] -> valtype?.

Blocktype_ok/typeidx
- the block type (_IDX typeidx) is valid with the function type t_1* -> t_2* if:
  - the function type C.TYPES[typeidx] exists.
  - C.TYPES[typeidx] is t_1* -> t_2*.

Instr_ok/nop
- the instruction NOP is valid with the function type [] -> [].

Instr_ok/unreachable
- the instruction UNREACHABLE is valid with t_1* -> t_2*.

Instr_ok/drop
- the instruction DROP is valid with the function type [t] -> [].

Instr_ok/select
- the instruction (SELECT t_u1?) is valid with the function type [t, t, I32] -> [t] if:
  - Either:
    - the value type sequence t_u1? is ?([t]).
  - Or:
    - t_u1? is ?().
    - the value type t matches the value type t'.
    - t' is numtype or t' is vectype.

Instr_ok/block
- the instruction (BLOCK bt instr*) is valid with the function type t_1* -> t_2* if:
  - the block type bt is valid with t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr* is valid with t_1* -> t_2*.

Instr_ok/loop
- the instruction (LOOP bt instr*) is valid with the function type t_1* -> t_2* if:
  - the block type bt is valid with t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_1*].
  - Under the context C', the instruction sequence instr* is valid with t_1* -> t_2*.

Instr_ok/if
- the instruction (IF bt instr_1* ELSE instr_2*) is valid with the function type t_1* :: [I32] -> t_2* if:
  - the block type bt is valid with the function type t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr_1* is valid with t_1* -> t_2*.
  - Under the context C', the instruction sequence instr_2* is valid with t_1* -> t_2*.

Instr_ok/br
- the instruction (BR l) is valid with the function type t_1* :: t* -> t_2* if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t*.

Instr_ok/br_if
- the instruction (BR_IF l) is valid with the function type t* :: [I32] -> t* if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t*.

Instr_ok/br_table
- the instruction (BR_TABLE l* l') is valid with the function type t_1* :: t* :: [I32] -> t_2* if:
  - For all l in l*:
    - the result type C.LABELS[l] exists.
  - For all l in l*:
    - the value type sequence t* matches C.LABELS[l].
  - the result type C.LABELS[l'] exists.
  - t* matches C.LABELS[l'].

Instr_ok/call
- the instruction (CALL x) is valid with the function type t_1* -> t_2* if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is t_1* -> t_2*.

Instr_ok/call_indirect
- the instruction (CALL_INDIRECT x y) is valid with the function type t_1* :: [I32] -> t_2* if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim FUNCREF).
  - the function type C.TYPES[y] exists.
  - C.TYPES[y] is t_1* -> t_2*.

Instr_ok/return
- the instruction RETURN is valid with the function type t_1* :: t* -> t_2* if:
  - the result type C.RETURN is ?(t*).

Instr_ok/const
- the instruction (nt.CONST c_nt) is valid with the function type [] -> [nt].

Instr_ok/unop
- the instruction (UNOP nt unop_nt) is valid with the function type [nt] -> [nt].

Instr_ok/binop
- the instruction (BINOP nt binop_nt) is valid with the function type [nt, nt] -> [nt].

Instr_ok/testop
- the instruction (TESTOP nt testop_nt) is valid with the function type [nt] -> [I32].

Instr_ok/relop
- the instruction (RELOP nt relop_nt) is valid with the function type [nt, nt] -> [I32].

Instr_ok/cvtop
- the instruction (CVTOP nt_1 nt_2 cvtop_u1) is valid with the function type [nt_2] -> [nt_1] if:
  - Either:
    - cvtop_u1 is REINTERPRET.
    - $size(nt_1) is $size(nt_2).
  - Or:
    - cvtop_u1 is cvtop.

Instr_ok/ref.null
- the instruction (REF.NULL rt) is valid with the function type [] -> [rt].

Instr_ok/ref.func
- the instruction (REF.FUNC x) is valid with the function type [] -> [FUNCREF] if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is ft.

Instr_ok/ref.is_null
- the instruction REF.IS_NULL is valid with the function type [rt] -> [I32].

Instr_ok/vconst
- the instruction (V128.CONST c) is valid with the function type [] -> [V128].

Instr_ok/vvunop
- the instruction (VVUNOP V128 vvunop) is valid with the function type [V128] -> [V128].

Instr_ok/vvbinop
- the instruction (VVBINOP V128 vvbinop) is valid with the function type [V128, V128] -> [V128].

Instr_ok/vvternop
- the instruction (VVTERNOP V128 vvternop) is valid with the function type [V128, V128, V128] -> [V128].

Instr_ok/vvtestop
- the instruction (VVTESTOP V128 vvtestop) is valid with the function type [V128] -> [I32].

Instr_ok/vunop
- the instruction (VUNOP sh vunop_sh) is valid with [V128] -> [V128].

Instr_ok/vbinop
- the instruction (VBINOP sh vbinop_sh) is valid with [V128, V128] -> [V128].

Instr_ok/vtestop
- the instruction (VTESTOP sh vtestop_sh) is valid with [V128] -> [I32].

Instr_ok/vrelop
- the instruction (VRELOP sh vrelop_sh) is valid with [V128, V128] -> [V128].

Instr_ok/vshiftop
- the instruction (VSHIFTOP sh vshiftop_sh) is valid with the function type [V128, I32] -> [V128].

Instr_ok/vbitmask
- the instruction (VBITMASK sh) is valid with [V128] -> [I32].

Instr_ok/vswizzle
- the instruction (VSWIZZLE sh) is valid with [V128, V128] -> [V128].

Instr_ok/vshuffle
- the instruction (VSHUFFLE sh i*) is valid with the function type [V128, V128] -> [V128] if:
  - For all i in i*:
    - the lane index i is less than (2 * $dim(sh)).

Instr_ok/vsplat
- the instruction (VSPLAT sh) is valid with the function type [t] -> [V128] if:
  - Let t be the number type $shunpack(sh).

Instr_ok/vextract_lane
- the instruction (VEXTRACT_LANE sh sx? i) is valid with the function type [V128] -> [t] if:
  - the lane index i is less than $dim(sh).
  - Let t be the number type $shunpack(sh).

Instr_ok/vreplace_lane
- the instruction (VREPLACE_LANE sh i) is valid with the function type [V128, t] -> [V128] if:
  - the lane index i is less than $dim(sh).
  - Let t be the number type $shunpack(sh).

Instr_ok/vextunop
- the instruction (VEXTUNOP sh_1 sh_2 vextunop) is valid with the function type [V128] -> [V128].

Instr_ok/vextbinop
- the instruction (VEXTBINOP sh_1 sh_2 vextbinop) is valid with the function type [V128, V128] -> [V128].

Instr_ok/vnarrow
- the instruction (VNARROW sh_1 sh_2 sx) is valid with [V128, V128] -> [V128].

Instr_ok/vcvtop
- the instruction (VCVTOP sh_1 sh_2 vcvtop hf? zero?) is valid with [V128] -> [V128].

Instr_ok/local.get
- the instruction (LOCAL.GET x) is valid with the function type [] -> [t] if:
  - the value type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/local.set
- the instruction (LOCAL.SET x) is valid with the function type [t] -> [] if:
  - the value type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/local.tee
- the instruction (LOCAL.TEE x) is valid with the function type [t] -> [t] if:
  - the value type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/global.get
- the instruction (GLOBAL.GET x) is valid with the function type [] -> [t] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (mut t).

Instr_ok/global.set
- the instruction (GLOBAL.SET x) is valid with the function type [t] -> [] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?(MUT) t).

Instr_ok/table.get
- the instruction (TABLE.GET x) is valid with the function type [I32] -> [rt] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.set
- the instruction (TABLE.SET x) is valid with the function type [I32, rt] -> [] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.size
- the instruction (TABLE.SIZE x) is valid with the function type [] -> [I32] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.grow
- the instruction (TABLE.GROW x) is valid with the function type [rt, I32] -> [I32] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.fill
- the instruction (TABLE.FILL x) is valid with the function type [I32, rt, I32] -> [] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.copy
- the instruction (TABLE.COPY x_1 x_2) is valid with the function type [I32, I32, I32] -> [] if:
  - the table type C.TABLES[x_1] exists.
  - C.TABLES[x_1] is (lim_1 rt).
  - the table type C.TABLES[x_2] exists.
  - C.TABLES[x_2] is (lim_2 rt).

Instr_ok/table.init
- the instruction (TABLE.INIT x_1 x_2) is valid with the function type [I32, I32, I32] -> [] if:
  - the table type C.TABLES[x_1] exists.
  - C.TABLES[x_1] is (lim rt).
  - the element type C.ELEMS[x_2] exists.
  - C.ELEMS[x_2] is rt.

Instr_ok/elem.drop
- the instruction (ELEM.DROP x) is valid with the function type [] -> [] if:
  - the element type C.ELEMS[x] exists.
  - C.ELEMS[x] is rt.

Instr_ok/memory.size
- the instruction MEMORY.SIZE is valid with the function type [] -> [I32] if:
  - the memory type C.MEMS[0] is mt.

Instr_ok/memory.grow
- the instruction MEMORY.GROW is valid with the function type [I32] -> [I32] if:
  - the memory type C.MEMS[0] is mt.

Instr_ok/memory.fill
- the instruction MEMORY.FILL is valid with the function type [I32, I32, I32] -> [] if:
  - the memory type C.MEMS[0] is mt.

Instr_ok/memory.copy
- the instruction MEMORY.COPY is valid with the function type [I32, I32, I32] -> [] if:
  - the memory type C.MEMS[0] is mt.

Instr_ok/memory.init
- the instruction (MEMORY.INIT x) is valid with the function type [I32, I32, I32] -> [] if:
  - the memory type C.MEMS[0] is mt.
  - the data type C.DATAS[x] exists.
  - C.DATAS[x] is OK.

Instr_ok/data.drop
- the instruction (DATA.DROP x) is valid with the function type [] -> [] if:
  - the data type C.DATAS[x] exists.
  - C.DATAS[x] is OK.

Instr_ok/load
- the instruction (LOAD nt_u1 loadop__u1? memarg) is valid with the function type [I32] -> [t_u1] if:
  - the memory type C.MEMS[0] is mt.
  - Either:
    - the number type nt_u1 is nt.
    - loadop__u1? is ?().
    - the value type t_u1 is nt.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - Or:
    - nt_u1 is Inn.
    - loadop__u1? is ?(M _ sx).
    - t_u1 is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store
- the instruction (STORE nt_u1 sz_u1? memarg) is valid with the function type [I32, t_u1] -> [] if:
  - the memory type C.MEMS[0] is mt.
  - Either:
    - the number type nt_u1 is nt.
    - the pack size sz_u1? is ?().
    - the value type t_u1 is nt.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - Or:
    - nt_u1 is Inn.
    - sz_u1? is ?(M).
    - t_u1 is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/vload
- the instruction (VLOAD V128 ?(vloadop_u1) memarg) is valid with the function type [I32] -> [V128] if:
  - the memory type C.MEMS[0] is mt.
  - Either:
    - vloadop_u1 is (SHAPE M X N _ sx).
    - (2 ^ memarg.ALIGN) is less than or equal to ((M / 8) * N).
  - Or:
    - vloadop_u1 is (SPLAT n).
    - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).
  - Or:
    - vloadop_u1 is (ZERO n).
    - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).

Instr_ok/vload_lane
- the instruction (VLOAD_LANE V128 n memarg laneidx) is valid with the function type [I32, V128] -> [V128] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).
  - laneidx is less than (128 / n).

Instr_ok/vstore
- the instruction (VSTORE V128 memarg) is valid with the function type [I32, V128] -> [] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(V128) / 8).

Instr_ok/vstore_lane
- the instruction (VSTORE_LANE V128 n memarg laneidx) is valid with the function type [I32, V128] -> [] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).
  - laneidx is less than (128 / n).

Instr_ok/select-expl
- the instruction (SELECT ?([t])) is valid with the function type [t, t, I32] -> [t].

Instr_ok/select-impl
- the instruction (SELECT ?()) is valid with the function type [t, t, I32] -> [t] if:
  - the value type t matches the value type t'.
  - t' is numtype or t' is vectype.

Instr_ok/cvtop-reinterpret
- the instruction (CVTOP nt_1 nt_2 REINTERPRET) is valid with the function type [nt_2] -> [nt_1] if:
  - $size(nt_1) is $size(nt_2).

Instr_ok/cvtop-convert
- the instruction (CVTOP nt_1 nt_2 cvtop) is valid with [nt_2] -> [nt_1].

Instr_ok/load-val
- the instruction (LOAD nt ?() memarg) is valid with the function type [I32] -> [nt] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).

Instr_ok/load-pack
- the instruction (LOAD Inn ?(M _ sx) memarg) is valid with the function type [I32] -> [Inn] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store-val
- the instruction (STORE nt ?() memarg) is valid with the function type [I32, nt] -> [] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).

Instr_ok/store-pack
- the instruction (STORE Inn ?(M) memarg) is valid with the function type [I32, Inn] -> [] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/vload
- the instruction (VLOAD V128 ?((SHAPE M X N _ sx)) memarg) is valid with the function type [I32] -> [V128] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ((M / 8) * N).

Instr_ok/vload-splat
- the instruction (VLOAD V128 ?((SPLAT n)) memarg) is valid with the function type [I32] -> [V128] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).

Instr_ok/vload-zero
- the instruction (VLOAD V128 ?((ZERO n)) memarg) is valid with the function type [I32] -> [V128] if:
  - the memory type C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).

Instrs_ok
- the instruction sequence in_u1* is valid with the function type t_u1* -> t_u2* if:
  - Either:
    - in_u1* is [].
    - the value type sequence t_u1* is [].
    - the value type sequence t_u2* is [].
  - Or:
    - in_u1* is [instr_1] :: instr_2*.
    - t_u1* is t_1*.
    - t_u2* is t_3*.
    - the instruction instr_1 is valid with the function type t_1* -> t_2*.
    - the instruction sequence instr_2* is valid with the function type t_2* -> t_3*.
  - Or:
    - in_u1* is instr*.
    - t_u1* is t'_1*.
    - t_u2* is t'_2*.
    - the instruction sequence instr* is valid with t_1* -> t_2*.
    - the value type sequence t'_1* matches the value type sequence t_1*.
    - the value type sequence t_2* matches the value type sequence t'_2*.
  - Or:
    - in_u1* is instr*.
    - t_u1* is t* :: t_1*.
    - t_u2* is t* :: t_2*.
    - instr* is valid with t_1* -> t_2*.

Instrs_ok/empty
- the instruction sequence [] is valid with the function type [] -> [].

Instrs_ok/seq
- the instruction sequence [instr_1] :: instr_2* is valid with the function type t_1* -> t_3* if:
  - the instruction instr_1 is valid with the function type t_1* -> t_2*.
  - the instruction sequence instr_2* is valid with the function type t_2* -> t_3*.

Instrs_ok/sub
- the instruction sequence instr* is valid with the function type t'_1* -> t'_2* if:
  - instr* is valid with the function type t_1* -> t_2*.
  - the value type sequence t'_1* matches the value type sequence t_1*.
  - the value type sequence t_2* matches the value type sequence t'_2*.

Instrs_ok/frame
- the instruction sequence instr* is valid with the function type t* :: t_1* -> t* :: t_2* if:
  - instr* is valid with the function type t_1* -> t_2*.

Expr_ok
- the expression instr* is valid with the result type t* if:
  - instr* is valid with the function type [] -> t*.

Instr_const
- the instruction in_u1 is constant if:
  - Either:
    - in_u1 is (nt.CONST c).
  - Or:
    - in_u1 is (vt.CONST vc).
  - Or:
    - in_u1 is (REF.NULL rt).
  - Or:
    - in_u1 is (REF.FUNC x).
  - Or:
    - in_u1 is (GLOBAL.GET x).
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is (?() t).

Instr_const/const
- the instruction (nt.CONST c) is constant.

Instr_const/vconst
- the instruction (vt.CONST vc) is constant.

Instr_const/ref.null
- the instruction (REF.NULL rt) is constant.

Instr_const/ref.func
- the instruction (REF.FUNC x) is constant.

Instr_const/global.get
- the instruction (GLOBAL.GET x) is constant if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?() t).

Expr_const
- the expression instr* is constant if:
  - For all instr in instr*:
    - the instruction instr is constant.

Type_ok
- the type (TYPE ft) is valid with the function type ft if:
  - ft is valid.

Func_ok
- the function (FUNC x (LOCAL t)* expr) is valid with the function type t_1* -> t_2* if:
  - the function type C.TYPES[x] exists.
  - C.TYPES[x] is t_1* -> t_2*.
  - Under the context C with .LOCALS appended by t_1* :: t* with .LABELS appended by [t_2*] with .RETURN appended by ?(t_2*), the expression expr is valid with the result type t_2*.

Global_ok
- the global (GLOBAL gt expr) is valid with the global type gt if:
  - gt is valid.
  - gt is (mut t).
  - the expression expr is valid with the value type t.
  - expr is constant.

Table_ok
- the table (TABLE tt) is valid with the table type tt if:
  - tt is valid.

Mem_ok
- the memory (MEMORY mt) is valid with the memory type mt if:
  - mt is valid.

Elemmode_ok
- elemmode_u1 is valid with the reference type rt if:
  - Either:
    - elemmode_u1 is (ACTIVE x expr).
    - the table type C.TABLES[x] exists.
    - C.TABLES[x] is (lim rt).
    - the expression expr is valid with the value type I32.
    - expr is constant.
  - Or:
    - elemmode_u1 is PASSIVE.
  - Or:
    - elemmode_u1 is DECLARE.

Elemmode_ok/active
- (ACTIVE x expr) is valid with the reference type rt if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim rt).
  - the expression expr is valid with the value type I32.
  - expr is constant.

Elemmode_ok/passive
- PASSIVE is valid with rt.

Elemmode_ok/declare
- DECLARE is valid with rt.

Elem_ok
- the table segment (ELEM rt expr* elemmode) is valid with the reference type rt if:
  - For all expr in expr*:
    - the expression expr is valid with rt.
    - expr is constant.
  - elemmode is valid with rt.

Datamode_ok
- datamode_u1 is valid if:
  - Either:
    - datamode_u1 is (ACTIVE 0 expr).
    - the memory type C.MEMS[0] is mt.
    - the expression expr is valid with the value type I32.
    - expr is constant.
  - Or:
    - datamode_u1 is PASSIVE.

Datamode_ok/active
- (ACTIVE 0 expr) is valid if:
  - the memory type C.MEMS[0] is mt.
  - the expression expr is valid with the value type I32.
  - expr is constant.

Datamode_ok/passive
- PASSIVE is valid.

Data_ok
- the memory segment (DATA b* datamode) is valid if:
  - datamode is valid.

Start_ok
- the start function (START x) is valid if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is [] -> [].

Import_ok
- the import (IMPORT name_1 name_2 xt) is valid with the external type xt if:
  - xt is valid.

Externidx_ok
- the external index externidx_u1 is valid with the external type xt_u1 if:
  - Either:
    - externidx_u1 is (FUNC x).
    - xt_u1 is (FUNC ft).
    - the function type C.FUNCS[x] exists.
    - C.FUNCS[x] is ft.
  - Or:
    - externidx_u1 is (GLOBAL x).
    - xt_u1 is (GLOBAL gt).
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is gt.
  - Or:
    - externidx_u1 is (TABLE x).
    - xt_u1 is (TABLE tt).
    - the table type C.TABLES[x] exists.
    - C.TABLES[x] is tt.
  - Or:
    - externidx_u1 is (MEM x).
    - xt_u1 is (MEM mt).
    - the memory type C.MEMS[x] exists.
    - C.MEMS[x] is mt.

Externidx_ok/func
- the external index (FUNC x) is valid with the external type (FUNC ft) if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is ft.

Externidx_ok/global
- the external index (GLOBAL x) is valid with the external type (GLOBAL gt) if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is gt.

Externidx_ok/table
- the external index (TABLE x) is valid with the external type (TABLE tt) if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is tt.

Externidx_ok/mem
- the external index (MEM x) is valid with the external type (MEM mt) if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is mt.

Export_ok
- the export (EXPORT name externidx) is valid with the external type xt if:
  - the external index externidx is valid with xt.

Module_ok
- the module (MODULE type* import* func* global* table* mem* elem* data^n start? export*) is valid if:
  - |ft'*| is |type*|.
  - For all ft' in ft'* and type in type*:
    - the type type is valid with the function type ft'.
  - |import*| is |ixt*|.
  - For all import in import* and ixt in ixt*:
    - Under the context { TYPES: ft'*; RETURN: ?() }, the import import is valid with the external type ixt.
  - |global*| is |gt*|.
  - For all global in global* and gt in gt*:
    - Under the context C', the global global is valid with the global type gt.
  - |table*| is |tt*|.
  - For all table in table* and tt in tt*:
    - Under the context C', the table table is valid with the table type tt.
  - |mem*| is |mt*|.
  - For all mem in mem* and mt in mt*:
    - Under the context C', the memory mem is valid with the memory type mt.
  - |elem*| is |rt*|.
  - For all elem in elem* and rt in rt*:
    - Under the context C', the table segment elem is valid with the reference type rt.
  - For all data in data*:
    - Under the context C', the memory segment data is valid.
  - |ft*| is |func*|.
  - For all ft in ft* and func in func*:
    - the function func is valid with the function type ft.
  - If start is defined, then:
    - the start function start is valid.
  - |export*| is |xt*|.
  - For all export in export* and xt in xt*:
    - the export export is valid with the external type xt.
  - |mt*| is less than or equal to 1.
  - the context C is { TYPES: ft'*; FUNCS: ift* :: ft*; GLOBALS: igt* :: gt*; TABLES: itt* :: tt*; MEMS: imt* :: mt*; ELEMS: rt*; DATAS: OK^n; RETURN: ?() }.
  - the context C' is { TYPES: ft'*; FUNCS: ift* :: ft*; GLOBALS: igt*; TABLES: itt* :: tt*; MEMS: imt* :: mt*; RETURN: ?() }.
  - the function type sequence ift* is $funcsxt(ixt*).
  - the global type sequence igt* is $globalsxt(ixt*).
  - the table type sequence itt* is $tablesxt(ixt*).
  - the memory type sequence imt* is $memsxt(ixt*).

Step_pure/unreachable
1. Trap.

Step_pure/nop
1. Do nothing.

Step_pure/drop
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Do nothing.

Step_pure/select t*?
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. Assert: Due to validation, a value is on the top of the stack.
4. Pop the value val_2 from the stack.
5. Assert: Due to validation, a value is on the top of the stack.
6. Pop the value val_1 from the stack.
7. If (c =/= 0), then:
  a. Push the value val_1 to the stack.
8. Else:
  a. Push the value val_2 to the stack.

Step_pure/if bt instr_1* instr_2*
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BLOCK bt instr_1*).
4. Else:
  a. Execute the instruction (BLOCK bt instr_2*).

Step_pure/label
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
3. Pop the current LABEL_ context from the stack.
4. Push the values val* to the stack.

Step_pure/br n_u1
1. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
2. Let (LABEL_ n { instr'* }) be the current LABEL_ context.
3. If (n_u1 = 0), then:
  a. Assert: Due to validation, there are at least n values on the top of the stack.
  b. Pop the values val^n from the stack.
  c. Pop all values val'* from the top of the stack.
  d. Pop the current LABEL_ context from the stack.
  e. Push the values val^n to the stack.
  f. Execute the instruction instr'*.
4. Else:
  a. Pop all values val* from the top of the stack.
  b. If (n_u1 >= 1), then:
    1) Let l be (n_u1 - 1).
    2) Pop the current LABEL_ context from the stack.
    3) Push the values val* to the stack.
    4) Execute the instruction (BR l).

Step_pure/br_if l
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BR l).
4. Else:
  a. Do nothing.

Step_pure/br_table l* l'
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. If (i < |l*|), then:
  a. Execute the instruction (BR l*[i]).
4. Else:
  a. Execute the instruction (BR l').

Step_pure/frame
1. Let (FRAME_ n { f }) be the current FRAME_ context.
2. Assert: Due to validation, there are at least n values on the top of the stack.
3. Assert: Due to validation, there are at least n values on the top of the stack.
4. Pop the values val^n from the stack.
5. Assert: Due to validation, the first non-value entry of the stack is a FRAME_.
6. Pop the current FRAME_ context from the stack.
7. Push the values val^n to the stack.

Step_pure/return
1. If the first non-value entry of the stack is a FRAME_, then:
  a. Let (FRAME_ n { f }) be the current FRAME_ context.
  b. Assert: Due to validation, there are at least n values on the top of the stack.
  c. Pop the values val^n from the stack.
  d. Pop all values val'* from the top of the stack.
  e. Pop the current FRAME_ context from the stack.
  f. Push the values val^n to the stack.
2. Else if the first non-value entry of the stack is a LABEL_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the current LABEL_ context from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction RETURN.

Step_pure/unop nt unop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. If (|$unop_(nt, unop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $unop_(nt, unop, c_1).
5. Push the value (nt.CONST c) to the stack.

Step_pure/binop nt binop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type numtype_0 is on the top of the stack.
4. Pop the value (numtype_0.CONST c_1) from the stack.
5. If (|$binop_(nt, binop, c_1, c_2)| <= 0), then:
  a. Trap.
6. Let c be an element of $binop_(nt, binop, c_1, c_2).
7. Push the value (nt.CONST c) to the stack.

Step_pure/testop nt testop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. Let c be $testop_(nt, testop, c_1).
4. Push the value (I32.CONST c) to the stack.

Step_pure/relop nt relop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type numtype_0 is on the top of the stack.
4. Pop the value (numtype_0.CONST c_1) from the stack.
5. Let c be $relop_(nt, relop, c_1, c_2).
6. Push the value (I32.CONST c) to the stack.

Step_pure/cvtop nt_2 nt_1 cvtop
1. Assert: Due to validation, a value of value type nt_1 is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. If (|$cvtop__(nt_1, nt_2, cvtop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $cvtop__(nt_1, nt_2, cvtop, c_1).
5. Push the value (nt_2.CONST c) to the stack.

Step_pure/ref.is_null
1. Assert: Due to validation, a value of value type ref is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is REF.NULL, then:
  a. Push the value (I32.CONST 1) to the stack.
4. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_pure/vvunop V128 vvunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vvunop_(V128, vvunop, c_1).
4. Push the value (V128.CONST c) to the stack.

Step_pure/vvbinop V128 vvbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vvbinop_(V128, vvbinop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vvternop V128 vvternop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_3) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_2) from the stack.
5. Assert: Due to validation, a value of value type V128 is on the top of the stack.
6. Pop the value (V128.CONST c_1) from the stack.
7. Let c be $vvternop_(V128, vvternop, c_1, c_2, c_3).
8. Push the value (V128.CONST c) to the stack.

Step_pure/vvtestop V128 ANY_TRUE
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $ine_($size(V128), c_1, 0).
4. Push the value (I32.CONST c) to the stack.

Step_pure/vunop sh vunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (|$vunop_(sh, vunop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $vunop_(sh, vunop, c_1).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vbinop sh vbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. If (|$vbinop_(sh, vbinop, c_1, c_2)| <= 0), then:
  a. Trap.
6. Let c be an element of $vbinop_(sh, vbinop, c_1, c_2).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vtestop Jnn X N ALL_TRUE
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c) from the stack.
3. Let ci_1* be $lanes_(Jnn X N, c).
4. If (ci_1 =/= 0)*, then:
  a. Push the value (I32.CONST 1) to the stack.
5. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_pure/vrelop sh vrelop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vrelop_(sh, vrelop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vshiftop Jnn X N vshiftop
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST n) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c'* be $lanes_(Jnn X N, c_1).
6. Let c be $invlanes_(Jnn X N, $vshiftop_(Jnn X N, vshiftop, c', n)*).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vbitmask Jnn X N
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c) from the stack.
3. Let ci_1* be $lanes_(Jnn X N, c).
4. Let ci be $ibits__1^-1(32, $ilt_($lsize(Jnn), S, ci_1, 0)* :: 0^(32 - N)).
5. Push the value (I32.CONST $irev_(32, ci)) to the stack.

Step_pure/vswizzle Pnn X M
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c'* be $lanes_(Pnn X M, c_1) :: 0^(256 - M).
6. Let ci* be $lanes_(Pnn X M, c_2).
7. Assert: Due to validation, (ci*[k] < |c'*|)^(k<M).
8. Assert: Due to validation, (k < |ci*|)^(k<M).
9. Let c be $invlanes_(Pnn X M, c'*[ci*[k]]^(k<M)).
10. Push the value (V128.CONST c) to the stack.

Step_pure/vshuffle Pnn X N i*
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Assert: Due to validation, (k < |i*|)^(k<N).
6. Let c'* be $lanes_(Pnn X N, c_1) :: $lanes_(Pnn X N, c_2).
7. Assert: Due to validation, (i*[k] < |c'*|)^(k<N).
8. Let c be $invlanes_(Pnn X N, c'*[i*[k]]^(k<N)).
9. Push the value (V128.CONST c) to the stack.

Step_pure/vsplat Lnn X N
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. Assert: Due to validation, (numtype_0 = $unpack(Lnn)).
4. Let c be $invlanes_(Lnn X N, $packnum_(Lnn, c_1)^N).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vextract_lane lt_u1 X N sx_u1? i
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (sx_u1? is not defined /\ lt_u1 is numtype), then:
  a. Let nt be lt_u1.
  b. If (i < |$lanes_(nt X N, c_1)|), then:
    1) Let c_2 be $lanes_(nt X N, c_1)[i].
    2) Push the value (nt.CONST c_2) to the stack.
4. If lt_u1 is packtype, then:
  a. Let pt be lt_u1.
  b. If sx_u1? is defined, then:
    1) Let ?(sx) be sx_u1?.
    2) If (i < |$lanes_(pt X N, c_1)|), then:
      a) Let c_2 be $extend__($psize(pt), 32, sx, $lanes_(pt X N, c_1)[i]).
      b) Push the value (I32.CONST c_2) to the stack.

Step_pure/vreplace_lane Lnn X N i
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, (numtype_0 = $unpack(Lnn)).
4. Assert: Due to validation, a value of value type V128 is on the top of the stack.
5. Pop the value (V128.CONST c_1) from the stack.
6. Let c be $invlanes_(Lnn X N, $lanes_(Lnn X N, c_1) with [i] replaced by $packnum_(Lnn, c_2)).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vextunop sh_1 sh_2 vextunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vextunop__(sh_1, sh_2, vextunop, c_1).
4. Push the value (V128.CONST c) to the stack.

Step_pure/vextbinop sh_1 sh_2 vextbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vextbinop__(sh_1, sh_2, vextbinop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vnarrow Jnn_2 X N_2 Jnn_1 X N_1 sx
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let ci_1* be $lanes_(Jnn_1 X N_1, c_1).
6. Let ci_2* be $lanes_(Jnn_1 X N_1, c_2).
7. Let cj_1* be $narrow__($lsize(Jnn_1), $lsize(Jnn_2), sx, ci_1)*.
8. Let cj_2* be $narrow__($lsize(Jnn_1), $lsize(Jnn_2), sx, ci_2)*.
9. Let c be $invlanes_(Jnn_2 X N_2, cj_1* :: cj_2*).
10. Push the value (V128.CONST c) to the stack.

Step_pure/vcvtop lt_u1 X n_u1 lt_u2 X n_u2 vcvtop hf_u1? zero_u1?
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (hf_u1? is not defined /\ zero_u1? is not defined), then:
  a. Let Lnn_1 be lt_u2.
  b. Let Lnn_2 be lt_u1.
  c. Let M be n_u2.
  d. If (n_u1 = M), then:
    1) Let ci* be $lanes_(Lnn_1 X M, c_1).
    2) Let cj** be $setproduct_(lane_(Lnn_2), $vcvtop__(Lnn_1 X M, Lnn_2 X M, vcvtop, ci)*).
    3) If (|$invlanes_(Lnn_2 X M, cj*)*| > 0), then:
      a) Let c be an element of $invlanes_(Lnn_2 X M, cj*)*.
      b) Push the value (V128.CONST c) to the stack.
4. If zero_u1? is not defined, then:
  a. Let Lnn_1 be lt_u2.
  b. Let Lnn_2 be lt_u1.
  c. Let M_1 be n_u2.
  d. Let M_2 be n_u1.
  e. If hf_u1? is defined, then:
    1) Let ?(half) be hf_u1?.
    2) Let ci* be $lanes_(Lnn_1 X M_1, c_1)[$half(half, 0, M_2) : M_2].
    3) Let cj** be $setproduct_(lane_(Lnn_2), $vcvtop__(Lnn_1 X M_1, Lnn_2 X M_2, vcvtop, ci)*).
    4) If (|$invlanes_(Lnn_2 X M_2, cj*)*| > 0), then:
      a) Let c be an element of $invlanes_(Lnn_2 X M_2, cj*)*.
      b) Push the value (V128.CONST c) to the stack.
5. If hf_u1? is not defined, then:
  a. Let M_1 be n_u2.
  b. Let M_2 be n_u1.
  c. If lt_u2 is numtype, then:
    1) Let nt_1 be lt_u2.
    2) If lt_u1 is numtype, then:
      a) Let nt_2 be lt_u1.
      b) If zero_u1? is defined, then:
        1. Let ci* be $lanes_(nt_1 X M_1, c_1).
        2. Let cj** be $setproduct_(lane_((nt_2 : numtype <: lanetype)), $vcvtop__(nt_1 X M_1, nt_2 X M_2, vcvtop, ci)* :: [$zero(nt_2)]^M_1).
        3. If (|$invlanes_(nt_2 X M_2, cj*)*| > 0), then:
          a. Let c be an element of $invlanes_(nt_2 X M_2, cj*)*.
          b. Push the value (V128.CONST c) to the stack.

Step_pure/local.tee x
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Push the value val to the stack.
4. Push the value val to the stack.
5. Execute the instruction (LOCAL.SET x).

Step_read/block bt instr*
1. Let z be the current state.
2. Let t_1^k -> t_2^n be $blocktype(z, bt).
3. Assert: Due to validation, there are at least k values on the top of the stack.
4. Pop the values val^k from the stack.
5. Enter val^k :: instr* with label (LABEL_ n { [] }).

Step_read/loop bt instr*
1. Let z be the current state.
2. Let t_1^k -> t_2^n be $blocktype(z, bt).
3. Assert: Due to validation, there are at least k values on the top of the stack.
4. Pop the values val^k from the stack.
5. Enter val^k :: instr* with label (LABEL_ k { [(LOOP bt instr*)] }).

Step_read/call x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$funcaddr(z)|).
3. Execute the instruction (CALL_ADDR $funcaddr(z)[x]).

Step_read/call_indirect x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (i >= |$table(z, x).REFS|), then:
  a. Trap.
5. If $table(z, x).REFS[i] is not REF.FUNC_ADDR, then:
  a. Trap.
6. Let (REF.FUNC_ADDR a) be $table(z, x).REFS[i].
7. If (a >= |$funcinst(z)|), then:
  a. Trap.
8. If ($type(z, y) =/= $funcinst(z)[a].TYPE), then:
  a. Trap.
9. Execute the instruction (CALL_ADDR a).

Step_read/call_addr a
1. Let z be the current state.
2. Assert: Due to validation, (a < |$funcinst(z)|).
3. Let { TYPE: t_1^k -> t_2^n; MODULE: mm; CODE: func } be $funcinst(z)[a].
4. Let (FUNC x local_0* instr*) be func.
5. Let (LOCAL t)* be local_0*.
6. Assert: Due to validation, there are at least k values on the top of the stack.
7. Pop the values val^k from the stack.
8. Let f be { LOCALS: val^k :: $default_(t)*; MODULE: mm }.
9. Push the :ref:`frame <syntax-frame>` (FRAME_ n { f }) to the stack.
10. Enter instr* with label (LABEL_ n { [] }).

Step_read/ref.func x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$funcaddr(z)|).
3. Push the value (REF.FUNC_ADDR $funcaddr(z)[x]) to the stack.

Step_read/local.get x
1. Let z be the current state.
2. Push the value $local(z, x) to the stack.

Step_read/global.get x
1. Let z be the current state.
2. Push the value $global(z, x).VALUE to the stack.

Step_read/table.get x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (i >= |$table(z, x).REFS|), then:
  a. Trap.
5. Push the value $table(z, x).REFS[i] to the stack.

Step_read/table.size x
1. Let z be the current state.
2. Let n be |$table(z, x).REFS|.
3. Push the value (I32.CONST n) to the stack.

Step_read/table.fill x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. If ((i + n) > |$table(z, x).REFS|), then:
  a. Trap.
9. If (n = 0), then:
  a. Do nothing.
10. Else:
  a. Push the value (I32.CONST i) to the stack.
  b. Push the value val to the stack.
  c. Execute the instruction (TABLE.SET x).
  d. Push the value (I32.CONST (i + 1)) to the stack.
  e. Push the value val to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (TABLE.FILL x).

Step_read/table.copy x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$table(z, y).REFS|), then:
  a. Trap.
9. If ((j + n) > |$table(z, x).REFS|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else:
  a. If (j <= i), then:
    1) Push the value (I32.CONST j) to the stack.
    2) Push the value (I32.CONST i) to the stack.
    3) Execute the instruction (TABLE.GET y).
    4) Execute the instruction (TABLE.SET x).
    5) Push the value (I32.CONST (j + 1)) to the stack.
    6) Push the value (I32.CONST (i + 1)) to the stack.
  b. Else:
    1) Push the value (I32.CONST ((j + n) - 1)) to the stack.
    2) Push the value (I32.CONST ((i + n) - 1)) to the stack.
    3) Execute the instruction (TABLE.GET y).
    4) Execute the instruction (TABLE.SET x).
    5) Push the value (I32.CONST j) to the stack.
    6) Push the value (I32.CONST i) to the stack.
  c. Push the value (I32.CONST (n - 1)) to the stack.
  d. Execute the instruction (TABLE.COPY x y).

Step_read/table.init x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$elem(z, y).REFS|), then:
  a. Trap.
9. If ((j + n) > |$table(z, x).REFS|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else if (i < |$elem(z, y).REFS|), then:
  a. Push the value (I32.CONST j) to the stack.
  b. Push the value $elem(z, y).REFS[i] to the stack.
  c. Execute the instruction (TABLE.SET x).
  d. Push the value (I32.CONST (j + 1)) to the stack.
  e. Push the value (I32.CONST (i + 1)) to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (TABLE.INIT x y).

Step_read/load nt_u1 loadop__u1? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If loadop__u1? is not defined, then:
  a. Let nt be nt_u1.
  b. If (((i + ao.OFFSET) + ($size(nt) / 8)) > |$mem(z, 0).BYTES|), then:
    1) Trap.
  c. Let c be $nbytes__1^-1(nt, $mem(z, 0).BYTES[(i + ao.OFFSET) : ($size(nt) / 8)]).
  d. Push the value (nt.CONST c) to the stack.
5. If nt_u1 is Inn, then:
  a. If loadop__u1? is defined, then:
    1) Let ?(loadop__0) be loadop__u1?.
    2) Let n _ sx be loadop__0.
    3) If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
  b. Let Inn be nt_u1.
  c. If loadop__u1? is defined, then:
    1) Let ?(loadop__0) be loadop__u1?.
    2) Let n _ sx be loadop__0.
    3) Let c be $ibytes__1^-1(n, $mem(z, 0).BYTES[(i + ao.OFFSET) : (n / 8)]).
    4) Push the value (Inn.CONST $extend__(n, $size(Inn), sx, c)) to the stack.

Step_read/vload V128 vloadop_u1? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If ((((i + ao.OFFSET) + ($size(V128) / 8)) > |$mem(z, 0).BYTES|) /\ vloadop_u1? is not defined), then:
  a. Trap.
5. If vloadop_u1? is not defined, then:
  a. Let c be $vbytes__1^-1(V128, $mem(z, 0).BYTES[(i + ao.OFFSET) : ($size(V128) / 8)]).
  b. Push the value (V128.CONST c) to the stack.
6. Else:
  a. Let ?(vloadop_0) be vloadop_u1?.
  b. If vloadop_0 is SHAPE, then:
    1) Let (SHAPE M X N _ sx) be vloadop_0.
    2) If (((i + ao.OFFSET) + ((M * N) / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
    3) Let j^N be $ibytes__1^-1(M, $mem(z, 0).BYTES[((i + ao.OFFSET) + ((k * M) / 8)) : (M / 8)])^(k<N).
    4) If $lsize^-1((M * 2)) is Jnn, then:
      a) Let Jnn be $lsize^-1((M * 2)).
      b) Let c be $invlanes_(Jnn X N, $extend__(M, $lsize(Jnn), sx, j)^N).
      c) Push the value (V128.CONST c) to the stack.
  c. If vloadop_0 is SPLAT, then:
    1) Let (SPLAT N) be vloadop_0.
    2) If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
    3) Let M be (128 / N).
    4) If $lsize^-1(N) is Jnn, then:
      a) Let Jnn be $lsize^-1(N).
      b) Let j be $ibytes__1^-1(N, $mem(z, 0).BYTES[(i + ao.OFFSET) : (N / 8)]).
      c) Let c be $invlanes_(Jnn X M, j^M).
      d) Push the value (V128.CONST c) to the stack.
  d. If vloadop_0 is ZERO, then:
    1) Let (ZERO N) be vloadop_0.
    2) If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
    3) Let j be $ibytes__1^-1(N, $mem(z, 0).BYTES[(i + ao.OFFSET) : (N / 8)]).
    4) Let c be $extend__(N, 128, U, j).
    5) Push the value (V128.CONST c) to the stack.

Step_read/vload_lane V128 N ao j
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c_1) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, 0).BYTES|), then:
  a. Trap.
7. Let M be (128 / N).
8. If $lsize^-1(N) is Jnn, then:
  a. Let Jnn be $lsize^-1(N).
  b. Let k be $ibytes__1^-1(N, $mem(z, 0).BYTES[(i + ao.OFFSET) : (N / 8)]).
  c. Let c be $invlanes_(Jnn X M, $lanes_(Jnn X M, c_1) with [j] replaced by k).
  d. Push the value (V128.CONST c) to the stack.

Step_read/memory.size
1. Let z be the current state.
2. Let ((n * 64) * $Ki()) be |$mem(z, 0).BYTES|.
3. Push the value (I32.CONST n) to the stack.

Step_read/memory.fill
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. If ((i + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.
9. If (n = 0), then:
  a. Do nothing.
10. Else:
  a. Push the value (I32.CONST i) to the stack.
  b. Push the value val to the stack.
  c. Execute the instruction (STORE I32 ?(8) $memarg0()).
  d. Push the value (I32.CONST (i + 1)) to the stack.
  e. Push the value val to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction MEMORY.FILL.

Step_read/memory.copy
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.
9. If ((j + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else:
  a. If (j <= i), then:
    1) Push the value (I32.CONST j) to the stack.
    2) Push the value (I32.CONST i) to the stack.
    3) Execute the instruction (LOAD I32 ?(8 _ U) $memarg0()).
    4) Execute the instruction (STORE I32 ?(8) $memarg0()).
    5) Push the value (I32.CONST (j + 1)) to the stack.
    6) Push the value (I32.CONST (i + 1)) to the stack.
  b. Else:
    1) Push the value (I32.CONST ((j + n) - 1)) to the stack.
    2) Push the value (I32.CONST ((i + n) - 1)) to the stack.
    3) Execute the instruction (LOAD I32 ?(8 _ U) $memarg0()).
    4) Execute the instruction (STORE I32 ?(8) $memarg0()).
    5) Push the value (I32.CONST j) to the stack.
    6) Push the value (I32.CONST i) to the stack.
  c. Push the value (I32.CONST (n - 1)) to the stack.
  d. Execute the instruction MEMORY.COPY.

Step_read/memory.init x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$data(z, x).BYTES|), then:
  a. Trap.
9. If ((j + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else if (i < |$data(z, x).BYTES|), then:
  a. Push the value (I32.CONST j) to the stack.
  b. Push the value (I32.CONST $data(z, x).BYTES[i]) to the stack.
  c. Execute the instruction (STORE I32 ?(8) $memarg0()).
  d. Push the value (I32.CONST (j + 1)) to the stack.
  e. Push the value (I32.CONST (i + 1)) to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (MEMORY.INIT x).

Step/local.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_local(z, x, val).

Step/global.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_global(z, x, val).

Step/table.set x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (i >= |$table(z, x).REFS|), then:
  a. Trap.
7. Perform $with_table(z, x, i, ref).

Step/table.grow x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type ref is on the top of the stack.
5. Pop the value ref from the stack.
6. Either:
  a. Let ti be $growtable($table(z, x), n, ref).
  b. Push the value (I32.CONST |$table(z, x).REFS|) to the stack.
  c. Perform $with_tableinst(z, x, ti).
7. Or:
  a. Push the value (I32.CONST $invsigned_(32, (- 1))) to the stack.

Step/elem.drop x
1. Let z be the current state.
2. Perform $with_elem(z, x, []).

Step/store nt_u1 sz_u1? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type nt_u2 is on the top of the stack.
3. Pop the value (nt_u2.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Let nt be nt_u2.
7. If ((((i + ao.OFFSET) + ($size(nt) / 8)) > |$mem(z, 0).BYTES|) /\ ((nt_u1 = nt) /\ sz_u1? is not defined)), then:
  a. Trap.
8. If ((nt_u1 = nt) /\ sz_u1? is not defined), then:
  a. Let b* be $nbytes_(nt, c).
  b. Perform $with_mem(z, 0, (i + ao.OFFSET), ($size(nt) / 8), b*).
9. If nt_u2 is Inn, then:
  a. Let Inn be nt_u2.
  b. If ((nt_u1 = Inn) /\ sz_u1? is defined), then:
    1) Let ?(n) be sz_u1?.
    2) If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
    3) Let b* be $ibytes_(n, $wrap__($size(Inn), n, c)).
    4) Perform $with_mem(z, 0, (i + ao.OFFSET), (n / 8), b*).

Step/vstore V128 ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + ($size(V128) / 8)) > |$mem(z, 0).BYTES|), then:
  a. Trap.
7. Let b* be $vbytes_(V128, c).
8. Perform $with_mem(z, 0, (i + ao.OFFSET), ($size(V128) / 8), b*).

Step/vstore_lane V128 N ao j
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + N) > |$mem(z, 0).BYTES|), then:
  a. Trap.
7. Let M be (128 / N).
8. If $lsize^-1(N) is Jnn, then:
  a. Let Jnn be $lsize^-1(N).
  b. If (j < |$lanes_(Jnn X M, c)|), then:
    1) Let b* be $ibytes_(N, $lanes_(Jnn X M, c)[j]).
    2) Perform $with_mem(z, 0, (i + ao.OFFSET), (N / 8), b*).

Step/memory.grow
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Either:
  a. Let mi be $growmemory($mem(z, 0), n).
  b. Push the value (I32.CONST (|$mem(z, 0).BYTES| / (64 * $Ki()))) to the stack.
  c. Perform $with_meminst(z, 0, mi).
5. Or:
  a. Push the value (I32.CONST $invsigned_(32, (- 1))) to the stack.

Step/data.drop x
1. Let z be the current state.
2. Perform $with_data(z, x, []).

Ki
1. Return 1024.

min i j
1. If (i <= j), then:
  a. Return i.
2. Return j.

sum n_u1*
1. If (n_u1* = []), then:
  a. Return 0.
2. Let [n] :: n'* be n_u1*.
3. Return (n + $sum(n'*)).

opt_ X X_u1*
1. If (X_u1* = []), then:
  a. Return ?().
2. Assert: Due to validation, (|X_u1*| = 1).
3. Let [w] be X_u1*.
4. Return ?(w).

list_ X X_u1?
1. If X_u1? is not defined, then:
  a. Return [].
2. Let ?(w) be X_u1?.
3. Return [w].

concat_ X X_u1*
1. If (X_u1* = []), then:
  a. Return [].
2. Let [w*] :: w'** be X_u1*.
3. Return w* :: $concat_(X, w'**).

setproduct2_ X w_1 X_u1*
1. If (X_u1* = []), then:
  a. Return [].
2. Let [w'*] :: w** be X_u1*.
3. Return [[w_1] :: w'*] :: $setproduct2_(X, w_1, w**).

setproduct1_ X X_u1* w**
1. If (X_u1* = []), then:
  a. Return [].
2. Let [w_1] :: w'* be X_u1*.
3. Return $setproduct2_(X, w_1, w**) :: $setproduct1_(X, w'*, w**).

setproduct_ X X_u1*
1. If (X_u1* = []), then:
  a. Return [[]].
2. Let [w_1*] :: w** be X_u1*.
3. Return $setproduct1_(X, w_1*, $setproduct_(X, w**)).

signif N_u1
1. If (N_u1 = 32), then:
  a. Return 23.
2. Assert: Due to validation, (N_u1 = 64).
3. Return 52.

expon N_u1
1. If (N_u1 = 32), then:
  a. Return 8.
2. Assert: Due to validation, (N_u1 = 64).
3. Return 11.

M N
1. Return $signif(N).

E N
1. Return $expon(N).

fzero N
1. Return (POS (SUBNORM 0)).

fone N
1. Return (POS (NORM 1 0)).

canon_ N
1. Return (2 ^ ($signif(N) - 1)).

size t_u1
1. If (t_u1 = I32), then:
  a. Return 32.
2. If (t_u1 = I64), then:
  a. Return 64.
3. If (t_u1 = F32), then:
  a. Return 32.
4. If (t_u1 = F64), then:
  a. Return 64.
5. If (t_u1 = V128), then:
  a. Return 128.

isize Inn
1. Return $size(Inn).

psize pt_u1
1. If (pt_u1 = I8), then:
  a. Return 8.
2. Assert: Due to validation, (pt_u1 = I16).
3. Return 16.

lsize lt_u1
1. If lt_u1 is numtype, then:
  a. Let numtype be lt_u1.
  b. Return $size(numtype).
2. Assert: Due to validation, lt_u1 is packtype.
3. Let packtype be lt_u1.
4. Return $psize(packtype).

lanetype Lnn X N
1. Return Lnn.

sizenn nt
1. Return $size(nt).

sizenn1 nt
1. Return $size(nt).

sizenn2 nt
1. Return $size(nt).

lsizenn lt
1. Return $lsize(lt).

lsizenn1 lt
1. Return $lsize(lt).

lsizenn2 lt
1. Return $lsize(lt).

zero nt_u1
1. If nt_u1 is Inn, then:
  a. Return 0.
2. Assert: Due to validation, nt_u1 is Fnn.
3. Let Fnn be nt_u1.
4. Return $fzero($size(Fnn)).

dim Lnn X N
1. Return N.

shsize Lnn X N
1. Return ($lsize(Lnn) * N).

concat_bytes b_u1*
1. If (b_u1* = []), then:
  a. Return [].
2. Let [b*] :: b'** be b_u1*.
3. Return b* :: $concat_bytes(b'**).

unpack lt_u1
1. If lt_u1 is numtype, then:
  a. Let numtype be lt_u1.
  b. Return numtype.
2. Assert: Due to validation, lt_u1 is packtype.
3. Return I32.

shunpack Lnn X N
1. Return $unpack(Lnn).

funcsxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is FUNC, then:
  a. Let (FUNC ft) be externtype_0.
  b. Return [ft] :: $funcsxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $funcsxt(xt*).

globalsxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is GLOBAL, then:
  a. Let (GLOBAL gt) be externtype_0.
  b. Return [gt] :: $globalsxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $globalsxt(xt*).

tablesxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is TABLE, then:
  a. Let (TABLE tt) be externtype_0.
  b. Return [tt] :: $tablesxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $tablesxt(xt*).

memsxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is MEM, then:
  a. Let (MEM mt) be externtype_0.
  b. Return [mt] :: $memsxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $memsxt(xt*).

dataidx_instr in_u1
1. If in_u1 is MEMORY.INIT, then:
  a. Let (MEMORY.INIT x) be in_u1.
  b. Return [x].
2. If in_u1 is DATA.DROP, then:
  a. Let (DATA.DROP x) be in_u1.
  b. Return [x].
3. Return [].

dataidx_instrs in_u1*
1. If (in_u1* = []), then:
  a. Return [].
2. Let [instr] :: instr'* be in_u1*.
3. Return $dataidx_instr(instr) :: $dataidx_instrs(instr'*).

dataidx_expr in*
1. Return $dataidx_instrs(in*).

dataidx_func (FUNC x loc* e)
1. Return $dataidx_expr(e).

dataidx_funcs func_u1*
1. If (func_u1* = []), then:
  a. Return [].
2. Let [func] :: func'* be func_u1*.
3. Return $dataidx_func(func) :: $dataidx_funcs(func'*).

memarg0
1. Return { ALIGN: 0; OFFSET: 0 }.

signed_ N i
1. If (i < (2 ^ (N - 1))), then:
  a. Return i.
2. Assert: Due to validation, ((2 ^ (N - 1)) <= i).
3. Assert: Due to validation, (i < (2 ^ N)).
4. Return (i - (2 ^ N)).

invsigned_ N i
1. Let j be $signed__1^-1(N, i).
2. Return j.

unop_ nt_u1 unop_u1 i_u1
1. If nt_u1 is Inn, then:
  a. Let Inn be nt_u1.
  b. Let iN be i_u1.
  c. If (unop_u1 = CLZ), then:
    1) Return [$iclz_($sizenn(Inn), iN)].
  d. If (unop_u1 = CTZ), then:
    1) Return [$ictz_($sizenn(Inn), iN)].
  e. If (unop_u1 = POPCNT), then:
    1) Return [$ipopcnt_($sizenn(Inn), iN)].
  f. Assert: Due to validation, unop_u1 is EXTEND.
  g. Let (EXTEND M) be unop_u1.
  h. Return [$extend__(M, $sizenn(Inn), S, $wrap__($sizenn(Inn), M, iN))].
2. Assert: Due to validation, nt_u1 is Fnn.
3. Let Fnn be nt_u1.
4. Let fN be i_u1.
5. If (unop_u1 = ABS), then:
  a. Return $fabs_($sizenn(Fnn), fN).
6. If (unop_u1 = NEG), then:
  a. Return $fneg_($sizenn(Fnn), fN).
7. If (unop_u1 = SQRT), then:
  a. Return $fsqrt_($sizenn(Fnn), fN).
8. If (unop_u1 = CEIL), then:
  a. Return $fceil_($sizenn(Fnn), fN).
9. If (unop_u1 = FLOOR), then:
  a. Return $ffloor_($sizenn(Fnn), fN).
10. If (unop_u1 = TRUNC), then:
  a. Return $ftrunc_($sizenn(Fnn), fN).
11. Assert: Due to validation, (unop_u1 = NEAREST).
12. Return $fnearest_($sizenn(Fnn), fN).

binop_ nt_u1 binop_u1 i_u1 i_u2
1. If nt_u1 is Inn, then:
  a. Let Inn be nt_u1.
  b. Let iN_1 be i_u1.
  c. Let iN_2 be i_u2.
  d. If (binop_u1 = ADD), then:
    1) Return [$iadd_($sizenn(Inn), iN_1, iN_2)].
  e. If (binop_u1 = SUB), then:
    1) Return [$isub_($sizenn(Inn), iN_1, iN_2)].
  f. If (binop_u1 = MUL), then:
    1) Return [$imul_($sizenn(Inn), iN_1, iN_2)].
  g. If binop_u1 is DIV, then:
    1) Let (DIV sx) be binop_u1.
    2) Return $list_(num_((Inn : Inn <: numtype)), $idiv_($sizenn(Inn), sx, iN_1, iN_2)).
  h. If binop_u1 is REM, then:
    1) Let (REM sx) be binop_u1.
    2) Return $list_(num_((Inn : Inn <: numtype)), $irem_($sizenn(Inn), sx, iN_1, iN_2)).
  i. If (binop_u1 = AND), then:
    1) Return [$iand_($sizenn(Inn), iN_1, iN_2)].
  j. If (binop_u1 = OR), then:
    1) Return [$ior_($sizenn(Inn), iN_1, iN_2)].
  k. If (binop_u1 = XOR), then:
    1) Return [$ixor_($sizenn(Inn), iN_1, iN_2)].
  l. If (binop_u1 = SHL), then:
    1) Return [$ishl_($sizenn(Inn), iN_1, iN_2)].
  m. If binop_u1 is SHR, then:
    1) Let (SHR sx) be binop_u1.
    2) Return [$ishr_($sizenn(Inn), sx, iN_1, iN_2)].
  n. If (binop_u1 = ROTL), then:
    1) Return [$irotl_($sizenn(Inn), iN_1, iN_2)].
  o. If (binop_u1 = ROTR), then:
    1) Return [$irotr_($sizenn(Inn), iN_1, iN_2)].
2. Assert: Due to validation, nt_u1 is Fnn.
3. Let Fnn be nt_u1.
4. Let fN_1 be i_u1.
5. Let fN_2 be i_u2.
6. If (binop_u1 = ADD), then:
  a. Return $fadd_($sizenn(Fnn), fN_1, fN_2).
7. If (binop_u1 = SUB), then:
  a. Return $fsub_($sizenn(Fnn), fN_1, fN_2).
8. If (binop_u1 = MUL), then:
  a. Return $fmul_($sizenn(Fnn), fN_1, fN_2).
9. If (binop_u1 = DIV), then:
  a. Return $fdiv_($sizenn(Fnn), fN_1, fN_2).
10. If (binop_u1 = MIN), then:
  a. Return $fmin_($sizenn(Fnn), fN_1, fN_2).
11. If (binop_u1 = MAX), then:
  a. Return $fmax_($sizenn(Fnn), fN_1, fN_2).
12. Assert: Due to validation, (binop_u1 = COPYSIGN).
13. Return $fcopysign_($sizenn(Fnn), fN_1, fN_2).

testop_ Inn EQZ iN
1. Return $ieqz_($sizenn(Inn), iN).

relop_ nt_u1 relop_u1 i_u1 i_u2
1. If nt_u1 is Inn, then:
  a. Let Inn be nt_u1.
  b. Let iN_1 be i_u1.
  c. Let iN_2 be i_u2.
  d. If (relop_u1 = EQ), then:
    1) Return $ieq_($sizenn(Inn), iN_1, iN_2).
  e. If (relop_u1 = NE), then:
    1) Return $ine_($sizenn(Inn), iN_1, iN_2).
  f. If relop_u1 is LT, then:
    1) Let (LT sx) be relop_u1.
    2) Return $ilt_($sizenn(Inn), sx, iN_1, iN_2).
  g. If relop_u1 is GT, then:
    1) Let (GT sx) be relop_u1.
    2) Return $igt_($sizenn(Inn), sx, iN_1, iN_2).
  h. If relop_u1 is LE, then:
    1) Let (LE sx) be relop_u1.
    2) Return $ile_($sizenn(Inn), sx, iN_1, iN_2).
  i. If relop_u1 is GE, then:
    1) Let (GE sx) be relop_u1.
    2) Return $ige_($sizenn(Inn), sx, iN_1, iN_2).
2. Assert: Due to validation, nt_u1 is Fnn.
3. Let Fnn be nt_u1.
4. Let fN_1 be i_u1.
5. Let fN_2 be i_u2.
6. If (relop_u1 = EQ), then:
  a. Return $feq_($sizenn(Fnn), fN_1, fN_2).
7. If (relop_u1 = NE), then:
  a. Return $fne_($sizenn(Fnn), fN_1, fN_2).
8. If (relop_u1 = LT), then:
  a. Return $flt_($sizenn(Fnn), fN_1, fN_2).
9. If (relop_u1 = GT), then:
  a. Return $fgt_($sizenn(Fnn), fN_1, fN_2).
10. If (relop_u1 = LE), then:
  a. Return $fle_($sizenn(Fnn), fN_1, fN_2).
11. Assert: Due to validation, (relop_u1 = GE).
12. Return $fge_($sizenn(Fnn), fN_1, fN_2).

cvtop__ nt_u1 nt_u3 cvtop_u1 i_u1
1. If nt_u1 is Inn, then:
  a. Let Inn_1 be nt_u1.
  b. If nt_u3 is Inn, then:
    1) Let Inn_2 be nt_u3.
    2) If cvtop_u1 is EXTEND, then:
      a) Let (EXTEND sx) be cvtop_u1.
      b) Let iN_1 be i_u1.
      c) Return [$extend__($sizenn1(Inn_1), $sizenn2(Inn_2), sx, iN_1)].
    3) Let iN_1 be i_u1.
    4) If (cvtop_u1 = WRAP), then:
      a) Return [$wrap__($sizenn1(Inn_1), $sizenn2(Inn_2), iN_1)].
2. If nt_u1 is Fnn, then:
  a. Let Fnn_1 be nt_u1.
  b. If nt_u3 is Inn, then:
    1) Let Inn_2 be nt_u3.
    2) If cvtop_u1 is TRUNC, then:
      a) Let (TRUNC sx) be cvtop_u1.
      b) Let fN_1 be i_u1.
      c) Return $list_(num_((Inn_2 : Inn <: numtype)), $trunc__($sizenn1(Fnn_1), $sizenn2(Inn_2), sx, fN_1)).
    3) If cvtop_u1 is TRUNC_SAT, then:
      a) Let (TRUNC_SAT sx) be cvtop_u1.
      b) Let fN_1 be i_u1.
      c) Return $list_(num_((Inn_2 : Inn <: numtype)), $trunc_sat__($sizenn1(Fnn_1), $sizenn2(Inn_2), sx, fN_1)).
3. If nt_u1 is Inn, then:
  a. Let Inn_1 be nt_u1.
  b. If nt_u3 is Fnn, then:
    1) Let Fnn_2 be nt_u3.
    2) If cvtop_u1 is CONVERT, then:
      a) Let (CONVERT sx) be cvtop_u1.
      b) Let iN_1 be i_u1.
      c) Return [$convert__($sizenn1(Inn_1), $sizenn2(Fnn_2), sx, iN_1)].
4. If nt_u1 is Fnn, then:
  a. Let Fnn_1 be nt_u1.
  b. If nt_u3 is Fnn, then:
    1) Let Fnn_2 be nt_u3.
    2) Let fN_1 be i_u1.
    3) If (cvtop_u1 = PROMOTE), then:
      a) Return $promote__($sizenn1(Fnn_1), $sizenn2(Fnn_2), fN_1).
    4) If (cvtop_u1 = DEMOTE), then:
      a) Return $demote__($sizenn1(Fnn_1), $sizenn2(Fnn_2), fN_1).
5. If nt_u1 is Inn, then:
  a. Let Inn_1 be nt_u1.
  b. If nt_u3 is Fnn, then:
    1) Let Fnn_2 be nt_u3.
    2) Let iN_1 be i_u1.
    3) If ((cvtop_u1 = REINTERPRET) /\ ($size(Inn_1) = $size(Fnn_2))), then:
      a) Return [$reinterpret__(Inn_1, Fnn_2, iN_1)].
6. Assert: Due to validation, nt_u1 is Fnn.
7. Let Fnn_1 be nt_u1.
8. Assert: Due to validation, nt_u3 is Inn.
9. Let Inn_2 be nt_u3.
10. Let fN_1 be i_u1.
11. Assert: Due to validation, (cvtop_u1 = REINTERPRET).
12. Assert: Due to validation, ($size(Fnn_1) = $size(Inn_2)).
13. Return [$reinterpret__(Fnn_1, Inn_2, fN_1)].

invibytes_ N b*
1. Let n be $ibytes__1^-1(N, b*).
2. Return n.

invfbytes_ N b*
1. Let p be $fbytes__1^-1(N, b*).
2. Return p.

packnum_ lt_u1 c
1. If lt_u1 is numtype, then:
  a. Return c.
2. Assert: Due to validation, lt_u1 is packtype.
3. Let packtype be lt_u1.
4. Return $wrap__($size($unpack(packtype)), $psize(packtype), c).

unpacknum_ lt_u1 c
1. If lt_u1 is numtype, then:
  a. Return c.
2. Assert: Due to validation, lt_u1 is packtype.
3. Let packtype be lt_u1.
4. Return $extend__($psize(packtype), $size($unpack(packtype)), U, c).

invlanes_ sh c*
1. Let vc be $lanes__1^-1(sh, c*).
2. Return vc.

half hf_u1 i j
1. If (hf_u1 = LOW), then:
  a. Return i.
2. Assert: Due to validation, (hf_u1 = HIGH).
3. Return j.

vvunop_ V128 NOT v128
1. Return $inot_($size(V128), v128).

vvbinop_ V128 vvbinop_u1 v128_1 v128_2
1. If (vvbinop_u1 = AND), then:
  a. Return $iand_($size(V128), v128_1, v128_2).
2. If (vvbinop_u1 = ANDNOT), then:
  a. Return $iandnot_($size(V128), v128_1, v128_2).
3. If (vvbinop_u1 = OR), then:
  a. Return $ior_($size(V128), v128_1, v128_2).
4. Assert: Due to validation, (vvbinop_u1 = XOR).
5. Return $ixor_($size(V128), v128_1, v128_2).

vvternop_ V128 BITSELECT v128_1 v128_2 v128_3
1. Return $ibitselect_($size(V128), v128_1, v128_2, v128_3).

vunop_ lt_u1 X M vunop_u1 v128_1
1. If lt_u1 is Jnn, then:
  a. Let Jnn be lt_u1.
  b. If (vunop_u1 = ABS), then:
    1) Let lane_1* be $lanes_(Jnn X M, v128_1).
    2) Let v128 be $invlanes_(Jnn X M, $iabs_($lsizenn(Jnn), lane_1)*).
    3) Return [v128].
  c. If (vunop_u1 = NEG), then:
    1) Let lane_1* be $lanes_(Jnn X M, v128_1).
    2) Let v128 be $invlanes_(Jnn X M, $ineg_($lsizenn(Jnn), lane_1)*).
    3) Return [v128].
  d. If (vunop_u1 = POPCNT), then:
    1) Let lane_1* be $lanes_(Jnn X M, v128_1).
    2) Let v128 be $invlanes_(Jnn X M, $ipopcnt_($lsizenn(Jnn), lane_1)*).
    3) Return [v128].
2. Assert: Due to validation, lt_u1 is Fnn.
3. Let Fnn be lt_u1.
4. If (vunop_u1 = ABS), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fabs_($sizenn(Fnn), lane_1)*).
  c. Let v128* be $invlanes_(Fnn X M, lane*)*.
  d. Return v128*.
5. If (vunop_u1 = NEG), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fneg_($sizenn(Fnn), lane_1)*).
  c. Let v128* be $invlanes_(Fnn X M, lane*)*.
  d. Return v128*.
6. If (vunop_u1 = SQRT), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fsqrt_($sizenn(Fnn), lane_1)*).
  c. Let v128* be $invlanes_(Fnn X M, lane*)*.
  d. Return v128*.
7. If (vunop_u1 = CEIL), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fceil_($sizenn(Fnn), lane_1)*).
  c. Let v128* be $invlanes_(Fnn X M, lane*)*.
  d. Return v128*.
8. If (vunop_u1 = FLOOR), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $ffloor_($sizenn(Fnn), lane_1)*).
  c. Let v128* be $invlanes_(Fnn X M, lane*)*.
  d. Return v128*.
9. If (vunop_u1 = TRUNC), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $ftrunc_($sizenn(Fnn), lane_1)*).
  c. Let v128* be $invlanes_(Fnn X M, lane*)*.
  d. Return v128*.
10. Assert: Due to validation, (vunop_u1 = NEAREST).
11. Let lane_1* be $lanes_(Fnn X M, v128_1).
12. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fnearest_($sizenn(Fnn), lane_1)*).
13. Let v128* be $invlanes_(Fnn X M, lane*)*.
14. Return v128*.

vbinop_ lt_u1 X M vbinop_u1 v128_1 v128_2
1. If lt_u1 is Jnn, then:
  a. Let Jnn be lt_u1.
  b. If (vbinop_u1 = ADD), then:
    1) Let lane_1* be $lanes_(Jnn X M, v128_1).
    2) Let lane_2* be $lanes_(Jnn X M, v128_2).
    3) Let v128 be $invlanes_(Jnn X M, $iadd_($lsizenn(Jnn), lane_1, lane_2)*).
    4) Return [v128].
  c. If (vbinop_u1 = SUB), then:
    1) Let lane_1* be $lanes_(Jnn X M, v128_1).
    2) Let lane_2* be $lanes_(Jnn X M, v128_2).
    3) Let v128 be $invlanes_(Jnn X M, $isub_($lsizenn(Jnn), lane_1, lane_2)*).
    4) Return [v128].
  d. If vbinop_u1 is MIN, then:
    1) Let (MIN sx) be vbinop_u1.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let v128 be $invlanes_(Jnn X M, $imin_($lsizenn(Jnn), sx, lane_1, lane_2)*).
    5) Return [v128].
  e. If vbinop_u1 is MAX, then:
    1) Let (MAX sx) be vbinop_u1.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let v128 be $invlanes_(Jnn X M, $imax_($lsizenn(Jnn), sx, lane_1, lane_2)*).
    5) Return [v128].
  f. If vbinop_u1 is ADD_SAT, then:
    1) Let (ADD_SAT sx) be vbinop_u1.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let v128 be $invlanes_(Jnn X M, $iadd_sat_($lsizenn(Jnn), sx, lane_1, lane_2)*).
    5) Return [v128].
  g. If vbinop_u1 is SUB_SAT, then:
    1) Let (SUB_SAT sx) be vbinop_u1.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let v128 be $invlanes_(Jnn X M, $isub_sat_($lsizenn(Jnn), sx, lane_1, lane_2)*).
    5) Return [v128].
  h. If (vbinop_u1 = MUL), then:
    1) Let lane_1* be $lanes_(Jnn X M, v128_1).
    2) Let lane_2* be $lanes_(Jnn X M, v128_2).
    3) Let v128 be $invlanes_(Jnn X M, $imul_($lsizenn(Jnn), lane_1, lane_2)*).
    4) Return [v128].
  i. If (vbinop_u1 = AVGRU), then:
    1) Let lane_1* be $lanes_(Jnn X M, v128_1).
    2) Let lane_2* be $lanes_(Jnn X M, v128_2).
    3) Let v128 be $invlanes_(Jnn X M, $iavgr_($lsizenn(Jnn), U, lane_1, lane_2)*).
    4) Return [v128].
  j. If (vbinop_u1 = Q15MULR_SATS), then:
    1) Let lane_1* be $lanes_(Jnn X M, v128_1).
    2) Let lane_2* be $lanes_(Jnn X M, v128_2).
    3) Let v128 be $invlanes_(Jnn X M, $iq15mulr_sat_($lsizenn(Jnn), S, lane_1, lane_2)*).
    4) Return [v128].
2. Assert: Due to validation, lt_u1 is Fnn.
3. Let Fnn be lt_u1.
4. If (vbinop_u1 = ADD), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fadd_($sizenn(Fnn), lane_1, lane_2)*).
  d. Let v128* be $invlanes_(Fnn X M, lane*)*.
  e. Return v128*.
5. If (vbinop_u1 = SUB), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fsub_($sizenn(Fnn), lane_1, lane_2)*).
  d. Let v128* be $invlanes_(Fnn X M, lane*)*.
  e. Return v128*.
6. If (vbinop_u1 = MUL), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fmul_($sizenn(Fnn), lane_1, lane_2)*).
  d. Let v128* be $invlanes_(Fnn X M, lane*)*.
  e. Return v128*.
7. If (vbinop_u1 = DIV), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fdiv_($sizenn(Fnn), lane_1, lane_2)*).
  d. Let v128* be $invlanes_(Fnn X M, lane*)*.
  e. Return v128*.
8. If (vbinop_u1 = MIN), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fmin_($sizenn(Fnn), lane_1, lane_2)*).
  d. Let v128* be $invlanes_(Fnn X M, lane*)*.
  e. Return v128*.
9. If (vbinop_u1 = MAX), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fmax_($sizenn(Fnn), lane_1, lane_2)*).
  d. Let v128* be $invlanes_(Fnn X M, lane*)*.
  e. Return v128*.
10. If (vbinop_u1 = PMIN), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fpmin_($sizenn(Fnn), lane_1, lane_2)*).
  d. Let v128* be $invlanes_(Fnn X M, lane*)*.
  e. Return v128*.
11. Assert: Due to validation, (vbinop_u1 = PMAX).
12. Let lane_1* be $lanes_(Fnn X M, v128_1).
13. Let lane_2* be $lanes_(Fnn X M, v128_2).
14. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fpmax_($sizenn(Fnn), lane_1, lane_2)*).
15. Let v128* be $invlanes_(Fnn X M, lane*)*.
16. Return v128*.

vrelop_ lt_u1 X M vrelop_u1 v128_1 v128_2
1. If lt_u1 is Jnn, then:
  a. Let Jnn be lt_u1.
  b. If (vrelop_u1 = EQ), then:
    1) Let lane_1* be $lanes_(Jnn X M, v128_1).
    2) Let lane_2* be $lanes_(Jnn X M, v128_2).
    3) Let lane_3* be $extend__(1, $lsizenn(Jnn), S, $ieq_($lsizenn(Jnn), lane_1, lane_2))*.
    4) Let v128 be $invlanes_(Jnn X M, lane_3*).
    5) Return v128.
  c. If (vrelop_u1 = NE), then:
    1) Let lane_1* be $lanes_(Jnn X M, v128_1).
    2) Let lane_2* be $lanes_(Jnn X M, v128_2).
    3) Let lane_3* be $extend__(1, $lsizenn(Jnn), S, $ine_($lsizenn(Jnn), lane_1, lane_2))*.
    4) Let v128 be $invlanes_(Jnn X M, lane_3*).
    5) Return v128.
  d. If vrelop_u1 is LT, then:
    1) Let (LT sx) be vrelop_u1.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let lane_3* be $extend__(1, $lsizenn(Jnn), S, $ilt_($lsizenn(Jnn), sx, lane_1, lane_2))*.
    5) Let v128 be $invlanes_(Jnn X M, lane_3*).
    6) Return v128.
  e. If vrelop_u1 is GT, then:
    1) Let (GT sx) be vrelop_u1.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let lane_3* be $extend__(1, $lsizenn(Jnn), S, $igt_($lsizenn(Jnn), sx, lane_1, lane_2))*.
    5) Let v128 be $invlanes_(Jnn X M, lane_3*).
    6) Return v128.
  f. If vrelop_u1 is LE, then:
    1) Let (LE sx) be vrelop_u1.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let lane_3* be $extend__(1, $lsizenn(Jnn), S, $ile_($lsizenn(Jnn), sx, lane_1, lane_2))*.
    5) Let v128 be $invlanes_(Jnn X M, lane_3*).
    6) Return v128.
  g. If vrelop_u1 is GE, then:
    1) Let (GE sx) be vrelop_u1.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let lane_3* be $extend__(1, $lsizenn(Jnn), S, $ige_($lsizenn(Jnn), sx, lane_1, lane_2))*.
    5) Let v128 be $invlanes_(Jnn X M, lane_3*).
    6) Return v128.
2. Assert: Due to validation, lt_u1 is Fnn.
3. Let Fnn be lt_u1.
4. If (vrelop_u1 = EQ), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let Inn be $isize^-1($size(Fnn)).
  d. Let lane_3* be $extend__(1, $sizenn(Fnn), S, $feq_($sizenn(Fnn), lane_1, lane_2))*.
  e. Let v128 be $invlanes_(Inn X M, lane_3*).
  f. Return v128.
5. If (vrelop_u1 = NE), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let Inn be $isize^-1($size(Fnn)).
  d. Let lane_3* be $extend__(1, $sizenn(Fnn), S, $fne_($sizenn(Fnn), lane_1, lane_2))*.
  e. Let v128 be $invlanes_(Inn X M, lane_3*).
  f. Return v128.
6. If (vrelop_u1 = LT), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let Inn be $isize^-1($size(Fnn)).
  d. Let lane_3* be $extend__(1, $sizenn(Fnn), S, $flt_($sizenn(Fnn), lane_1, lane_2))*.
  e. Let v128 be $invlanes_(Inn X M, lane_3*).
  f. Return v128.
7. If (vrelop_u1 = GT), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let Inn be $isize^-1($size(Fnn)).
  d. Let lane_3* be $extend__(1, $sizenn(Fnn), S, $fgt_($sizenn(Fnn), lane_1, lane_2))*.
  e. Let v128 be $invlanes_(Inn X M, lane_3*).
  f. Return v128.
8. If (vrelop_u1 = LE), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let Inn be $isize^-1($size(Fnn)).
  d. Let lane_3* be $extend__(1, $sizenn(Fnn), S, $fle_($sizenn(Fnn), lane_1, lane_2))*.
  e. Let v128 be $invlanes_(Inn X M, lane_3*).
  f. Return v128.
9. Assert: Due to validation, (vrelop_u1 = GE).
10. Let lane_1* be $lanes_(Fnn X M, v128_1).
11. Let lane_2* be $lanes_(Fnn X M, v128_2).
12. Let Inn be $isize^-1($size(Fnn)).
13. Let lane_3* be $extend__(1, $sizenn(Fnn), S, $fge_($sizenn(Fnn), lane_1, lane_2))*.
14. Let v128 be $invlanes_(Inn X M, lane_3*).
15. Return v128.

vcvtop__ lt_u2 X M_1 lt_u1 X M_2 vcvtop_u1 c_u1
1. If lt_u2 is Jnn, then:
  a. Let Jnn_1 be lt_u2.
  b. If lt_u1 is Jnn, then:
    1) Let Jnn_2 be lt_u1.
    2) If vcvtop_u1 is EXTEND, then:
      a) Let (EXTEND sx) be vcvtop_u1.
      b) Let iN_1 be c_u1.
      c) Let iN_2 be $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), sx, iN_1).
      d) Return [iN_2].
  c. If lt_u1 is Fnn, then:
    1) Let Fnn_2 be lt_u1.
    2) If vcvtop_u1 is CONVERT, then:
      a) Let (CONVERT sx) be vcvtop_u1.
      b) Let iN_1 be c_u1.
      c) Let fN_2 be $convert__($lsizenn1(Jnn_1), $lsizenn2(Fnn_2), sx, iN_1).
      d) Return [fN_2].
2. Assert: Due to validation, lt_u2 is Fnn.
3. Let Fnn_1 be lt_u2.
4. If lt_u1 is Inn, then:
  a. Let Inn_2 be lt_u1.
  b. If vcvtop_u1 is TRUNC_SAT, then:
    1) Let (TRUNC_SAT sx) be vcvtop_u1.
    2) Let fN_1 be c_u1.
    3) Let iN_2? be $trunc_sat__($lsizenn1(Fnn_1), $lsizenn2(Inn_2), sx, fN_1).
    4) Return $list_(lane_((Inn_2 : Inn <: lanetype)), iN_2?).
5. Assert: Due to validation, lt_u1 is Fnn.
6. Let Fnn_2 be lt_u1.
7. Let fN_1 be c_u1.
8. If (vcvtop_u1 = DEMOTE), then:
  a. Let fN_2* be $demote__($lsizenn1(Fnn_1), $lsizenn2(Fnn_2), fN_1).
  b. Return fN_2*.
9. Assert: Due to validation, (vcvtop_u1 = PROMOTE).
10. Let fN_2* be $promote__($lsizenn1(Fnn_1), $lsizenn2(Fnn_2), fN_1).
11. Return fN_2*.

vextunop__ Inn_1 X M_1 Inn_2 X M_2 (EXTADD_PAIRWISE sx) c_1
1. Let ci* be $lanes_(Inn_2 X M_2, c_1).
2. Let [cj_1, cj_2]* be $concat__1^-1(iN($lsizenn1((Inn_1 : Inn <: lanetype))), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), sx, ci)*).
3. Let c be $invlanes_(Inn_1 X M_1, $iadd_($lsizenn1(Inn_1), cj_1, cj_2)*).
4. Return c.

vextbinop__ Inn_1 X M_1 Inn_2 X M_2 vextbinop_u1 c_1 c_2
1. If vextbinop_u1 is EXTMUL, then:
  a. Let (EXTMUL sx hf) be vextbinop_u1.
  b. Let ci_1* be $lanes_(Inn_2 X M_2, c_1)[$half(hf, 0, M_1) : M_1].
  c. Let ci_2* be $lanes_(Inn_2 X M_2, c_2)[$half(hf, 0, M_1) : M_1].
  d. Let c be $invlanes_(Inn_1 X M_1, $imul_($lsizenn1(Inn_1), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), sx, ci_1), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), sx, ci_2))*).
  e. Return c.
2. Assert: Due to validation, (vextbinop_u1 = DOTS).
3. Let ci_1* be $lanes_(Inn_2 X M_2, c_1).
4. Let ci_2* be $lanes_(Inn_2 X M_2, c_2).
5. Let [cj_1, cj_2]* be $concat__1^-1(iN($lsizenn1((Inn_1 : Inn <: lanetype))), $imul_($lsizenn1(Inn_1), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), S, ci_1), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), S, ci_2))*).
6. Let c be $invlanes_(Inn_1 X M_1, $iadd_($lsizenn1(Inn_1), cj_1, cj_2)*).
7. Return c.

vshiftop_ Jnn X M vshiftop_u1 lane n
1. If (vshiftop_u1 = SHL), then:
  a. Return $ishl_($lsizenn(Jnn), lane, n).
2. Assert: Due to validation, vshiftop_u1 is SHR.
3. Let (SHR sx) be vshiftop_u1.
4. Return $ishr_($lsizenn(Jnn), sx, lane, n).

default_ t_u1
1. If (t_u1 = I32), then:
  a. Return (I32.CONST 0).
2. If (t_u1 = I64), then:
  a. Return (I64.CONST 0).
3. If (t_u1 = F32), then:
  a. Return (F32.CONST $fzero(32)).
4. If (t_u1 = F64), then:
  a. Return (F64.CONST $fzero(64)).
5. If (t_u1 = V128), then:
  a. Return (V128.CONST 0).
6. If (t_u1 = FUNCREF), then:
  a. Return (REF.NULL FUNCREF).
7. Assert: Due to validation, (t_u1 = EXTERNREF).
8. Return (REF.NULL EXTERNREF).

funcsxa xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be xv_u1*.
3. If externaddr_0 is FUNC, then:
  a. Let (FUNC fa) be externaddr_0.
  b. Return [fa] :: $funcsxa(xv*).
4. Let [externaddr] :: xv* be xv_u1*.
5. Return $funcsxa(xv*).

globalsxa xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be xv_u1*.
3. If externaddr_0 is GLOBAL, then:
  a. Let (GLOBAL ga) be externaddr_0.
  b. Return [ga] :: $globalsxa(xv*).
4. Let [externaddr] :: xv* be xv_u1*.
5. Return $globalsxa(xv*).

tablesxa xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be xv_u1*.
3. If externaddr_0 is TABLE, then:
  a. Let (TABLE ta) be externaddr_0.
  b. Return [ta] :: $tablesxa(xv*).
4. Let [externaddr] :: xv* be xv_u1*.
5. Return $tablesxa(xv*).

memsxa xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be xv_u1*.
3. If externaddr_0 is MEM, then:
  a. Let (MEM ma) be externaddr_0.
  b. Return [ma] :: $memsxa(xv*).
4. Let [externaddr] :: xv* be xv_u1*.
5. Return $memsxa(xv*).

store (s, f)
1. Return.

frame (s, f)
1. Return f.

funcaddr (s, f)
1. Return f.MODULE.FUNCS.

funcinst (s, f)
1. Return s.FUNCS.

globalinst (s, f)
1. Return s.GLOBALS.

tableinst (s, f)
1. Return s.TABLES.

meminst (s, f)
1. Return s.MEMS.

eleminst (s, f)
1. Return s.ELEMS.

datainst (s, f)
1. Return s.DATAS.

moduleinst (s, f)
1. Return f.MODULE.

type (s, f) x
1. Return f.MODULE.TYPES[x].

func (s, f) x
1. Return s.FUNCS[f.MODULE.FUNCS[x]].

global (s, f) x
1. Return s.GLOBALS[f.MODULE.GLOBALS[x]].

table (s, f) x
1. Return s.TABLES[f.MODULE.TABLES[x]].

mem (s, f) x
1. Return s.MEMS[f.MODULE.MEMS[x]].

elem (s, f) x
1. Return s.ELEMS[f.MODULE.ELEMS[x]].

data (s, f) x
1. Return s.DATAS[f.MODULE.DATAS[x]].

local (s, f) x
1. Return f.LOCALS[x].

with_local (s, f) x v
1. Replace f.LOCALS[x] with v.

with_global (s, f) x v
1. Replace s.GLOBALS[f.MODULE.GLOBALS[x]].VALUE with v.

with_table (s, f) x i r
1. Replace s.TABLES[f.MODULE.TABLES[x]].REFS[i] with r.

with_tableinst (s, f) x ti
1. Replace s.TABLES[f.MODULE.TABLES[x]] with ti.

with_mem (s, f) x i j b*
1. Replace s.MEMS[f.MODULE.MEMS[x]].BYTES[i : j] with b*.

with_meminst (s, f) x mi
1. Replace s.MEMS[f.MODULE.MEMS[x]] with mi.

with_elem (s, f) x r*
1. Replace s.ELEMS[f.MODULE.ELEMS[x]].REFS with r*.

with_data (s, f) x b*
1. Replace s.DATAS[f.MODULE.DATAS[x]].BYTES with b*.

growtable ti n r
1. Let { TYPE: (([ i .. j ]) rt); REFS: r'* } be ti.
2. Let i' be (|r'*| + n).
3. If (i' <= j), then:
  a. Let ti' be { TYPE: (([ i' .. j ]) rt); REFS: r'* :: r^n }.
  b. Return ti'.

growmemory mi n
1. Let { TYPE: ([ i .. j ]) PAGE; BYTES: b* } be mi.
2. Let i' be ((|b*| / (64 * $Ki())) + n).
3. If (i' <= j), then:
  a. Let mi' be { TYPE: ([ i' .. j ]) PAGE; BYTES: b* :: 0^(n * (64 * $Ki())) }.
  b. Return mi'.

blocktype z bt_u1
1. If (bt_u1 = (_RESULT ?())), then:
  a. Return [] -> [].
2. If bt_u1 is _RESULT, then:
  a. Let (_RESULT valtype_0?) be bt_u1.
  b. If valtype_0? is defined, then:
    1) Let ?(t) be valtype_0?.
    2) Return [] -> [t].
3. Assert: Due to validation, bt_u1 is _IDX.
4. Let (_IDX x) be bt_u1.
5. Return $type(z, x).

funcs xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be xv_u1*.
3. If externaddr_0 is FUNC, then:
  a. Let (FUNC fa) be externaddr_0.
  b. Return [fa] :: $funcs(externaddr'*).
4. Let [externaddr] :: externaddr'* be xv_u1*.
5. Return $funcs(externaddr'*).

globals xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be xv_u1*.
3. If externaddr_0 is GLOBAL, then:
  a. Let (GLOBAL ga) be externaddr_0.
  b. Return [ga] :: $globals(externaddr'*).
4. Let [externaddr] :: externaddr'* be xv_u1*.
5. Return $globals(externaddr'*).

tables xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be xv_u1*.
3. If externaddr_0 is TABLE, then:
  a. Let (TABLE ta) be externaddr_0.
  b. Return [ta] :: $tables(externaddr'*).
4. Let [externaddr] :: externaddr'* be xv_u1*.
5. Return $tables(externaddr'*).

mems xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be xv_u1*.
3. If externaddr_0 is MEM, then:
  a. Let (MEM ma) be externaddr_0.
  b. Return [ma] :: $mems(externaddr'*).
4. Let [externaddr] :: externaddr'* be xv_u1*.
5. Return $mems(externaddr'*).

allocfunc s moduleinst func
1. Let (FUNC x local* expr) be func.
2. Let fi be { TYPE: moduleinst.TYPES[x]; MODULE: moduleinst; CODE: func }.
3. Let a be |s.FUNCS|.
4. Append fi to the s.FUNCS.
5. Return a.

allocfuncs s moduleinst func_u1*
1. If (func_u1* = []), then:
  a. Return [].
2. Let [func] :: func'* be func_u1*.
3. Let fa be $allocfunc(s, moduleinst, func).
4. Let fa'* be $allocfuncs(s, moduleinst, func'*).
5. Return [fa] :: fa'*.

allocglobal s globaltype val
1. Let gi be { TYPE: globaltype; VALUE: val }.
2. Let a be |s.GLOBALS|.
3. Append gi to the s.GLOBALS.
4. Return a.

allocglobals s gt_u1* v_u1*
1. If (gt_u1* = []), then:
  a. Assert: Due to validation, (v_u1* = []).
  b. Return [].
2. Else:
  a. Let [globaltype] :: globaltype'* be gt_u1*.
  b. Assert: Due to validation, (|v_u1*| >= 1).
  c. Let [val] :: val'* be v_u1*.
  d. Let ga be $allocglobal(s, globaltype, val).
  e. Let ga'* be $allocglobals(s, globaltype'*, val'*).
  f. Return [ga] :: ga'*.

alloctable s (([ i .. j ]) rt)
1. Let ti be { TYPE: (([ i .. j ]) rt); REFS: (REF.NULL rt)^i }.
2. Let a be |s.TABLES|.
3. Append ti to the s.TABLES.
4. Return a.

alloctables s tt_u1*
1. If (tt_u1* = []), then:
  a. Return [].
2. Let [tabletype] :: tabletype'* be tt_u1*.
3. Let ta be $alloctable(s, tabletype).
4. Let ta'* be $alloctables(s, tabletype'*).
5. Return [ta] :: ta'*.

allocmem s ([ i .. j ]) PAGE
1. Let mi be { TYPE: ([ i .. j ]) PAGE; BYTES: 0^(i * (64 * $Ki())) }.
2. Let a be |s.MEMS|.
3. Append mi to the s.MEMS.
4. Return a.

allocmems s mt_u1*
1. If (mt_u1* = []), then:
  a. Return [].
2. Let [memtype] :: memtype'* be mt_u1*.
3. Let ma be $allocmem(s, memtype).
4. Let ma'* be $allocmems(s, memtype'*).
5. Return [ma] :: ma'*.

allocelem s rt ref*
1. Let ei be { TYPE: rt; REFS: ref* }.
2. Let a be |s.ELEMS|.
3. Append ei to the s.ELEMS.
4. Return a.

allocelems s rt_u1* r_u1*
1. If ((rt_u1* = []) /\ (r_u1* = [])), then:
  a. Return [].
2. Assert: Due to validation, (|r_u1*| >= 1).
3. Let [ref*] :: ref'** be r_u1*.
4. Assert: Due to validation, (|rt_u1*| >= 1).
5. Let [rt] :: rt'* be rt_u1*.
6. Let ea be $allocelem(s, rt, ref*).
7. Let ea'* be $allocelems(s, rt'*, ref'**).
8. Return [ea] :: ea'*.

allocdata s byte*
1. Let di be { BYTES: byte* }.
2. Let a be |s.DATAS|.
3. Append di to the s.DATAS.
4. Return a.

allocdatas s b_u1*
1. If (b_u1* = []), then:
  a. Return [].
2. Let [byte*] :: byte'** be b_u1*.
3. Let da be $allocdata(s, byte*).
4. Let da'* be $allocdatas(s, byte'**).
5. Return [da] :: da'*.

instexport fa* ga* ta* ma* (EXPORT name externidx_u1)
1. If externidx_u1 is FUNC, then:
  a. Let (FUNC x) be externidx_u1.
  b. Return { NAME: name; ADDR: (FUNC fa*[x]) }.
2. If externidx_u1 is GLOBAL, then:
  a. Let (GLOBAL x) be externidx_u1.
  b. Return { NAME: name; ADDR: (GLOBAL ga*[x]) }.
3. If externidx_u1 is TABLE, then:
  a. Let (TABLE x) be externidx_u1.
  b. Return { NAME: name; ADDR: (TABLE ta*[x]) }.
4. Assert: Due to validation, externidx_u1 is MEM.
5. Let (MEM x) be externidx_u1.
6. Return { NAME: name; ADDR: (MEM ma*[x]) }.

allocmodule s module externaddr* val* ref**
1. Let (MODULE type_0* import* func^n_func global_1* table_2* mem_3* elem_4* data_5* start? export*) be module.
2. Let (DATA byte* datamode)^n_data be data_5*.
3. Let (ELEM rt expr_2* elemmode)^n_elem be elem_4*.
4. Let (MEMORY memtype)^n_mem be mem_3*.
5. Let (TABLE tabletype)^n_table be table_2*.
6. Let (GLOBAL globaltype expr_1)^n_global be global_1*.
7. Let (TYPE ft)* be type_0*.
8. Let fa_ex* be $funcs(externaddr*).
9. Let ga_ex* be $globals(externaddr*).
10. Let ma_ex* be $mems(externaddr*).
11. Let ta_ex* be $tables(externaddr*).
12. Let fa* be (|s.FUNCS| + i_func)^(i_func<n_func).
13. Let ga* be (|s.GLOBALS| + i_global)^(i_global<n_global).
14. Let ta* be (|s.TABLES| + i_table)^(i_table<n_table).
15. Let ma* be (|s.MEMS| + i_mem)^(i_mem<n_mem).
16. Let ea* be (|s.ELEMS| + i_elem)^(i_elem<n_elem).
17. Let da* be (|s.DATAS| + i_data)^(i_data<n_data).
18. Let xi* be $instexport(fa_ex* :: fa*, ga_ex* :: ga*, ta_ex* :: ta*, ma_ex* :: ma*, export)*.
19. Let moduleinst be { TYPES: ft*; FUNCS: fa_ex* :: fa*; GLOBALS: ga_ex* :: ga*; TABLES: ta_ex* :: ta*; MEMS: ma_ex* :: ma*; ELEMS: ea*; DATAS: da*; EXPORTS: xi* }.
20. Let funcaddr_0* be $allocfuncs(s, moduleinst, func^n_func).
21. Assert: Due to validation, (funcaddr_0* = fa*).
22. Let globaladdr_0* be $allocglobals(s, globaltype^n_global, val*).
23. Assert: Due to validation, (globaladdr_0* = ga*).
24. Let tableaddr_0* be $alloctables(s, tabletype^n_table).
25. Assert: Due to validation, (tableaddr_0* = ta*).
26. Let memaddr_0* be $allocmems(s, memtype^n_mem).
27. Assert: Due to validation, (memaddr_0* = ma*).
28. Let elemaddr_0* be $allocelems(s, rt^n_elem, ref**).
29. Assert: Due to validation, (elemaddr_0* = ea*).
30. Let dataaddr_0* be $allocdatas(s, byte*^n_data).
31. Assert: Due to validation, (dataaddr_0* = da*).
32. Return moduleinst.

runelem (ELEM reftype expr* elemmode_u1) i
1. If (elemmode_u1 = PASSIVE), then:
  a. Return [].
2. If (elemmode_u1 = DECLARE), then:
  a. Return [(ELEM.DROP i)].
3. Assert: Due to validation, elemmode_u1 is ACTIVE.
4. Let (ACTIVE x instr*) be elemmode_u1.
5. Let n be |expr*|.
6. Return instr* :: [(I32.CONST 0), (I32.CONST n), (TABLE.INIT x i), (ELEM.DROP i)].

rundata (DATA byte* datamode_u1) i
1. If (datamode_u1 = PASSIVE), then:
  a. Return [].
2. Assert: Due to validation, datamode_u1 is ACTIVE.
3. Let (ACTIVE memidx_0 instr*) be datamode_u1.
4. Assert: Due to validation, (memidx_0 = 0).
5. Let n be |byte*|.
6. Return instr* :: [(I32.CONST 0), (I32.CONST n), (MEMORY.INIT i), (DATA.DROP i)].

instantiate s module externaddr*
1. Let (MODULE type* import* func* global* table* mem* elem* data* start? export*) be module.
2. Let (TYPE functype)* be type*.
3. Let n_D be |data*|.
4. Let n_E be |elem*|.
5. Let n_F be |func*|.
6. Let (START x)? be start?.
7. Let (GLOBAL globaltype expr_G)* be global*.
8. Let (ELEM reftype expr_E* elemmode)* be elem*.
9. Let instr_D* be $concat_(instr, $rundata(data*[j], j)^(j<n_D)).
10. Let instr_E* be $concat_(instr, $runelem(elem*[i], i)^(i<n_E)).
11. Let moduleinst_init be { TYPES: functype*; FUNCS: $funcs(externaddr*) :: (|s.FUNCS| + i_F)^(i_F<n_F); GLOBALS: $globals(externaddr*) }.
12. Let f_init be { MODULE: moduleinst_init }.
13. Let z be (s, f_init).
14. Push the :ref:`frame <syntax-frame>` (FRAME_ 0 { $frame(z) }) to the stack.
15. Let [val]* be $Eval_expr(z, expr_G)*.
16. Pop the :ref:`frame <syntax-frame>` (FRAME_ 0 { $frame(z) }) from the stack.
17. Push the :ref:`frame <syntax-frame>` (FRAME_ 0 { $frame(z) }) to the stack.
18. Let [ref]** be $Eval_expr(z, expr_E)**.
19. Pop the :ref:`frame <syntax-frame>` (FRAME_ 0 { $frame(z) }) from the stack.
20. Let moduleinst be $allocmodule(s, module, externaddr*, val*, ref**).
21. Let f be { MODULE: moduleinst }.
22. Push the :ref:`frame <syntax-frame>` (FRAME_ 0 { f }) to the stack.
23. Execute the sequence (instr_E*).
24. Execute the sequence (instr_D*).
25. Execute the sequence ((CALL x)?).
26. Pop the :ref:`frame <syntax-frame>` (FRAME_ 0 { f }) from the stack.
27. Return f.MODULE.

invoke s fa val^n
1. Let f be { MODULE: {} }.
2. Push the :ref:`frame <syntax-frame>` (FRAME_ 0 { (s, f) }) to the stack.
3. Let t_1^n -> t_2* be $funcinst((s, f))[fa].TYPE.
4. Pop the :ref:`frame <syntax-frame>` (FRAME_ 0 { _f }) from the stack.
5. Let k be |t_2*|.
6. Push the :ref:`frame <syntax-frame>` (FRAME_ k { f }) to the stack.
7. Push the values val^n to the stack.
8. Execute the instruction (CALL_ADDR fa).
9. Pop all values val_0* from the top of the stack.
10. Pop the :ref:`frame <syntax-frame>` (FRAME_ k { f }) from the stack.
11. Push the values val_0* to the stack.
12. Pop the values val^k from the stack.
13. Return val^k.

Eval_expr instr*
1. Execute the instruction instr*.
2. Pop the value val from the stack.
3. Return [val].

== Complete.
Generating prose for Wasm 3.0...
watsup 0.4 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...
Untranslated relation Expand: `%~~%`(deftype, comptype)



The :ref:`number type <syntax-numtype>` :math:`{\mathit{numtype}}` is valid.




The :ref:`vector type <syntax-vectype>` :math:`{\mathit{vectype}}` is valid.




The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid if:


   * Either:

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{absheaptype}}`.

   * Or:

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{typeidx}}`.

      * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

      * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is equal to :math:`{\mathit{dt}}`.
   * Or:

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{rec}~i)`.

      * The sub type :math:`C{.}\mathsf{recs}{}[i]` exists.

      * The sub type :math:`C{.}\mathsf{recs}{}[i]` is equal to :math:`{\mathit{st}}`.




The heap type :math:`{\mathit{absheaptype}}` is valid.




The heap type :math:`{\mathit{typeidx}}` is valid if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is equal to :math:`{\mathit{dt}}`.




The heap type :math:`(\mathsf{rec}~i)` is valid if:


   * The sub type :math:`C{.}\mathsf{recs}{}[i]` exists.

   * The sub type :math:`C{.}\mathsf{recs}{}[i]` is equal to :math:`{\mathit{st}}`.




The reference type :math:`(\mathsf{ref}~{\mathsf{null}^?}~{\mathit{heaptype}})` is valid if:


   * The heap type :math:`{\mathit{heaptype}}` is valid.




The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid if:


   * Either:

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{numtype}}`.

      * The :ref:`number type <syntax-numtype>` :math:`{\mathit{numtype}}` is valid.

   * Or:

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{vectype}}`.

      * The :ref:`vector type <syntax-vectype>` :math:`{\mathit{vectype}}` is valid.
   * Or:

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{reftype}}`.

      * The reference type :math:`{\mathit{reftype}}` is valid.
   * Or:

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{bot}`.




The :ref:`value type <syntax-valtype>` :math:`{\mathit{numtype}}` is valid if:


   * The :ref:`number type <syntax-numtype>` :math:`{\mathit{numtype}}` is valid.




The :ref:`value type <syntax-valtype>` :math:`{\mathit{vectype}}` is valid if:


   * The :ref:`vector type <syntax-vectype>` :math:`{\mathit{vectype}}` is valid.




The :ref:`value type <syntax-valtype>` :math:`{\mathit{reftype}}` is valid if:


   * The reference type :math:`{\mathit{reftype}}` is valid.




The :ref:`value type <syntax-valtype>` :math:`\mathsf{bot}` is valid.




The result type :math:`{t^\ast}` is valid if:


   * For all :math:`t` in :math:`{t^\ast}`:

      * The :ref:`value type <syntax-valtype>` :math:`t` is valid.




The instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}` is valid if:


   * The result type :math:`{t_1^\ast}` is valid.

   * The result type :math:`{t_2^\ast}` is valid.

   * :math:`{|{{{\mathit{lt}}}^\ast}|}` is equal to :math:`{|{x^\ast}|}`.

   * For all :math:`x` in :math:`{x^\ast}`:

      * The local type :math:`C{.}\mathsf{locals}{}[x]` exists.

   * For all :math:`{{\mathit{lt}}}` in :math:`{{{\mathit{lt}}}^\ast}` and :math:`x` in :math:`{x^\ast}`:

      * The local type :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`{{\mathit{lt}}}`.




The packed type :math:`{\mathit{packtype}}` is valid.




The storage type :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid if:


   * Either:

      * The storage type :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{valtype}}`.

      * The :ref:`value type <syntax-valtype>` :math:`{\mathit{valtype}}` is valid.

   * Or:

      * The storage type :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{packtype}}`.

      * The packed type :math:`{\mathit{packtype}}` is valid.




The storage type :math:`{\mathit{valtype}}` is valid if:


   * The :ref:`value type <syntax-valtype>` :math:`{\mathit{valtype}}` is valid.




The storage type :math:`{\mathit{packtype}}` is valid if:


   * The packed type :math:`{\mathit{packtype}}` is valid.




The field type :math:`({\mathsf{mut}^?}~{\mathit{storagetype}})` is valid if:


   * The storage type :math:`{\mathit{storagetype}}` is valid.




The function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid if:


   * The result type :math:`{t_1^\ast}` is valid.

   * The result type :math:`{t_2^\ast}` is valid.




The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid if:


   * Either:

      * The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{struct}~{{\mathit{fieldtype}}^\ast})`.

      * For all :math:`{\mathit{fieldtype}}` in :math:`{{\mathit{fieldtype}}^\ast}`:

         * The field type :math:`{\mathit{fieldtype}}` is valid.

   * Or:

      * The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{array}~{\mathit{fieldtype}})`.

      * The field type :math:`{\mathit{fieldtype}}` is valid.
   * Or:

      * The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{functype}})`.

      * The function type :math:`{\mathit{functype}}` is valid.




The composite type :math:`(\mathsf{struct}~{{\mathit{fieldtype}}^\ast})` is valid if:


   * For all :math:`{\mathit{fieldtype}}` in :math:`{{\mathit{fieldtype}}^\ast}`:

      * The field type :math:`{\mathit{fieldtype}}` is valid.




The composite type :math:`(\mathsf{array}~{\mathit{fieldtype}})` is valid if:


   * The field type :math:`{\mathit{fieldtype}}` is valid.




The composite type :math:`(\mathsf{func}~{\mathit{functype}})` is valid if:


   * The function type :math:`{\mathit{functype}}` is valid.




The packed type :math:`{\mathit{packtype}}` matches itself.




The :ref:`number type <syntax-numtype>` :math:`{\mathit{numtype}}` matches itself.




The :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}_1` matches the :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}_2` if:


   * Either:

      * The :ref:`defined type <syntax-deftype>` :math:`{{\mathrm{clos}}}_{C}({\mathit{deftype}}_1)` is equal to :math:`{{\mathrm{clos}}}_{C}({\mathit{deftype}}_2)`.

   * Or:

      * The sub type :math:`{\mathrm{unroll}}({\mathit{deftype}}_1)` is equal to :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{ct}})`.

      * :math:`{|{{\mathit{typeuse}}^\ast}|}` is greater than :math:`i`.

      * The type use :math:`{{\mathit{typeuse}}^\ast}{}[i]` matches the heap type :math:`{\mathit{deftype}}_2`.




The :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}_1` matches the :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}_2` if:


   * The :ref:`defined type <syntax-deftype>` :math:`{{\mathrm{clos}}}_{C}({\mathit{deftype}}_1)` is equal to :math:`{{\mathrm{clos}}}_{C}({\mathit{deftype}}_2)`.




The :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}_1` matches the :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}_2` if:


   * The sub type :math:`{\mathrm{unroll}}({\mathit{deftype}}_1)` is equal to :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{ct}})`.

   * :math:`{|{{\mathit{typeuse}}^\ast}|}` is greater than :math:`i`.

   * The type use :math:`{{\mathit{typeuse}}^\ast}{}[i]` matches the heap type :math:`{\mathit{deftype}}_2`.




The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` matches the heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` if:


   * Either:

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{heaptype}}`.

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{heaptype}}`.

   * Or:

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{heaptype}}_1`.

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{heaptype}}_2`.

      * The heap type :math:`{\mathit{heaptype}'}` is valid.

      * The heap type :math:`{\mathit{heaptype}}_1` matches the heap type :math:`{\mathit{heaptype}'}`.

      * The heap type :math:`{\mathit{heaptype}'}` matches the heap type :math:`{\mathit{heaptype}}_2`.
   * Or:

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{eq}`.

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`\mathsf{any}`.
   * Or:

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{i{\scriptstyle 31}}`.

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`\mathsf{eq}`.
   * Or:

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{struct}`.

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`\mathsf{eq}`.
   * Or:

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{array}`.

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`\mathsf{eq}`.
   * Or:

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{deftype}}`.

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`\mathsf{struct}`.

      * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{struct}~{{\mathit{fieldtype}}^\ast})`.
   * Or:

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{deftype}}`.

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`\mathsf{array}`.

      * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{array}~{\mathit{fieldtype}})`.
   * Or:

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{deftype}}`.

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`\mathsf{func}`.

      * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{func}~{\mathit{functype}})`.
   * Or:

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{deftype}}_1`.

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{deftype}}_2`.

      * The :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}_1` matches the :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}_2`.
   * Or:

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{typeidx}}`.

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{heaptype}}`.

      * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

      * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` matches the heap type :math:`{\mathit{heaptype}}`.
   * Or:

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{heaptype}}`.

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{typeidx}}`.

      * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

      * The heap type :math:`{\mathit{heaptype}}` matches the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]`.
   * Or:

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{rec}~i)`.

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{{\mathit{typeuse}}^\ast}{}[j]`.

      * :math:`{|{{\mathit{typeuse}}^\ast}|}` is greater than :math:`j`.

      * The sub type :math:`C{.}\mathsf{recs}{}[i]` exists.

      * The sub type :math:`C{.}\mathsf{recs}{}[i]` is equal to :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{ct}})`.
   * Or:

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{none}`.

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{heaptype}}`.

      * The heap type :math:`{\mathit{heaptype}}` matches the heap type :math:`\mathsf{any}`.
   * Or:

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{nofunc}`.

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{heaptype}}`.

      * The heap type :math:`{\mathit{heaptype}}` matches the heap type :math:`\mathsf{func}`.
   * Or:

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{noextern}`.

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{heaptype}}`.

      * The heap type :math:`{\mathit{heaptype}}` matches the heap type :math:`\mathsf{extern}`.
   * Or:

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{bot}`.

      * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{heaptype}}`.




The heap type :math:`{\mathit{heaptype}}` matches itself.




The heap type :math:`{\mathit{heaptype}}_1` matches the heap type :math:`{\mathit{heaptype}}_2` if:


   * The heap type :math:`{\mathit{heaptype}'}` is valid.

   * The heap type :math:`{\mathit{heaptype}}_1` matches the heap type :math:`{\mathit{heaptype}'}`.

   * The heap type :math:`{\mathit{heaptype}'}` matches the heap type :math:`{\mathit{heaptype}}_2`.




The heap type :math:`\mathsf{eq}` matches the heap type :math:`\mathsf{any}`.




The heap type :math:`\mathsf{i{\scriptstyle 31}}` matches the heap type :math:`\mathsf{eq}`.




The heap type :math:`\mathsf{struct}` matches the heap type :math:`\mathsf{eq}`.




The heap type :math:`\mathsf{array}` matches the heap type :math:`\mathsf{eq}`.




The heap type :math:`{\mathit{deftype}}` matches the heap type :math:`\mathsf{struct}` if:


   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{struct}~{{\mathit{fieldtype}}^\ast})`.




The heap type :math:`{\mathit{deftype}}` matches the heap type :math:`\mathsf{array}` if:


   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{array}~{\mathit{fieldtype}})`.




The heap type :math:`{\mathit{deftype}}` matches the heap type :math:`\mathsf{func}` if:


   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{func}~{\mathit{functype}})`.




The heap type :math:`{\mathit{deftype}}_1` matches the heap type :math:`{\mathit{deftype}}_2` if:


   * The :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}_1` matches the :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}_2`.




The heap type :math:`{\mathit{typeidx}}` matches the heap type :math:`{\mathit{heaptype}}` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` matches the heap type :math:`{\mathit{heaptype}}`.




The heap type :math:`{\mathit{heaptype}}` matches the heap type :math:`{\mathit{typeidx}}` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

   * The heap type :math:`{\mathit{heaptype}}` matches the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]`.




The heap type :math:`(\mathsf{rec}~i)` matches the type use :math:`{{\mathit{typeuse}}^\ast}{}[j]` if:


   * :math:`{|{{\mathit{typeuse}}^\ast}|}` is greater than :math:`j`.

   * The sub type :math:`C{.}\mathsf{recs}{}[i]` exists.

   * The sub type :math:`C{.}\mathsf{recs}{}[i]` is equal to :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{ct}})`.




The heap type :math:`\mathsf{none}` matches the heap type :math:`{\mathit{heaptype}}` if:


   * The heap type :math:`{\mathit{heaptype}}` matches the heap type :math:`\mathsf{any}`.




The heap type :math:`\mathsf{nofunc}` matches the heap type :math:`{\mathit{heaptype}}` if:


   * The heap type :math:`{\mathit{heaptype}}` matches the heap type :math:`\mathsf{func}`.




The heap type :math:`\mathsf{noextern}` matches the heap type :math:`{\mathit{heaptype}}` if:


   * The heap type :math:`{\mathit{heaptype}}` matches the heap type :math:`\mathsf{extern}`.




The heap type :math:`\mathsf{bot}` matches the heap type :math:`{\mathit{heaptype}}`.




The reference type :math:`(\mathsf{ref}~{{\mathsf{null}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}~{\mathit{ht}}_1)` matches the reference type :math:`(\mathsf{ref}~{{\mathsf{null}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}~{\mathit{ht}}_2)` if:


   * The heap type :math:`{\mathit{ht}}_1` matches the heap type :math:`{\mathit{ht}}_2`.

   * Either:

      * :math:`{{\mathsf{null}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is absent.

      * :math:`{{\mathsf{null}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is absent.

   * Or:

      * :math:`{{\mathsf{null}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{null}^?}`.

      * :math:`{{\mathsf{null}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`\mathsf{null}`.




The reference type :math:`(\mathsf{ref}~\epsilon~{\mathit{ht}}_1)` matches the reference type :math:`(\mathsf{ref}~\epsilon~{\mathit{ht}}_2)` if:


   * The heap type :math:`{\mathit{ht}}_1` matches the heap type :math:`{\mathit{ht}}_2`.




The reference type :math:`(\mathsf{ref}~{\mathsf{null}^?}~{\mathit{ht}}_1)` matches the reference type :math:`(\mathsf{ref}~\mathsf{null}~{\mathit{ht}}_2)` if:


   * The heap type :math:`{\mathit{ht}}_1` matches the heap type :math:`{\mathit{ht}}_2`.




The :ref:`vector type <syntax-vectype>` :math:`{\mathit{vectype}}` matches itself.




The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` matches the :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` if:


   * Either:

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{numtype}}_1`.

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{numtype}}_2`.

      * The :ref:`number type <syntax-numtype>` :math:`{\mathit{numtype}}_1` matches the :ref:`number type <syntax-numtype>` :math:`{\mathit{numtype}}_2`.

   * Or:

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{vectype}}_1`.

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{vectype}}_2`.

      * The :ref:`vector type <syntax-vectype>` :math:`{\mathit{vectype}}_1` matches the :ref:`vector type <syntax-vectype>` :math:`{\mathit{vectype}}_2`.
   * Or:

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{reftype}}_1`.

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{reftype}}_2`.

      * The reference type :math:`{\mathit{reftype}}_1` matches the reference type :math:`{\mathit{reftype}}_2`.
   * Or:

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{bot}`.

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{valtype}}`.




The :ref:`value type <syntax-valtype>` :math:`{\mathit{numtype}}_1` matches the :ref:`value type <syntax-valtype>` :math:`{\mathit{numtype}}_2` if:


   * The :ref:`number type <syntax-numtype>` :math:`{\mathit{numtype}}_1` matches the :ref:`number type <syntax-numtype>` :math:`{\mathit{numtype}}_2`.




The :ref:`value type <syntax-valtype>` :math:`{\mathit{vectype}}_1` matches the :ref:`value type <syntax-valtype>` :math:`{\mathit{vectype}}_2` if:


   * The :ref:`vector type <syntax-vectype>` :math:`{\mathit{vectype}}_1` matches the :ref:`vector type <syntax-vectype>` :math:`{\mathit{vectype}}_2`.




The :ref:`value type <syntax-valtype>` :math:`{\mathit{reftype}}_1` matches the :ref:`value type <syntax-valtype>` :math:`{\mathit{reftype}}_2` if:


   * The reference type :math:`{\mathit{reftype}}_1` matches the reference type :math:`{\mathit{reftype}}_2`.




The :ref:`value type <syntax-valtype>` :math:`\mathsf{bot}` matches the :ref:`value type <syntax-valtype>` :math:`{\mathit{valtype}}`.




The storage type :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` matches the storage type :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` if:


   * Either:

      * The storage type :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{valtype}}_1`.

      * The storage type :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{valtype}}_2`.

      * The :ref:`value type <syntax-valtype>` :math:`{\mathit{valtype}}_1` matches the :ref:`value type <syntax-valtype>` :math:`{\mathit{valtype}}_2`.

   * Or:

      * The storage type :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{packtype}}_1`.

      * The storage type :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{packtype}}_2`.

      * The packed type :math:`{\mathit{packtype}}_1` matches the packed type :math:`{\mathit{packtype}}_2`.




The storage type :math:`{\mathit{valtype}}_1` matches the storage type :math:`{\mathit{valtype}}_2` if:


   * The :ref:`value type <syntax-valtype>` :math:`{\mathit{valtype}}_1` matches the :ref:`value type <syntax-valtype>` :math:`{\mathit{valtype}}_2`.




The storage type :math:`{\mathit{packtype}}_1` matches the storage type :math:`{\mathit{packtype}}_2` if:


   * The packed type :math:`{\mathit{packtype}}_1` matches the packed type :math:`{\mathit{packtype}}_2`.




The field type :math:`({{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}~{\mathit{zt}}_1)` matches the field type :math:`({{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}~{\mathit{zt}}_2)` if:


   * The storage type :math:`{\mathit{zt}}_1` matches the storage type :math:`{\mathit{zt}}_2`.

   * Either:

      * :math:`{{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is absent.

      * :math:`{{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is absent.

   * Or:

      * :math:`{{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{mut}`.

      * :math:`{{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`\mathsf{mut}`.

      * The storage type :math:`{\mathit{zt}}_2` matches the storage type :math:`{\mathit{zt}}_1`.




The field type :math:`(\epsilon~{\mathit{zt}}_1)` matches the field type :math:`(\epsilon~{\mathit{zt}}_2)` if:


   * The storage type :math:`{\mathit{zt}}_1` matches the storage type :math:`{\mathit{zt}}_2`.




The field type :math:`(\mathsf{mut}~{\mathit{zt}}_1)` matches the field type :math:`(\mathsf{mut}~{\mathit{zt}}_2)` if:


   * The storage type :math:`{\mathit{zt}}_1` matches the storage type :math:`{\mathit{zt}}_2`.

   * The storage type :math:`{\mathit{zt}}_2` matches the storage type :math:`{\mathit{zt}}_1`.




The value type sequence :math:`{t_1^\ast}` matches the value type sequence :math:`{t_2^\ast}` if:


   * :math:`{|{t_1^\ast}|}` is equal to :math:`{|{t_2^\ast}|}`.

   * For all :math:`t_1` in :math:`{t_1^\ast}` and :math:`t_2` in :math:`{t_2^\ast}`:

      * The :ref:`value type <syntax-valtype>` :math:`t_1` matches the :ref:`value type <syntax-valtype>` :math:`t_2`.




The function type :math:`{t_{11}^\ast}~\rightarrow~{t_{12}^\ast}` matches the function type :math:`{t_{21}^\ast}~\rightarrow~{t_{22}^\ast}` if:


   * The value type sequence :math:`{t_{21}^\ast}` matches the value type sequence :math:`{t_{11}^\ast}`.

   * The value type sequence :math:`{t_{12}^\ast}` matches the value type sequence :math:`{t_{22}^\ast}`.




The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` matches the composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` if:


   * Either:

      * The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{struct}~{{\mathit{yt}}_1^\ast}~{\mathit{yt}'}_1)`.

      * The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{struct}~{{\mathit{yt}}_2^\ast})`.

      * :math:`{|{{\mathit{yt}}_1^\ast}|}` is equal to :math:`{|{{\mathit{yt}}_2^\ast}|}`.

      * For all :math:`{\mathit{yt}}_1` in :math:`{{\mathit{yt}}_1^\ast}` and :math:`{\mathit{yt}}_2` in :math:`{{\mathit{yt}}_2^\ast}`:

         * The field type :math:`{\mathit{yt}}_1` matches the field type :math:`{\mathit{yt}}_2`.

   * Or:

      * The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{array}~{\mathit{yt}}_1)`.

      * The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{array}~{\mathit{yt}}_2)`.

      * The field type :math:`{\mathit{yt}}_1` matches the field type :math:`{\mathit{yt}}_2`.
   * Or:

      * The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{ft}}_1)`.

      * The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{func}~{\mathit{ft}}_2)`.

      * The function type :math:`{\mathit{ft}}_1` matches the function type :math:`{\mathit{ft}}_2`.




The composite type :math:`(\mathsf{struct}~{{\mathit{yt}}_1^\ast}~{\mathit{yt}'}_1)` matches the composite type :math:`(\mathsf{struct}~{{\mathit{yt}}_2^\ast})` if:


   * :math:`{|{{\mathit{yt}}_1^\ast}|}` is equal to :math:`{|{{\mathit{yt}}_2^\ast}|}`.

   * For all :math:`{\mathit{yt}}_1` in :math:`{{\mathit{yt}}_1^\ast}` and :math:`{\mathit{yt}}_2` in :math:`{{\mathit{yt}}_2^\ast}`:

      * The field type :math:`{\mathit{yt}}_1` matches the field type :math:`{\mathit{yt}}_2`.




The composite type :math:`(\mathsf{array}~{\mathit{yt}}_1)` matches the composite type :math:`(\mathsf{array}~{\mathit{yt}}_2)` if:


   * The field type :math:`{\mathit{yt}}_1` matches the field type :math:`{\mathit{yt}}_2`.




The composite type :math:`(\mathsf{func}~{\mathit{ft}}_1)` matches the composite type :math:`(\mathsf{func}~{\mathit{ft}}_2)` if:


   * The function type :math:`{\mathit{ft}}_1` matches the function type :math:`{\mathit{ft}}_2`.




The sub type :math:`(\mathsf{sub}~{\mathsf{final}^?}~{x^\ast}~{\mathit{comptype}})` is valid with :math:`({\mathsf{ok}}{(x_0)})` if:


   * :math:`{|{x^\ast}|}` is less than or equal to :math:`1`.

   * For all :math:`x` in :math:`{x^\ast}`:

      * The index :math:`x` is less than :math:`x_0`.

   * :math:`{|{{\mathit{comptype}'}^\ast}|}` is equal to :math:`{|{x^\ast}|}`.

   * :math:`{|{{\mathit{comptype}'}^\ast}|}` is equal to :math:`{|{{{x'}^\ast}^\ast}|}`.

   * For all :math:`x` in :math:`{x^\ast}`:

      * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` exists.

   * For all :math:`{\mathit{comptype}'}` in :math:`{{\mathit{comptype}'}^\ast}` and :math:`x` in :math:`{x^\ast}` and :math:`{\mathit{x'*}}` in :math:`{{\mathit{x'*}}^\ast}`:

      * The sub type :math:`{\mathrm{unroll}}(C{.}\mathsf{types}{}[x])` is equal to :math:`(\mathsf{sub}~\epsilon~{{x'}^\ast}~{\mathit{comptype}'})`.

   * The composite type :math:`{\mathit{comptype}}` is valid.

   * For all :math:`{\mathit{comptype}'}` in :math:`{{\mathit{comptype}'}^\ast}`:

      * The composite type :math:`{\mathit{comptype}}` matches the composite type :math:`{\mathit{comptype}'}`.




The sub type :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{compttype}})` is valid with :math:`({\mathsf{ok}}{(x, i)})` if:


   * :math:`{|{{\mathit{typeuse}}^\ast}|}` is less than or equal to :math:`1`.

   * For all :math:`{\mathit{typeuse}}` in :math:`{{\mathit{typeuse}}^\ast}`:

      * :math:`{\mathit{typeuse}} \prec x, i` is equal to true.

   * :math:`{|{{\mathit{comptype}'}^\ast}|}` is equal to :math:`{|{{\mathit{typeuse}}^\ast}|}`.

   * :math:`{|{{\mathit{comptype}'}^\ast}|}` is equal to :math:`{|{{{\mathit{typeuse}'}^\ast}^\ast}|}`.

   * For all :math:`{\mathit{comptype}'}` in :math:`{{\mathit{comptype}'}^\ast}` and :math:`{\mathit{typeuse}}` in :math:`{{\mathit{typeuse}}^\ast}` and :math:`{\mathit{typeuse'*}}` in :math:`{{\mathit{typeuse'*}}^\ast}`:

      * The sub type :math:`{{\mathrm{unroll}}}_{C}({\mathit{typeuse}})` is equal to :math:`(\mathsf{sub}~\epsilon~{{\mathit{typeuse}'}^\ast}~{\mathit{comptype}'})`.

   * The composite type :math:`{\mathit{comptype}}` is valid.

   * For all :math:`{\mathit{comptype}'}` in :math:`{{\mathit{comptype}'}^\ast}`:

      * The composite type :math:`{\mathit{comptype}}` matches the composite type :math:`{\mathit{comptype}'}`.




The recursive type :math:`(\mathsf{rec}~{{\mathit{st}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})` is valid with :math:`({\mathsf{ok}}{(x, i)})` if:


   * Either:

      * The sub type sequence :math:`{{\mathit{st}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

   * Or:

      * The sub type sequence :math:`{{\mathit{st}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{\mathit{subtype}}_1~{{\mathit{subtype}}^\ast}`.

      * The sub type :math:`{\mathit{subtype}}_1` is valid with :math:`({\mathsf{ok}}{(x, i)})`.

      * The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is valid with :math:`({\mathsf{ok}}{(x + 1, i + 1)})`.




The recursive type :math:`(\mathsf{rec}~\epsilon)` is valid with :math:`({\mathsf{ok}}{(x, i)})`.




The recursive type :math:`(\mathsf{rec}~{\mathit{subtype}}_1~{{\mathit{subtype}}^\ast})` is valid with :math:`({\mathsf{ok}}{(x, i)})` if:


   * The sub type :math:`{\mathit{subtype}}_1` is valid with :math:`({\mathsf{ok}}{(x, i)})`.

   * The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is valid with :math:`({\mathsf{ok}}{(x + 1, i + 1)})`.




The recursive type :math:`(\mathsf{rec}~{{\mathit{st}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})` is valid for :math:`({\mathsf{ok}}{(x)})` if:


   * Either:

      * The sub type sequence :math:`{{\mathit{st}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

   * Or:

      * The sub type sequence :math:`{{\mathit{st}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{\mathit{subtype}}_1~{{\mathit{subtype}}^\ast}`.

      * The sub type :math:`{\mathit{subtype}}_1` is valid with :math:`({\mathsf{ok}}{(x)})`.

      * The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is valid for :math:`({\mathsf{ok}}{(x + 1)})`.




The recursive type :math:`(\mathsf{rec}~\epsilon)` is valid for :math:`({\mathsf{ok}}{(x)})`.




The recursive type :math:`(\mathsf{rec}~{\mathit{subtype}}_1~{{\mathit{subtype}}^\ast})` is valid for :math:`({\mathsf{ok}}{(x)})` if:


   * The sub type :math:`{\mathit{subtype}}_1` is valid with :math:`({\mathsf{ok}}{(x)})`.

   * The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is valid for :math:`({\mathsf{ok}}{(x + 1)})`.




The :ref:`defined type <syntax-deftype>` :math:`({\mathit{rectype}} {.} i)` is valid if:


   * The recursive type :math:`{\mathit{rectype}}` is valid for :math:`({\mathsf{ok}}{(x)})`.

   * The recursive type :math:`{\mathit{rectype}}` is equal to :math:`(\mathsf{rec}~{{\mathit{subtype}}^{n}})`.

   * :math:`i` is less than :math:`n`.




The limits :math:`{}[~n~..~m~]` is valid within :math:`k` if:


   * :math:`n` is less than or equal to :math:`m`.

   * :math:`m` is less than or equal to :math:`k`.




The global type :math:`({\mathsf{mut}^?}~t)` is valid if:


   * The :ref:`value type <syntax-valtype>` :math:`t` is valid.




The table type :math:`({\mathit{addrtype}}~{\mathit{limits}}~{\mathit{reftype}})` is valid if:


   * The limits :math:`{\mathit{limits}}` is valid within :math:`{2^{32}} - 1`.

   * The reference type :math:`{\mathit{reftype}}` is valid.




The memory type :math:`({\mathit{addrtype}}~{\mathit{limits}}~\mathsf{page})` is valid if:


   * The limits :math:`{\mathit{limits}}` is valid within :math:`{2^{16}}`.




The tag type :math:`{\mathit{deftype}}` is valid if:


   * The :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}` is valid.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{func}~{\mathit{functype}})`.




The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid if:


   * Either:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{deftype}})`.

      * The :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}` is valid.

      * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{func}~{\mathit{functype}})`.

   * Or:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~{\mathit{globaltype}})`.

      * The global type :math:`{\mathit{globaltype}}` is valid.
   * Or:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~{\mathit{tabletype}})`.

      * The table type :math:`{\mathit{tabletype}}` is valid.
   * Or:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~{\mathit{memtype}})`.

      * The memory type :math:`{\mathit{memtype}}` is valid.
   * Or:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{tag}~{\mathit{tagtype}})`.

      * The tag type :math:`{\mathit{tagtype}}` is valid.




The external type :math:`(\mathsf{func}~{\mathit{deftype}})` is valid if:


   * The :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}` is valid.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{func}~{\mathit{functype}})`.




The external type :math:`(\mathsf{global}~{\mathit{globaltype}})` is valid if:


   * The global type :math:`{\mathit{globaltype}}` is valid.




The external type :math:`(\mathsf{table}~{\mathit{tabletype}})` is valid if:


   * The table type :math:`{\mathit{tabletype}}` is valid.




The external type :math:`(\mathsf{mem}~{\mathit{memtype}})` is valid if:


   * The memory type :math:`{\mathit{memtype}}` is valid.




The external type :math:`(\mathsf{tag}~{\mathit{tagtype}})` is valid if:


   * The tag type :math:`{\mathit{tagtype}}` is valid.




The instruction type :math:`{t_{11}^\ast}~{\rightarrow}_{{x_1^\ast}}\,{t_{12}^\ast}` matches the instruction type :math:`{t_{21}^\ast}~{\rightarrow}_{{x_2^\ast}}\,{t_{22}^\ast}` if:


   * The value type sequence :math:`{t_{21}^\ast}` matches the value type sequence :math:`{t_{11}^\ast}`.

   * The value type sequence :math:`{t_{12}^\ast}` matches the value type sequence :math:`{t_{22}^\ast}`.

   * The local index sequence :math:`{x^\ast}` is equal to :math:`{x_2^\ast} \setminus {x_1^\ast}`.

   * :math:`{|{t^\ast}|}` is equal to :math:`{|{x^\ast}|}`.

   * For all :math:`x` in :math:`{x^\ast}`:

      * The local type :math:`C{.}\mathsf{locals}{}[x]` exists.

   * For all :math:`t` in :math:`{t^\ast}` and :math:`x` in :math:`{x^\ast}`:

      * The local type :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`(\mathsf{set}~t)`.




The limits :math:`{}[~n_1~..~m_1~]` matches the limits :math:`{}[~n_2~..~m_2~]` if:


   * :math:`n_1` is greater than or equal to :math:`n_2`.

   * :math:`m_1` is less than or equal to :math:`m_2`.




The global type :math:`({{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}~{\mathit{valtype}}_1)` matches the global type :math:`({{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}~{\mathit{valtype}}_2)` if:


   * The :ref:`value type <syntax-valtype>` :math:`{\mathit{valtype}}_1` matches the :ref:`value type <syntax-valtype>` :math:`{\mathit{valtype}}_2`.

   * Either:

      * :math:`{{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is absent.

      * :math:`{{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is absent.

   * Or:

      * :math:`{{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{mut}`.

      * :math:`{{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`\mathsf{mut}`.

      * The :ref:`value type <syntax-valtype>` :math:`{\mathit{valtype}}_2` matches the :ref:`value type <syntax-valtype>` :math:`{\mathit{valtype}}_1`.




The global type :math:`(\epsilon~{\mathit{valtype}}_1)` matches the global type :math:`(\epsilon~{\mathit{valtype}}_2)` if:


   * The :ref:`value type <syntax-valtype>` :math:`{\mathit{valtype}}_1` matches the :ref:`value type <syntax-valtype>` :math:`{\mathit{valtype}}_2`.




The global type :math:`(\mathsf{mut}~{\mathit{valtype}}_1)` matches the global type :math:`(\mathsf{mut}~{\mathit{valtype}}_2)` if:


   * The :ref:`value type <syntax-valtype>` :math:`{\mathit{valtype}}_1` matches the :ref:`value type <syntax-valtype>` :math:`{\mathit{valtype}}_2`.

   * The :ref:`value type <syntax-valtype>` :math:`{\mathit{valtype}}_2` matches the :ref:`value type <syntax-valtype>` :math:`{\mathit{valtype}}_1`.




The table type :math:`({\mathit{addrtype}}~{\mathit{limits}}_1~{\mathit{reftype}}_1)` matches the table type :math:`({\mathit{addrtype}}~{\mathit{limits}}_2~{\mathit{reftype}}_2)` if:


   * The limits :math:`{\mathit{limits}}_1` matches the limits :math:`{\mathit{limits}}_2`.

   * The reference type :math:`{\mathit{reftype}}_1` matches the reference type :math:`{\mathit{reftype}}_2`.

   * The reference type :math:`{\mathit{reftype}}_2` matches the reference type :math:`{\mathit{reftype}}_1`.




The memory type :math:`({\mathit{addrtype}}~{\mathit{limits}}_1~\mathsf{page})` matches the memory type :math:`({\mathit{addrtype}}~{\mathit{limits}}_2~\mathsf{page})` if:


   * The limits :math:`{\mathit{limits}}_1` matches the limits :math:`{\mathit{limits}}_2`.




The tag type :math:`{\mathit{deftype}}_1` matches the tag type :math:`{\mathit{deftype}}_2` if:


   * The :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}_1` matches the :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}_2`.

   * The :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}_2` matches the :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}_1`.




The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` matches the external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` if:


   * Either:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{deftype}}_1)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{func}~{\mathit{deftype}}_2)`.

      * The :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}_1` matches the :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}_2`.

   * Or:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~{\mathit{globaltype}}_1)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{global}~{\mathit{globaltype}}_2)`.

      * The global type :math:`{\mathit{globaltype}}_1` matches the global type :math:`{\mathit{globaltype}}_2`.
   * Or:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~{\mathit{tabletype}}_1)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{table}~{\mathit{tabletype}}_2)`.

      * The table type :math:`{\mathit{tabletype}}_1` matches the table type :math:`{\mathit{tabletype}}_2`.
   * Or:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~{\mathit{memtype}}_1)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{mem}~{\mathit{memtype}}_2)`.

      * The memory type :math:`{\mathit{memtype}}_1` matches the memory type :math:`{\mathit{memtype}}_2`.
   * Or:

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{tag}~{\mathit{tagtype}}_1)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{tag}~{\mathit{tagtype}}_2)`.

      * The tag type :math:`{\mathit{tagtype}}_1` matches the tag type :math:`{\mathit{tagtype}}_2`.




The external type :math:`(\mathsf{func}~{\mathit{deftype}}_1)` matches the external type :math:`(\mathsf{func}~{\mathit{deftype}}_2)` if:


   * The :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}_1` matches the :ref:`defined type <syntax-deftype>` :math:`{\mathit{deftype}}_2`.




The external type :math:`(\mathsf{global}~{\mathit{globaltype}}_1)` matches the external type :math:`(\mathsf{global}~{\mathit{globaltype}}_2)` if:


   * The global type :math:`{\mathit{globaltype}}_1` matches the global type :math:`{\mathit{globaltype}}_2`.




The external type :math:`(\mathsf{table}~{\mathit{tabletype}}_1)` matches the external type :math:`(\mathsf{table}~{\mathit{tabletype}}_2)` if:


   * The table type :math:`{\mathit{tabletype}}_1` matches the table type :math:`{\mathit{tabletype}}_2`.




The external type :math:`(\mathsf{mem}~{\mathit{memtype}}_1)` matches the external type :math:`(\mathsf{mem}~{\mathit{memtype}}_2)` if:


   * The memory type :math:`{\mathit{memtype}}_1` matches the memory type :math:`{\mathit{memtype}}_2`.




The external type :math:`(\mathsf{tag}~{\mathit{tagtype}}_1)` matches the external type :math:`(\mathsf{tag}~{\mathit{tagtype}}_2)` if:


   * The tag type :math:`{\mathit{tagtype}}_1` matches the tag type :math:`{\mathit{tagtype}}_2`.




The block type :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid as the instruction type :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}~\rightarrow~{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` if:


   * Either:

      * The block type :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{{\mathit{valtype}}^?}`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`{{\mathit{valtype}}^?}`.

      * If :math:`{\mathit{valtype}}` is defined, then:

         * The :ref:`value type <syntax-valtype>` :math:`{\mathit{valtype}}` is valid.

   * Or:

      * The block type :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{typeidx}}`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{t_1^\ast}`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`{t_2^\ast}`.

      * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

      * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The block type :math:`{{\mathit{valtype}}^?}` is valid as the instruction type :math:`\epsilon~\rightarrow~{{\mathit{valtype}}^?}` if:


   * If :math:`{\mathit{valtype}}` is defined, then:

      * The :ref:`value type <syntax-valtype>` :math:`{\mathit{valtype}}` is valid.




The block type :math:`{\mathit{typeidx}}` is valid as the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The catch clause :math:`{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid if:


   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * Either:

      * The catch clause :math:`{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{catch}~x~l)`.

      * The tag type :math:`C{.}\mathsf{tags}{}[x]` exists.

      * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{tags}{}[x]` is the composite type :math:`(\mathsf{func}~{t^\ast}~\rightarrow~\epsilon)`.

      * The value type sequence :math:`{t^\ast}` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.

   * Or:

      * The catch clause :math:`{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{catch\_ref}~x~l)`.

      * The tag type :math:`C{.}\mathsf{tags}{}[x]` exists.

      * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{tags}{}[x]` is the composite type :math:`(\mathsf{func}~{t^\ast}~\rightarrow~\epsilon)`.

      * The value type sequence :math:`{t^\ast}~(\mathsf{ref}~\epsilon~\mathsf{exn})` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.
   * Or:

      * The catch clause :math:`{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{catch\_all}~l)`.

      * The value type sequence :math:`\epsilon` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.
   * Or:

      * The catch clause :math:`{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{catch\_all\_ref}~l)`.

      * The value type sequence :math:`(\mathsf{ref}~\epsilon~\mathsf{exn})` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.




The catch clause :math:`(\mathsf{catch}~x~l)` is valid if:


   * The tag type :math:`C{.}\mathsf{tags}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{tags}{}[x]` is the composite type :math:`(\mathsf{func}~{t^\ast}~\rightarrow~\epsilon)`.

   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The value type sequence :math:`{t^\ast}` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.




The catch clause :math:`(\mathsf{catch\_ref}~x~l)` is valid if:


   * The tag type :math:`C{.}\mathsf{tags}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{tags}{}[x]` is the composite type :math:`(\mathsf{func}~{t^\ast}~\rightarrow~\epsilon)`.

   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The value type sequence :math:`{t^\ast}~(\mathsf{ref}~\epsilon~\mathsf{exn})` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.




The catch clause :math:`(\mathsf{catch\_all}~l)` is valid if:


   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The value type sequence :math:`\epsilon` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.




The catch clause :math:`(\mathsf{catch\_all\_ref}~l)` is valid if:


   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The value type sequence :math:`(\mathsf{ref}~\epsilon~\mathsf{exn})` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.




The :ref:`value type <syntax-valtype>` :math:`t` is defaultable if:


   * The value :math:`{{\mathrm{default}}}_{t}` is not absent.




The instruction :math:`\mathsf{nop}` is valid with the instruction type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction :math:`\mathsf{unreachable}` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid.




The instruction :math:`\mathsf{drop}` is valid with the instruction type :math:`t~\rightarrow~\epsilon` if:


   * The :ref:`value type <syntax-valtype>` :math:`t` is valid.




The instruction :math:`(\mathsf{select}~{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?})` is valid with the instruction type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


   * The :ref:`value type <syntax-valtype>` :math:`t` is valid.

   * Either:

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`t`.

   * Or:

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is absent.

      * The :ref:`value type <syntax-valtype>` :math:`t` matches the :ref:`value type <syntax-valtype>` :math:`{t'}`.

      * The :ref:`value type <syntax-valtype>` :math:`{t'}` is equal to :math:`{\mathit{numtype}}` or :math:`{t'}` is equal to :math:`{\mathit{vectype}}`.




The instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}^\ast})` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{bt}}` is valid as the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.




The instruction :math:`(\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast})` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{bt}}` is valid as the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_1^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.




The instruction :math:`(\mathsf{if}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast})` is valid with the instruction type :math:`{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{bt}}` is valid as the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_1^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}}\,{t_2^\ast}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_2^\ast}}\,{t_2^\ast}`.




The instruction :math:`(\mathsf{br}~l)` is valid with the instruction type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The result type :math:`C{.}\mathsf{labels}{}[l]` is equal to :math:`{t^\ast}`.

   * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid.




The instruction :math:`(\mathsf{br\_if}~l)` is valid with the instruction type :math:`{t^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t^\ast}` if:


   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The result type :math:`C{.}\mathsf{labels}{}[l]` is equal to :math:`{t^\ast}`.




The instruction :math:`(\mathsf{br\_table}~{l^\ast}~{l'})` is valid with the instruction type :math:`{t_1^\ast}~{t^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


   * For all :math:`l` in :math:`{l^\ast}`:

      * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * For all :math:`l` in :math:`{l^\ast}`:

      * The value type sequence :math:`{t^\ast}` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.

   * The result type :math:`C{.}\mathsf{labels}{}[{l'}]` exists.

   * The value type sequence :math:`{t^\ast}` matches the result type :math:`C{.}\mathsf{labels}{}[{l'}]`.

   * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid.




The instruction :math:`(\mathsf{br\_on\_null}~l)` is valid with the instruction type :math:`{t^\ast}~(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})~\rightarrow~{t^\ast}~(\mathsf{ref}~\epsilon~{\mathit{ht}})` if:


   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The result type :math:`C{.}\mathsf{labels}{}[l]` is equal to :math:`{t^\ast}`.

   * The heap type :math:`{\mathit{ht}}` is valid.




The instruction :math:`(\mathsf{br\_on\_non\_null}~l)` is valid with the instruction type :math:`{t^\ast}~(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})~\rightarrow~{t^\ast}` if:


   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The result type :math:`C{.}\mathsf{labels}{}[l]` is equal to :math:`{t^\ast}~(\mathsf{ref}~\epsilon~{\mathit{ht}})`.




The instruction :math:`(\mathsf{br\_on\_cast}~l~{\mathit{rt}}_1~{\mathit{rt}}_2)` is valid with the instruction type :math:`{t^\ast}~{\mathit{rt}}_1~\rightarrow~{t^\ast}~{t'}` if:


   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The result type :math:`C{.}\mathsf{labels}{}[l]` is equal to :math:`{t^\ast}~{\mathit{rt}}`.

   * The reference type :math:`{\mathit{rt}}_1` is valid.

   * The reference type :math:`{\mathit{rt}}_2` is valid.

   * The reference type :math:`{\mathit{rt}}_2` matches the reference type :math:`{\mathit{rt}}_1`.

   * The reference type :math:`{\mathit{rt}}_2` matches the reference type :math:`{\mathit{rt}}`.

   * Let :math:`{t'}` be the reference type :math:`{\mathit{rt}}_1 \setminus {\mathit{rt}}_2`.




The instruction :math:`(\mathsf{br\_on\_cast\_fail}~l~{\mathit{rt}}_1~{\mathit{rt}}_2)` is valid with the instruction type :math:`{t^\ast}~{\mathit{rt}}_1~\rightarrow~{t^\ast}~{\mathit{rt}}_2` if:


   * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

   * The result type :math:`C{.}\mathsf{labels}{}[l]` is equal to :math:`{t^\ast}~{\mathit{rt}}`.

   * The reference type :math:`{\mathit{rt}}_1` is valid.

   * The reference type :math:`{\mathit{rt}}_2` is valid.

   * The reference type :math:`{\mathit{rt}}_2` matches the reference type :math:`{\mathit{rt}}_1`.

   * The reference type :math:`{\mathit{rt}}_1 \setminus {\mathit{rt}}_2` matches the reference type :math:`{\mathit{rt}}`.




The instruction :math:`(\mathsf{call}~x)` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{funcs}{}[x]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The instruction :math:`(\mathsf{call\_ref}~x)` is valid with the instruction type :math:`{t_1^\ast}~(\mathsf{ref}~\mathsf{null}~x)~\rightarrow~{t_2^\ast}` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The instruction :math:`(\mathsf{call\_indirect}~x~y)` is valid with the instruction type :math:`{t_1^\ast}~{\mathit{at}}~\rightarrow~{t_2^\ast}` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.

   * The reference type :math:`{\mathit{rt}}` matches the reference type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{func})`.

   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[y]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[y]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The instruction :math:`\mathsf{return}` is valid with the instruction type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


   * The result type :math:`C{.}\mathsf{return}` is equal to :math:`{t^\ast}`.

   * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid.




The instruction :math:`(\mathsf{return\_call}~x)` is valid with the instruction type :math:`{t_3^\ast}~{t_1^\ast}~\rightarrow~{t_4^\ast}` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{funcs}{}[x]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.

   * The result type :math:`C{.}\mathsf{return}` is equal to :math:`{{t'}_2^\ast}`.

   * The value type sequence :math:`{t_2^\ast}` matches the value type sequence :math:`{{t'}_2^\ast}`.

   * The instruction type :math:`{t_3^\ast}~\rightarrow~{t_4^\ast}` is valid.




The instruction :math:`(\mathsf{return\_call\_ref}~x)` is valid with the instruction type :math:`{t_3^\ast}~{t_1^\ast}~(\mathsf{ref}~\mathsf{null}~x)~\rightarrow~{t_4^\ast}` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.

   * The result type :math:`C{.}\mathsf{return}` is equal to :math:`{{t'}_2^\ast}`.

   * The value type sequence :math:`{t_2^\ast}` matches the value type sequence :math:`{{t'}_2^\ast}`.

   * The instruction type :math:`{t_3^\ast}~\rightarrow~{t_4^\ast}` is valid.




The instruction :math:`(\mathsf{return\_call\_indirect}~x~y)` is valid with the instruction type :math:`{t_3^\ast}~{t_1^\ast}~{\mathit{at}}~\rightarrow~{t_4^\ast}` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.

   * The reference type :math:`{\mathit{rt}}` matches the reference type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{func})`.

   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[y]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[y]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.

   * The result type :math:`C{.}\mathsf{return}` is equal to :math:`{{t'}_2^\ast}`.

   * The value type sequence :math:`{t_2^\ast}` matches the value type sequence :math:`{{t'}_2^\ast}`.

   * The instruction type :math:`{t_3^\ast}~\rightarrow~{t_4^\ast}` is valid.




The instruction :math:`(\mathsf{throw}~x)` is valid with the instruction type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


   * The tag type :math:`C{.}\mathsf{tags}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{tags}{}[x]` is the composite type :math:`(\mathsf{func}~{t^\ast}~\rightarrow~\epsilon)`.

   * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid.




The instruction :math:`\mathsf{throw\_ref}` is valid with the instruction type :math:`{t_1^\ast}~(\mathsf{ref}~\mathsf{null}~\mathsf{exn})~\rightarrow~{t_2^\ast}` if:


   * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid.




The instruction :math:`(\mathsf{try\_table}~{\mathit{bt}}~{{\mathit{catch}}^\ast}~{{\mathit{instr}}^\ast})` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{bt}}` is valid as the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.

   * For all :math:`{\mathit{catch}}` in :math:`{{\mathit{catch}}^\ast}`:

      * The catch clause :math:`{\mathit{catch}}` is valid.




The instruction :math:`({\mathit{nt}}{.}\mathsf{const}~c_{\mathit{nt}})` is valid with the instruction type :math:`\epsilon~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{unop}}_{\mathit{nt}})` is valid with the instruction type :math:`{\mathit{nt}}~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{binop}}_{\mathit{nt}})` is valid with the instruction type :math:`{\mathit{nt}}~{\mathit{nt}}~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{testop}}_{\mathit{nt}})` is valid with the instruction type :math:`{\mathit{nt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{relop}}_{\mathit{nt}})` is valid with the instruction type :math:`{\mathit{nt}}~{\mathit{nt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{nt}}_1 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_2})` is valid with the instruction type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1`.




The instruction :math:`(\mathsf{ref{.}null}~{\mathit{ht}})` is valid with the instruction type :math:`\epsilon~\rightarrow~(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})` if:


   * The heap type :math:`{\mathit{ht}}` is valid.




The instruction :math:`(\mathsf{ref{.}func}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~(\mathsf{ref}~\epsilon~{\mathit{dt}})` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{\mathit{dt}}`.

   * :math:`x` is contained in :math:`C{.}\mathsf{refs}`.




The instruction :math:`\mathsf{ref{.}i{\scriptstyle 31}}` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~\epsilon~\mathsf{i{\scriptstyle 31}})`.




The instruction :math:`\mathsf{ref{.}is\_null}` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The heap type :math:`{\mathit{ht}}` is valid.




The instruction :math:`\mathsf{ref{.}as\_non\_null}` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})~\rightarrow~(\mathsf{ref}~\epsilon~{\mathit{ht}})` if:


   * The heap type :math:`{\mathit{ht}}` is valid.




The instruction :math:`\mathsf{ref{.}eq}` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{eq})~(\mathsf{ref}~\mathsf{null}~\mathsf{eq})~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`(\mathsf{ref{.}test}~{\mathit{rt}})` is valid with the instruction type :math:`{\mathit{rt}'}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


   * The reference type :math:`{\mathit{rt}}` is valid.

   * The reference type :math:`{\mathit{rt}'}` is valid.

   * The reference type :math:`{\mathit{rt}}` matches the reference type :math:`{\mathit{rt}'}`.




The instruction :math:`(\mathsf{ref{.}cast}~{\mathit{rt}})` is valid with the instruction type :math:`{\mathit{rt}'}~\rightarrow~{\mathit{rt}}` if:


   * The reference type :math:`{\mathit{rt}}` is valid.

   * The reference type :math:`{\mathit{rt}'}` is valid.

   * The reference type :math:`{\mathit{rt}}` matches the reference type :math:`{\mathit{rt}'}`.




The instruction :math:`({\mathsf{i{\scriptstyle 31}{.}get}}{\mathsf{\_}}{{\mathit{sx}}})` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{i{\scriptstyle 31}})~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`(\mathsf{struct{.}new}~x)` is valid with the instruction type :math:`{t^\ast}~\rightarrow~(\mathsf{ref}~\epsilon~x)` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{struct}~{({\mathsf{mut}^?}~{\mathit{zt}})^\ast})`.

   * Let :math:`{t^\ast}` be the value type sequence :math:`{{\mathrm{unpack}}({\mathit{zt}})^\ast}`.




The instruction :math:`(\mathsf{struct{.}new\_default}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~(\mathsf{ref}~\epsilon~x)` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{struct}~{({\mathsf{mut}^?}~{\mathit{zt}})^\ast})`.

   * For all :math:`{\mathit{zt}}` in :math:`{{\mathit{zt}}^\ast}`:

      * A :ref:`default value <aux-default>` for the :ref:`value type <syntax-valtype>` :math:`{\mathrm{unpack}}({\mathit{zt}})` is defined.




The instruction :math:`({\mathsf{struct{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x~i)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\rightarrow~t` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{struct}~{{\mathit{yt}}^\ast})`.

   * :math:`{|{{\mathit{yt}}^\ast}|}` is greater than :math:`i`.

   * The field type :math:`{{\mathit{yt}}^\ast}{}[i]` is equal to :math:`({\mathsf{mut}^?}~{\mathit{zt}})`.

   * The signedness :math:`{{\mathit{sx}}^?}` is absent if and only if the storage type :math:`{\mathit{zt}}` is equal to :math:`{\mathrm{unpack}}({\mathit{zt}})`.

   * Let :math:`t` be the :ref:`value type <syntax-valtype>` :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{struct{.}set}~x~i)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~t~\rightarrow~\epsilon` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{struct}~{{\mathit{yt}}^\ast})`.

   * :math:`{|{{\mathit{yt}}^\ast}|}` is greater than :math:`i`.

   * The field type :math:`{{\mathit{yt}}^\ast}{}[i]` is equal to :math:`(\mathsf{mut}~{\mathit{zt}})`.

   * Let :math:`t` be the :ref:`value type <syntax-valtype>` :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{array{.}new}~x)` is valid with the instruction type :math:`t~\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~\epsilon~x)` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}))`.

   * Let :math:`t` be the :ref:`value type <syntax-valtype>` :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{array{.}new\_default}~x)` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~\epsilon~x)` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}))`.

   * A :ref:`default value <aux-default>` for the :ref:`value type <syntax-valtype>` :math:`{\mathrm{unpack}}({\mathit{zt}})` is defined.




The instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)` is valid with the instruction type :math:`{t^{n}}~\rightarrow~(\mathsf{ref}~\epsilon~x)` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}))`.

   * Let :math:`t` be the :ref:`value type <syntax-valtype>` :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{array{.}new\_elem}~x~y)` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~\epsilon~x)` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{rt}}))`.

   * The element type :math:`C{.}\mathsf{elems}{}[y]` exists.

   * The reference type :math:`C{.}\mathsf{elems}{}[y]` matches the reference type :math:`{\mathit{rt}}`.




The instruction :math:`(\mathsf{array{.}new\_data}~x~y)` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~\epsilon~x)` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}))`.

   * The :ref:`value type <syntax-valtype>` :math:`{\mathrm{unpack}}({\mathit{zt}})` is equal to :math:`{\mathit{numtype}}` or :math:`{\mathrm{unpack}}({\mathit{zt}})` is equal to :math:`{\mathit{vectype}}`.

   * The data type :math:`C{.}\mathsf{datas}{}[y]` exists.

   * The data type :math:`C{.}\mathsf{datas}{}[y]` is equal to :math:`\mathsf{ok}`.




The instruction :math:`({\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}))`.

   * The signedness :math:`{{\mathit{sx}}^?}` is absent if and only if the storage type :math:`{\mathit{zt}}` is equal to :math:`{\mathrm{unpack}}({\mathit{zt}})`.

   * Let :math:`t` be the :ref:`value type <syntax-valtype>` :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{array{.}set}~x)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~t~\rightarrow~\epsilon` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~(\mathsf{mut}~{\mathit{zt}}))`.

   * Let :math:`t` be the :ref:`value type <syntax-valtype>` :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`\mathsf{array{.}len}` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{array})~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`(\mathsf{array{.}fill}~x)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~(\mathsf{mut}~{\mathit{zt}}))`.

   * Let :math:`t` be the :ref:`value type <syntax-valtype>` :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{array{.}copy}~x_1~x_2)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x_1)~\mathsf{i{\scriptstyle 32}}~(\mathsf{ref}~\mathsf{null}~x_2)~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x_1]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x_1]` is the composite type :math:`(\mathsf{array}~(\mathsf{mut}~{\mathit{zt}}_1))`.

   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x_2]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x_2]` is the composite type :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}_2))`.

   * The storage type :math:`{\mathit{zt}}_2` matches the storage type :math:`{\mathit{zt}}_1`.




The instruction :math:`(\mathsf{array{.}init\_elem}~x~y)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~(\mathsf{mut}~{\mathit{zt}}))`.

   * The element type :math:`C{.}\mathsf{elems}{}[y]` exists.

   * The element type :math:`C{.}\mathsf{elems}{}[y]` matches the storage type :math:`{\mathit{zt}}`.




The instruction :math:`(\mathsf{array{.}init\_data}~x~y)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~(\mathsf{mut}~{\mathit{zt}}))`.

   * The :ref:`value type <syntax-valtype>` :math:`{\mathrm{unpack}}({\mathit{zt}})` is equal to :math:`{\mathit{numtype}}` or :math:`{\mathrm{unpack}}({\mathit{zt}})` is equal to :math:`{\mathit{vectype}}`.

   * The data type :math:`C{.}\mathsf{datas}{}[y]` exists.

   * The data type :math:`C{.}\mathsf{datas}{}[y]` is equal to :math:`\mathsf{ok}`.




The instruction :math:`\mathsf{extern{.}convert\_any}` is valid with the instruction type :math:`(\mathsf{ref}~{\mathsf{null}}{{{}_{1}^?}}~\mathsf{any})~\rightarrow~(\mathsf{ref}~{\mathsf{null}}{{{}_{2}^?}}~\mathsf{extern})` if:


   * :math:`{\mathsf{null}}{{{}_{1}^?}}` is equal to :math:`{\mathsf{null}}{{{}_{2}^?}}`.




The instruction :math:`\mathsf{any{.}convert\_extern}` is valid with the instruction type :math:`(\mathsf{ref}~{\mathsf{null}}{{{}_{1}^?}}~\mathsf{extern})~\rightarrow~(\mathsf{ref}~{\mathsf{null}}{{{}_{2}^?}}~\mathsf{any})` if:


   * :math:`{\mathsf{null}}{{{}_{1}^?}}` is equal to :math:`{\mathsf{null}}{{{}_{2}^?}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` is valid with the instruction type :math:`\epsilon~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvunop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvbinop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvternop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvtestop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vunop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vbinop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vternop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vtestop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vrelop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vshiftop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{bitmask})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vswizzlop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{shuffle}~{i^\ast})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * For all :math:`i` in :math:`{i^\ast}`:

      * The lane index :math:`i` is less than :math:`2 \cdot {\mathrm{dim}}({\mathit{sh}})`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{splat})` is valid with the instruction type :math:`t~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * Let :math:`t` be the :ref:`number type <syntax-numtype>` :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`({{\mathit{sh}}{.}\mathsf{extract\_lane}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~i)` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~t` if:


   * The lane index :math:`i` is less than :math:`{\mathrm{dim}}({\mathit{sh}})`.

   * Let :math:`t` be the :ref:`number type <syntax-numtype>` :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{replace\_lane}~i)` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~t~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The lane index :math:`i` is less than :math:`{\mathrm{dim}}({\mathit{sh}})`.

   * Let :math:`t` be the :ref:`number type <syntax-numtype>` :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`({\mathit{sh}}_1 {.} {{\mathit{vextunop}}}{\mathsf{\_}}{{\mathit{sh}}_2})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}_1 {.} {{\mathit{vextbinop}}}{\mathsf{\_}}{{\mathit{sh}}_2})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}_1 {.} {{\mathit{vextternop}}}{\mathsf{\_}}{{\mathit{sh}}_2})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({{\mathit{sh}}_1{.}\mathsf{narrow}}{\mathsf{\_}}{{\mathit{sh}}_2}{\mathsf{\_}}{{\mathit{sx}}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}_1 {.} {{\mathit{vcvtop}}}{\mathsf{\_}}{{{\mathit{zero}}^?}}{\mathsf{\_}}{{\mathit{sh}}_2}{\mathsf{\_}}{{{\mathit{half}}^?}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{local{.}get}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~t` if:


   * The local type :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The local type :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`(\mathsf{set}~t)`.




The instruction :math:`(\mathsf{local{.}set}~x)` is valid with the instruction type :math:`t~{\rightarrow}_{x}\,\epsilon` if:


   * The local type :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The local type :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`({\mathit{init}}~t)`.




The instruction :math:`(\mathsf{local{.}tee}~x)` is valid with the instruction type :math:`t~{\rightarrow}_{x}\,t` if:


   * The local type :math:`C{.}\mathsf{locals}{}[x]` exists.

   * The local type :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`({\mathit{init}}~t)`.




The instruction :math:`(\mathsf{global{.}get}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~t` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`({\mathsf{mut}^?}~t)`.




The instruction :math:`(\mathsf{global{.}set}~x)` is valid with the instruction type :math:`t~\rightarrow~\epsilon` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`(\mathsf{mut}~t)`.




The instruction :math:`(\mathsf{table{.}get}~x)` is valid with the instruction type :math:`{\mathit{at}}~\rightarrow~{\mathit{rt}}` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}set}~x)` is valid with the instruction type :math:`{\mathit{at}}~{\mathit{rt}}~\rightarrow~\epsilon` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}size}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~{\mathit{at}}` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}grow}~x)` is valid with the instruction type :math:`{\mathit{rt}}~{\mathit{at}}~\rightarrow~{\mathit{at}}` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}fill}~x)` is valid with the instruction type :math:`{\mathit{at}}~{\mathit{rt}}~{\mathit{at}}~\rightarrow~\epsilon` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}copy}~x_1~x_2)` is valid with the instruction type :math:`{\mathit{at}}_1~{\mathit{at}}_2~t~\rightarrow~\epsilon` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x_1]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x_1]` is equal to :math:`({\mathit{at}}_1~{\mathit{lim}}_1~{\mathit{rt}}_1)`.

   * The table type :math:`C{.}\mathsf{tables}{}[x_2]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x_2]` is equal to :math:`({\mathit{at}}_2~{\mathit{lim}}_2~{\mathit{rt}}_2)`.

   * The reference type :math:`{\mathit{rt}}_2` matches the reference type :math:`{\mathit{rt}}_1`.

   * Let :math:`t` be the address type :math:`{\mathrm{min}}({\mathit{at}}_1, {\mathit{at}}_2)`.




The instruction :math:`(\mathsf{table{.}init}~x~y)` is valid with the instruction type :math:`{\mathit{at}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}}_1)`.

   * The element type :math:`C{.}\mathsf{elems}{}[y]` exists.

   * The reference type :math:`C{.}\mathsf{elems}{}[y]` is equal to :math:`{\mathit{rt}}_2`.

   * The reference type :math:`{\mathit{rt}}_2` matches the reference type :math:`{\mathit{rt}}_1`.




The instruction :math:`(\mathsf{elem{.}drop}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~\epsilon` if:


   * The element type :math:`C{.}\mathsf{elems}{}[x]` exists.

   * The reference type :math:`C{.}\mathsf{elems}{}[x]` is equal to :math:`{\mathit{rt}}`.




The instruction :math:`(\mathsf{memory{.}size}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~{\mathit{at}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.




The instruction :math:`(\mathsf{memory{.}grow}~x)` is valid with the instruction type :math:`{\mathit{at}}~\rightarrow~{\mathit{at}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.




The instruction :math:`(\mathsf{memory{.}fill}~x)` is valid with the instruction type :math:`{\mathit{at}}~\mathsf{i{\scriptstyle 32}}~{\mathit{at}}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.




The instruction :math:`(\mathsf{memory{.}copy}~x_1~x_2)` is valid with the instruction type :math:`{\mathit{at}}_1~{\mathit{at}}_2~t~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x_1]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x_1]` is equal to :math:`({\mathit{at}}_1~{\mathit{lim}}_1~\mathsf{page})`.

   * The memory type :math:`C{.}\mathsf{mems}{}[x_2]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x_2]` is equal to :math:`({\mathit{at}}_2~{\mathit{lim}}_2~\mathsf{page})`.

   * Let :math:`t` be the address type :math:`{\mathrm{min}}({\mathit{at}}_1, {\mathit{at}}_2)`.




The instruction :math:`(\mathsf{memory{.}init}~x~y)` is valid with the instruction type :math:`{\mathit{at}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * The data type :math:`C{.}\mathsf{datas}{}[y]` exists.

   * The data type :math:`C{.}\mathsf{datas}{}[y]` is equal to :math:`\mathsf{ok}`.




The instruction :math:`(\mathsf{data{.}drop}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~\epsilon` if:


   * The data type :math:`C{.}\mathsf{datas}{}[x]` exists.

   * The data type :math:`C{.}\mathsf{datas}{}[x]` is equal to :math:`\mathsf{ok}`.




The instruction :math:`({{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{load}}{{{\mathit{loadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~\rightarrow~t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * Either:

      * The :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{nt}}`.

      * :math:`{{\mathit{loadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is absent.

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{nt}}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

   * Or:

      * The :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{i}}{N}`.

      * :math:`{{\mathit{loadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`{M}{\mathsf{\_}}{{\mathit{sx}}}`.

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{i}}{N}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{store}}{{{\mathit{storeop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * Either:

      * The :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{nt}}`.

      * :math:`{{\mathit{storeop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is absent.

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{nt}}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

   * Or:

      * The :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{i}}{N}`.

      * :math:`{{\mathit{storeop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`M`.

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{i}}{N}`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * Either:

      * :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is absent.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|\mathsf{v{\scriptstyle 128}}|} / 8`.

   * Or:

      * :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`({M}{\mathsf{x}}{N}{\mathsf{\_}}{{\mathit{sx}}})`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8 \cdot N`.
   * Or:

      * :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`({N}{\mathsf{\_}}{\mathsf{splat}})`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.
   * Or:

      * :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`({N}{\mathsf{\_}}{\mathsf{zero}})`.

      * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{N}{\mathsf{\_}}{\mathsf{lane}}~x~{\mathit{memarg}}~i)` is valid with the instruction type :math:`{\mathit{at}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.

   * :math:`i` is less than :math:`128 / N`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{store}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|\mathsf{v{\scriptstyle 128}}|} / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{store}}{N}{\mathsf{\_}}{\mathsf{lane}}~x~{\mathit{memarg}}~i)` is valid with the instruction type :math:`{\mathit{at}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.

   * :math:`i` is less than :math:`128 / N`.




The instruction :math:`(\mathsf{select}~t)` is valid with the instruction type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


   * The :ref:`value type <syntax-valtype>` :math:`t` is valid.




The instruction :math:`(\mathsf{select}~\epsilon)` is valid with the instruction type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


   * The :ref:`value type <syntax-valtype>` :math:`t` is valid.

   * The :ref:`value type <syntax-valtype>` :math:`t` matches the :ref:`value type <syntax-valtype>` :math:`{t'}`.

   * The :ref:`value type <syntax-valtype>` :math:`{t'}` is equal to :math:`{\mathit{numtype}}` or :math:`{t'}` is equal to :math:`{\mathit{vectype}}`.




The instruction :math:`({{\mathit{nt}}{.}\mathsf{load}}{\epsilon}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~\rightarrow~{\mathit{nt}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.




The instruction :math:`({{\mathsf{i}}{N}{.}\mathsf{load}}{{M}{\mathsf{\_}}{{\mathit{sx}}}}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~\rightarrow~{\mathsf{i}}{N}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({{\mathit{nt}}{.}\mathsf{store}}{\epsilon}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~{\mathit{nt}}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.




The instruction :math:`({{\mathsf{i}}{N}{.}\mathsf{store}}{M}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~{\mathsf{i}}{N}~\rightarrow~\epsilon` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{\epsilon}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|\mathsf{v{\scriptstyle 128}}|} / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{M}{\mathsf{x}}{N}{\mathsf{\_}}{{\mathit{sx}}}}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8 \cdot N`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{N}{\mathsf{\_}}{\mathsf{splat}}}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{N}{\mathsf{\_}}{\mathsf{zero}}}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

   * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.




The instruction sequence :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is valid with the instruction type :math:`{\mathit{instrtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


   * Either:

      * The instruction sequence :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

      * The instruction type :math:`{\mathit{instrtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\epsilon~\rightarrow~\epsilon`.

   * Or:

      * The instruction sequence :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}`.

      * The instruction type :math:`{\mathit{instrtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}~{x_2^\ast}}\,{t_3^\ast}`.

      * The instruction :math:`{\mathit{instr}}_1` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}}\,{t_2^\ast}`.

      * :math:`{|{{\mathit{init}}^\ast}|}` is equal to :math:`{|{t^\ast}|}`.

      * :math:`{|{{\mathit{init}}^\ast}|}` is equal to :math:`{|{x_1^\ast}|}`.

      * For all :math:`x_1` in :math:`{x_1^\ast}`:

         * The local type :math:`C{.}\mathsf{locals}{}[x_1]` exists.

      * For all :math:`{\mathit{init}}` in :math:`{{\mathit{init}}^\ast}` and :math:`t` in :math:`{t^\ast}` and :math:`x_1` in :math:`{x_1^\ast}`:

         * The local type :math:`C{.}\mathsf{locals}{}[x_1]` is equal to :math:`({\mathit{init}}~t)`.

      * Under the context :math:`C{}[{.}\mathsf{local}{}[{x_1^\ast}] = {(\mathsf{set}~t)^\ast}]`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the instruction type :math:`{t_2^\ast}~{\rightarrow}_{{x_2^\ast}}\,{t_3^\ast}`.
   * Or:

      * The instruction sequence :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{{\mathit{instr}}^\ast}`.

      * The instruction type :math:`{\mathit{instrtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{it}'}`.

      * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{\mathit{it}}`.

      * The instruction type :math:`{\mathit{it}}` matches the instruction type :math:`{\mathit{it}'}`.

      * The instruction type :math:`{\mathit{it}'}` is valid.
   * Or:

      * The instruction sequence :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{{\mathit{instr}}^\ast}`.

      * The instruction type :math:`{\mathit{instrtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{t^\ast}~{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t^\ast}~{t_2^\ast}`.

      * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.

      * The result type :math:`{t^\ast}` is valid.




The instruction sequence :math:`\epsilon` is valid with the instruction type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction sequence :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}~{x_2^\ast}}\,{t_3^\ast}` if:


   * The instruction :math:`{\mathit{instr}}_1` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}}\,{t_2^\ast}`.

   * :math:`{|{{\mathit{init}}^\ast}|}` is equal to :math:`{|{t^\ast}|}`.

   * :math:`{|{{\mathit{init}}^\ast}|}` is equal to :math:`{|{x_1^\ast}|}`.

   * For all :math:`x_1` in :math:`{x_1^\ast}`:

      * The local type :math:`C{.}\mathsf{locals}{}[x_1]` exists.

   * For all :math:`{\mathit{init}}` in :math:`{{\mathit{init}}^\ast}` and :math:`t` in :math:`{t^\ast}` and :math:`x_1` in :math:`{x_1^\ast}`:

      * The local type :math:`C{.}\mathsf{locals}{}[x_1]` is equal to :math:`({\mathit{init}}~t)`.

   * Under the context :math:`C{}[{.}\mathsf{local}{}[{x_1^\ast}] = {(\mathsf{set}~t)^\ast}]`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the instruction type :math:`{t_2^\ast}~{\rightarrow}_{{x_2^\ast}}\,{t_3^\ast}`.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{\mathit{it}'}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{\mathit{it}}`.

   * The instruction type :math:`{\mathit{it}}` matches the instruction type :math:`{\mathit{it}'}`.

   * The instruction type :math:`{\mathit{it}'}` is valid.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{t^\ast}~{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t^\ast}~{t_2^\ast}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.

   * The result type :math:`{t^\ast}` is valid.




The expression :math:`{{\mathit{instr}}^\ast}` is valid with the result type :math:`{t^\ast}` if:


   * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`\epsilon~\rightarrow~{t^\ast}`.




The :ref:`value type <syntax-valtype>` :math:`t` is not defaultable if:


   * The value :math:`{{\mathrm{default}}}_{t}` is absent.




:math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is constant if:


   * Either:

      * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`({\mathit{nt}}{.}\mathsf{const}~c_{\mathit{nt}})`.

   * Or:

      * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`({\mathit{vt}}{.}\mathsf{const}~c_{\mathit{vt}})`.
   * Or:

      * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref{.}null}~{\mathit{ht}})`.
   * Or:

      * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{ref{.}i{\scriptstyle 31}}`.
   * Or:

      * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref{.}func}~x)`.
   * Or:

      * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{struct{.}new}~x)`.
   * Or:

      * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{struct{.}new\_default}~x)`.
   * Or:

      * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{array{.}new}~x)`.
   * Or:

      * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{array{.}new\_default}~x)`.
   * Or:

      * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{array{.}new\_fixed}~x~n)`.
   * Or:

      * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{any{.}convert\_extern}`.
   * Or:

      * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{extern{.}convert\_any}`.
   * Or:

      * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global{.}get}~x)`.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`(\epsilon~t)`.
   * Or:

      * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`({\mathsf{i}}{N} {.} {\mathit{binop}})`.

      * :math:`{\mathsf{i}}{N}` is contained in [:math:`\mathsf{i{\scriptstyle 32}}`; :math:`\mathsf{i{\scriptstyle 64}}`].

      * :math:`{\mathit{binop}}` is contained in [:math:`\mathsf{add}`; :math:`\mathsf{sub}`; :math:`\mathsf{mul}`].




:math:`({\mathit{nt}}{.}\mathsf{const}~c_{\mathit{nt}})` is constant.




:math:`({\mathit{vt}}{.}\mathsf{const}~c_{\mathit{vt}})` is constant.




:math:`(\mathsf{ref{.}null}~{\mathit{ht}})` is constant.




:math:`\mathsf{ref{.}i{\scriptstyle 31}}` is constant.




:math:`(\mathsf{ref{.}func}~x)` is constant.




:math:`(\mathsf{struct{.}new}~x)` is constant.




:math:`(\mathsf{struct{.}new\_default}~x)` is constant.




:math:`(\mathsf{array{.}new}~x)` is constant.




:math:`(\mathsf{array{.}new\_default}~x)` is constant.




:math:`(\mathsf{array{.}new\_fixed}~x~n)` is constant.




:math:`\mathsf{any{.}convert\_extern}` is constant.




:math:`\mathsf{extern{.}convert\_any}` is constant.




:math:`(\mathsf{global{.}get}~x)` is constant if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`(\epsilon~t)`.




:math:`({\mathsf{i}}{N} {.} {\mathit{binop}})` is constant if:


   * :math:`{\mathsf{i}}{N}` is contained in [:math:`\mathsf{i{\scriptstyle 32}}`; :math:`\mathsf{i{\scriptstyle 64}}`].

   * :math:`{\mathit{binop}}` is contained in [:math:`\mathsf{add}`; :math:`\mathsf{sub}`; :math:`\mathsf{mul}`].




:math:`{{\mathit{instr}}^\ast}` is constant if:


   * For all :math:`{\mathit{instr}}` in :math:`{{\mathit{instr}}^\ast}`:

      * :math:`{\mathit{instr}}` is constant.




The type definition :math:`(\mathsf{type}~{\mathit{rectype}})` is valid with the defined type sequence :math:`{{\mathit{dt}}^\ast}` if:


   * :math:`{|C{.}\mathsf{types}|}` is equal to :math:`x`.

   * The defined type sequence :math:`{{\mathit{dt}}^\ast}` is equal to :math:`{{{{\mathrm{roll}}}_{x}^\ast}}{({\mathit{rectype}})}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the defined type sequence :math:`{{\mathit{dt}}^\ast}` appended to the field :math:`\mathsf{types}`.

   * Under the context :math:`{C'}`, the recursive type :math:`{\mathit{rectype}}` is valid for :math:`({\mathsf{ok}}{(x)})`.




The local :math:`(\mathsf{local}~t)` is valid with the local type :math:`({\mathit{init}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}~t)` if:


   * Either:

      * The initialization status :math:`{\mathit{init}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{set}`.

      * A :ref:`default value <aux-default>` for the :ref:`value type <syntax-valtype>` :math:`t` is defined.

   * Or:

      * The initialization status :math:`{\mathit{init}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{unset}`.

      * A :ref:`default value <aux-default>` for the :ref:`value type <syntax-valtype>` :math:`t` is not defined.




The local :math:`(\mathsf{local}~t)` is valid with the local type :math:`(\mathsf{set}~t)` if:


   * A :ref:`default value <aux-default>` for the :ref:`value type <syntax-valtype>` :math:`t` is defined.




The local :math:`(\mathsf{local}~t)` is valid with the local type :math:`(\mathsf{unset}~t)` if:


   * A :ref:`default value <aux-default>` for the :ref:`value type <syntax-valtype>` :math:`t` is not defined.




The function :math:`(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}})` is valid with the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.

   * :math:`{|{{{\mathit{lt}}}^\ast}|}` is equal to :math:`{|{{\mathit{local}}^\ast}|}`.

   * For all :math:`{{\mathit{lt}}}` in :math:`{{{\mathit{lt}}}^\ast}` and :math:`{\mathit{local}}` in :math:`{{\mathit{local}}^\ast}`:

      * The local :math:`{\mathit{local}}` is valid with the local type :math:`{{\mathit{lt}}}`.

   * Under the context :math:`C{}[{.}\mathsf{locals} \mathrel{{=}{\oplus}} {(\mathsf{set}~t_1)^\ast}~{{{\mathit{lt}}}^\ast}]{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_2^\ast}]{}[{.}\mathsf{return} \mathrel{{=}{\oplus}} {t_2^\ast}]`, the expression :math:`{\mathit{expr}}` is valid with the result type :math:`{t_2^\ast}`.




The global :math:`(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}})` is valid with the global type :math:`{\mathit{globaltype}}` if:


   * The global type :math:`{\mathit{gt}}` is valid.

   * The global type :math:`{\mathit{globaltype}}` is equal to :math:`({\mathsf{mut}^?}~t)`.

   * The expression :math:`{\mathit{expr}}` is valid with the :ref:`value type <syntax-valtype>` :math:`t`.

   * :math:`{\mathit{expr}}` is constant.




The table :math:`(\mathsf{table}~{\mathit{tabletype}}~{\mathit{expr}})` is valid with the table type :math:`{\mathit{tabletype}}` if:


   * The table type :math:`{\mathit{tabletype}}` is valid.

   * The table type :math:`{\mathit{tabletype}}` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})`.

   * The expression :math:`{\mathit{expr}}` is valid with the :ref:`value type <syntax-valtype>` :math:`{\mathit{rt}}`.

   * :math:`{\mathit{expr}}` is constant.




The memory :math:`(\mathsf{memory}~{\mathit{memtype}})` is valid with the memory type :math:`{\mathit{memtype}}` if:


   * The memory type :math:`{\mathit{memtype}}` is valid.




The tag :math:`(\mathsf{tag}~x)` is valid with the tag type :math:`C{.}\mathsf{types}{}[x]` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{func}~{\mathit{functype}})`.




The element mode :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid with the element type :math:`{\mathit{rt}}` if:


   * Either:

      * The element mode :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{active}~x~{\mathit{expr}})`.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}'})`.

      * The reference type :math:`{\mathit{rt}}` matches the reference type :math:`{\mathit{rt}'}`.

      * The expression :math:`{\mathit{expr}}` is valid with the :ref:`value type <syntax-valtype>` :math:`\mathsf{i{\scriptstyle 32}}`.

      * :math:`{\mathit{expr}}` is constant.

   * Or:

      * The element mode :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{passive}`.
   * Or:

      * The element mode :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{declare}`.




The element mode :math:`(\mathsf{active}~x~{\mathit{expr}})` is valid with the element type :math:`{\mathit{rt}}` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}'})`.

   * The reference type :math:`{\mathit{rt}}` matches the reference type :math:`{\mathit{rt}'}`.

   * The expression :math:`{\mathit{expr}}` is valid with the :ref:`value type <syntax-valtype>` :math:`\mathsf{i{\scriptstyle 32}}`.

   * :math:`{\mathit{expr}}` is constant.




The element mode :math:`\mathsf{passive}` is valid with the element type :math:`{\mathit{rt}}`.




The element mode :math:`\mathsf{declare}` is valid with the element type :math:`{\mathit{rt}}`.




The element segment :math:`(\mathsf{elem}~{\mathit{elemtype}}~{{\mathit{expr}}^\ast}~{\mathit{elemmode}})` is valid with the element type :math:`{\mathit{elemtype}}` if:


   * The reference type :math:`{\mathit{elemtype}}` is valid.

   * For all :math:`{\mathit{expr}}` in :math:`{{\mathit{expr}}^\ast}`:

      * The expression :math:`{\mathit{expr}}` is valid with the :ref:`value type <syntax-valtype>` :math:`{\mathit{elemtype}}`.

      * :math:`{\mathit{expr}}` is constant.

   * The element mode :math:`{\mathit{elemmode}}` is valid with the element type :math:`{\mathit{elemtype}}`.




The data mode :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid with the data type :math:`\mathsf{ok}` if:


   * Either:

      * The data mode :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{active}~x~{\mathit{expr}})`.

      * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

      * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`{\mathit{mt}}`.

      * The expression :math:`{\mathit{expr}}` is valid with the :ref:`value type <syntax-valtype>` :math:`\mathsf{i{\scriptstyle 32}}`.

      * :math:`{\mathit{expr}}` is constant.

   * Or:

      * The data mode :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{passive}`.




The data mode :math:`(\mathsf{active}~x~{\mathit{expr}})` is valid with the data type :math:`\mathsf{ok}` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`{\mathit{mt}}`.

   * The expression :math:`{\mathit{expr}}` is valid with the :ref:`value type <syntax-valtype>` :math:`\mathsf{i{\scriptstyle 32}}`.

   * :math:`{\mathit{expr}}` is constant.




The data mode :math:`\mathsf{passive}` is valid with the data type :math:`\mathsf{ok}`.




The data segment :math:`(\mathsf{data}~{b^\ast}~{\mathit{datamode}})` is valid with the data type :math:`\mathsf{ok}` if:


   * The data mode :math:`{\mathit{datamode}}` is valid with the data type :math:`\mathsf{ok}`.




The start function :math:`(\mathsf{start}~x)` is valid if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The :ref:`expansion <aux-expand-deftype>` of the :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{funcs}{}[x]` is the composite type :math:`(\mathsf{func}~\epsilon~\rightarrow~\epsilon)`.




The import :math:`(\mathsf{import}~{\mathit{name}}_1~{\mathit{name}}_2~{\mathit{xt}})` is valid with the external type :math:`{\mathit{xt}}` if:


   * The external type :math:`{\mathit{xt}}` is valid.




The external index :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid with the external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


   * Either:

      * The external index :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~x)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{dt}})`.

      * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{funcs}{}[x]` exists.

      * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{\mathit{dt}}`.

   * Or:

      * The external index :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~x)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~{\mathit{gt}})`.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`{\mathit{gt}}`.
   * Or:

      * The external index :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~x)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~{\mathit{tt}})`.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

      * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`{\mathit{tt}}`.
   * Or:

      * The external index :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~x)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~{\mathit{mt}})`.

      * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

      * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`{\mathit{mt}}`.
   * Or:

      * The external index :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{tag}~x)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{tag}~{\mathit{jt}})`.

      * The tag type :math:`C{.}\mathsf{tags}{}[x]` exists.

      * The tag type :math:`C{.}\mathsf{tags}{}[x]` is equal to :math:`{\mathit{jt}}`.




The external index :math:`(\mathsf{func}~x)` is valid with the external type :math:`(\mathsf{func}~{\mathit{dt}})` if:


   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{funcs}{}[x]` exists.

   * The :ref:`defined type <syntax-deftype>` :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{\mathit{dt}}`.




The external index :math:`(\mathsf{global}~x)` is valid with the external type :math:`(\mathsf{global}~{\mathit{gt}})` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`{\mathit{gt}}`.




The external index :math:`(\mathsf{table}~x)` is valid with the external type :math:`(\mathsf{table}~{\mathit{tt}})` if:


   * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

   * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`{\mathit{tt}}`.




The external index :math:`(\mathsf{mem}~x)` is valid with the external type :math:`(\mathsf{mem}~{\mathit{mt}})` if:


   * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

   * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`{\mathit{mt}}`.




The external index :math:`(\mathsf{tag}~x)` is valid with the external type :math:`(\mathsf{tag}~{\mathit{jt}})` if:


   * The tag type :math:`C{.}\mathsf{tags}{}[x]` exists.

   * The tag type :math:`C{.}\mathsf{tags}{}[x]` is equal to :math:`{\mathit{jt}}`.




The export :math:`(\mathsf{export}~{\mathit{name}}~{\mathit{externidx}})` is valid with the name :math:`{\mathit{name}}` and the external type :math:`{\mathit{xt}}` if:


   * The external index :math:`{\mathit{externidx}}` is valid with the external type :math:`{\mathit{xt}}`.




The global sequence :math:`{{\mathit{global}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is valid with the global type sequence :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` if:


   * Either:

      * The global sequence :math:`{{\mathit{global}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

      * The global type sequence :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

   * Or:

      * The global sequence :math:`{{\mathit{global}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{\mathit{global}}_1~{{\mathit{global}}^\ast}`.

      * The global type sequence :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{\mathit{gt}}_1~{{\mathit{gt}}^\ast}`.

      * The global :math:`{\mathit{global}}_1` is valid with the global type :math:`{\mathit{gt}}_1`.

      * Let :math:`{C'}` be the same context as :math:`C`, but with the global type sequence :math:`{\mathit{gt}}_1` appended to the field :math:`\mathsf{globals}`.

      * Under the context :math:`{C'}`, the global sequence :math:`{{\mathit{global}}^\ast}` is valid with the global type sequence :math:`{{\mathit{gt}}^\ast}`.




The global sequence :math:`\epsilon` is valid with the global type sequence :math:`\epsilon`.




The global sequence :math:`{\mathit{global}}_1~{{\mathit{global}}^\ast}` is valid with the global type sequence :math:`{\mathit{gt}}_1~{{\mathit{gt}}^\ast}` if:


   * The global :math:`{\mathit{global}}_1` is valid with the global type :math:`{\mathit{gt}}_1`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the global type sequence :math:`{\mathit{gt}}_1` appended to the field :math:`\mathsf{globals}`.

   * Under the context :math:`{C'}`, the global sequence :math:`{{\mathit{global}}^\ast}` is valid with the global type sequence :math:`{{\mathit{gt}}^\ast}`.




The type definition sequence :math:`{{\mathit{type}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is valid with the defined type sequence :math:`{{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` if:


   * Either:

      * The type definition sequence :math:`{{\mathit{type}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

      * The defined type sequence :math:`{{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

   * Or:

      * The type definition sequence :math:`{{\mathit{type}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{\mathit{type}}_1~{{\mathit{type}}^\ast}`.

      * The defined type sequence :math:`{{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{{\mathit{dt}}_1^\ast}~{{\mathit{dt}}^\ast}`.

      * The type definition :math:`{\mathit{type}}_1` is valid with the defined type sequence :math:`{{\mathit{dt}}_1^\ast}`.

      * Let :math:`{C'}` be the same context as :math:`C`, but with the defined type sequence :math:`{{\mathit{dt}}_1^\ast}` appended to the field :math:`\mathsf{types}`.

      * Under the context :math:`{C'}`, the type definition sequence :math:`{{\mathit{type}}^\ast}` is valid with the defined type sequence :math:`{{\mathit{dt}}^\ast}`.




The type definition sequence :math:`\epsilon` is valid with the defined type sequence :math:`\epsilon`.




The type definition sequence :math:`{\mathit{type}}_1~{{\mathit{type}}^\ast}` is valid with the defined type sequence :math:`{{\mathit{dt}}_1^\ast}~{{\mathit{dt}}^\ast}` if:


   * The type definition :math:`{\mathit{type}}_1` is valid with the defined type sequence :math:`{{\mathit{dt}}_1^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the defined type sequence :math:`{{\mathit{dt}}_1^\ast}` appended to the field :math:`\mathsf{types}`.

   * Under the context :math:`{C'}`, the type definition sequence :math:`{{\mathit{type}}^\ast}` is valid with the defined type sequence :math:`{{\mathit{dt}}^\ast}`.




The module :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{tag}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` is valid with the module type :math:`t` if:


   * Under the context :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{return}~\epsilon \}\end{array}`, the type definition sequence :math:`{{\mathit{type}}^\ast}` is valid with the defined type sequence :math:`{{\mathit{dt}'}^\ast}`.

   * :math:`{|{{\mathit{import}}^\ast}|}` is equal to :math:`{|{{\mathit{xt}}_{\mathsf{i}}^\ast}|}`.

   * For all :math:`{\mathit{import}}` in :math:`{{\mathit{import}}^\ast}` and :math:`{\mathit{xt}}_{\mathsf{i}}` in :math:`{{\mathit{xt}}_{\mathsf{i}}^\ast}`:

      * Under the context :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{dt}'}^\ast},\; \mathsf{return}~\epsilon \}\end{array}`, the import :math:`{\mathit{import}}` is valid with the external type :math:`{\mathit{xt}}_{\mathsf{i}}`.

   * Under the context :math:`{C'}`, the global sequence :math:`{{\mathit{global}}^\ast}` is valid with the global type sequence :math:`{{\mathit{gt}}^\ast}`.

   * :math:`{|{{\mathit{table}}^\ast}|}` is equal to :math:`{|{{\mathit{tt}}^\ast}|}`.

   * For all :math:`{\mathit{table}}` in :math:`{{\mathit{table}}^\ast}` and :math:`{\mathit{tt}}` in :math:`{{\mathit{tt}}^\ast}`:

      * Under the context :math:`{C'}`, the table :math:`{\mathit{table}}` is valid with the table type :math:`{\mathit{tt}}`.

   * :math:`{|{{\mathit{mem}}^\ast}|}` is equal to :math:`{|{{\mathit{mt}}^\ast}|}`.

   * For all :math:`{\mathit{mem}}` in :math:`{{\mathit{mem}}^\ast}` and :math:`{\mathit{mt}}` in :math:`{{\mathit{mt}}^\ast}`:

      * Under the context :math:`{C'}`, the memory :math:`{\mathit{mem}}` is valid with the memory type :math:`{\mathit{mt}}`.

   * :math:`{|{{\mathit{jt}}^\ast}|}` is equal to :math:`{|{{\mathit{tag}}^\ast}|}`.

   * For all :math:`{\mathit{jt}}` in :math:`{{\mathit{jt}}^\ast}` and :math:`{\mathit{tag}}` in :math:`{{\mathit{tag}}^\ast}`:

      * Under the context :math:`{C'}`, the tag :math:`{\mathit{tag}}` is valid with the tag type :math:`{\mathit{jt}}`.

   * :math:`{|{{\mathit{dt}}^\ast}|}` is equal to :math:`{|{{\mathit{func}}^\ast}|}`.

   * For all :math:`{\mathit{dt}}` in :math:`{{\mathit{dt}}^\ast}` and :math:`{\mathit{func}}` in :math:`{{\mathit{func}}^\ast}`:

      * The function :math:`{\mathit{func}}` is valid with the :ref:`defined type <syntax-deftype>` :math:`{\mathit{dt}}`.

   * :math:`{|{{\mathit{elem}}^\ast}|}` is equal to :math:`{|{{\mathit{rt}}^\ast}|}`.

   * For all :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}` and :math:`{\mathit{rt}}` in :math:`{{\mathit{rt}}^\ast}`:

      * The element segment :math:`{\mathit{elem}}` is valid with the element type :math:`{\mathit{rt}}`.

   * :math:`{|{{\mathit{data}}^\ast}|}` is equal to :math:`{|{{\mathit{ok}}^\ast}|}`.

   * For all :math:`{\mathit{data}}` in :math:`{{\mathit{data}}^\ast}` and :math:`{\mathit{ok}}` in :math:`{{\mathit{ok}}^\ast}`:

      * The data segment :math:`{\mathit{data}}` is valid.

   * If :math:`{\mathit{start}}` is defined, then:

      * The start function :math:`{\mathit{start}}` is valid.

   * :math:`{|{{\mathit{export}}^\ast}|}` is equal to :math:`{|{{\mathit{nm}}^\ast}|}`.

   * :math:`{|{{\mathit{export}}^\ast}|}` is equal to :math:`{|{{\mathit{xt}}_{\mathsf{e}}^\ast}|}`.

   * For all :math:`{\mathit{export}}` in :math:`{{\mathit{export}}^\ast}` and :math:`{\mathit{nm}}` in :math:`{{\mathit{nm}}^\ast}` and :math:`{\mathit{xt}}_{\mathsf{e}}` in :math:`{{\mathit{xt}}_{\mathsf{e}}^\ast}`:

      * The export :math:`{\mathit{export}}` is valid with the name :math:`{\mathit{nm}}` and the external type :math:`{\mathit{xt}}_{\mathsf{e}}`.

   * :math:`{{\mathit{nm}}^\ast}~{\mathrm{disjoint}}` is equal to true.

   * The context :math:`C` is equal to :math:`{C'}{}[{.}\mathsf{globals} \mathrel{{=}{\oplus}} {{\mathit{gt}}^\ast}]{}[{.}\mathsf{tables} \mathrel{{=}{\oplus}} {{\mathit{tt}}_{\mathsf{i}}^\ast}~{{\mathit{tt}}^\ast}]{}[{.}\mathsf{mems} \mathrel{{=}{\oplus}} {{\mathit{mt}}_{\mathsf{i}}^\ast}~{{\mathit{mt}}^\ast}]{}[{.}\mathsf{tags} \mathrel{{=}{\oplus}} {{\mathit{jt}}_{\mathsf{i}}^\ast}~{{\mathit{jt}}^\ast}]{}[{.}\mathsf{elems} \mathrel{{=}{\oplus}} {{\mathit{rt}}^\ast}]{}[{.}\mathsf{datas} \mathrel{{=}{\oplus}} {{\mathit{ok}}^\ast}]`.

   * The context :math:`{C'}` is equal to :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{dt}'}^\ast},\; \mathsf{funcs}~{{\mathit{dt}}_{\mathsf{i}}^\ast}~{{\mathit{dt}}^\ast},\; \mathsf{globals}~{{\mathit{gt}}_{\mathsf{i}}^\ast},\; \mathsf{return}~\epsilon,\; \mathsf{refs}~{x^\ast} \}\end{array}`.

   * The function index sequence :math:`{x^\ast}` is equal to :math:`{\mathrm{funcidx}}({{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast})`.

   * The defined type sequence :math:`{{\mathit{dt}}_{\mathsf{i}}^\ast}` is equal to :math:`{\mathrm{funcs}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

   * The global type sequence :math:`{{\mathit{gt}}_{\mathsf{i}}^\ast}` is equal to :math:`{\mathrm{globals}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

   * The table type sequence :math:`{{\mathit{tt}}_{\mathsf{i}}^\ast}` is equal to :math:`{\mathrm{tables}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

   * The memory type sequence :math:`{{\mathit{mt}}_{\mathsf{i}}^\ast}` is equal to :math:`{\mathrm{mems}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

   * The tag type sequence :math:`{{\mathit{jt}}_{\mathsf{i}}^\ast}` is equal to :math:`{\mathrm{tags}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

   * Let :math:`t` be the module type :math:`{{\mathrm{clos}}}_{C}({{\mathit{xt}}_{\mathsf{i}}^\ast}~\rightarrow~{{\mathit{xt}}_{\mathsf{e}}^\ast})`.




The number value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` is valid with the :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}`.




The vector value :math:`({\mathit{vt}}{.}\mathsf{const}~c)` is valid with the :ref:`vector type <syntax-vectype>` :math:`{\mathit{vt}}`.




The reference value :math:`r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid with the reference type :math:`{\mathit{rt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


   * Either:

      * The reference value :math:`r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref{.}null}~{\mathit{ht}})`.

      * The reference type :math:`{\mathit{rt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref}~\mathsf{null}~{\mathit{ht}'})`.

      * The heap type :math:`{\mathit{ht}'}` matches the heap type :math:`{\mathit{ht}}`.

   * Or:

      * The reference value :math:`r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref{.}i{\scriptstyle 31}}~i)`.

      * The reference type :math:`{\mathit{rt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref}~\epsilon~\mathsf{i{\scriptstyle 31}})`.
   * Or:

      * The reference value :math:`r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref{.}struct}~a)`.

      * The reference type :math:`{\mathit{rt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref}~\epsilon~{\mathit{dt}})`.

      * The structure instance :math:`s{.}\mathsf{structs}{}[a]` exists.

      * The :ref:`defined type <syntax-deftype>` :math:`s{.}\mathsf{structs}{}[a]{.}\mathsf{type}` is equal to :math:`{\mathit{dt}}`.
   * Or:

      * The reference value :math:`r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref{.}array}~a)`.

      * The reference type :math:`{\mathit{rt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref}~\epsilon~{\mathit{dt}})`.

      * The array instance :math:`s{.}\mathsf{arrays}{}[a]` exists.

      * The :ref:`defined type <syntax-deftype>` :math:`s{.}\mathsf{arrays}{}[a]{.}\mathsf{type}` is equal to :math:`{\mathit{dt}}`.
   * Or:

      * The reference value :math:`r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref{.}func}~a)`.

      * The reference type :math:`{\mathit{rt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref}~\epsilon~{\mathit{dt}})`.

      * The function instance :math:`s{.}\mathsf{funcs}{}[a]` exists.

      * The :ref:`defined type <syntax-deftype>` :math:`s{.}\mathsf{funcs}{}[a]{.}\mathsf{type}` is equal to :math:`{\mathit{dt}}`.
   * Or:

      * The reference value :math:`r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref{.}exn}~a)`.

      * The reference type :math:`{\mathit{rt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref}~\epsilon~\mathsf{exn})`.
   * Or:

      * The reference value :math:`r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref{.}host}~a)`.

      * The reference type :math:`{\mathit{rt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref}~\epsilon~\mathsf{any})`.
   * Or:

      * The reference value :math:`r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref{.}extern}~{\mathit{addrref}})`.

      * The reference type :math:`{\mathit{rt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref}~\epsilon~\mathsf{extern})`.
   * Or:

      * The reference value :math:`r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{ref}}`.

      * The reference type :math:`{\mathit{rt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{rt}}`.

      * Under the context :math:`s`, the reference value :math:`{\mathit{ref}}` is valid with the reference type :math:`{\mathit{rt}'}`.

      * The reference type :math:`{\mathit{rt}'}` matches the reference type :math:`{\mathit{rt}}`.




The reference value :math:`(\mathsf{ref{.}null}~{\mathit{ht}})` is valid with the reference type :math:`(\mathsf{ref}~\mathsf{null}~{\mathit{ht}'})` if:


   * The heap type :math:`{\mathit{ht}'}` matches the heap type :math:`{\mathit{ht}}`.




The reference value :math:`(\mathsf{ref{.}i{\scriptstyle 31}}~i)` is valid with the reference type :math:`(\mathsf{ref}~\epsilon~\mathsf{i{\scriptstyle 31}})`.




The reference value :math:`(\mathsf{ref{.}struct}~a)` is valid with the reference type :math:`(\mathsf{ref}~\epsilon~{\mathit{dt}})` if:


   * The structure instance :math:`s{.}\mathsf{structs}{}[a]` exists.

   * The :ref:`defined type <syntax-deftype>` :math:`s{.}\mathsf{structs}{}[a]{.}\mathsf{type}` is equal to :math:`{\mathit{dt}}`.




The reference value :math:`(\mathsf{ref{.}array}~a)` is valid with the reference type :math:`(\mathsf{ref}~\epsilon~{\mathit{dt}})` if:


   * The array instance :math:`s{.}\mathsf{arrays}{}[a]` exists.

   * The :ref:`defined type <syntax-deftype>` :math:`s{.}\mathsf{arrays}{}[a]{.}\mathsf{type}` is equal to :math:`{\mathit{dt}}`.




The reference value :math:`(\mathsf{ref{.}func}~a)` is valid with the reference type :math:`(\mathsf{ref}~\epsilon~{\mathit{dt}})` if:


   * The function instance :math:`s{.}\mathsf{funcs}{}[a]` exists.

   * The :ref:`defined type <syntax-deftype>` :math:`s{.}\mathsf{funcs}{}[a]{.}\mathsf{type}` is equal to :math:`{\mathit{dt}}`.




The reference value :math:`(\mathsf{ref{.}exn}~a)` is valid with the reference type :math:`(\mathsf{ref}~\epsilon~\mathsf{exn})`.




The reference value :math:`(\mathsf{ref{.}host}~a)` is valid with the reference type :math:`(\mathsf{ref}~\epsilon~\mathsf{any})`.




The reference value :math:`(\mathsf{ref{.}extern}~{\mathit{addrref}})` is valid with the reference type :math:`(\mathsf{ref}~\epsilon~\mathsf{extern})`.




The reference value :math:`{\mathit{ref}}` is valid with the reference type :math:`{\mathit{rt}}` if:


   * Under the context :math:`s`, the reference value :math:`{\mathit{ref}}` is valid with the reference type :math:`{\mathit{rt}'}`.

   * The reference type :math:`{\mathit{rt}'}` matches the reference type :math:`{\mathit{rt}}`.




The value :math:`v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid with the :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


   * Either:

      * The value :math:`v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{num}}`.

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{nt}}`.

      * Under the context :math:`s`, the number value :math:`{\mathit{num}}` is valid with the :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}`.

   * Or:

      * The value :math:`v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{vec}}`.

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{vt}}`.

      * Under the context :math:`s`, the vector value :math:`{\mathit{vec}}` is valid with the :ref:`vector type <syntax-vectype>` :math:`{\mathit{vt}}`.
   * Or:

      * The value :math:`v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{ref}}`.

      * The :ref:`value type <syntax-valtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{rt}}`.

      * Under the context :math:`s`, the reference value :math:`{\mathit{ref}}` is valid with the reference type :math:`{\mathit{rt}}`.




The value :math:`{\mathit{num}}` is valid with the :ref:`value type <syntax-valtype>` :math:`{\mathit{nt}}` if:


   * Under the context :math:`s`, the number value :math:`{\mathit{num}}` is valid with the :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}`.




The value :math:`{\mathit{vec}}` is valid with the :ref:`value type <syntax-valtype>` :math:`{\mathit{vt}}` if:


   * Under the context :math:`s`, the vector value :math:`{\mathit{vec}}` is valid with the :ref:`vector type <syntax-vectype>` :math:`{\mathit{vt}}`.




The value :math:`{\mathit{ref}}` is valid with the :ref:`value type <syntax-valtype>` :math:`{\mathit{rt}}` if:


   * Under the context :math:`s`, the reference value :math:`{\mathit{ref}}` is valid with the reference type :math:`{\mathit{rt}}`.




The external address :math:`{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid with the external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


   * Either:

      * The external address :math:`{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~a)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{funcinst}}{.}\mathsf{type})`.

      * The function instance :math:`s{.}\mathsf{funcs}{}[a]` exists.

      * The function instance :math:`s{.}\mathsf{funcs}{}[a]` is equal to :math:`{\mathit{funcinst}}`.

   * Or:

      * The external address :math:`{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~a)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~{\mathit{globalinst}}{.}\mathsf{type})`.

      * The global instance :math:`s{.}\mathsf{globals}{}[a]` exists.

      * The global instance :math:`s{.}\mathsf{globals}{}[a]` is equal to :math:`{\mathit{globalinst}}`.
   * Or:

      * The external address :math:`{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~a)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~{\mathit{tableinst}}{.}\mathsf{type})`.

      * The table instance :math:`s{.}\mathsf{tables}{}[a]` exists.

      * The table instance :math:`s{.}\mathsf{tables}{}[a]` is equal to :math:`{\mathit{tableinst}}`.
   * Or:

      * The external address :math:`{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~a)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~{\mathit{meminst}}{.}\mathsf{type})`.

      * The memory instance :math:`s{.}\mathsf{mems}{}[a]` exists.

      * The memory instance :math:`s{.}\mathsf{mems}{}[a]` is equal to :math:`{\mathit{meminst}}`.
   * Or:

      * The external address :math:`{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{tag}~a)`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{tag}~{\mathit{taginst}}{.}\mathsf{type})`.

      * The tag instance :math:`s{.}\mathsf{tags}{}[a]` exists.

      * The tag instance :math:`s{.}\mathsf{tags}{}[a]` is equal to :math:`{\mathit{taginst}}`.
   * Or:

      * The external address :math:`{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{externaddr}}`.

      * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{xt}}`.

      * Under the context :math:`s`, the external address :math:`{\mathit{externaddr}}` is valid with the external type :math:`{\mathit{xt}'}`.

      * The external type :math:`{\mathit{xt}'}` matches the external type :math:`{\mathit{xt}}`.




The external address :math:`(\mathsf{func}~a)` is valid with the external type :math:`(\mathsf{func}~{\mathit{funcinst}}{.}\mathsf{type})` if:


   * The function instance :math:`s{.}\mathsf{funcs}{}[a]` exists.

   * The function instance :math:`s{.}\mathsf{funcs}{}[a]` is equal to :math:`{\mathit{funcinst}}`.




The external address :math:`(\mathsf{global}~a)` is valid with the external type :math:`(\mathsf{global}~{\mathit{globalinst}}{.}\mathsf{type})` if:


   * The global instance :math:`s{.}\mathsf{globals}{}[a]` exists.

   * The global instance :math:`s{.}\mathsf{globals}{}[a]` is equal to :math:`{\mathit{globalinst}}`.




The external address :math:`(\mathsf{table}~a)` is valid with the external type :math:`(\mathsf{table}~{\mathit{tableinst}}{.}\mathsf{type})` if:


   * The table instance :math:`s{.}\mathsf{tables}{}[a]` exists.

   * The table instance :math:`s{.}\mathsf{tables}{}[a]` is equal to :math:`{\mathit{tableinst}}`.




The external address :math:`(\mathsf{mem}~a)` is valid with the external type :math:`(\mathsf{mem}~{\mathit{meminst}}{.}\mathsf{type})` if:


   * The memory instance :math:`s{.}\mathsf{mems}{}[a]` exists.

   * The memory instance :math:`s{.}\mathsf{mems}{}[a]` is equal to :math:`{\mathit{meminst}}`.




The external address :math:`(\mathsf{tag}~a)` is valid with the external type :math:`(\mathsf{tag}~{\mathit{taginst}}{.}\mathsf{type})` if:


   * The tag instance :math:`s{.}\mathsf{tags}{}[a]` exists.

   * The tag instance :math:`s{.}\mathsf{tags}{}[a]` is equal to :math:`{\mathit{taginst}}`.




The external address :math:`{\mathit{externaddr}}` is valid with the external type :math:`{\mathit{xt}}` if:


   * Under the context :math:`s`, the external address :math:`{\mathit{externaddr}}` is valid with the external type :math:`{\mathit{xt}'}`.

   * The external type :math:`{\mathit{xt}'}` matches the external type :math:`{\mathit{xt}}`.




The instruction sequence :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid with the function type :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}~\rightarrow~{t_{\mathit{u{\kern-0.1em\scriptstyle 3}}}^\ast}` if:


   * Either:

      * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{i{\scriptstyle 32}} {.} \mathsf{add})`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 3}}}^\ast}` is equal to :math:`\mathsf{i{\scriptstyle 32}}`.

   * Or:

      * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global{.}get}~x)`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 3}}}^\ast}` is equal to :math:`t`.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

      * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`({\mathsf{mut}^?}~t)`.
   * Or:

      * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{block}~{\mathit{blocktype}}~{{\mathit{instr}}^\ast})`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{t_1^\ast}`.

      * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 3}}}^\ast}` is equal to :math:`{t_2^\ast}`.

      * The block type :math:`{\mathit{blocktype}}` is valid as the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

      * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

      * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction sequence :math:`(\mathsf{i{\scriptstyle 32}} {.} \mathsf{add})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction sequence :math:`(\mathsf{global{.}get}~x)` is valid with the function type :math:`\epsilon~\rightarrow~t` if:


   * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

   * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`({\mathsf{mut}^?}~t)`.




The instruction sequence :math:`(\mathsf{block}~{\mathit{blocktype}}~{{\mathit{instr}}^\ast})` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


   * The block type :math:`{\mathit{blocktype}}` is valid as the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

   * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

   * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.


:math:`\mathsf{unreachable}`
............................


1. Trap.


:math:`\mathsf{nop}`
....................


1. Do nothing.


:math:`\mathsf{drop}`
.....................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Do nothing.


:math:`\mathsf{select}~{({t^\ast})^?}`
......................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_2` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_1` from the stack.

#. If :math:`c \neq 0`, then:

   a. Push the value :math:`{\mathit{val}}_1` to the stack.

#. Else:

   a. Push the value :math:`{\mathit{val}}_2` to the stack.


:math:`\mathsf{if}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast}~{{\mathit{instr}}_2^\ast}`
.....................................................................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

   a. Execute the instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast})`.

#. Else:

   a. Execute the instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}_2^\ast})`.


:math:`\mathsf{label}`
......................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

#. Pop the current :math:`\mathsf{label}` context from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.


:math:`\mathsf{br}~l`
.....................


1. If the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

   a. Let :math:`({{\mathsf{label}}_{n}}{\{}~{{\mathit{instr}'}^\ast}~\})` be the current :math:`\mathsf{label}` context.

   #. If :math:`l = 0`, then:

      1) Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

      #) Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

      #) Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

      #) Pop the current :math:`\mathsf{label}` context from the stack.

      #) Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

      #) Execute the instruction :math:`{{\mathit{instr}'}^\ast}`.

   #. Else:

      1) Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

      #) If :math:`l > 0`, then:

         a) Pop the current :math:`\mathsf{label}` context from the stack.

         #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

         #) Execute the instruction :math:`(\mathsf{br}~l - 1)`.

#. Else if the first non-value entry of the stack is a :math:`\mathsf{handler}`, then:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Pop the current :math:`\mathsf{handler}` context from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{br\_if}~l`
.........................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

   a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

   a. Do nothing.


:math:`\mathsf{br\_table}~{l^\ast}~{l'}`
........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i < {|{l^\ast}|}`, then:

   a. Execute the instruction :math:`(\mathsf{br}~{l^\ast}{}[i])`.

#. Else:

   a. Execute the instruction :math:`(\mathsf{br}~{l'})`.


:math:`\mathsf{br\_on\_null}~l`
...............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is :math:`\mathsf{ref{.}null}`, then:

   a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

   a. Push the value :math:`{\mathit{val}}` to the stack.


:math:`\mathsf{br\_on\_non\_null}~l`
....................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is :math:`\mathsf{ref{.}null}`, then:

   a. Do nothing.

#. Else:

   a. Push the value :math:`{\mathit{val}}` to the stack.

   #. Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{call\_indirect}~x~y`
...................................


1. Execute the instruction :math:`(\mathsf{table{.}get}~x)`.

#. Execute the instruction :math:`(\mathsf{ref{.}cast}~(\mathsf{ref}~\mathsf{null}~y))`.

#. Execute the instruction :math:`(\mathsf{call\_ref}~y)`.


:math:`\mathsf{return\_call\_indirect}~x~y`
...........................................


1. Execute the instruction :math:`(\mathsf{table{.}get}~x)`.

#. Execute the instruction :math:`(\mathsf{ref{.}cast}~(\mathsf{ref}~\mathsf{null}~y))`.

#. Execute the instruction :math:`(\mathsf{return\_call\_ref}~y)`.


:math:`\mathsf{frame}`
......................


1. Let :math:`({{\mathsf{frame}}_{n}}{\{}~f~\})` be the current :math:`\mathsf{frame}` context.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{frame}`.

#. Pop the current :math:`\mathsf{frame}` context from the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.


:math:`\mathsf{return}`
.......................


1. If the first non-value entry of the stack is a :math:`\mathsf{frame}`, then:

   a. Let :math:`({{\mathsf{frame}}_{n}}{\{}~f~\})` be the current :math:`\mathsf{frame}` context.

   #. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

   #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

   #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

   #. Pop the current :math:`\mathsf{frame}` context from the stack.

   #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Else if the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Pop the current :math:`\mathsf{label}` context from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`\mathsf{return}`.

#. Else:

   a. If the first non-value entry of the stack is a :math:`\mathsf{handler}`, then:

      1) Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

      #) Pop the current :math:`\mathsf{handler}` context from the stack.

      #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

      #) Execute the instruction :math:`\mathsf{return}`.


:math:`\mathsf{handler}`
........................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{handler}`.

#. Pop the current :math:`\mathsf{handler}` context from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{unop}}`
.........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{unop}}}{{}_{{\mathit{nt}}}(c_1)}|} \leq 0`, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{unop}}}{{}_{{\mathit{nt}}}(c_1)}`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{binop}}`
..........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{numtype}}_0` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{binop}}}{{}_{{\mathit{nt}}}(c_1, c_2)}|} \leq 0`, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{binop}}}{{}_{{\mathit{nt}}}(c_1, c_2)}`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{testop}}`
...........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{testop}}}{{}_{{\mathit{nt}}}(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{relop}}`
..........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{numtype}}_0` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{relop}}}{{}_{{\mathit{nt}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}}_2 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_1}`
............................................................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}_1` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{cvtop}}}{{}_{{\mathit{nt}}_1, {\mathit{nt}}_2}(c_1)}|} \leq 0`, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{cvtop}}}{{}_{{\mathit{nt}}_1, {\mathit{nt}}_2}(c_1)}`.

#. Push the value :math:`({\mathit{nt}}_2{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{ref{.}i{\scriptstyle 31}}`
.........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Push the value :math:`(\mathsf{ref{.}i{\scriptstyle 31}}~{{\mathrm{wrap}}}_{32, 31}(i))` to the stack.


:math:`\mathsf{ref{.}is\_null}`
...............................


1. Assert: Due to validation, a :ref:`reference value <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. If :math:`{\mathit{ref}}` is :math:`\mathsf{ref{.}null}`, then:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`\mathsf{ref{.}as\_non\_null}`
....................................


1. Assert: Due to validation, a :ref:`reference value <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. If :math:`{\mathit{ref}}` is :math:`\mathsf{ref{.}null}`, then:

   a. Trap.

#. Push the value :math:`{\mathit{ref}}` to the stack.


:math:`\mathsf{ref{.}eq}`
.........................


1. Assert: Due to validation, a :ref:`reference value <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}_2` from the stack.

#. Assert: Due to validation, a :ref:`reference value <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}_1` from the stack.

#. If :math:`{\mathit{ref}}_1` is :math:`\mathsf{ref{.}null}`, then:

   a. If :math:`{\mathit{ref}}_2` is :math:`\mathsf{ref{.}null}`, then:

      1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

   #. Else if :math:`{\mathit{ref}}_1 = {\mathit{ref}}_2`, then:

      1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

   #. Else:

      1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.

#. Else if :math:`{\mathit{ref}}_1 = {\mathit{ref}}_2`, then:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`{\mathsf{i{\scriptstyle 31}{.}get}}{\mathsf{\_}}{{\mathit{sx}}}`
.......................................................................


1. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}null}`, then:

   a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}i{\scriptstyle 31}}`, then:

   a. Let :math:`(\mathsf{ref{.}i{\scriptstyle 31}}~i)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{31, 32}^{{\mathit{sx}}}}}{(i)})` to the stack.


:math:`\mathsf{array{.}new}~x`
..............................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)`.


:math:`\mathsf{extern{.}convert\_any}`
......................................


1. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}null}`, then:

   a. Push the value :math:`(\mathsf{ref{.}null}~\mathsf{extern})` to the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is address value, then:

   a. Let :math:`{\mathit{addrref}}` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Push the value :math:`(\mathsf{ref{.}extern}~{\mathit{addrref}})` to the stack.


:math:`\mathsf{any{.}convert\_extern}`
......................................


1. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}null}`, then:

   a. Push the value :math:`(\mathsf{ref{.}null}~\mathsf{any})` to the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}extern}`, then:

   a. Let :math:`(\mathsf{ref{.}extern}~{\mathit{addrref}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Push the value :math:`{\mathit{addrref}}` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvunop}}`
..........................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{|{{\mathit{vvunop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1)}|} > 0`.

#. Let :math:`c` be an element of :math:`{{\mathit{vvunop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvbinop}}`
...........................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{|{{\mathit{vvbinop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2)}|} > 0`.

#. Let :math:`c` be an element of :math:`{{\mathit{vvbinop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvternop}}`
............................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_3)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{|{{\mathit{vvternop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2, c_3)}|} > 0`.

#. Let :math:`c` be an element of :math:`{{\mathit{vvternop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2, c_3)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} \mathsf{any\_true}`
...........................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{ine}}}_{{|\mathsf{v{\scriptstyle 128}}|}}(c_1, 0)`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vunop}}`
..........................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{vunop}}}{{}_{{\mathit{sh}}}(c_1)}|} \leq 0`, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vunop}}}{{}_{{\mathit{sh}}}(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vbinop}}`
...........................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{vbinop}}}{{}_{{\mathit{sh}}}(c_1, c_2)}|} \leq 0`, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vbinop}}}{{}_{{\mathit{sh}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vternop}}`
............................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_3)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{vternop}}}{{}_{{\mathit{sh}}}(c_1, c_2, c_3)}|} \leq 0`, then:

   a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vternop}}}{{}_{{\mathit{sh}}}(c_1, c_2, c_3)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vtestop}}`
............................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`i` be :math:`{{\mathit{vtestop}}}{{}_{{\mathit{sh}}}(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vrelop}}`
...........................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vrelop}}}{{}_{{\mathit{sh}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vshiftop}}`
.............................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vshiftop}}}{{}_{{\mathit{sh}}}}{(c_1, i)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}{.}\mathsf{bitmask}`
........................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{\mathsf{vbitmask}}{{}_{{\mathit{sh}}}(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vswizzlop}}`
..............................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vswizzlop}}}{{}_{{\mathit{sh}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}{.}\mathsf{shuffle}~{i^\ast}`
.................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{\mathsf{vshuffle}}{{}_{{\mathit{sh}}}({i^\ast}, c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{N}}{\mathsf{x}}{M}{.}\mathsf{splat}`
.........................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0 = {\mathrm{unpack}}({\mathsf{i}}{N})`.

#. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({{{\mathrm{pack}}}_{{\mathsf{i}}{N}}(c_1)^{M}})}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}{.}\mathsf{extract\_lane}}{\mathsf{\_}}{{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~i`
...................................................................................................................................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined and :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

   a. Let :math:`{\mathit{nt}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`i < {|{{\mathrm{lanes}}}_{{{\mathit{nt}}}{\mathsf{x}}{M}}(c_1)|}`, then:

      1) Let :math:`c_2` be :math:`{{\mathrm{lanes}}}_{{{\mathit{nt}}}{\mathsf{x}}{M}}(c_1){}[i]`.

      #) Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c_2)` to the stack.

#. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type, then:

   a. Let :math:`{\mathit{pt}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

      1) Let :math:`{\mathit{sx}}` be :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

      #) If :math:`i < {|{{\mathrm{lanes}}}_{{{\mathit{pt}}}{\mathsf{x}}{M}}(c_1)|}`, then:

         a) Let :math:`c_2` be :math:`{{{{\mathrm{extend}}}_{{|{\mathit{pt}}|}, 32}^{{\mathit{sx}}}}}{({{\mathrm{lanes}}}_{{{\mathit{pt}}}{\mathsf{x}}{M}}(c_1){}[i])}`.

         #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c_2)` to the stack.


:math:`{{\mathsf{i}}{N}}{\mathsf{x}}{M}{.}\mathsf{replace\_lane}~i`
...................................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0 = {\mathrm{unpack}}({\mathsf{i}}{N})`.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c_1){}[{}[i] = {{\mathrm{pack}}}_{{\mathsf{i}}{N}}(c_2)])}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}_2 {.} {{\mathit{vextunop}}}{\mathsf{\_}}{{\mathit{sh}}_1}`
...............................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vextunop}}}{{}_{{\mathit{sh}}_1, {\mathit{sh}}_2}(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}_2 {.} {{\mathit{vextbinop}}}{\mathsf{\_}}{{\mathit{sh}}_1}`
................................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vextbinop}}}{{}_{{\mathit{sh}}_1, {\mathit{sh}}_2}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}_2 {.} {{\mathit{vextternop}}}{\mathsf{\_}}{{\mathit{sh}}_1}`
.................................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_3)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vextternop}}}{{}_{{\mathit{sh}}_1, {\mathit{sh}}_2}(c_1, c_2, c_3)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathit{sh}}_2{.}\mathsf{narrow}}{\mathsf{\_}}{{\mathit{sh}}_1}{\mathsf{\_}}{{\mathit{sx}}}`
.....................................................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{\mathsf{vnarrow}}{{{}_{{\mathit{sh}}_1, {\mathit{sh}}_2}^{{\mathit{sx}}}}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}_2 {.} {{\mathit{vcvtop}}}{\mathsf{\_}}{{{\mathit{zero}}^?}}{\mathsf{\_}}{{\mathit{sh}}_1}{\mathsf{\_}}{{{\mathit{half}}^?}}`
.................................................................................................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{vcvtop}}}_{{\mathit{sh}}_1, {\mathit{sh}}_2}({\mathit{vcvtop}}, {{\mathit{half}}^?}, {{\mathit{zero}}^?}, c_1)`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{local{.}tee}~x`
..............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Execute the instruction :math:`(\mathsf{local{.}set}~x)`.


:math:`\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}^\ast}`
............................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{m}}~\rightarrow~{t_2^{n}}` be :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`m` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{m}}` from the stack.

#. Enter :math:`{{\mathit{val}}^{m}}~{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{n}}{\{}~\epsilon~\})`.


:math:`\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast}`
...........................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{m}}~\rightarrow~{t_2^{n}}` be :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`m` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{m}}` from the stack.

#. Enter :math:`{{\mathit{val}}^{m}}~{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{m}}{\{}~(\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast})~\})`.


:math:`\mathsf{br\_on\_cast}~l~{\mathit{rt}}_1~{\mathit{rt}}_2`
...............................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Assert: Due to validation, a :ref:`reference value <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Assert: Due to validation, :math:`{\mathit{ref}}` is :ref:`valid <valid-val>`.

#. Let :math:`{\mathit{rt}}` be the type of :math:`{\mathit{ref}}`.

#. Push the value :math:`{\mathit{ref}}` to the stack.

#. If :math:`{\mathit{rt}}` does not match :math:`{{\mathrm{inst}}}_{f{.}\mathsf{module}}({\mathit{rt}}_2)`, then:

   a. Do nothing.

#. Else:

   a. Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{br\_on\_cast\_fail}~l~{\mathit{rt}}_1~{\mathit{rt}}_2`
.....................................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Assert: Due to validation, a :ref:`reference value <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Assert: Due to validation, :math:`{\mathit{ref}}` is :ref:`valid <valid-val>`.

#. Let :math:`{\mathit{rt}}` be the type of :math:`{\mathit{ref}}`.

#. Push the value :math:`{\mathit{ref}}` to the stack.

#. If :math:`{\mathit{rt}}` matches :math:`{{\mathrm{inst}}}_{f{.}\mathsf{module}}({\mathit{rt}}_2)`, then:

   a. Do nothing.

#. Else:

   a. Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{call}~x`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Let :math:`a` be :math:`z{.}\mathsf{module}{.}\mathsf{funcs}{}[x]`.

#. Assert: Due to validation, :math:`a < {|z{.}\mathsf{funcs}|}`.

#. Push the value :math:`(\mathsf{ref{.}func}~a)` to the stack.

#. Execute the instruction :math:`(\mathsf{call\_ref}~z{.}\mathsf{funcs}{}[a]{.}\mathsf{type})`.


:math:`\mathsf{call\_ref}~y`
............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}null}`, then:

   a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}func}`, then:

   a. Let :math:`(\mathsf{ref{.}func}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`a < {|z{.}\mathsf{funcs}|}`, then:

      1) Let :math:`{\mathit{fi}}` be :math:`z{.}\mathsf{funcs}{}[a]`.

      #) Assert: Due to validation, :math:`{\mathit{fi}}{.}\mathsf{code}` is :math:`\mathsf{func}`.

      #) Let :math:`(\mathsf{func}~x~{{\mathit{local}}_0^\ast}~{{\mathit{instr}}^\ast})` be :math:`{\mathit{fi}}{.}\mathsf{code}`.

      #) Let :math:`{(\mathsf{local}~t)^\ast}` be :math:`{{\mathit{local}}_0^\ast}`.

      #) Assert: Due to validation, :math:`{\mathrm{expand}}({\mathit{fi}}{.}\mathsf{type})` is :math:`\mathsf{func}`.

      #) Let :math:`(\mathsf{func}~{\mathit{functype}}_0)` be :math:`{\mathrm{expand}}({\mathit{fi}}{.}\mathsf{type})`.

      #) Let :math:`{t_1^{n}}~\rightarrow~{t_2^{m}}` be :math:`{\mathit{functype}}_0`.

      #) Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

      #) Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

      #) Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~{{\mathit{val}}^{n}}~{{{\mathrm{default}}}_{t}^\ast},\; \mathsf{module}~{\mathit{fi}}{.}\mathsf{module} \}\end{array}`.

      #) Push the :ref:`frame <syntax-frame>` :math:`({{\mathsf{frame}}_{m}}{\{}~f~\})` to the stack.

      #) Enter :math:`{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{m}}{\{}~\epsilon~\})`.


:math:`\mathsf{return\_call}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Let :math:`a` be :math:`z{.}\mathsf{module}{.}\mathsf{funcs}{}[x]`.

#. Assert: Due to validation, :math:`a < {|z{.}\mathsf{funcs}|}`.

#. Push the value :math:`(\mathsf{ref{.}func}~a)` to the stack.

#. Execute the instruction :math:`(\mathsf{return\_call\_ref}~z{.}\mathsf{funcs}{}[a]{.}\mathsf{type})`.


:math:`\mathsf{return\_call\_ref}~y`
....................................


1. Let :math:`z` be the current state.

#. If the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Pop the current :math:`\mathsf{label}` context from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`(\mathsf{return\_call\_ref}~y)`.

#. Else if the first non-value entry of the stack is a :math:`\mathsf{handler}`, then:

   a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. Pop the current :math:`\mathsf{handler}` context from the stack.

   #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

   #. Execute the instruction :math:`(\mathsf{return\_call\_ref}~y)`.

#. Else:

   a. If the first non-value entry of the stack is a :math:`\mathsf{frame}`, then:

      1) Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

      #) Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

      #) If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}null}`, then:

         a) Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

         #) Pop the current :math:`\mathsf{frame}` context from the stack.

         #) Trap.

      #) If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}func}`, then:

         a) Let :math:`(\mathsf{ref{.}func}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) If :math:`a < {|z{.}\mathsf{funcs}|}`, then:

            1. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{funcs}{}[a]{.}\mathsf{type})` is :math:`\mathsf{func}`.

            #. Let :math:`(\mathsf{func}~{\mathit{functype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{funcs}{}[a]{.}\mathsf{type})`.

            #. Let :math:`{t_1^{n}}~\rightarrow~{t_2^{m}}` be :math:`{\mathit{functype}}_0`.

            #. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

            #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

            #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

            #. Pop the current :math:`\mathsf{frame}` context from the stack.

            #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

            #. Push the value :math:`(\mathsf{ref{.}func}~a)` to the stack.

            #. Execute the instruction :math:`(\mathsf{call\_ref}~y)`.


:math:`\mathsf{throw\_ref}`
...........................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}null}`, then:

   a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}exn}`, then:

   a. Let :math:`(\mathsf{ref{.}exn}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

   #. If :math:`{{\mathit{val}}^\ast} \neq \epsilon`, then:

      1) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

      #) Execute the instruction :math:`\mathsf{throw\_ref}`.

   #. Else if the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

      1) Pop the current :math:`\mathsf{label}` context from the stack.

      #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

      #) Execute the instruction :math:`\mathsf{throw\_ref}`.

   #. Else:

      1) If the first non-value entry of the stack is a :math:`\mathsf{frame}`, then:

         a) Pop the current :math:`\mathsf{frame}` context from the stack.

         #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

         #) Execute the instruction :math:`\mathsf{throw\_ref}`.

      #) Else if not the first non-value entry of the stack is a :math:`\mathsf{handler}`, then:

         a) Throw the exception :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` as a result.

      #) Else:

         a) Let :math:`({{\mathsf{handler}}_{n}}{\{}~{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}~\})` be the current :math:`\mathsf{handler}` context.

         #) If :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

            1. Pop the current :math:`\mathsf{handler}` context from the stack.

            #. Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

            #. Execute the instruction :math:`\mathsf{throw\_ref}`.

         #) Else if :math:`a \geq {|z{.}\mathsf{exns}|}`, then:

            1. Let :math:`{\mathit{catch}}_0~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

            #. If :math:`{\mathit{catch}}_0` is :math:`\mathsf{catch\_all}`, then:

               a. Let :math:`(\mathsf{catch\_all}~l)` be :math:`{\mathit{catch}}_0`.

               #. Pop the current :math:`\mathsf{handler}` context from the stack.

               #. Execute the instruction :math:`(\mathsf{br}~l)`.

            #. Else if :math:`{\mathit{catch}}_0` is not :math:`\mathsf{catch\_all\_ref}`, then:

               a. Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

               #. Pop the current :math:`\mathsf{handler}` context from the stack.

               #. Push the :ref:`handler <syntax-handler>` :math:`({{\mathsf{handler}}_{n}}{\{}~{{\mathit{catch}'}^\ast}~\})` to the stack.

               #. Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

               #. Execute the instruction :math:`\mathsf{throw\_ref}`.

            #. Else:

               a. Let :math:`(\mathsf{catch\_all\_ref}~l)` be :math:`{\mathit{catch}}_0`.

               #. Pop the current :math:`\mathsf{handler}` context from the stack.

               #. Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

               #. Execute the instruction :math:`(\mathsf{br}~l)`.

         #) Else:

            1. Let :math:`{{\mathit{val}}^\ast}` be :math:`z{.}\mathsf{exns}{}[a]{.}\mathsf{fields}`.

            #. Let :math:`{\mathit{catch}}_0~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

            #. If :math:`{\mathit{catch}}_0` is :math:`\mathsf{catch}`, then:

               a. Let :math:`(\mathsf{catch}~x~l)` be :math:`{\mathit{catch}}_0`.

               #. If :math:`x < {|z{.}\mathsf{tags}|}` and :math:`z{.}\mathsf{exns}{}[a]{.}\mathsf{tag} = z{.}\mathsf{tags}{}[x]`, then:

                  1) Pop the current :math:`\mathsf{handler}` context from the stack.

                  #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

                  #) Execute the instruction :math:`(\mathsf{br}~l)`.

               #. Else:

                  1) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

                  #) Pop the current :math:`\mathsf{handler}` context from the stack.

                  #) Push the :ref:`handler <syntax-handler>` :math:`({{\mathsf{handler}}_{n}}{\{}~{{\mathit{catch}'}^\ast}~\})` to the stack.

                  #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

                  #) Execute the instruction :math:`\mathsf{throw\_ref}`.

            #. Else if :math:`{\mathit{catch}}_0` is :math:`\mathsf{catch\_ref}`, then:

               a. Let :math:`(\mathsf{catch\_ref}~x~l)` be :math:`{\mathit{catch}}_0`.

               #. If :math:`x \geq {|z{.}\mathsf{tags}|}`, then:

                  1) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

                  #) Pop the current :math:`\mathsf{handler}` context from the stack.

                  #) Push the :ref:`handler <syntax-handler>` :math:`({{\mathsf{handler}}_{n}}{\{}~{{\mathit{catch}'}^\ast}~\})` to the stack.

                  #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

                  #) Execute the instruction :math:`\mathsf{throw\_ref}`.

               #. Else if :math:`z{.}\mathsf{exns}{}[a]{.}\mathsf{tag} \neq z{.}\mathsf{tags}{}[x]`, then:

                  1) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

                  #) Pop the current :math:`\mathsf{handler}` context from the stack.

                  #) Push the :ref:`handler <syntax-handler>` :math:`({{\mathsf{handler}}_{n}}{\{}~{{\mathit{catch}'}^\ast}~\})` to the stack.

                  #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

                  #) Execute the instruction :math:`\mathsf{throw\_ref}`.

               #. Else:

                  1) Pop the current :math:`\mathsf{handler}` context from the stack.

                  #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

                  #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

                  #) Execute the instruction :math:`(\mathsf{br}~l)`.

            #. Else:

               a. If :math:`{\mathit{catch}}_0` is :math:`\mathsf{catch\_all}`, then:

                  1) Let :math:`(\mathsf{catch\_all}~l)` be :math:`{\mathit{catch}}_0`.

                  #) Pop the current :math:`\mathsf{handler}` context from the stack.

                  #) Execute the instruction :math:`(\mathsf{br}~l)`.

               #. Else if :math:`{\mathit{catch}}_0` is not :math:`\mathsf{catch\_all\_ref}`, then:

                  1) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

                  #) Pop the current :math:`\mathsf{handler}` context from the stack.

                  #) Push the :ref:`handler <syntax-handler>` :math:`({{\mathsf{handler}}_{n}}{\{}~{{\mathit{catch}'}^\ast}~\})` to the stack.

                  #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

                  #) Execute the instruction :math:`\mathsf{throw\_ref}`.

               #. Else:

                  1) Let :math:`(\mathsf{catch\_all\_ref}~l)` be :math:`{\mathit{catch}}_0`.

                  #) Pop the current :math:`\mathsf{handler}` context from the stack.

                  #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

                  #) Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else if not the first non-value entry of the stack is a :math:`\mathsf{label}` and not the first non-value entry of the stack is a :math:`\mathsf{frame}` and not the first non-value entry of the stack is a :math:`\mathsf{handler}`, then:

   a. Throw the exception :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` as a result.


:math:`\mathsf{try\_table}~{\mathit{bt}}~{{\mathit{catch}}^\ast}~{{\mathit{instr}}^\ast}`
.........................................................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{m}}~\rightarrow~{t_2^{n}}` be :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`m` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{m}}` from the stack.

#. Push the :ref:`handler <syntax-handler>` :math:`({{\mathsf{handler}}_{n}}{\{}~{{\mathit{catch}}^\ast}~\})` to the stack.

#. Enter :math:`{{\mathit{val}}^{m}}~{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{n}}{\{}~\epsilon~\})`.


:math:`\mathsf{ref{.}null}~x`
.............................


1. Let :math:`z` be the current state.

#. Push the value :math:`(\mathsf{ref{.}null}~z{.}\mathsf{types}{}[x])` to the stack.


:math:`\mathsf{ref{.}func}~x`
.............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Push the value :math:`(\mathsf{ref{.}func}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x])` to the stack.


:math:`\mathsf{ref{.}test}~{\mathit{rt}}`
.........................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Assert: Due to validation, a :ref:`reference value <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Assert: Due to validation, :math:`{\mathit{ref}}` is :ref:`valid <valid-val>`.

#. Let :math:`{\mathit{rt}'}` be the type of :math:`{\mathit{ref}}`.

#. If :math:`{\mathit{rt}'}` matches :math:`{{\mathrm{inst}}}_{f{.}\mathsf{module}}({\mathit{rt}})`, then:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

   a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`\mathsf{ref{.}cast}~{\mathit{rt}}`
.........................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Assert: Due to validation, a :ref:`reference value <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Assert: Due to validation, :math:`{\mathit{ref}}` is :ref:`valid <valid-val>`.

#. Let :math:`{\mathit{rt}'}` be the type of :math:`{\mathit{ref}}`.

#. If :math:`{\mathit{rt}'}` does not match :math:`{{\mathrm{inst}}}_{f{.}\mathsf{module}}({\mathit{rt}})`, then:

   a. Trap.

#. Push the value :math:`{\mathit{ref}}` to the stack.


:math:`\mathsf{struct{.}new\_default}~x`
........................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is :math:`\mathsf{struct}`.

#. Let :math:`(\mathsf{struct}~{\mathit{structtype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

#. Let :math:`{({\mathsf{mut}^?}~{\mathit{zt}})^\ast}` be :math:`{\mathit{structtype}}_0`.

#. Assert: Due to validation, for all :math:`{\mathit{zt}}` in :math:`{{\mathit{zt}}^\ast}`, :math:`{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}` is defined.

#. Let :math:`{{\mathit{val}}^\ast}` be :math:`{{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}^\ast}`.

#. Assert: Due to validation, :math:`{|{\mathit{val*}}|} = {|{\mathit{zt*}}|}`.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

#. Execute the instruction :math:`(\mathsf{struct{.}new}~x)`.


:math:`{\mathsf{struct{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x~i`
...................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}null}`, then:

   a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}struct}`, then:

   a. Let :math:`(\mathsf{ref{.}struct}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`i < {|z{.}\mathsf{structs}{}[a]{.}\mathsf{fields}|}` and :math:`a < {|z{.}\mathsf{structs}|}`, then:

      1) Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is :math:`\mathsf{struct}`.

      #) Let :math:`(\mathsf{struct}~{\mathit{structtype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

      #) Let :math:`{({\mathsf{mut}^?}~{\mathit{zt}})^\ast}` be :math:`{\mathit{structtype}}_0`.

      #) If :math:`i < {|{{\mathit{zt}}^\ast}|}`, then:

         a) Push the value :math:`{{{{\mathrm{unpack}}}_{{{\mathit{zt}}^\ast}{}[i]}^{{{\mathit{sx}}^?}}}}{(z{.}\mathsf{structs}{}[a]{.}\mathsf{fields}{}[i])}` to the stack.


:math:`\mathsf{array{.}new\_default}~x`
.......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is :math:`\mathsf{array}`.

#. Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

#. Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be :math:`{\mathit{arraytype}}_0`.

#. Assert: Due to validation, :math:`{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}` is defined.

#. Let :math:`{\mathit{val}}` be :math:`{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}`.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)`.


:math:`\mathsf{array{.}new\_elem}~x~y`
......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. Assert: Due to validation, :math:`{|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[i : n]|} = n`.

#. Let :math:`{{\mathit{ref}}^\ast}` be :math:`z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[i : n]`.

#. Push the values :math:`{{\mathit{ref}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)`.


:math:`\mathsf{array{.}new\_data}~x~y`
......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is :math:`\mathsf{array}`.

#. Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

#. Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be :math:`{\mathit{arraytype}}_0`.

#. If :math:`i + n \cdot {|{\mathit{zt}}|} / 8 > {|z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Assert: Due to validation, the length of :math:`({\mathit{fresh}}_1)` for which :math:`{\bigoplus}\, {\mathit{fresh}}_1` :math:`=` :math:`z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}{}[i : n \cdot {|{\mathit{zt}}|} / 8]` is :math:`n`.

#. Let :math:`{{{\mathit{byte}}^\ast}^\ast}` be the result for which :math:`{\bigoplus}\, {{{\mathit{byte}}^\ast}^\ast}` :math:`=` :math:`z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}{}[i : n \cdot {|{\mathit{zt}}|} / 8]`.

#. Let :math:`{c^\ast}` be the result for which :math:`{({{\mathrm{bytes}}}_{{\mathit{zt}}}({c^\ast}) = {{\mathit{byte}}^\ast})^\ast}`.

#. Push the values :math:`{{\mathrm{unpack}}({\mathit{zt}}){.}\mathsf{const}~{{\mathrm{unpack}}}_{{\mathit{zt}}}(c)^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)`.


:math:`{\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x`
................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}null}`, then:

   a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}array}`, then:

   a. Let :math:`(\mathsf{ref{.}array}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`a < {|z{.}\mathsf{arrays}|}` and :math:`i \geq {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

      1) Trap.

   #. If :math:`i < {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}` and :math:`a < {|z{.}\mathsf{arrays}|}`, then:

      1) Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is :math:`\mathsf{array}`.

      #) Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

      #) Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be :math:`{\mathit{arraytype}}_0`.

      #) Push the value :math:`{{{{\mathrm{unpack}}}_{{\mathit{zt}}}^{{{\mathit{sx}}^?}}}}{(z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}{}[i])}` to the stack.


:math:`\mathsf{array{.}len}`
............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}null}`, then:

   a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}array}`, then:

   a. Let :math:`(\mathsf{ref{.}array}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`a < {|z{.}\mathsf{arrays}|}`, then:

      1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|})` to the stack.


:math:`\mathsf{array{.}fill}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}null}`, then:

   a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}array}`, then:

   a. Let :math:`(\mathsf{ref{.}array}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`a \geq {|z{.}\mathsf{arrays}|}`, then:

      1) Do nothing.

   #. Else if :math:`i + n > {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

      1) Trap.

   #. If :math:`n = 0`, then:

      1) Do nothing.

   #. Else:

      1) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

      #) Push the value :math:`{\mathit{val}}` to the stack.

      #) Execute the instruction :math:`(\mathsf{array{.}set}~x)`.

      #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

      #) Push the value :math:`{\mathit{val}}` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

      #) Execute the instruction :math:`(\mathsf{array{.}fill}~x)`.


:math:`\mathsf{array{.}copy}~x_1~x_2`
.....................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2)` from the stack.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1)` from the stack.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is :math:`\mathsf{ref{.}null}` and :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is reference value, then:

   a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}null}` and :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is reference value, then:

   a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is :math:`\mathsf{ref{.}array}`, then:

   a. Let :math:`(\mathsf{ref{.}array}~a_1)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

   #. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}array}`, then:

      1) If :math:`a_1 < {|z{.}\mathsf{arrays}|}` and :math:`i_1 + n > {|z{.}\mathsf{arrays}{}[a_1]{.}\mathsf{fields}|}`, then:

         a) Trap.

      #) Let :math:`(\mathsf{ref{.}array}~a_2)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) If :math:`a_2 \geq {|z{.}\mathsf{arrays}|}`, then:

         a) Do nothing.

      #) Else if :math:`i_2 + n > {|z{.}\mathsf{arrays}{}[a_2]{.}\mathsf{fields}|}`, then:

         a) Trap.

      #) If :math:`n = 0`, then:

         a) Do nothing.

      #) Else if :math:`i_1 \leq i_2` and :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x_2])` is :math:`\mathsf{array}`, then:

         a) Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x_2])`.

         #) Let :math:`({\mathsf{mut}^?}~{\mathit{zt}}_2)` be :math:`{\mathit{arraytype}}_0`.

         #) Let :math:`{{\mathit{sx}}^?}` be :math:`{\mathrm{sx}}({\mathit{zt}}_2)`.

         #) Push the value :math:`(\mathsf{ref{.}array}~a_1)` to the stack.

         #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1)` to the stack.

         #) Push the value :math:`(\mathsf{ref{.}array}~a_2)` to the stack.

         #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2)` to the stack.

         #) Execute the instruction :math:`({\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x_2)`.

         #) Execute the instruction :math:`(\mathsf{array{.}set}~x_1)`.

         #) Push the value :math:`(\mathsf{ref{.}array}~a_1)` to the stack.

         #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1 + 1)` to the stack.

         #) Push the value :math:`(\mathsf{ref{.}array}~a_2)` to the stack.

         #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2 + 1)` to the stack.

         #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

         #) Execute the instruction :math:`(\mathsf{array{.}copy}~x_1~x_2)`.

      #) Else:

         a) If :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x_2])` is :math:`\mathsf{array}`, then:

            1. Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x_2])`.

            #. Let :math:`({\mathsf{mut}^?}~{\mathit{zt}}_2)` be :math:`{\mathit{arraytype}}_0`.

            #. Let :math:`{{\mathit{sx}}^?}` be :math:`{\mathrm{sx}}({\mathit{zt}}_2)`.

            #. Push the value :math:`(\mathsf{ref{.}array}~a_1)` to the stack.

            #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1 + n - 1)` to the stack.

            #. Push the value :math:`(\mathsf{ref{.}array}~a_2)` to the stack.

            #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2 + n - 1)` to the stack.

            #. Execute the instruction :math:`({\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x_2)`.

            #. Execute the instruction :math:`(\mathsf{array{.}set}~x_1)`.

            #. Push the value :math:`(\mathsf{ref{.}array}~a_1)` to the stack.

            #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1)` to the stack.

            #. Push the value :math:`(\mathsf{ref{.}array}~a_2)` to the stack.

            #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2)` to the stack.

            #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

            #. Execute the instruction :math:`(\mathsf{array{.}copy}~x_1~x_2)`.

   #. Else if :math:`n \neq 0`, then:

      1) Do nothing.


:math:`\mathsf{array{.}init\_elem}~x~y`
.......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}null}`, then:

   a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}array}`, then:

   a. Let :math:`(\mathsf{ref{.}array}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`a < {|z{.}\mathsf{arrays}|}` and :math:`i + n > {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

      1) Trap.

   #. If :math:`j + n > {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

      1) Trap.

   #. If :math:`n = 0`, then:

      1) Do nothing.

   #. Else if :math:`j < {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

      1) Let :math:`{\mathit{ref}}` be :math:`z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[j]`.

      #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

      #) Push the value :math:`{\mathit{ref}}` to the stack.

      #) Execute the instruction :math:`(\mathsf{array{.}set}~x)`.

      #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

      #) Execute the instruction :math:`(\mathsf{array{.}init\_elem}~x~y)`.


:math:`\mathsf{array{.}init\_data}~x~y`
.......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}null}`, then:

   a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}array}`, then:

   a. Let :math:`(\mathsf{ref{.}array}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`a < {|z{.}\mathsf{arrays}|}` and :math:`i + n > {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

      1) Trap.

   #. If :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is :math:`\mathsf{array}`, then:

      1) Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

      #) Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be :math:`{\mathit{arraytype}}_0`.

      #) If :math:`j + n \cdot {|{\mathit{zt}}|} / 8 > {|z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) If :math:`n = 0`, then:

         a) Do nothing.

      #) Else:

         a) Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathit{zt}}}(c)` :math:`=` :math:`z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}{}[j : {|{\mathit{zt}}|} / 8]`.

         #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

         #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

         #) Push the value :math:`{\mathrm{unpack}}({\mathit{zt}}){.}\mathsf{const}~{{\mathrm{unpack}}}_{{\mathit{zt}}}(c)` to the stack.

         #) Execute the instruction :math:`(\mathsf{array{.}set}~x)`.

         #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

         #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

         #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + {|{\mathit{zt}}|} / 8)` to the stack.

         #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

         #) Execute the instruction :math:`(\mathsf{array{.}init\_data}~x~y)`.

   #. Else if :math:`n = 0`, then:

      1) Do nothing.


:math:`\mathsf{local{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`z{.}\mathsf{locals}{}[x]` is defined.

#. Let :math:`{\mathit{val}}` be :math:`z{.}\mathsf{locals}{}[x]`.

#. Push the value :math:`{\mathit{val}}` to the stack.


:math:`\mathsf{global{.}get}~x`
...............................


1. Let :math:`z` be the current state.

#. Let :math:`{\mathit{val}}` be :math:`z{.}\mathsf{globals}{}[x]{.}\mathsf{value}`.

#. Push the value :math:`{\mathit{val}}` to the stack.


:math:`\mathsf{table{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. Push the value :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i]` to the stack.


:math:`\mathsf{table{.}size}~x`
...............................


1. Let :math:`z` be the current state.

#. Let :math:`({\mathit{at}}~{\mathit{lim}}~{\mathit{rt}})` be :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{type}`.

#. Let :math:`n` be :math:`{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`.

#. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{table{.}fill}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}fill}~x)`.


:math:`\mathsf{table{.}copy}~x_1~x_2`
.....................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}'}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}'}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}_2` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}_1` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` from the stack.

#. If :math:`i_1 + n > {|z{.}\mathsf{tables}{}[x_1]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`i_2 + n > {|z{.}\mathsf{tables}{}[x_2]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. If :math:`i_1 \leq i_2`, then:

      1) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` to the stack.

      #) Execute the instruction :math:`(\mathsf{table{.}get}~x_2)`.

      #) Execute the instruction :math:`(\mathsf{table{.}set}~x_1)`.

      #) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1 + 1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2 + 1)` to the stack.

   #. Else:

      1) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1 + n - 1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2 + n - 1)` to the stack.

      #) Execute the instruction :math:`(\mathsf{table{.}get}~x_2)`.

      #) Execute the instruction :math:`(\mathsf{table{.}set}~x_1)`.

      #) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` to the stack.

   #. Push the value :math:`({\mathit{at}'}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}copy}~x_1~x_2)`.


:math:`\mathsf{table{.}init}~x~y`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else if :math:`j < {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

   a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[j]` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{table{.}init}~x~y)`.


:math:`{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{load}}{{{\mathit{loadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~x~{\mathit{ao}}`
..............................................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`{{\mathit{loadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

   a. Let :math:`{\mathit{nt}}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}}|} / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

      1) Trap.

   #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathit{nt}}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}}|} / 8]`.

   #. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.

#. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{{\mathit{loadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

      1) Let :math:`{\mathit{loadop\_{\scriptstyle 0}}}` be :math:`{{\mathit{loadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

      #) Let :math:`{n}{\mathsf{\_}}{{\mathit{sx}}}` be :math:`{\mathit{loadop\_{\scriptstyle 0}}}`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

         a) Trap.

   #. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{{\mathit{loadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

      1) Let :math:`{\mathit{loadop\_{\scriptstyle 0}}}` be :math:`{{\mathit{loadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

      #) Let :math:`{n}{\mathsf{\_}}{{\mathit{sx}}}` be :math:`{\mathit{loadop\_{\scriptstyle 0}}}`.

      #) Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8]`.

      #) Push the value :math:`({\mathsf{i}}{N}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{n, {|{\mathsf{i}}{N}|}}^{{\mathit{sx}}}}}{(c)})` to the stack.


:math:`{\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~x~{\mathit{ao}}`
......................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|\mathsf{v{\scriptstyle 128}}|} / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}` and :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

   a. Trap.

#. If :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

   a. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{\mathsf{v{\scriptstyle 128}}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|\mathsf{v{\scriptstyle 128}}|} / 8]`.

   #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. Else:

   a. Let :math:`{\mathit{vloadop\_{\scriptstyle 0}}}` be :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

   #. If :math:`{\mathit{vloadop\_{\scriptstyle 0}}}` is :math:`\mathsf{shape}`, then:

      1) Let :math:`({M}{\mathsf{x}}{K}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vloadop\_{\scriptstyle 0}}}`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + M \cdot K / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) Let :math:`{j^{K}}` be the result for which :math:`{({{\mathrm{bytes}}}_{{\mathsf{i}}{M}}({j^{K}}) = z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} + k \cdot M / 8 : M / 8])^{k<K}}`.

      #) If :math:`N` for which :math:`N` :math:`=` :math:`M \cdot 2` is :math:`{\mathsf{i}}{N}`, then:

         a) Let :math:`{\mathsf{i}}{N}` be the result for which :math:`N` :math:`=` :math:`M \cdot 2`.

         #) Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{K}}^{{-1}}}}{({{{{{\mathrm{extend}}}_{M, N}^{{\mathit{sx}}}}}{(j)}^{K}})}`.

         #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

   #. If :math:`{\mathit{vloadop\_{\scriptstyle 0}}}` is :math:`\mathsf{splat}`, then:

      1) Let :math:`({N}{\mathsf{\_}}{\mathsf{splat}})` be :math:`{\mathit{vloadop\_{\scriptstyle 0}}}`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) Let :math:`M` be :math:`128 / N`.

      #) If :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`N` is :math:`{\mathsf{i}}{N}`, then:

         a) Let :math:`{\mathsf{i}}{N}` be the result for which :math:`{|{\mathsf{i}}{N}|}` :math:`=` :math:`N`.

         #) Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

         #) Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({j^{M}})}`.

         #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

   #. If :math:`{\mathit{vloadop\_{\scriptstyle 0}}}` is :math:`\mathsf{zero}`, then:

      1) Let :math:`({N}{\mathsf{\_}}{\mathsf{zero}})` be :math:`{\mathit{vloadop\_{\scriptstyle 0}}}`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

      #) Let :math:`c` be :math:`{{{{\mathrm{extend}}}_{N, 128}^{\mathsf{u}}}}{(j)}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{N}{\mathsf{\_}}{\mathsf{lane}}~x~{\mathit{ao}}~j`
.......................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`M` be :math:`{|\mathsf{v{\scriptstyle 128}}|} / N`.

#. If :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`N` is :math:`{\mathsf{i}}{N}`, then:

   a. Let :math:`{\mathsf{i}}{N}` be the result for which :math:`{|{\mathsf{i}}{N}|}` :math:`=` :math:`N`.

   #. Let :math:`k` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(k)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

   #. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c_1){}[{}[j] = k])}`.

   #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{memory{.}size}~x`
................................


1. Let :math:`z` be the current state.

#. Let :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})` be :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{type}`.

#. Let :math:`n \cdot 64 \, {\mathrm{Ki}}` be :math:`{|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`.

#. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{memory{.}fill}~x`
................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8}~x)`.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`{\mathit{val}}` to the stack.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{memory{.}fill}~x)`.


:math:`\mathsf{memory{.}copy}~x_1~x_2`
......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}'}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}'}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}_2` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}_1` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` from the stack.

#. If :math:`i_1 + n > {|z{.}\mathsf{mems}{}[x_1]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`i_2 + n > {|z{.}\mathsf{mems}{}[x_2]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else:

   a. If :math:`i_1 \leq i_2`, then:

      1) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` to the stack.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{load}}{{8}{\mathsf{\_}}{\mathsf{u}}}~x_2)`.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8}~x_1)`.

      #) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1 + 1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2 + 1)` to the stack.

   #. Else:

      1) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1 + n - 1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2 + n - 1)` to the stack.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{load}}{{8}{\mathsf{\_}}{\mathsf{u}}}~x_2)`.

      #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8}~x_1)`.

      #) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` to the stack.

      #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` to the stack.

   #. Push the value :math:`({\mathit{at}'}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{memory{.}copy}~x_1~x_2)`.


:math:`\mathsf{memory{.}init}~x~y`
..................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. If :math:`n = 0`, then:

   a. Do nothing.

#. Else if :math:`j < {|z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}|}`, then:

   a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}{}[j])` to the stack.

   #. Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8}~x)`.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

   #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

   #. Execute the instruction :math:`(\mathsf{memory{.}init}~x~y)`.


:math:`\mathsf{throw}~x`
........................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{tags}|}`.

#. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{tags}{}[x]{.}\mathsf{type})` is :math:`\mathsf{func}`.

#. Let :math:`(\mathsf{func}~{\mathit{functype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{tags}{}[x]{.}\mathsf{type})`.

#. Let :math:`{t^{n}}~\rightarrow~{\mathit{resulttype}}_1` be :math:`{\mathit{functype}}_0`.

#. Assert: Due to validation, :math:`{\mathit{resulttype}}_1 = \epsilon`.

#. Let :math:`a` be :math:`{|z{.}\mathsf{exns}|}`.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Let :math:`{\mathit{exn}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{tag}~z{.}\mathsf{tags}{}[x],\; \mathsf{fields}~{{\mathit{val}}^{n}} \}\end{array}`.

#. Perform :math:`z{}[{.}\mathsf{exns} \mathrel{{=}{\oplus}} {\mathit{exn}}]`.

#. Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

#. Execute the instruction :math:`\mathsf{throw\_ref}`.


:math:`\mathsf{struct{.}new}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is :math:`\mathsf{struct}`.

#. Let :math:`(\mathsf{struct}~{\mathit{structtype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

#. Let :math:`{({\mathsf{mut}^?}~{\mathit{zt}})^{n}}` be :math:`{\mathit{structtype}}_0`.

#. Let :math:`a` be :math:`{|z{.}\mathsf{structs}|}`.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Let :math:`{\mathit{si}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~z{.}\mathsf{types}{}[x],\; \mathsf{fields}~{{{\mathrm{pack}}}_{{\mathit{zt}}}({\mathit{val}})^{n}} \}\end{array}`.

#. Push the value :math:`(\mathsf{ref{.}struct}~a)` to the stack.

#. Perform :math:`z{}[{.}\mathsf{structs} \mathrel{{=}{\oplus}} {\mathit{si}}]`.


:math:`\mathsf{struct{.}set}~x~i`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}null}`, then:

   a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}struct}`, then:

   a. Let :math:`(\mathsf{ref{.}struct}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is :math:`\mathsf{struct}`.

   #. Let :math:`(\mathsf{struct}~{\mathit{structtype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

   #. Let :math:`{({\mathsf{mut}^?}~{\mathit{zt}})^\ast}` be :math:`{\mathit{structtype}}_0`.

   #. If :math:`i < {|{{\mathit{zt}}^\ast}|}`, then:

      1) Perform :math:`z{}[{.}\mathsf{structs}{}[a]{.}\mathsf{fields}{}[i] = {{\mathrm{pack}}}_{{{\mathit{zt}}^\ast}{}[i]}({\mathit{val}})]`.


:math:`\mathsf{array{.}new\_fixed}~x~n`
.......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is :math:`\mathsf{array}`.

#. Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

#. Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be :math:`{\mathit{arraytype}}_0`.

#. Let :math:`a` be :math:`{|z{.}\mathsf{arrays}|}`.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Let :math:`{\mathit{ai}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~z{.}\mathsf{types}{}[x],\; \mathsf{fields}~{{{\mathrm{pack}}}_{{\mathit{zt}}}({\mathit{val}})^{n}} \}\end{array}`.

#. Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

#. Perform :math:`z{}[{.}\mathsf{arrays} \mathrel{{=}{\oplus}} {\mathit{ai}}]`.


:math:`\mathsf{array{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}null}`, then:

   a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}array}`, then:

   a. Let :math:`(\mathsf{ref{.}array}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`a < {|z{.}\mathsf{arrays}|}` and :math:`i \geq {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

      1) Trap.

   #. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is :math:`\mathsf{array}`.

   #. Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

   #. Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be :math:`{\mathit{arraytype}}_0`.

   #. Perform :math:`z{}[{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}{}[i] = {{\mathrm{pack}}}_{{\mathit{zt}}}({\mathit{val}})]`.


:math:`\mathsf{local{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{locals}{}[x] = {\mathit{val}}]`.


:math:`\mathsf{global{.}set}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = {\mathit{val}}]`.


:math:`\mathsf{table{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a :ref:`reference value <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

   a. Trap.

#. Perform :math:`z{}[{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i] = {\mathit{ref}}]`.


:math:`\mathsf{table{.}grow}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a :ref:`reference value <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Either:

   a. Let :math:`{\mathit{ti}}` be :math:`{\mathrm{growtable}}(z{.}\mathsf{tables}{}[x], n, {\mathit{ref}})`.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|})` to the stack.

   #. Perform :math:`z{}[{.}\mathsf{tables}{}[x] = {\mathit{ti}}]`.

#. Or:

   a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{{|{\mathit{at}}|}}^{{-1}}}}{({-1})})` to the stack.


:math:`\mathsf{elem{.}drop}~x`
..............................


1. Let :math:`z` be the current state.

#. Perform :math:`z{}[{.}\mathsf{elems}{}[x]{.}\mathsf{refs} = \epsilon]`.


:math:`{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{store}}{{{\mathit{storeop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~x~{\mathit{ao}}`
................................................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. Let :math:`{\mathit{nt}}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}}|} / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}` and :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = {\mathit{nt}}` and :math:`{{\mathit{storeop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

   a. Trap.

#. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = {\mathit{nt}}` and :math:`{{\mathit{storeop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

   a. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathit{nt}}}(c)`.

   #. Perform :math:`z{}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}}|} / 8] = {b^\ast}]`.

#. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is :math:`{\mathsf{i}}{N}`, then:

   a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

   #. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = {\mathsf{i}}{N}` and :math:`{{\mathit{storeop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

      1) Let :math:`n` be :math:`{{\mathit{storeop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

      #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

         a) Trap.

      #) Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}({{\mathrm{wrap}}}_{{|{\mathsf{i}}{N}|}, n}(c))`.

      #) Perform :math:`z{}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8] = {b^\ast}]`.


:math:`\mathsf{v{\scriptstyle 128}}{.}\mathsf{store}~x~{\mathit{ao}}`
.....................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|\mathsf{v{\scriptstyle 128}}|} / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{\mathsf{v{\scriptstyle 128}}}(c)`.

#. Perform :math:`z{}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|\mathsf{v{\scriptstyle 128}}|} / 8] = {b^\ast}]`.


:math:`{\mathsf{v{\scriptstyle 128}}{.}\mathsf{store}}{N}{\mathsf{\_}}{\mathsf{lane}}~x~{\mathit{ao}}~j`
........................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

   a. Trap.

#. Let :math:`M` be :math:`128 / N`.

#. If :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`N` is :math:`{\mathsf{i}}{N}`, then:

   a. Let :math:`{\mathsf{i}}{N}` be the result for which :math:`{|{\mathsf{i}}{N}|}` :math:`=` :math:`N`.

   #. If :math:`j < {|{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c)|}`, then:

      1) Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}({{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c){}[j])`.

      #) Perform :math:`z{}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8] = {b^\ast}]`.


:math:`\mathsf{memory{.}grow}~x`
................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` from the stack.

#. Either:

   a. Let :math:`{\mathit{mi}}` be :math:`{\mathrm{growmem}}(z{.}\mathsf{mems}{}[x], n)`.

   #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~{|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|} / (64 \, {\mathrm{Ki}}))` to the stack.

   #. Perform :math:`z{}[{.}\mathsf{mems}{}[x] = {\mathit{mi}}]`.

#. Or:

   a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{{|{\mathit{at}}|}}^{{-1}}}}{({-1})})` to the stack.


:math:`\mathsf{data{.}drop}~x`
..............................


1. Let :math:`z` be the current state.

#. Perform :math:`z{}[{.}\mathsf{datas}{}[x]{.}\mathsf{bytes} = \epsilon]`.


:math:`{\mathrm{min}}(i, j)`
............................


1. If :math:`i \leq j`, then:

   a. Return :math:`i`.

#. Return :math:`j`.


:math:`{\Sigma}\, {n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`
...................................................................


1. If :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`0`.

#. Let :math:`n~{{n'}^\ast}` be :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`n + {\Sigma}\, {{n'}^\ast}`.


:math:`{\Pi}\, {n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`
................................................................


1. If :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`1`.

#. Let :math:`n~{{n'}^\ast}` be :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`n \cdot {\Pi}\, {{n'}^\ast}`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`
........................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} = 1`.

#. Let :math:`w` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`w`.


:math:`{\bigoplus}\, {X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`
......................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{w^\ast}~{{{w'}^\ast}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{w^\ast}~{\bigoplus}\, {{{w'}^\ast}^\ast}`.


:math:`{\bigoplus}\, {X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`
......................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{w^{n}}~{({{w'}^{n}})^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{w^{n}}~{\bigoplus}\, {({{w'}^{n}})^\ast}`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}~{\mathrm{disjoint}}`
............................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return true.

#. Let :math:`w~{{w'}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`w` is not contained in :math:`{{w'}^\ast}` and :math:`{{w'}^\ast}~{\mathrm{disjoint}}`.


:math:`{{\mathrm{setminus{\kern-0.1em\scriptstyle 1}}}}_{X}(w, {X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.................................................................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`w`.

#. Let :math:`w_1~{{w'}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`w = w_1`, then:

   a. Return :math:`\epsilon`.

#. Return :math:`{{\mathrm{setminus{\kern-0.1em\scriptstyle 1}}}}_{X}(w, {{w'}^\ast})`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} \setminus {w^\ast}`
...........................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`w_1~{{w'}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{{\mathrm{setminus{\kern-0.1em\scriptstyle 1}}}}_{X}(w_1, {w^\ast})~{{w'}^\ast} \setminus {w^\ast}`.


:math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{X}(w_1, {X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{{w'}^\ast}~{{w^\ast}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`w_1~{{w'}^\ast}~{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{X}(w_1, {{w^\ast}^\ast})`.


:math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{X}({X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {{w^\ast}^\ast})`
.................................................................................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`w_1~{{w'}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{X}(w_1, {{w^\ast}^\ast})~{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{X}({{w'}^\ast}, {{w^\ast}^\ast})`.


:math:`\Large\times~{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`
.....................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{w_1^\ast}~{{w^\ast}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{X}({w_1^\ast}, \Large\times~{{w^\ast}^\ast})`.


:math:`{\mathrm{signif}}(N_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
....................................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 32`, then:

   a. Return :math:`23`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 64`.

#. Return :math:`52`.


:math:`{\mathrm{expon}}(N_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
...................................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 32`, then:

   a. Return :math:`8`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 64`.

#. Return :math:`11`.


:math:`M`
.........


1. Return :math:`{\mathrm{signif}}(N)`.


:math:`E`
.........


1. Return :math:`{\mathrm{expon}}(N)`.


:math:`{+0}`
............


1. Return :math:`({+((0 + 0 \cdot {2^{{-M}}}) \cdot {2^{e}})})`.


:math:`{+1}`
............


1. Return :math:`({+((1 + 1 \cdot {2^{{-M}}}) \cdot {2^{0}})})`.


:math:`{+N}`
............


1. Return :math:`({+((1 + n \cdot {2^{{-M}}}) \cdot {2^{0}})})`.


:math:`{{\mathrm{canon}}}_{N}`
..............................


1. Return :math:`{2^{{\mathrm{signif}}(N) - 1}}`.


:math:`{\mathrm{cont}}(b)`
..........................


1. Assert: Due to validation, :math:`128 < b`.

#. Assert: Due to validation, :math:`b < 192`.

#. Return :math:`b - 128`.


:math:`\mathsf{anyref}`
.......................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{any})`.


:math:`\mathsf{eqref}`
......................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{eq})`.


:math:`\mathsf{i{\scriptstyle 31}ref}`
......................................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{i{\scriptstyle 31}})`.


:math:`\mathsf{structref}`
..........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{struct})`.


:math:`\mathsf{arrayref}`
.........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{array})`.


:math:`\mathsf{funcref}`
........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{func})`.


:math:`\mathsf{exnref}`
.......................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{extern})`.


:math:`\mathsf{externref}`
..........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{extern})`.


:math:`\mathsf{nullref}`
........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{none})`.


:math:`\mathsf{nullfuncref}`
............................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{nofunc})`.


:math:`\mathsf{nullexnref}`
...........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{noexn})`.


:math:`\mathsf{nullexternref}`
..............................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{noextern})`.


:math:`{|{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}|}`
.................................................................


1. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 32}}`, then:

   a. Return :math:`32`.

#. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 64}}`, then:

   a. Return :math:`64`.

#. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 32}}`, then:

   a. Return :math:`32`.

#. Assert: Due to validation, :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 64}}`.

#. Return :math:`64`.


:math:`{|\mathsf{v{\scriptstyle 128}}|}`
........................................


1. Return :math:`128`.


:math:`{|{\mathit{pt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}|}`
.................................................................


1. If :math:`{\mathit{pt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 8}}`, then:

   a. Return :math:`8`.

#. Assert: Due to validation, :math:`{\mathit{pt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 16}}`.

#. Return :math:`16`.


:math:`{|{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}|}`
.................................................................


1. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

   a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{|{\mathit{numtype}}|}`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{|{\mathit{packtype}}|}`.


:math:`{|{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}|}`
.................................................................


1. If :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

   a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{|{\mathit{numtype}}|}`.

#. If :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is vector type, then:

   a. Let :math:`{\mathit{vectype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{|{\mathit{vectype}}|}`.

#. Assert: Due to validation, :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{|{\mathit{packtype}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N_1`
...........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N_2`
...........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{vt}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{pt}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`N_1`
...........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`N_2`
...........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`{\mathrm{unpack}}({\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
................................................................................


1. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

   a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathit{numtype}}`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Return :math:`\mathsf{i{\scriptstyle 32}}`.


:math:`{\mathrm{unpack}}({\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
................................................................................


1. If :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is value type, then:

   a. Let :math:`{\mathit{valtype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathit{valtype}}`.

#. Assert: Due to validation, :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Return :math:`\mathsf{i{\scriptstyle 32}}`.


:math:`{\mathrm{unpack}}({\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
................................................................................


1. If :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

   a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathit{numtype}}`.

#. If :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type, then:

   a. Return :math:`\mathsf{i{\scriptstyle 32}}`.


:math:`{\mathrm{unpack}}({\mathit{vectype}})`
.............................................


1. Return :math:`{\mathit{vectype}}`.


:math:`{\mathrm{unpack}}({\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
................................................................................


1. If :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is literal type, then:

   a. Let :math:`{\mathit{consttype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathit{consttype}}`.

#. If :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type, then:

   a. Return :math:`\mathsf{i{\scriptstyle 32}}`.

#. If :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is lane type, then:

   a. Let :math:`{\mathit{lanetype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{unpack}}({\mathit{lanetype}})`.


:math:`{\mathrm{dim}}({{\mathsf{i}}{N}}{\mathsf{x}}{N})`
........................................................


1. Return :math:`N`.


:math:`{\mathrm{lanetype}}({{\mathsf{i}}{N}}{\mathsf{x}}{N})`
.............................................................


1. Return :math:`{\mathsf{i}}{N}`.


:math:`{\mathrm{unpack}}({{\mathsf{i}}{N}}{\mathsf{x}}{N})`
...........................................................


1. Return :math:`{\mathrm{unpack}}({\mathsf{i}}{N})`.


:math:`{\mathrm{funcs}}({{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
......................................................................................


1. If :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is :math:`\mathsf{func}`, then:

   a. Let :math:`(\mathsf{func}~x)` be :math:`{\mathit{externidx}}_0`.

   #. Return :math:`x~{\mathrm{funcs}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................................


1. If :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is :math:`\mathsf{global}`, then:

   a. Let :math:`(\mathsf{global}~x)` be :math:`{\mathit{externidx}}_0`.

   #. Return :math:`x~{\mathrm{globals}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................


1. If :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is :math:`\mathsf{table}`, then:

   a. Let :math:`(\mathsf{table}~x)` be :math:`{\mathit{externidx}}_0`.

   #. Return :math:`x~{\mathrm{tables}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is :math:`\mathsf{mem}`, then:

   a. Let :math:`(\mathsf{mem}~x)` be :math:`{\mathit{externidx}}_0`.

   #. Return :math:`x~{\mathrm{mems}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{tags}}({{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is :math:`\mathsf{tag}`, then:

   a. Let :math:`(\mathsf{tag}~x)` be :math:`{\mathit{externidx}}_0`.

   #. Return :math:`x~{\mathrm{tags}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tags}}({{\mathit{xx}}^\ast})`.


:math:`{\mathsf{i}}{N_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}`
...............................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 32`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 32}}`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 64`.

#. Return :math:`\mathsf{i{\scriptstyle 64}}`.


:math:`{\mathsf{f}}{N_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}`
...............................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 32`, then:

   a. Return :math:`\mathsf{f{\scriptstyle 32}}`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 64`.

#. Return :math:`\mathsf{f{\scriptstyle 64}}`.


:math:`{\mathsf{i}}{N_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}`
...............................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 8`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 8}}`.

#. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 16`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 16}}`.

#. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 32`, then:

   a. Return :math:`\mathsf{i{\scriptstyle 32}}`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 64`.

#. Return :math:`\mathsf{i{\scriptstyle 64}}`.


:math:`{\mathrm{min}}({\mathit{at}}_1, {\mathit{at}}_2)`
........................................................


1. If :math:`{|{\mathit{at}}_1|} \leq {|{\mathit{at}}_2|}`, then:

   a. Return :math:`{\mathit{at}}_1`.

#. Return :math:`{\mathit{at}}_2`.


:math:`\mathsf{ref}~{\mathsf{null}}{{{}_{1}^?}}~{\mathit{ht}}_1 \setminus \mathsf{ref}~{{\mathsf{null}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}~{\mathit{ht}}_2`
...................................................................................................................................................................


1. If :math:`{{\mathsf{null}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{null}`, then:

   a. Return :math:`(\mathsf{ref}~\epsilon~{\mathit{ht}}_1)`.

#. Assert: Due to validation, :math:`{{\mathsf{null}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is not defined.

#. Return :math:`(\mathsf{ref}~{\mathsf{null}}{{{}_{1}^?}}~{\mathit{ht}}_1)`.


:math:`{\mathrm{funcs}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
......................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is :math:`\mathsf{func}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{dt}})` be :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{dt}}~{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is :math:`\mathsf{global}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{gt}})` be :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{gt}}~{\mathrm{globals}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is :math:`\mathsf{table}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{tt}})` be :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{tt}}~{\mathrm{tables}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is :math:`\mathsf{mem}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{mt}})` be :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{mt}}~{\mathrm{mems}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{tags}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is :math:`\mathsf{tag}`, then:

   a. Let :math:`(\mathsf{tag}~{\mathit{jt}})` be :math:`{\mathit{externtype}}_0`.

   #. Return :math:`{\mathit{jt}}~{\mathrm{tags}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tags}}({{\mathit{xt}}^\ast})`.


:math:`{{\mathit{tv}}}{{}[ {{\mathit{tv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} := {y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} ]}`
...............................................................................................................................................


1. If :math:`{{\mathit{tv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon` and :math:`{y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`{\mathit{tv}}`.

#. Assert: Due to validation, :math:`{|{y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{tu}}_1~{{\mathit{tu}'}^\ast}` be :math:`{y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{tv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{tv}}_1~{{\mathit{tv}'}^\ast}` be :math:`{{\mathit{tv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{tv}} = {\mathit{tv}}_1`, then:

   a. Return :math:`{\mathit{tu}}_1`.

#. Return :math:`{{\mathit{tv}}}{{}[ {{\mathit{tv}'}^\ast} := {{\mathit{tu}'}^\ast} ]}`.


:math:`{{\mathit{pt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{\mathit{pt}}`.


:math:`{{\mathit{nt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{\mathit{nt}}`.


:math:`{{\mathit{vt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{\mathit{vt}}`.


:math:`{y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.......................................................................................................


1. If :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is type variable, then:

   a. Let :math:`{\mathit{tv}'}` be :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{{\mathit{tv}'}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. Assert: Due to validation, :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is defined type.

#. Let :math:`{\mathit{dt}}` be :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{\mathit{dt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.


:math:`{{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...................................................................................................................


1. If :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is type variable, then:

   a. Let :math:`{\mathit{tv}'}` be :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{{\mathit{tv}'}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. If :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is defined type, then:

   a. Let :math:`{\mathit{dt}}` be :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{{\mathit{dt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. Let :math:`{\mathit{ht}}` be :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathit{ht}}`.


:math:`{\mathsf{ref}~{\mathsf{null}^?}~{\mathit{ht}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
..........................................................................................................


1. Return :math:`(\mathsf{ref}~{\mathsf{null}^?}~{{\mathit{ht}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.......................................................................................................


1. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

   a. Let :math:`{\mathit{nt}}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{{\mathit{nt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is vector type, then:

   a. Let :math:`{\mathit{vt}}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{{\mathit{vt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is reference type, then:

   a. Let :math:`{\mathit{rt}}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{{\mathit{rt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. Assert: Due to validation, :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{bot}`.

#. Return :math:`\mathsf{bot}`.


:math:`{{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...................................................................................................................


1. If :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is value type, then:

   a. Let :math:`t` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{t}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. Assert: Due to validation, :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{pt}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{\mathit{pt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.


:math:`{{\mathsf{mut}^?}~{\mathit{zt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
............................................................................................


1. Return :math:`({\mathsf{mut}^?}~{{\mathit{zt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...................................................................................................................


1. If :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{struct}`, then:

   a. Let :math:`(\mathsf{struct}~{{\mathit{yt}}^\ast})` be :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`(\mathsf{struct}~{{{\mathit{yt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast})`.

#. If :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{array}`, then:

   a. Let :math:`(\mathsf{array}~{\mathit{yt}})` be :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`(\mathsf{array}~{{\mathit{yt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. Assert: Due to validation, :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{func}`.

#. Let :math:`(\mathsf{func}~{\mathit{ft}})` be :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`(\mathsf{func}~{{\mathit{ft}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{tu}'}^\ast}~{\mathit{ct}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.................................................................................................................................


1. Return :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{{\mathit{tu}'}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}~{{\mathit{ct}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{\mathsf{rec}~{{\mathit{st}}^\ast}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...............................................................................................


1. Return :math:`(\mathsf{rec}~{{{\mathit{st}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast})`.


:math:`{{\mathit{qt}} {.} i}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.................................................................................


1. Return :math:`({{\mathit{qt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]} {.} i)`.


:math:`{{t_1^\ast}~\rightarrow~{t_2^\ast}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...............................................................................................


1. Return :math:`{{t_1}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}~\rightarrow~{{t_2}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}`.


:math:`{{\mathit{at}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{\mathit{at}}`.


:math:`{{\mathsf{mut}^?}~t}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
................................................................................


1. Return :math:`({\mathsf{mut}^?}~{t}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{{\mathit{at}}~{\mathit{lim}}~{\mathit{rt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
........................................................................................................


1. Return :math:`({\mathit{at}}~{\mathit{lim}}~{{\mathit{rt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{{\mathit{at}}~{\mathit{lim}}~\mathsf{page}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
........................................................................................................


1. Return :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.


:math:`{{\mathit{dt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{{\mathit{dt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.


:math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...................................................................................................................


1. If :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{func}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{dt}})` be :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`(\mathsf{func}~{{\mathit{dt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. If :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{global}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{gt}})` be :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`(\mathsf{global}~{{\mathit{gt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. If :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{table}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{tt}})` be :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`(\mathsf{table}~{{\mathit{tt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. If :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{mem}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{mt}})` be :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`(\mathsf{mem}~{{\mathit{mt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. Assert: Due to validation, :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{tag}`.

#. Let :math:`(\mathsf{tag}~{\mathit{jt}})` be :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`(\mathsf{tag}~{{\mathit{jt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{{{\mathit{xt}}_1^\ast}~\rightarrow~{{\mathit{xt}}_2^\ast}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.......................................................................................................................


1. Return :math:`{{{\mathit{xt}}_1}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}~\rightarrow~{{{\mathit{xt}}_2}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}`.


:math:`{t}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.............................................


1. Return :math:`{t}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{rt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{rt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{dt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{dt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{gt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{gt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{tt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{tt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{mt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{mt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{mmt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
..........................................................


1. Return :math:`{{\mathit{mmt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}}{{}[ {:=}\, {{\mathit{tu}}^\ast} ]}`
.........................................................................................................


1. If :math:`{{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{dt}}_1~{{\mathit{dt}}^\ast}` be :math:`{{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{{\mathit{dt}}_1}{{}[ {:=}\, {{\mathit{tu}}^\ast} ]}~{{{\mathit{dt}}^\ast}}{{}[ {:=}\, {{\mathit{tu}}^\ast} ]}`.


:math:`{{\mathrm{roll}}}_{x}({\mathit{rectype}})`
.................................................


1. Let :math:`(\mathsf{rec}~{{\mathit{subtype}}^{n}})` be :math:`{\mathit{rectype}}`.

#. Return :math:`(\mathsf{rec}~{{{\mathit{subtype}}}{{}[ {x + i^{i<n}} := {(\mathsf{rec}~i)^{i<n}} ]}^{n}})`.


:math:`{\mathrm{unroll}}({\mathit{rectype}})`
.............................................


1. Let :math:`(\mathsf{rec}~{{\mathit{subtype}}^{n}})` be :math:`{\mathit{rectype}}`.

#. Return :math:`(\mathsf{rec}~{{{\mathit{subtype}}}{{}[ {(\mathsf{rec}~i)^{i<n}} := {({\mathit{rectype}} {.} i)^{i<n}} ]}^{n}})`.


:math:`{{{{\mathrm{roll}}}_{x}^\ast}}{({\mathit{rectype}})}`
............................................................


1. Let :math:`(\mathsf{rec}~{{\mathit{subtype}}^{n}})` be :math:`{{\mathrm{roll}}}_{x}({\mathit{rectype}})`.

#. Return :math:`{((\mathsf{rec}~{{\mathit{subtype}}^{n}}) {.} i)^{i<n}}`.


:math:`{\mathrm{unroll}}({\mathit{rectype}} {.} i)`
...................................................


1. Let :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` be :math:`{\mathrm{unroll}}({\mathit{rectype}})`.

#. Return :math:`{{\mathit{subtype}}^\ast}{}[i]`.


:math:`{\mathrm{expand}}({\mathit{deftype}})`
.............................................


1. Let :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{comptype}})` be :math:`{\mathrm{unroll}}({\mathit{deftype}})`.

#. Return :math:`{\mathit{comptype}}`.






1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{align}~0,\; \mathsf{offset}~0 \}\end{array}`.


:math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{const}~c`
.......................................................................................


1. If :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

   a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`({\mathit{numtype}}{.}\mathsf{const}~c)`.

#. Assert: Due to validation, :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is vector type.

#. Let :math:`{\mathit{vectype}}` be :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`({\mathit{vectype}}{.}\mathsf{const}~c)`.


:math:`{\mathrm{free}}_{\mathit{opt}}({{\mathit{free}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?})`
...................................................................................................


1. If :math:`{{\mathit{free}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. Let :math:`{\mathit{free}}` be :math:`{{\mathit{free}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

#. Return :math:`{\mathit{free}}`.


:math:`{\mathrm{free}}_{\mathit{list}}({{\mathit{free}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................................


1. If :math:`{{\mathit{free}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. Let :math:`{\mathit{free}}~{{\mathit{free}'}^\ast}` be :math:`{{\mathit{free}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return `free ++ $free_list(free'*{free' <- free'*})`.


:math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{\mathit{typeidx}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{funcs}~{\mathit{funcidx}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{globalidx}}({\mathit{globalidx}})`
..................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{globals}~{\mathit{globalidx}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`
................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{tables}~{\mathit{tableidx}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`
............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{mems}~{\mathit{memidx}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{elemidx}}({\mathit{elemidx}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{elems}~{\mathit{elemidx}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{dataidx}}({\mathit{dataidx}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{datas}~{\mathit{dataidx}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{localidx}}({\mathit{localidx}})`
................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~{\mathit{localidx}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`
................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{labels}~{\mathit{labelidx}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{externidx}}({\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
...................................................................................................


1. If :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{func}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{funcidx}})` be :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.

#. If :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{global}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{globalidx}})` be :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{globalidx}}({\mathit{globalidx}})`.

#. If :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{table}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{tableidx}})` be :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. Assert: Due to validation, :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{mem}`.

#. Let :math:`(\mathsf{mem}~{\mathit{memidx}})` be :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`.


:math:`{\mathrm{free}}_{\mathit{addrtype}}({\mathit{addrtype}})`
................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{packtype}}({\mathit{packtype}})`
................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{lanetype}}({\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
..................................................................................................


1. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

   a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{packtype}}({\mathit{packtype}})`.


:math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{consttype}}({\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
..........................................................................................................


1. If :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

   a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. Assert: Due to validation, :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is vector type.

#. Let :math:`{\mathit{vectype}}` be :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.


:math:`{\mathrm{free}}_{\mathit{absheaptype}}({\mathit{absheaptype}})`
......................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{typevar}}({\mathit{tv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
.................................................................................................


1. If :math:`{\mathit{tv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is , then:

   a. Let :math:`{\mathit{typeidx}}` be :math:`{\mathit{tv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. Assert: Due to validation, :math:`{\mathit{tv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{rec}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{heaptype}}({\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
..................................................................................................


1. If :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is abstract heap type, then:

   a. Let :math:`{\mathit{absheaptype}}` be :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{absheaptype}}({\mathit{absheaptype}})`.

#. Assert: Due to validation, :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is type use.

#. Let :math:`{\mathit{typeuse}}` be :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{typeuse}})`.


:math:`{\mathrm{free}}_{\mathit{reftype}}(\mathsf{ref}~{\mathsf{null}^?}~{\mathit{heaptype}})`
..............................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{heaptype}}({\mathit{heaptype}})`.


:math:`{\mathrm{free}}_{\mathit{typeuse}}(y_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
.....................................................................................


1. If :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is type variable, then:

   a. Let :math:`{\mathit{typevar}}` be :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typevar}}({\mathit{typevar}})`.

#. Assert: Due to validation, :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is defined type.

#. Let :math:`{\mathit{deftype}}` be :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{deftype}}({\mathit{deftype}})`.


:math:`{\mathrm{free}}_{\mathit{valtype}}(t_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
.....................................................................................


1. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

   a. Let :math:`{\mathit{numtype}}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is vector type, then:

   a. Let :math:`{\mathit{vectype}}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is reference type, then:

   a. Let :math:`{\mathit{reftype}}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{reftype}}({\mathit{reftype}})`.

#. Assert: Due to validation, :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{bot}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{resulttype}}({{\mathit{valtype}}^\ast})`
........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})^\ast})`.


:math:`{\mathrm{free}}_{\mathit{storagetype}}({\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
.....................................................................................................


1. If :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is value type, then:

   a. Let :math:`{\mathit{valtype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})`.

#. Assert: Due to validation, :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{packtype}}({\mathit{packtype}})`.


:math:`{\mathrm{free}}_{\mathit{fieldtype}}({\mathsf{mut}^?}~{\mathit{storagetype}})`
.....................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{storagetype}}({\mathit{storagetype}})`.


:math:`{\mathrm{free}}_{\mathit{structtype}}({{\mathit{fieldtype}}^\ast})`
..........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{fieldtype}}({\mathit{fieldtype}})^\ast})`.


:math:`{\mathrm{free}}_{\mathit{arraytype}}({\mathit{fieldtype}})`
..................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{fieldtype}}({\mathit{fieldtype}})`.


:math:`{\mathrm{free}}_{\mathit{functype}}({\mathit{resulttype}}_1~\rightarrow~{\mathit{resulttype}}_2)`
........................................................................................................


1. Return `$free_resulttype(resulttype_1) ++ $free_resulttype(resulttype_2)`.


:math:`{\mathrm{free}}_{\mathit{comptype}}({\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
..................................................................................................


1. If :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{struct}`, then:

   a. Let :math:`(\mathsf{struct}~{\mathit{structtype}})` be :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{structtype}}({\mathit{structtype}})`.

#. If :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{array}`, then:

   a. Let :math:`(\mathsf{array}~{\mathit{arraytype}})` be :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{arraytype}}({\mathit{arraytype}})`.

#. Assert: Due to validation, :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{func}`.

#. Let :math:`(\mathsf{func}~{\mathit{functype}})` be :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{functype}}({\mathit{functype}})`.


:math:`{\mathrm{free}}_{\mathit{subtype}}(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{comptype}})`
.........................................................................................................................


1. Return `$free_list($free_typeuse(typeuse)*{typeuse <- typeuse*}) ++ $free_comptype(comptype)`.


:math:`{\mathrm{free}}_{\mathit{rectype}}(\mathsf{rec}~{{\mathit{subtype}}^\ast})`
..................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{subtype}}({\mathit{subtype}})^\ast})`.


:math:`{\mathrm{free}}_{\mathit{deftype}}({\mathit{rectype}} {.} n)`
....................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{rectype}}({\mathit{rectype}})`.


:math:`{\mathrm{free}}_{\mathit{globaltype}}({\mathsf{mut}^?}~{\mathit{valtype}})`
..................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})`.


:math:`{\mathrm{free}}_{\mathit{tabletype}}({\mathit{addrtype}}~{\mathit{limits}}~{\mathit{reftype}})`
......................................................................................................


1. Return `$free_addrtype(addrtype) ++ $free_reftype(reftype)`.


:math:`{\mathrm{free}}_{\mathit{memtype}}({\mathit{addrtype}}~{\mathit{limits}}~\mathsf{page})`
...............................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{addrtype}}({\mathit{addrtype}})`.


:math:`{\mathrm{free}}_{\mathit{tagtype}}({\mathit{deftype}})`
..............................................................


1. Return :math:`{\mathrm{free}}_{\mathit{deftype}}({\mathit{deftype}})`.


:math:`{\mathrm{free}}_{\mathit{elemtype}}({\mathit{reftype}})`
...............................................................


1. Return :math:`{\mathrm{free}}_{\mathit{reftype}}({\mathit{reftype}})`.


:math:`{\mathrm{free}}_{\mathit{datatype}}(\mathsf{ok})`
........................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{externtype}}({\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
....................................................................................................


1. If :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{func}`, then:

   a. Let :math:`(\mathsf{func}~{\mathit{typeuse}})` be :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{typeuse}})`.

#. If :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{global}`, then:

   a. Let :math:`(\mathsf{global}~{\mathit{globaltype}})` be :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{globaltype}}({\mathit{globaltype}})`.

#. If :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{table}`, then:

   a. Let :math:`(\mathsf{table}~{\mathit{tabletype}})` be :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tabletype}}({\mathit{tabletype}})`.

#. If :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{mem}`, then:

   a. Let :math:`(\mathsf{mem}~{\mathit{memtype}})` be :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{memtype}}({\mathit{memtype}})`.

#. Assert: Due to validation, :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{tag}`.

#. Let :math:`(\mathsf{tag}~{\mathit{tagtype}})` be :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{tagtype}}({\mathit{tagtype}})`.


:math:`{\mathrm{free}}_{\mathit{moduletype}}({{\mathit{externtype}}_1^\ast}~\rightarrow~{{\mathit{externtype}}_2^\ast})`
........................................................................................................................


1. Return `$free_list($free_externtype(externtype_1)*{externtype_1 <- externtype_1*}) ++ $free_list($free_externtype(externtype_2)*{externtype_2 <- externtype_2*})`.


:math:`{\mathrm{free}}_{\mathit{shape}}({{\mathit{lanetype}}}{\mathsf{x}}{{\mathit{dim}}})`
...........................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{lanetype}}({\mathit{lanetype}})`.


:math:`{\mathrm{free}}_{\mathit{blocktype}}({\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
...................................................................................................


1. If :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is , then:

   a. Let :math:`{{\mathit{valtype}}^?}` be :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{opt}}({{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})^?})`.

#. Assert: Due to validation, :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is .

#. Let :math:`{\mathit{funcidx}}` be :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.


:math:`{\mathrm{shift}}_{\mathit{labelidxs}}({l_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
...............................................................................................


1. If :math:`{l_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{labelidx}}_0~{{\mathit{labelidx}'}^\ast}` be :math:`{l_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{labelidx}}_0 = 0`, then:

   a. Return :math:`{\mathrm{shift}}_{\mathit{labelidxs}}({{\mathit{labelidx}'}^\ast})`.

#. Let :math:`{\mathit{labelidx}}~{{\mathit{labelidx}'}^\ast}` be :math:`{l_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathit{labelidx}} - 1~{\mathrm{shift}}_{\mathit{labelidxs}}({{\mathit{labelidx}'}^\ast})`.


:math:`{\mathrm{free}}_{\mathit{instr}}({\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
..................................................................................................


1. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{nop}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{unreachable}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{drop}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{select}`, then:

   a. Let :math:`(\mathsf{select}~{({{\mathit{valtype}}^\ast})^?})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{opt}}({{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})^\ast})^?})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{block}`, then:

   a. Let :math:`(\mathsf{block}~{\mathit{blocktype}}~{{\mathit{instr}}^\ast})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_blocktype(blocktype) ++ $free_block(instr*{instr <- instr*})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{loop}`, then:

   a. Let :math:`(\mathsf{loop}~{\mathit{blocktype}}~{{\mathit{instr}}^\ast})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_blocktype(blocktype) ++ $free_block(instr*{instr <- instr*})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{if}`, then:

   a. Let :math:`(\mathsf{if}~{\mathit{blocktype}}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_blocktype(blocktype) ++ $free_block(instr_1*{instr_1 <- instr_1*}) ++ $free_block(instr_2*{instr_2 <- instr_2*})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{br}`, then:

   a. Let :math:`(\mathsf{br}~{\mathit{labelidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{br\_if}`, then:

   a. Let :math:`(\mathsf{br\_if}~{\mathit{labelidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{br\_table}`, then:

   a. Let :math:`(\mathsf{br\_table}~{{\mathit{labelidx}}^\ast}~{\mathit{labelidx}'})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_list($free_labelidx(labelidx)*{}) ++ $free_labelidx(labelidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{br\_on\_null}`, then:

   a. Let :math:`(\mathsf{br\_on\_null}~{\mathit{labelidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{br\_on\_non\_null}`, then:

   a. Let :math:`(\mathsf{br\_on\_non\_null}~{\mathit{labelidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{br\_on\_cast}`, then:

   a. Let :math:`(\mathsf{br\_on\_cast}~{\mathit{labelidx}}~{\mathit{reftype}}_1~{\mathit{reftype}}_2)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_labelidx(labelidx) ++ $free_reftype(reftype_1) ++ $free_reftype(reftype_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{br\_on\_cast\_fail}`, then:

   a. Let :math:`(\mathsf{br\_on\_cast\_fail}~{\mathit{labelidx}}~{\mathit{reftype}}_1~{\mathit{reftype}}_2)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_labelidx(labelidx) ++ $free_reftype(reftype_1) ++ $free_reftype(reftype_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{call}`, then:

   a. Let :math:`(\mathsf{call}~{\mathit{funcidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{call\_ref}`, then:

   a. Let :math:`(\mathsf{call\_ref}~{\mathit{typeuse}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{typeuse}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{call\_indirect}`, then:

   a. Let :math:`(\mathsf{call\_indirect}~{\mathit{tableidx}}~{\mathit{typeuse}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_tableidx(tableidx) ++ $free_typeuse(typeuse)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{return}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{return\_call}`, then:

   a. Let :math:`(\mathsf{return\_call}~{\mathit{funcidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{return\_call\_ref}`, then:

   a. Let :math:`(\mathsf{return\_call\_ref}~{\mathit{typeuse}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{typeuse}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{return\_call\_indirect}`, then:

   a. Let :math:`(\mathsf{return\_call\_indirect}~{\mathit{tableidx}}~{\mathit{typeuse}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_tableidx(tableidx) ++ $free_typeuse(typeuse)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{const}`, then:

   a. Let :math:`({\mathit{numtype}}{.}\mathsf{const}~{\mathit{numlit}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{unop}`, then:

   a. Let :math:`({\mathit{numtype}} {.} {\mathit{unop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{binop}`, then:

   a. Let :math:`({\mathit{numtype}} {.} {\mathit{binop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{testop}`, then:

   a. Let :math:`({\mathit{numtype}} {.} {\mathit{testop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{relop}`, then:

   a. Let :math:`({\mathit{numtype}} {.} {\mathit{relop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{cvtop}`, then:

   a. Let :math:`({\mathit{numtype}}_1 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{numtype}}_2})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_numtype(numtype_1) ++ $free_numtype(numtype_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vconst}`, then:

   a. Let :math:`({\mathit{vectype}}{.}\mathsf{const}~{\mathit{veclit}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vvunop}`, then:

   a. Let :math:`({\mathit{vectype}} {.} {\mathit{vvunop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vvbinop}`, then:

   a. Let :math:`({\mathit{vectype}} {.} {\mathit{vvbinop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vvternop}`, then:

   a. Let :math:`({\mathit{vectype}} {.} {\mathit{vvternop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vvtestop}`, then:

   a. Let :math:`({\mathit{vectype}} {.} {\mathit{vvtestop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vunop}`, then:

   a. Let :math:`({\mathit{shape}} {.} {\mathit{vunop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vbinop}`, then:

   a. Let :math:`({\mathit{shape}} {.} {\mathit{vbinop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vternop}`, then:

   a. Let :math:`({\mathit{shape}} {.} {\mathit{vternop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vtestop}`, then:

   a. Let :math:`({\mathit{shape}} {.} {\mathit{vtestop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vrelop}`, then:

   a. Let :math:`({\mathit{shape}} {.} {\mathit{vrelop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vshiftop}`, then:

   a. Let :math:`({\mathit{ishape}} {.} {\mathit{vshiftop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{ishape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vbitmask}`, then:

   a. Let :math:`({\mathit{ishape}}{.}\mathsf{bitmask})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{ishape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vswizzlop}`, then:

   a. Let :math:`({\mathit{bshape}} {.} {\mathit{vswizzlop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{bshape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vshuffle}`, then:

   a. Let :math:`({\mathit{bshape}}{.}\mathsf{shuffle}~{{\mathit{laneidx}}^\ast})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{bshape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vextunop}`, then:

   a. Let :math:`({\mathit{ishape}}_1 {.} {{\mathit{vextunop}}}{\mathsf{\_}}{{\mathit{ishape}}_2})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_shape(ishape_1) ++ $free_shape(ishape_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vextbinop}`, then:

   a. Let :math:`({\mathit{ishape}}_1 {.} {{\mathit{vextbinop}}}{\mathsf{\_}}{{\mathit{ishape}}_2})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_shape(ishape_1) ++ $free_shape(ishape_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vnarrow}`, then:

   a. Let :math:`({{\mathit{ishape}}_1{.}\mathsf{narrow}}{\mathsf{\_}}{{\mathit{ishape}}_2}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_shape(ishape_1) ++ $free_shape(ishape_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vcvtop}`, then:

   a. Let :math:`({\mathit{shape}}_1 {.} {{\mathit{vcvtop}}}{\mathsf{\_}}{{{\mathit{zero}}^?}}{\mathsf{\_}}{{\mathit{shape}}_2}{\mathsf{\_}}{{{\mathit{half}}^?}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_shape(shape_1) ++ $free_shape(shape_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vsplat}`, then:

   a. Let :math:`({\mathit{shape}}{.}\mathsf{splat})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vextract\_lane}`, then:

   a. Let :math:`({{\mathit{shape}}{.}\mathsf{extract\_lane}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~{\mathit{laneidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vreplace\_lane}`, then:

   a. Let :math:`({\mathit{shape}}{.}\mathsf{replace\_lane}~{\mathit{laneidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}null}`, then:

   a. Let :math:`(\mathsf{ref{.}null}~{\mathit{heaptype}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{heaptype}}({\mathit{heaptype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ref{.}is\_null}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ref{.}as\_non\_null}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ref{.}eq}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}test}`, then:

   a. Let :math:`(\mathsf{ref{.}test}~{\mathit{reftype}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{reftype}}({\mathit{reftype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}cast}`, then:

   a. Let :math:`(\mathsf{ref{.}cast}~{\mathit{reftype}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{reftype}}({\mathit{reftype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref{.}func}`, then:

   a. Let :math:`(\mathsf{ref{.}func}~{\mathit{funcidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ref{.}i{\scriptstyle 31}}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{i{\scriptstyle 31}{.}get}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{struct{.}new}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{struct{.}new\_default}`, then:

   a. Let :math:`(\mathsf{struct{.}new\_default}~{\mathit{typeidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{struct{.}get}`, then:

   a. Let :math:`({\mathsf{struct{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~{\mathit{typeidx}}~{\mathit{u{\kern-0.1em\scriptstyle 32}}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{struct{.}set}`, then:

   a. Let :math:`(\mathsf{struct{.}set}~{\mathit{typeidx}}~{\mathit{u{\kern-0.1em\scriptstyle 32}}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{array{.}new}`, then:

   a. Let :math:`(\mathsf{array{.}new}~{\mathit{typeidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{array{.}new\_default}`, then:

   a. Let :math:`(\mathsf{array{.}new\_default}~{\mathit{typeidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{array{.}new\_fixed}`, then:

   a. Let :math:`(\mathsf{array{.}new\_fixed}~{\mathit{typeidx}}~{\mathit{u{\kern-0.1em\scriptstyle 32}}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{array{.}new\_data}`, then:

   a. Let :math:`(\mathsf{array{.}new\_data}~{\mathit{typeidx}}~{\mathit{dataidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_typeidx(typeidx) ++ $free_dataidx(dataidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{array{.}new\_elem}`, then:

   a. Let :math:`(\mathsf{array{.}new\_elem}~{\mathit{typeidx}}~{\mathit{elemidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_typeidx(typeidx) ++ $free_elemidx(elemidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{array{.}get}`, then:

   a. Let :math:`({\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~{\mathit{typeidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{array{.}set}`, then:

   a. Let :math:`(\mathsf{array{.}set}~{\mathit{typeidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{array{.}len}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{array{.}fill}`, then:

   a. Let :math:`(\mathsf{array{.}fill}~{\mathit{typeidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{array{.}copy}`, then:

   a. Let :math:`(\mathsf{array{.}copy}~{\mathit{typeidx}}_1~{\mathit{typeidx}}_2)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_typeidx(typeidx_1) ++ $free_typeidx(typeidx_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{array{.}init\_data}`, then:

   a. Let :math:`(\mathsf{array{.}init\_data}~{\mathit{typeidx}}~{\mathit{dataidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_typeidx(typeidx) ++ $free_dataidx(dataidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{array{.}init\_elem}`, then:

   a. Let :math:`(\mathsf{array{.}init\_elem}~{\mathit{typeidx}}~{\mathit{elemidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_typeidx(typeidx) ++ $free_elemidx(elemidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{extern{.}convert\_any}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{any{.}convert\_extern}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{local{.}get}`, then:

   a. Let :math:`(\mathsf{local{.}get}~{\mathit{localidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{localidx}}({\mathit{localidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{local{.}set}`, then:

   a. Let :math:`(\mathsf{local{.}set}~{\mathit{localidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{localidx}}({\mathit{localidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{local{.}tee}`, then:

   a. Let :math:`(\mathsf{local{.}tee}~{\mathit{localidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{localidx}}({\mathit{localidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{global{.}get}`, then:

   a. Let :math:`(\mathsf{global{.}get}~{\mathit{globalidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{globalidx}}({\mathit{globalidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{global{.}set}`, then:

   a. Let :math:`(\mathsf{global{.}set}~{\mathit{globalidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{globalidx}}({\mathit{globalidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{table{.}get}`, then:

   a. Let :math:`(\mathsf{table{.}get}~{\mathit{tableidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{table{.}set}`, then:

   a. Let :math:`(\mathsf{table{.}set}~{\mathit{tableidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{table{.}size}`, then:

   a. Let :math:`(\mathsf{table{.}size}~{\mathit{tableidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{table{.}grow}`, then:

   a. Let :math:`(\mathsf{table{.}grow}~{\mathit{tableidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{table{.}fill}`, then:

   a. Let :math:`(\mathsf{table{.}fill}~{\mathit{tableidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{table{.}copy}`, then:

   a. Let :math:`(\mathsf{table{.}copy}~{\mathit{tableidx}}_1~{\mathit{tableidx}}_2)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_tableidx(tableidx_1) ++ $free_tableidx(tableidx_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{table{.}init}`, then:

   a. Let :math:`(\mathsf{table{.}init}~{\mathit{tableidx}}~{\mathit{elemidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_tableidx(tableidx) ++ $free_elemidx(elemidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{elem{.}drop}`, then:

   a. Let :math:`(\mathsf{elem{.}drop}~{\mathit{elemidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{elemidx}}({\mathit{elemidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{load}`, then:

   a. Let :math:`({{\mathit{numtype}}{.}\mathsf{load}}{{{\mathit{loadop}}^?}}~{\mathit{memidx}}~{\mathit{memarg}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_numtype(numtype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{store}`, then:

   a. Let :math:`({{\mathit{numtype}}{.}\mathsf{store}}{{{\mathit{storeop}}^?}}~{\mathit{memidx}}~{\mathit{memarg}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_numtype(numtype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vload}`, then:

   a. Let :math:`({{\mathit{vectype}}{.}\mathsf{load}}{{{\mathit{vloadop}}^?}}~{\mathit{memidx}}~{\mathit{memarg}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_vectype(vectype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vload\_lane}`, then:

   a. Let :math:`({{\mathit{vectype}}{.}\mathsf{load}}{{\mathit{sz}}}{\mathsf{\_}}{\mathsf{lane}}~{\mathit{memidx}}~{\mathit{memarg}}~{\mathit{laneidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_vectype(vectype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vstore}`, then:

   a. Let :math:`({\mathit{vectype}}{.}\mathsf{store}~{\mathit{memidx}}~{\mathit{memarg}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_vectype(vectype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{vstore\_lane}`, then:

   a. Let :math:`({{\mathit{vectype}}{.}\mathsf{store}}{{\mathit{sz}}}{\mathsf{\_}}{\mathsf{lane}}~{\mathit{memidx}}~{\mathit{memarg}}~{\mathit{laneidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_vectype(vectype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{memory{.}size}`, then:

   a. Let :math:`(\mathsf{memory{.}size}~{\mathit{memidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{memory{.}grow}`, then:

   a. Let :math:`(\mathsf{memory{.}grow}~{\mathit{memidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{memory{.}fill}`, then:

   a. Let :math:`(\mathsf{memory{.}fill}~{\mathit{memidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{memory{.}copy}`, then:

   a. Let :math:`(\mathsf{memory{.}copy}~{\mathit{memidx}}_1~{\mathit{memidx}}_2)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_memidx(memidx_1) ++ $free_memidx(memidx_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{memory{.}init}`, then:

   a. Let :math:`(\mathsf{memory{.}init}~{\mathit{memidx}}~{\mathit{dataidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_memidx(memidx) ++ $free_dataidx(dataidx)`.

#. Assert: Due to validation, :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{data{.}drop}`.

#. Let :math:`(\mathsf{data{.}drop}~{\mathit{dataidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{dataidx}}({\mathit{dataidx}})`.


:math:`{\mathrm{free}}_{\mathit{block}}({{\mathit{instr}}^\ast})`
.................................................................


1. Let :math:`{\mathit{free}}` be :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{instr}}({\mathit{instr}})^\ast})`.

#. Return :math:`{\mathit{free}}{}[{.}\mathsf{labels} = {\mathrm{shift}}_{\mathit{labelidxs}}({\mathit{free}}{.}\mathsf{labels})]`.


:math:`{\mathrm{free}}_{\mathit{expr}}({{\mathit{instr}}^\ast})`
................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{instr}}({\mathit{instr}})^\ast})`.


:math:`{\mathrm{free}}_{\mathit{type}}(\mathsf{type}~{\mathit{rectype}})`
.........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{rectype}}({\mathit{rectype}})`.


:math:`{\mathrm{free}}_{\mathit{local}}(\mathsf{local}~t)`
..........................................................


1. Return :math:`{\mathrm{free}}_{\mathit{valtype}}(t)`.


:math:`{\mathrm{free}}_{\mathit{func}}(\mathsf{func}~{\mathit{typeidx}}~{{\mathit{local}}^\ast}~{\mathit{expr}})`
.................................................................................................................


1. Return `$free_typeidx(typeidx) ++ $free_list($free_local(local)*{local <- local*}) ++ update($free_block(expr).LOCALS, [])`.


:math:`{\mathrm{free}}_{\mathit{global}}(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}})`
................................................................................................


1. Return `$free_globaltype(globaltype) ++ $free_expr(expr)`.


:math:`{\mathrm{free}}_{\mathit{table}}(\mathsf{table}~{\mathit{tabletype}}~{\mathit{expr}})`
.............................................................................................


1. Return `$free_tabletype(tabletype) ++ $free_expr(expr)`.


:math:`{\mathrm{free}}_{\mathit{mem}}(\mathsf{memory}~{\mathit{memtype}})`
..........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{memtype}}({\mathit{memtype}})`.


:math:`{\mathrm{free}}_{\mathit{tag}}(\mathsf{tag}~{\mathit{typeidx}})`
.......................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.


:math:`{\mathrm{free}}_{\mathit{elemmode}}({\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
........................................................................................................


1. If :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{active}`, then:

   a. Let :math:`(\mathsf{active}~{\mathit{tableidx}}~{\mathit{expr}})` be :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_tableidx(tableidx) ++ $free_expr(expr)`.

#. If :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{passive}`, then:

   a. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.

#. Assert: Due to validation, :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{declare}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{elem}}(\mathsf{elem}~{\mathit{reftype}}~{{\mathit{expr}}^\ast}~{\mathit{elemmode}})`
....................................................................................................................


1. Return `$free_reftype(reftype) ++ $free_list($free_expr(expr)*{expr <- expr*}) ++ $free_elemmode(elemmode)`.


:math:`{\mathrm{free}}_{\mathit{datamode}}({\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
........................................................................................................


1. If :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{active}`, then:

   a. Let :math:`(\mathsf{active}~{\mathit{memidx}}~{\mathit{expr}})` be :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return `$free_memidx(memidx) ++ $free_expr(expr)`.

#. Assert: Due to validation, :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{passive}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{data}}(\mathsf{data}~{{\mathit{byte}}^\ast}~{\mathit{datamode}})`
.................................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{datamode}}({\mathit{datamode}})`.


:math:`{\mathrm{free}}_{\mathit{start}}(\mathsf{start}~{\mathit{funcidx}})`
...........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.


:math:`{\mathrm{free}}_{\mathit{export}}(\mathsf{export}~{\mathit{name}}~{\mathit{externidx}})`
...............................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{externidx}}({\mathit{externidx}})`.


:math:`{\mathrm{free}}_{\mathit{import}}(\mathsf{import}~{\mathit{name}}_1~{\mathit{name}}_2~{\mathit{externtype}})`
....................................................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{externtype}}({\mathit{externtype}})`.


:math:`{\mathrm{free}}_{\mathit{module}}(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{tag}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})`
..........................................................................................................................................................................................................................................................................................................................


1. Return `$free_list($free_type(type)*{type <- type*}) ++ $free_list($free_import(import)*{import <- import*}) ++ $free_list($free_func(func)*{func <- func*}) ++ $free_list($free_global(global)*{global <- global*}) ++ $free_list($free_table(table)*{table <- table*}) ++ $free_list($free_mem(mem)*{mem <- mem*}) ++ $free_list($free_tag(tag)*{tag <- tag*}) ++ $free_list($free_elem(elem)*{elem <- elem*}) ++ $free_list($free_data(data)*{data <- data*}) ++ $free_opt($free_start(start)?{start <- start?}) ++ $free_list($free_export(export)*{export <- export*})`.


:math:`{\mathrm{funcidx}}({\mathit{module}})`
.............................................


1. Return :math:`{\mathrm{free}}_{\mathit{module}}({\mathit{module}}){.}\mathsf{funcs}`.


:math:`{\mathrm{dataidx}}({{\mathit{func}}^\ast})`
..................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{func}}({\mathit{func}})^\ast}){.}\mathsf{datas}`.


:math:`C{}[{.}\mathsf{local}{}[{{\mathit{localidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}] = {{{\mathit{lt}}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}]`
.....................................................................................................................................................................


1. If :math:`{{\mathit{localidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon` and :math:`{{{\mathit{lt}}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`C`.

#. Assert: Due to validation, :math:`{|{{{\mathit{lt}}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{{\mathit{lt}}}_1~{{{\mathit{lt}}}^\ast}` be :math:`{{{\mathit{lt}}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{localidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`x_1~{x^\ast}` be :math:`{{\mathit{localidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`C{}[{.}\mathsf{locals}{}[x_1] = {{\mathit{lt}}}_1]{}[{.}\mathsf{local}{}[{x^\ast}] = {{{\mathit{lt}}}^\ast}]`.


:math:`{{{\mathrm{clos}}^\ast}}{({{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
................................................................................................


1. If :math:`{{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{{\mathit{dt}}^\ast}~{\mathit{dt}}_n` be :math:`{{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{{\mathit{dt}'}^\ast}` be :math:`{{{\mathrm{clos}}^\ast}}{({{\mathit{dt}}^\ast})}`.

#. Return :math:`{{\mathit{dt}'}^\ast}~{{\mathit{dt}}_n}{{}[ {:=}\, {{\mathit{dt}'}^\ast} ]}`.


:math:`{{\mathrm{clos}}}_{C}(t)`
................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{{{\mathrm{clos}}^\ast}}{(C{.}\mathsf{types})}`.

#. Return :math:`{t}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{clos}}}_{C}({\mathit{dt}})`
............................................


1. Let :math:`{{\mathit{dt}'}^\ast}` be :math:`{{{\mathrm{clos}}^\ast}}{(C{.}\mathsf{types})}`.

#. Return :math:`{{\mathit{dt}}}{{}[ {:=}\, {{\mathit{dt}'}^\ast} ]}`.


:math:`{{\mathrm{clos}}}_{C}({\mathit{mmt}})`
.............................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{{{\mathrm{clos}}^\ast}}{(C{.}\mathsf{types})}`.

#. Return :math:`{{\mathit{mmt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}} \prec x, i`
............................................................


1. If :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is defined type, then:

   a. Return true.

#. If :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is , then:

   a. Let :math:`{\mathit{typeidx}}` be :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathit{typeidx}} < x`.

#. Assert: Due to validation, :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{rec}`.

#. Let :math:`(\mathsf{rec}~j)` be :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`j < i`.


:math:`{{\mathrm{unroll}}}_{C}({\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
......................................................................................


1. If :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is defined type, then:

   a. Let :math:`{\mathit{deftype}}` be :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{unroll}}({\mathit{deftype}})`.

#. If :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is , then:

   a. Let :math:`{\mathit{typeidx}}` be :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathrm{unroll}}(C{.}\mathsf{types}{}[{\mathit{typeidx}}])`.

#. Assert: Due to validation, :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{rec}`.

#. Let :math:`(\mathsf{rec}~i)` be :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`C{.}\mathsf{recs}{}[i]`.


:math:`{{\mathrm{default}}}_{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}`
........................................................................


1. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{N}`, then:

   a. Let :math:`{\mathsf{i}}{N}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`({\mathsf{i}}{N}{.}\mathsf{const}~0)`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{N}`, then:

   a. Let :math:`{\mathsf{f}}{N}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`({\mathsf{f}}{N}{.}\mathsf{const}~{+0})`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{v}}{N}`, then:

   a. Let :math:`{\mathsf{v}}{N}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`({\mathsf{v}}{N}{.}\mathsf{const}~0)`.

#. Assert: Due to validation, :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ref}`.

#. Let :math:`(\mathsf{ref}~{\mathit{NULL}}_{{\mathit{opt}}_0}~{\mathit{ht}})` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{NULL}}_{{\mathit{opt}}_0} = \mathsf{null}`, then:

   a. Return :math:`(\mathsf{ref{.}null}~{\mathit{ht}})`.

#. Assert: Due to validation, :math:`{\mathit{NULL}}_{{\mathit{opt}}_0}` is not defined.

#. Return :math:`\epsilon`.


:math:`{\mathrm{funcidx}}({{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast})`
................................................................................................................................................


1. Return :math:`{\mathrm{funcidx}}(\mathsf{module}~\epsilon~\epsilon~\epsilon~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~\epsilon~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~\epsilon~\epsilon)`.


:math:`{{\mathrm{relaxed}}(i)}{{}[ X_1, X_2 ]}`
...............................................


1. If :math:`{\mathrm{ND}}`, then:

   a. Return :math:`X_1~X_2{}[i]`.

#. Return :math:`X_1~X_2{}[0]`.


:math:`{{\mathrm{relaxed}}(i)}{{}[ X_1, X_2, X_3, X_4 ]}`
.........................................................


1. If :math:`{\mathrm{ND}}`, then:

   a. Return :math:`X_1~X_2~X_3~X_4{}[i]`.

#. Return :math:`X_1~X_2~X_3~X_4{}[0]`.


:math:`{{{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}^{{-1}}}}{({b^\ast})}`
...................................................................


1. Let :math:`n` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(n)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`n`.


:math:`{{{{\mathrm{bytes}}}_{{\mathsf{f}}{N}}^{{-1}}}}{({b^\ast})}`
...................................................................


1. Let :math:`p` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{f}}{N}}(p)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`p`.


:math:`{{\mathrm{signed}}}_{N}(i)`
..................................


1. If :math:`i < {2^{N - 1}}`, then:

   a. Return :math:`i`.

#. Assert: Due to validation, :math:`{2^{N - 1}} \leq i`.

#. Assert: Due to validation, :math:`i < {2^{N}}`.

#. Return :math:`i - {2^{N}}`.


:math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{(i)}`
...............................................


1. Let :math:`j` be the result for which :math:`{{\mathrm{signed}}}_{N}(j)` :math:`=` :math:`i`.

#. Return :math:`j`.


:math:`{\mathrm{sx}}({\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
............................................................................


1. If :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is literal type, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Return :math:`\mathsf{s}`.


:math:`0`
.........


1. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{N}`, then:

   a. Return :math:`0`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{N}`.

#. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{+0}`.


:math:`\mathbb{B}(b_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
.............................................................


1. If :math:`b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is false, then:

   a. Return :math:`0`.

#. Assert: Due to validation, :math:`b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is true.

#. Return :math:`1`.


:math:`{{\mathrm{sat\_u}}}_{N}(i)`
..................................


1. If :math:`i < 0`, then:

   a. Return :math:`0`.

#. If :math:`i > {2^{N}} - 1`, then:

   a. Return :math:`{2^{N}} - 1`.

#. Return :math:`i`.


:math:`{{\mathrm{sat\_s}}}_{N}(i)`
..................................


1. If :math:`i < {-{2^{N - 1}}}`, then:

   a. Return :math:`{-{2^{N - 1}}}`.

#. If :math:`i > {2^{N - 1}} - 1`, then:

   a. Return :math:`{2^{N - 1}} - 1`.

#. Return :math:`i`.


:math:`{{\mathrm{ineg}}}_{N}(i_1)`
..................................


1. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({-{{\mathrm{signed}}}_{N}(i_1)})}`.


:math:`{{\mathrm{iabs}}}_{N}(i_1)`
..................................


1. If :math:`{{\mathrm{signed}}}_{N}(i_1) \geq 0`, then:

   a. Return :math:`i_1`.

#. Return :math:`{{\mathrm{ineg}}}_{N}(i_1)`.


:math:`{{{{\mathrm{iextend}}}_{N, M}^{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}}{(i)}`
....................................................................................................


1. If :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{u}`, then:

   a. Return :math:`i \mathbin{\mathrm{mod}} ({2^{M}})`.

#. Assert: Due to validation, :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{s}`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({{\mathrm{signed}}}_{M}(i \mathbin{\mathrm{mod}} ({2^{M}})))}`.


:math:`{{\mathrm{iadd}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`(i_1 + i_2) \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{\mathrm{isub}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`({2^{N}} + i_1 - i_2) \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{\mathrm{imul}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`i_1 \cdot i_2 \mathbin{\mathrm{mod}} ({2^{N}})`.


:math:`{{{{\mathrm{iadd\_sat}}}_{N}^{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}}{(i_1, i_2)}`
..........................................................................................................


1. If :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{u}`, then:

   a. Return :math:`{{\mathrm{sat\_u}}}_{N}(i_1 + i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{s}`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({{\mathrm{sat\_s}}}_{N}({{\mathrm{signed}}}_{N}(i_1) + {{\mathrm{signed}}}_{N}(i_2)))}`.


:math:`{{{{\mathrm{isub\_sat}}}_{N}^{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}}{(i_1, i_2)}`
..........................................................................................................


1. If :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{u}`, then:

   a. Return :math:`{{\mathrm{sat\_u}}}_{N}(i_1 - i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{s}`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({{\mathrm{sat\_s}}}_{N}({{\mathrm{signed}}}_{N}(i_1) - {{\mathrm{signed}}}_{N}(i_2)))}`.


:math:`{{\mathrm{ieqz}}}_{N}(i_1)`
..................................


1. Return :math:`\mathbb{B}(i_1 = 0)`.


:math:`{{\mathrm{inez}}}_{N}(i_1)`
..................................


1. Return :math:`\mathbb{B}(i_1 \neq 0)`.


:math:`{{\mathrm{ieq}}}_{N}(i_1, i_2)`
......................................


1. Return :math:`\mathbb{B}(i_1 = i_2)`.


:math:`{{\mathrm{ine}}}_{N}(i_1, i_2)`
......................................


1. Return :math:`\mathbb{B}(i_1 \neq i_2)`.


:math:`{{{{\mathrm{ilt}}}_{N}^{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}}{(i_1, i_2)}`
....................................................................................................


1. If :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 < i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) < {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{{{\mathrm{igt}}}_{N}^{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}}{(i_1, i_2)}`
....................................................................................................


1. If :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 > i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) > {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{{{\mathrm{ile}}}_{N}^{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}}{(i_1, i_2)}`
....................................................................................................


1. If :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 \leq i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) \leq {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{{{\mathrm{ige}}}_{N}^{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}}{(i_1, i_2)}`
....................................................................................................


1. If :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{u}`, then:

   a. Return :math:`\mathbb{B}(i_1 \geq i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) \geq {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{\mathrm{pack}}}_{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}(c)`
....................................................................................


1. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

   a. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{\mathrm{wrap}}}_{{|{\mathrm{unpack}}({\mathit{packtype}})|}, {|{\mathit{packtype}}|}}(c)`.


:math:`{{\mathrm{unpack}}}_{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}(c)`
......................................................................................


1. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

   a. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{{{\mathrm{extend}}}_{{|{\mathit{packtype}}|}, {|{\mathrm{unpack}}({\mathit{packtype}})|}}^{\mathsf{u}}}}{(c)}`.


:math:`{{\mathrm{pack}}}_{{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}(c)`
....................................................................................


1. If :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is literal type, then:

   a. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{\mathrm{wrap}}}_{{|{\mathrm{unpack}}({\mathit{packtype}})|}, {|{\mathit{packtype}}|}}(c)`.


:math:`{{\mathrm{unpack}}}_{{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}(c)`
......................................................................................


1. If :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is literal type, then:

   a. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{{{\mathrm{extend}}}_{{|{\mathit{packtype}}|}, {|{\mathrm{unpack}}({\mathit{packtype}})|}}^{\mathsf{u}}}}{(c)}`.


:math:`{{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}(i_{\mathit{u{\kern-0.1em\scriptstyle 1}}})}`
........................................................................................................................................................................


1. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{N}`, then:

   a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Let :math:`i` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{clz}`, then:

      1) Return :math:`{{\mathrm{iclz}}}_{N}(i)`.

   #. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ctz}`, then:

      1) Return :math:`{{\mathrm{ictz}}}_{N}(i)`.

   #. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{popcnt}`, then:

      1) Return :math:`{{\mathrm{ipopcnt}}}_{N}(i)`.

   #. Assert: Due to validation, :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{extend}`.

   #. Let :math:`({\mathsf{extend}}{M}{\mathsf{\_}}{\mathsf{s}})` be :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{{{{\mathrm{iextend}}}_{N, M}^{\mathsf{s}}}}{(i)}`.

#. Assert: Due to validation, :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{N}`.

#. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`f` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{abs}`, then:

   a. Return :math:`{{\mathrm{fabs}}}_{N}(f)`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{neg}`, then:

   a. Return :math:`{{\mathrm{fneg}}}_{N}(f)`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sqrt}`, then:

   a. Return :math:`{{\mathrm{fsqrt}}}_{N}(f)`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ceil}`, then:

   a. Return :math:`{{\mathrm{fceil}}}_{N}(f)`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{floor}`, then:

   a. Return :math:`{{\mathrm{ffloor}}}_{N}(f)`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{trunc}`, then:

   a. Return :math:`{{\mathrm{ftrunc}}}_{N}(f)`.

#. Assert: Due to validation, :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{nearest}`.

#. Return :math:`{{\mathrm{fnearest}}}_{N}(f)`.


:math:`{{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}(i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, i_{\mathit{u{\kern-0.1em\scriptstyle 2}}})}`
....................................................................................................................................................................................................................


1. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{N}`, then:

   a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Let :math:`i_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Let :math:`i_2` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{add}`, then:

      1) Return :math:`{{\mathrm{iadd}}}_{N}(i_1, i_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sub}`, then:

      1) Return :math:`{{\mathrm{isub}}}_{N}(i_1, i_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{mul}`, then:

      1) Return :math:`{{\mathrm{imul}}}_{N}(i_1, i_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{div}`, then:

      1) Let :math:`({\mathsf{div}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{idiv}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{rem}`, then:

      1) Let :math:`({\mathsf{rem}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{irem}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{and}`, then:

      1) Return :math:`{{\mathrm{iand}}}_{N}(i_1, i_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{or}`, then:

      1) Return :math:`{{\mathrm{ior}}}_{N}(i_1, i_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{xor}`, then:

      1) Return :math:`{{\mathrm{ixor}}}_{N}(i_1, i_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{shl}`, then:

      1) Return :math:`{{\mathrm{ishl}}}_{N}(i_1, i_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{shr}`, then:

      1) Let :math:`({\mathsf{shr}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{ishr}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{rotl}`, then:

      1) Return :math:`{{\mathrm{irotl}}}_{N}(i_1, i_2)`.

   #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{rotr}`, then:

      1) Return :math:`{{\mathrm{irotr}}}_{N}(i_1, i_2)`.

#. Assert: Due to validation, :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{N}`.

#. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`f_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`f_2` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{add}`, then:

   a. Return :math:`{{\mathrm{fadd}}}_{N}(f_1, f_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sub}`, then:

   a. Return :math:`{{\mathrm{fsub}}}_{N}(f_1, f_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{mul}`, then:

   a. Return :math:`{{\mathrm{fmul}}}_{N}(f_1, f_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{div}`, then:

   a. Return :math:`{{\mathrm{fdiv}}}_{N}(f_1, f_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{min}`, then:

   a. Return :math:`{{\mathrm{fmin}}}_{N}(f_1, f_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{max}`, then:

   a. Return :math:`{{\mathrm{fmax}}}_{N}(f_1, f_2)`.

#. Assert: Due to validation, :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{copysign}`.

#. Return :math:`{{\mathrm{fcopysign}}}_{N}(f_1, f_2)`.


:math:`{\mathsf{eqz}}{{}_{{\mathsf{i}}{N}}(i)}`
...............................................


1. Return :math:`{{\mathrm{ieqz}}}_{N}(i)`.


:math:`{{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}(i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, i_{\mathit{u{\kern-0.1em\scriptstyle 2}}})}`
....................................................................................................................................................................................................................


1. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{N}`, then:

   a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Let :math:`i_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Let :math:`i_2` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

   #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{eq}`, then:

      1) Return :math:`{{\mathrm{ieq}}}_{N}(i_1, i_2)`.

   #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ne}`, then:

      1) Return :math:`{{\mathrm{ine}}}_{N}(i_1, i_2)`.

   #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{lt}`, then:

      1) Let :math:`({\mathsf{lt}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{ilt}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`.

   #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{gt}`, then:

      1) Let :math:`({\mathsf{gt}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{igt}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`.

   #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{le}`, then:

      1) Let :math:`({\mathsf{le}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{ile}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`.

   #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ge}`, then:

      1) Let :math:`({\mathsf{ge}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{ige}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`.

#. Assert: Due to validation, :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{N}`.

#. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`f_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`f_2` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{eq}`, then:

   a. Return :math:`{{\mathrm{feq}}}_{N}(f_1, f_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ne}`, then:

   a. Return :math:`{{\mathrm{fne}}}_{N}(f_1, f_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{lt}`, then:

   a. Return :math:`{{\mathrm{flt}}}_{N}(f_1, f_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{gt}`, then:

   a. Return :math:`{{\mathrm{fgt}}}_{N}(f_1, f_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{le}`, then:

   a. Return :math:`{{\mathrm{fle}}}_{N}(f_1, f_2)`.

#. Assert: Due to validation, :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ge}`.

#. Return :math:`{{\mathrm{fge}}}_{N}(f_1, f_2)`.


:math:`{{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, {\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}}(i_{\mathit{u{\kern-0.1em\scriptstyle 1}}})}`
................................................................................................................................................................................................................................


1. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{N}`, then:

   a. Let :math:`{{\mathsf{i}}{N}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is :math:`{\mathsf{i}}{N}`, then:

      1) Let :math:`{{\mathsf{i}}{N}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

      #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{extend}`, then:

         a) Let :math:`({\mathsf{extend}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Let :math:`i_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Return :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(i_1)}`.

      #) Let :math:`i_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{wrap}`, then:

         a) Return :math:`{{\mathrm{wrap}}}_{N_1, N_2}(i_1)`.

#. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{N}`, then:

   a. Let :math:`{{\mathsf{f}}{N}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is :math:`{\mathsf{i}}{N}`, then:

      1) Let :math:`{{\mathsf{i}}{N}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

      #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{trunc}`, then:

         a) Let :math:`({\mathsf{trunc}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Let :math:`f_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Return :math:`{{{{\mathrm{trunc}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(f_1)}`.

      #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{trunc\_sat}`, then:

         a) Let :math:`({\mathsf{trunc\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Let :math:`f_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Return :math:`{{{{\mathrm{trunc\_sat}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(f_1)}`.

#. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{N}`, then:

   a. Let :math:`{{\mathsf{i}}{N}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is :math:`{\mathsf{f}}{N}`, then:

      1) Let :math:`{{\mathsf{f}}{N}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

      #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{convert}`, then:

         a) Let :math:`({\mathsf{convert}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Let :math:`i_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Return :math:`{{{{\mathrm{convert}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(i_1)}`.

#. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{N}`, then:

   a. Let :math:`{{\mathsf{f}}{N}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is :math:`{\mathsf{f}}{N}`, then:

      1) Let :math:`{{\mathsf{f}}{N}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

      #) Let :math:`f_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{promote}`, then:

         a) Return :math:`{{\mathrm{promote}}}_{N_1, N_2}(f_1)`.

      #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{demote}`, then:

         a) Return :math:`{{\mathrm{demote}}}_{N_1, N_2}(f_1)`.

#. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{N}`, then:

   a. Let :math:`{{\mathsf{i}}{N}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is :math:`{\mathsf{f}}{N}`, then:

      1) Let :math:`{{\mathsf{f}}{N}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

      #) Let :math:`i_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{reinterpret}` and :math:`{|{{\mathsf{i}}{N}}_1|} = {|{{\mathsf{f}}{N}}_2|}`, then:

         a) Return :math:`{{\mathrm{reinterpret}}}_{{{\mathsf{i}}{N}}_1, {{\mathsf{f}}{N}}_2}(i_1)`.

#. Assert: Due to validation, :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{N}`.

#. Let :math:`{{\mathsf{f}}{N}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Assert: Due to validation, :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is :math:`{\mathsf{i}}{N}`.

#. Let :math:`{{\mathsf{i}}{N}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

#. Let :math:`f_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Assert: Due to validation, :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{reinterpret}`.

#. Assert: Due to validation, :math:`{|{{\mathsf{f}}{N}}_1|} = {|{{\mathsf{i}}{N}}_2|}`.

#. Return :math:`{{\mathrm{reinterpret}}}_{{{\mathsf{f}}{N}}_1, {{\mathsf{i}}{N}}_2}(f_1)`.


:math:`{{{{\mathrm{lanes}}}_{{\mathit{sh}}}^{{-1}}}}{({c^\ast})}`
.................................................................


1. Let :math:`{\mathit{vc}}` be the result for which :math:`{{\mathrm{lanes}}}_{{\mathit{sh}}}({\mathit{vc}})` :math:`=` :math:`{c^\ast}`.

#. Return :math:`{\mathit{vc}}`.


:math:`{\mathrm{half}}({\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, i, j)`
......................................................................................


1. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{N}` and :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is :math:`{\mathsf{i}}{N}`, then:

   a. If :math:`{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{low}`, then:

      1) Return :math:`i`.

   #. If :math:`{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{high}`, then:

      1) Return :math:`j`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is :math:`{\mathsf{f}}{N}`.

#. Assert: Due to validation, :math:`{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{low}`.

#. Return :math:`i`.


:math:`{{\mathrm{iswizzle}}_{{\mathit{lane}}}}_{N}({c^\ast}, i)`
................................................................


1. If :math:`i < {|{c^\ast}|}`, then:

   a. Return :math:`{c^\ast}{}[i]`.

#. Return :math:`0`.


:math:`{{\mathrm{irelaxed}}_{{\mathit{swizzle}}_{{\mathit{lane}}}}}_{N}({c^\ast}, i)`
.....................................................................................


1. If :math:`i < {|{c^\ast}|}`, then:

   a. Return :math:`{c^\ast}{}[i]`.

#. If :math:`{{\mathrm{signed}}}_{N}(i) < 0`, then:

   a. Return :math:`0`.

#. Return :math:`{{\mathrm{relaxed}}({\mathrm{R}}_{\mathit{swizzle}})}{{}[ 0, {c^\ast}{}[i \mathbin{\mathrm{mod}} {|{c^\ast}|}] ]}`.


:math:`{{\mathrm{ivunop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1)`
.................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}(c_1)^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1)`
.................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{f}}}_{N}(c_1)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{ivbinop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2)`
.......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}(c_1, c_2)^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{sx}}, v_1, v_2)`
........................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}({\mathit{sx}}, c_1, c_2)^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivbinopsxnd}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{sx}}, v_1, v_2)`
..........................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{f}}}_{N}({\mathit{sx}}, c_1, c_2)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2)`
.......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{f}}}_{N}(c_1, c_2)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{ivternopnd}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2, v_3)`
...............................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c_3^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_3)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{f}}}_{N}(c_1, c_2, c_3)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{fvternop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2, v_3)`
.............................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c_3^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_3)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{f}}}_{N}(c_1, c_2, c_3)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{ivtestop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1)`
...................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}(c_1)^\ast}`.

#. Return :math:`{\Pi}\, {c^\ast}`.


:math:`{{\mathrm{fvtestop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1)`
...................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}(c_1)^\ast}`.

#. Return :math:`{\Pi}\, {c^\ast}`.


:math:`{{\mathrm{ivrelop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2)`
.......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{f}}}_{N}(c_1, c_2))}^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivrelopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{sx}}, v_1, v_2)`
........................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{f}}}_{N}({\mathit{sx}}, c_1, c_2))}^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2)`
.......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Assert: Due to validation, :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`{|{\mathsf{f}}{N}|}` is :math:`{\mathsf{i}}{N}`.

#. Let :math:`{\mathsf{i}}{N}` be the result for which :math:`{|{\mathsf{i}}{N}|}` :math:`=` :math:`{|{\mathsf{f}}{N}|}`.

#. Let :math:`{c^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{f}}}_{N}(c_1, c_2))}^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivshiftop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, i)`
.......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}(c_1, i)^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivshiftopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{sx}}, v_1, i)`
........................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}({\mathit{sx}}, c_1, i)^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivbitmaskop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`
........................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`c` be the result for which :math:`{{\mathrm{bits}}}_{{\mathsf{i}}{32}}(c)` :math:`=` :math:`{{{{{\mathrm{ilt}}}_{N}^{\mathsf{s}}}}{(c_1, 0)}^\ast}~{0^{32 - M}}`.

#. Return :math:`{{\mathrm{irev}}}_{32}(c)`.


:math:`{{\mathrm{ivswizzlop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2)`
..........................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}({c_1^\ast}, c_2)^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivshufflop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({i^\ast}, v_1, v_2)`
......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`{{c_1^\ast}~{c_2^\ast}{}[i]^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{\mathsf{not}}{{}_{{\mathsf{v}}{N}}(v)}`
...............................................


1. Return :math:`{{\mathrm{inot}}}_{N}(v)`.


:math:`{{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{\mathsf{v}}{N}}(v_1, v_2)}`
....................................................................................................


1. If :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{and}`, then:

   a. Return :math:`{{\mathrm{iand}}}_{N}(v_1, v_2)`.

#. If :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{andnot}`, then:

   a. Return :math:`{{\mathrm{iandnot}}}_{N}(v_1, v_2)`.

#. If :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{or}`, then:

   a. Return :math:`{{\mathrm{ior}}}_{N}(v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{xor}`.

#. Return :math:`{{\mathrm{ixor}}}_{N}(v_1, v_2)`.


:math:`{\mathsf{bitselect}}{{}_{{\mathsf{v}}{N}}(v_1, v_2, v_3)}`
.................................................................


1. Return :math:`{{\mathrm{ibitselect}}}_{N}(v_1, v_2, v_3)`.


:math:`{{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}}(v)}`
..................................................................................................................................................


1. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{N}`, then:

   a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{abs}`, then:

      1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fabs}}, v)`.

   #. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{neg}`, then:

      1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fneg}}, v)`.

   #. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sqrt}`, then:

      1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fsqrt}}, v)`.

   #. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ceil}`, then:

      1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fceil}}, v)`.

   #. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{floor}`, then:

      1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{ffloor}}, v)`.

   #. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{trunc}`, then:

      1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{ftrunc}}, v)`.

   #. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{nearest}`, then:

      1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fnearest}}, v)`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{N}`.

#. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{abs}`, then:

   a. Return :math:`{{\mathrm{ivunop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{iabs}}, v)`.

#. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{neg}`, then:

   a. Return :math:`{{\mathrm{ivunop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ineg}}, v)`.

#. Assert: Due to validation, :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{popcnt}`.

#. Return :math:`{{\mathrm{ivunop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ipopcnt}}, v)`.


:math:`{{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}}(v_1, v_2)}`
..........................................................................................................................................................


1. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{N}`, then:

   a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{add}`, then:

      1) Return :math:`{{\mathrm{ivbinop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{iadd}}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sub}`, then:

      1) Return :math:`{{\mathrm{ivbinop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{isub}}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{mul}`, then:

      1) Return :math:`{{\mathrm{ivbinop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{imul}}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{add\_sat}`, then:

      1) Let :math:`({\mathsf{add\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{iadd}}_{{\mathit{sat}}}, {\mathit{sx}}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{sub\_sat}`, then:

      1) Let :math:`({\mathsf{sub\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{isub}}_{{\mathit{sat}}}, {\mathit{sx}}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{min}`, then:

      1) Let :math:`({\mathsf{min}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{imin}}, {\mathit{sx}}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{max}`, then:

      1) Let :math:`({\mathsf{max}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{imax}}, {\mathit{sx}}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = `, then:

      1) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{iavgr}}, \mathsf{u}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = `, then:

      1) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{iq{\kern-0.1em\scriptstyle 15\kern-0.1em}mulr}}_{{\mathit{sat}}}, \mathsf{s}, v_1, v_2)`.

   #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = `, then:

      1) Return :math:`{{\mathrm{ivbinopsxnd}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{irelaxed}}_{{\mathit{q{\kern-0.1em\scriptstyle 15\kern-0.1em}mulr}}}, \mathsf{s}, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{N}`.

#. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{add}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fadd}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sub}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fsub}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{mul}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fmul}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{div}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fdiv}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{min}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fmin}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{max}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fmax}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{pmin}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fpmin}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{pmax}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fpmax}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{relaxed\_min}`, then:

   a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{frelaxed}}_{{\mathit{min}}}, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{relaxed\_max}`.

#. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{frelaxed}}_{{\mathit{max}}}, v_1, v_2)`.


:math:`{{\mathit{vternop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}}(v_1, v_2, v_3)}`
................................................................................................................................................................


1. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{N}`, then:

   a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{vternop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{relaxed\_laneselect}`, then:

      1) Return :math:`{{\mathrm{ivternopnd}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{irelaxed}}_{{\mathit{laneselect}}}, v_1, v_2, v_3)`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{N}`.

#. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{vternop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{relaxed\_madd}`, then:

   a. Return :math:`{{\mathrm{fvternop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{frelaxed}}_{{\mathit{madd}}}, v_1, v_2, v_3)`.

#. Assert: Due to validation, :math:`{\mathit{vternop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{relaxed\_nmadd}`.

#. Return :math:`{{\mathrm{fvternop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{frelaxed}}_{{\mathit{nmadd}}}, v_1, v_2, v_3)`.


:math:`{\mathsf{all\_true}}{{}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v)}`
......................................................................


1. Return :math:`{{\mathrm{ivtestop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{inez}}, v)`.


:math:`{{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}}(v_1, v_2)}`
..........................................................................................................................................................


1. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{N}`, then:

   a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{eq}`, then:

      1) Return :math:`{{\mathrm{ivrelop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ieq}}, v_1, v_2)`.

   #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ne}`, then:

      1) Return :math:`{{\mathrm{ivrelop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ine}}, v_1, v_2)`.

   #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{lt}`, then:

      1) Let :math:`({\mathsf{lt}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{\mathrm{ivrelopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ilt}}, {\mathit{sx}}, v_1, v_2)`.

   #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{gt}`, then:

      1) Let :math:`({\mathsf{gt}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{\mathrm{ivrelopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{igt}}, {\mathit{sx}}, v_1, v_2)`.

   #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{le}`, then:

      1) Let :math:`({\mathsf{le}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{\mathrm{ivrelopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ile}}, {\mathit{sx}}, v_1, v_2)`.

   #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{ge}`, then:

      1) Let :math:`({\mathsf{ge}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{\mathrm{ivrelopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ige}}, {\mathit{sx}}, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{N}`.

#. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{eq}`, then:

   a. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{feq}}, v_1, v_2)`.

#. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ne}`, then:

   a. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fne}}, v_1, v_2)`.

#. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{lt}`, then:

   a. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{flt}}, v_1, v_2)`.

#. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{gt}`, then:

   a. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fgt}}, v_1, v_2)`.

#. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{le}`, then:

   a. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fle}}, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ge}`.

#. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fge}}, v_1, v_2)`.


:math:`{{\mathrm{lcvtop}}}_{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}}{\mathsf{x}}{M_1}, {{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, c_1)`
................................................................................................................................................................................................................................................


1. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is :math:`{\mathsf{i}}{N}`, then:

   a. Let :math:`{{\mathsf{i}}{N}}_1` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

   #. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{N}`, then:

      1) Let :math:`{{\mathsf{i}}{N}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{extend}`, then:

         a) Let :math:`({\mathsf{extend}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Let :math:`c` be :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(c_1)}`.

         #) Return :math:`c`.

   #. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{N}`, then:

      1) Let :math:`{{\mathsf{f}}{N}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{convert}`, then:

         a) Let :math:`({\mathsf{convert}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

         #) Let :math:`c` be :math:`{{{{\mathrm{convert}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(c_1)}`.

         #) Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is :math:`{\mathsf{f}}{N}`.

#. Let :math:`{{\mathsf{f}}{N}}_1` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

#. If :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{i}}{N}`, then:

   a. Let :math:`{{\mathsf{i}}{N}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{trunc\_sat}`, then:

      1) Let :math:`({\mathsf{trunc\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{c^?}` be :math:`{{{{\mathrm{trunc\_sat}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(c_1)}`.

      #) Return :math:`{c^?}`.

   #. If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{relaxed\_trunc}`, then:

      1) Let :math:`({\mathsf{relaxed\_trunc}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{c^?}` be :math:`{{{{\mathrm{relaxed\_trunc}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(c_1)}`.

      #) Return :math:`{c^?}`.

#. Assert: Due to validation, :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathsf{f}}{N}`.

#. Let :math:`{{\mathsf{f}}{N}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{demote}`, then:

   a. Let :math:`{c^\ast}` be :math:`{{\mathrm{demote}}}_{N_1, N_2}(c_1)`.

   #. Return :math:`{c^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{promote}`.

#. Let :math:`{c^\ast}` be :math:`{{\mathrm{promote}}}_{N_1, N_2}(c_1)`.

#. Return :math:`{c^\ast}`.


:math:`{{\mathrm{vcvtop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{n_{\mathit{u{\kern-0.1em\scriptstyle 2}}}}}({\mathit{vcvtop}}, {{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}, {{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}, v_1)`
..........................................................................................................................................................................................................................................................................................................................................


1. Let :math:`M` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`{{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined and :math:`{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined and :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = M`, then:

   a. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M}}(v_1)`.

   #. Let :math:`{{c^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{lcvtop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M}}({\mathit{vcvtop}}, c_1)^\ast}`.

   #. Let :math:`v` be an element of :math:`{{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.

   #. Return :math:`v`.

#. Let :math:`M_1` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`M_2` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined and :math:`{{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

   a. Let :math:`{\mathit{half}}` be :math:`{{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

   #. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_1){}[{\mathrm{half}}({\mathit{half}}, 0, M_2) : M_2]`.

   #. Let :math:`{{c^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{lcvtop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}, c_1)^\ast}`.

   #. Let :math:`v` be an element of :math:`{{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({c^\ast})}^\ast}`.

   #. Return :math:`v`.

#. Assert: Due to validation, :math:`{{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined.

#. Assert: Due to validation, :math:`{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined.

#. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_1)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{lcvtop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}, c_1)^\ast}~{0^{M_1}}`.

#. Let :math:`v` be an element of :math:`{{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({c^\ast})}^\ast}`.

#. Return :math:`v`.


:math:`{{\mathit{vshiftop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}}{(v, i)}`
....................................................................................................................


1. If :math:`{\mathit{vshiftop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{shl}`, then:

   a. Return :math:`{{\mathrm{ivshiftop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ishl}}, v, i)`.

#. Assert: Due to validation, :math:`{\mathit{vshiftop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{shr}`.

#. Let :math:`({\mathsf{shr}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vshiftop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{\mathrm{ivshiftopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ishr}}, {\mathit{sx}}, v, i)`.


:math:`{\mathsf{vbitmask}}{{}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v)}`
.....................................................................


1. Return :math:`{{\mathrm{ivbitmaskop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v)`.


:math:`{{\mathit{vswizzlop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{\mathsf{i{\scriptstyle 8}}}{\mathsf{x}}{M}}(v_1, v_2)}`
..................................................................................................................................


1. If :math:`{\mathit{vswizzlop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{swizzle}`, then:

   a. Return :math:`{{\mathrm{ivswizzlop}}}_{{\mathsf{i{\scriptstyle 8}}}{\mathsf{x}}{M}}({\mathrm{iswizzle}}_{{\mathit{lane}}}, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{vswizzlop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{relaxed\_swizzle}`.

#. Return :math:`{{\mathrm{ivswizzlop}}}_{{\mathsf{i{\scriptstyle 8}}}{\mathsf{x}}{M}}({\mathrm{irelaxed}}_{{\mathit{swizzle}}_{{\mathit{lane}}}}, v_1, v_2)`.


:math:`{\mathsf{vshuffle}}{{}_{{\mathsf{i{\scriptstyle 8}}}{\mathsf{x}}{M}}({i^\ast}, v_1, v_2)}`
.................................................................................................


1. Return :math:`{{\mathrm{ivshufflop}}}_{{\mathsf{i{\scriptstyle 8}}}{\mathsf{x}}{M}}({i^\ast}, v_1, v_2)`.


:math:`{\mathsf{vnarrow}}{{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{\mathit{sx}}}}}{(v_1, v_2)}`
.............................................................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_2)`.

#. Let :math:`{{c'}_1^\ast}` be :math:`{{{{{\mathrm{narrow}}}_{{|{{\mathsf{i}}{N}}_1|}, {|{{\mathsf{i}}{N}}_2|}}^{{\mathit{sx}}}}}{c_1}^\ast}`.

#. Let :math:`{{c'}_2^\ast}` be :math:`{{{{{\mathrm{narrow}}}_{{|{{\mathsf{i}}{N}}_1|}, {|{{\mathsf{i}}{N}}_2|}}^{{\mathit{sx}}}}}{c_2}^\ast}`.

#. Let :math:`v` be :math:`{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({{c'}_1^\ast}~{{c'}_2^\ast})}`.

#. Return :math:`v`.


:math:`{{\mathrm{ivadd\_pairwise}}}_{N}({i^\ast})`
..................................................


1. Let :math:`{j_1~j_2^\ast}` be the result for which :math:`{\bigoplus}\, {j_1~j_2^\ast}` :math:`=` :math:`{i^\ast}`.

#. Return :math:`{{{\mathrm{iadd}}}_{N}(j_1, j_2)^\ast}`.


:math:`{{\mathrm{ivextunop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{f}}, {\mathit{sx}}, v_1)`
.................................................................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_1)`.

#. Let :math:`{{c'}_1^\ast}` be :math:`{{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(c_1)}^\ast}`.

#. Let :math:`{c^\ast}` be :math:`{{\mathrm{f}}}_{N_2}({{c'}_1^\ast})`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathsf{extadd\_pairwise}}{\mathsf{\_}}{{\mathit{sx}}}}{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}(v_1)}`
...........................................................................................................................................................


1. Return :math:`{{\mathrm{ivextunop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{ivadd}}_{{\mathit{pairwise}}}, {\mathit{sx}}, v_1)`.


:math:`{{\mathrm{ivdot}}}_{N}({i_1^\ast}, {i_2^\ast})`
......................................................


1. Let :math:`{j_1~j_2^\ast}` be the result for which :math:`{\bigoplus}\, {j_1~j_2^\ast}` :math:`=` :math:`{{{\mathrm{imul}}}_{N}(i_1, i_2)^\ast}`.

#. Return :math:`{{{\mathrm{iadd}}}_{N}(j_1, j_2)^\ast}`.


:math:`{{\mathrm{ivdot\_sat}}}_{N}({i_1^\ast}, {i_2^\ast})`
...........................................................


1. Let :math:`{j_1~j_2^\ast}` be the result for which :math:`{\bigoplus}\, {j_1~j_2^\ast}` :math:`=` :math:`{{{\mathrm{imul}}}_{N}(i_1, i_2)^\ast}`.

#. Return :math:`{{{{{\mathrm{iadd\_sat}}}_{N}^{\mathsf{s}}}}{(j_1, j_2)}^\ast}`.


:math:`{{\mathrm{ivextbinop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{f}}, {\mathit{sx}}_1, {\mathit{sx}}_2, i, k, v_1, v_2)`
................................................................................................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_1){}[i : k]`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_2){}[i : k]`.

#. Let :math:`{{c'}_1^\ast}` be :math:`{{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}_1}}}{(c_1)}^\ast}`.

#. Let :math:`{{c'}_2^\ast}` be :math:`{{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}_2}}}{(c_2)}^\ast}`.

#. Let :math:`{c^\ast}` be :math:`{{\mathrm{f}}}_{N_2}({{c'}_1^\ast}, {{c'}_2^\ast})`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivmul}}}_{N}({i_1^\ast}, {i_2^\ast})`
......................................................


1. Return :math:`{{{\mathrm{imul}}}_{N}(i_1, i_2)^\ast}`.


:math:`{{\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}(v_1, v_2)}`
.....................................................................................................................................................................


1. If :math:`{\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{extmul}`, then:

   a. Let :math:`({\mathsf{extmul}}{\mathsf{\_}}{{\mathit{sx}}}{\mathsf{\_}}{{\mathit{half}}})` be :math:`{\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Let :math:`i` be :math:`{\mathrm{half}}({\mathit{half}}, 0, M_2)`.

   #. Return :math:`{{\mathrm{ivextbinop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{ivmul}}, {\mathit{sx}}, {\mathit{sx}}, i, M_2, v_1, v_2)`.

#. If :math:`{\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = `, then:

   a. Return :math:`{{\mathrm{ivextbinop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{ivdot}}, \mathsf{s}, \mathsf{s}, 0, M_1, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = `.

#. Return :math:`{{\mathrm{ivextbinop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{ivdot}}_{{\mathit{sat}}}, \mathsf{s}, {{\mathrm{relaxed}}({\mathrm{R}}_{\mathit{idot}})}{{}[ \mathsf{s}, \mathsf{u} ]}, 0, M_1, v_1, v_2)`.


:math:`{}{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}(c_1, c_2, c_3)}`
..............................................................................................................


1. Let :math:`M` be :math:`2 \, M_2`.

#. Assert: Due to validation, :math:`N` for which :math:`N` :math:`=` :math:`2 \cdot N_1` is :math:`{\mathsf{i}}{N}`.

#. Let :math:`{\mathsf{i}}{N}` be the result for which :math:`N` :math:`=` :math:`2 \cdot N_1`.

#. Let :math:`{c'}` be :math:`{}{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c_1, c_2)}`.

#. Let :math:`{c''}` be :math:`{{\mathsf{extadd\_pairwise}}{\mathsf{\_}}{\mathsf{s}}}{{}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({c'})}`.

#. Let :math:`c` be an element of :math:`{\mathsf{add}}{{}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({c''}, c_3)}`.

#. Return :math:`c`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}(t)`
....................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{t}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}({\mathit{rt}})`
................................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{{\mathit{rt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}({\mathit{gt}})`
................................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{{\mathit{gt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}({\mathit{tt}})`
................................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{{\mathit{tt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}({\mathit{mt}})`
................................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{{\mathit{mt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{\mathrm{Ki}}`
.....................


1. Return :math:`1024`.


:math:`{{\mathrm{pack}}}_{{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}(v_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
............................................................................................................................


1. If :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is value type, then:

   a. Let :math:`{\mathit{val}}` be :math:`v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`{\mathit{val}}`.

#. Assert: Due to validation, :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Assert: Due to validation, :math:`v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{const}`.

#. Let :math:`({\mathit{numtype}}_0{.}\mathsf{const}~i)` be :math:`v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0 = \mathsf{i{\scriptstyle 32}}`.

#. Return :math:`({\mathit{packtype}}{.}\mathsf{pack}~{{\mathrm{wrap}}}_{32, {|{\mathit{packtype}}|}}(i))`.


:math:`{{{{\mathrm{unpack}}}_{{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}^{{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}}}{({\mathit{fv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})}`
............................................................................................................................................................................................................


1. If :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is value type and :math:`{\mathit{fv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is value, then:

   a. Let :math:`{\mathit{val}}` be :math:`{\mathit{fv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. If :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

      1) Return :math:`{\mathit{val}}`.

#. Assert: Due to validation, :math:`{\mathit{fv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{pack}`.

#. Let :math:`({\mathit{packtype}}{.}\mathsf{pack}~i)` be :math:`{\mathit{fv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Assert: Due to validation, :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined.

#. Let :math:`{\mathit{sx}}` be :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

#. Assert: Due to validation, :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = {\mathit{packtype}}`.

#. Return :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{{|{\mathit{packtype}}|}, 32}^{{\mathit{sx}}}}}{(i)})`.


:math:`{\mathrm{funcs}}({{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
......................................................................................


1. If :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is :math:`\mathsf{func}`, then:

   a. Let :math:`(\mathsf{func}~a)` be :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`a~{\mathrm{funcs}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xa}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................................


1. If :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is :math:`\mathsf{global}`, then:

   a. Let :math:`(\mathsf{global}~a)` be :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`a~{\mathrm{globals}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xa}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................


1. If :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is :math:`\mathsf{table}`, then:

   a. Let :math:`(\mathsf{table}~a)` be :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`a~{\mathrm{tables}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xa}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is :math:`\mathsf{mem}`, then:

   a. Let :math:`(\mathsf{mem}~a)` be :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`a~{\mathrm{mems}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xa}}^\ast})`.


:math:`{\mathrm{tags}}({{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is :math:`\mathsf{tag}`, then:

   a. Let :math:`(\mathsf{tag}~a)` be :math:`{\mathit{externaddr}}_0`.

   #. Return :math:`a~{\mathrm{tags}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tags}}({{\mathit{xa}}^\ast})`.


:math:`(s, f){.}\mathsf{store}`
...............................


1. Return.


:math:`(s, f){.}\mathsf{frame}`
...............................


1. Return :math:`f`.


:math:`(s, f){.}\mathsf{tags}`
..............................


1. Return :math:`f{.}\mathsf{module}{.}\mathsf{tags}`.


:math:`(s, f){.}\mathsf{module}`
................................


1. Return :math:`f{.}\mathsf{module}`.


:math:`(s, f){.}\mathsf{funcs}`
...............................


1. Return :math:`s{.}\mathsf{funcs}`.


:math:`(s, f){.}\mathsf{globals}`
.................................


1. Return :math:`s{.}\mathsf{globals}`.


:math:`(s, f){.}\mathsf{tables}`
................................


1. Return :math:`s{.}\mathsf{tables}`.


:math:`(s, f){.}\mathsf{mems}`
..............................


1. Return :math:`s{.}\mathsf{mems}`.


:math:`(s, f){.}\mathsf{tags}`
..............................


1. Return :math:`s{.}\mathsf{tags}`.


:math:`(s, f){.}\mathsf{elems}`
...............................


1. Return :math:`s{.}\mathsf{elems}`.


:math:`(s, f){.}\mathsf{datas}`
...............................


1. Return :math:`s{.}\mathsf{datas}`.


:math:`(s, f){.}\mathsf{structs}`
.................................


1. Return :math:`s{.}\mathsf{structs}`.


:math:`(s, f){.}\mathsf{arrays}`
................................


1. Return :math:`s{.}\mathsf{arrays}`.


:math:`(s, f){.}\mathsf{exns}`
..............................


1. Return :math:`s{.}\mathsf{exns}`.


:math:`(s, f){.}\mathsf{types}{}[x]`
....................................


1. Return :math:`f{.}\mathsf{module}{.}\mathsf{types}{}[x]`.


:math:`(s, f){.}\mathsf{funcs}{}[x]`
....................................


1. Return :math:`s{.}\mathsf{funcs}{}[f{.}\mathsf{module}{.}\mathsf{funcs}{}[x]]`.


:math:`(s, f){.}\mathsf{globals}{}[x]`
......................................


1. Return :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]`.


:math:`(s, f){.}\mathsf{tables}{}[x]`
.....................................


1. Return :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]`.


:math:`(s, f){.}\mathsf{mems}{}[x]`
...................................


1. Return :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]`.


:math:`(s, f){.}\mathsf{tags}{}[x]`
...................................


1. Return :math:`s{.}\mathsf{tags}{}[f{.}\mathsf{module}{.}\mathsf{tags}{}[x]]`.


:math:`(s, f){.}\mathsf{elems}{}[x]`
....................................


1. Return :math:`s{.}\mathsf{elems}{}[f{.}\mathsf{module}{.}\mathsf{elems}{}[x]]`.


:math:`(s, f){.}\mathsf{datas}{}[x]`
....................................


1. Return :math:`s{.}\mathsf{datas}{}[f{.}\mathsf{module}{.}\mathsf{datas}{}[x]]`.


:math:`(s, f){.}\mathsf{locals}{}[x]`
.....................................


1. Return :math:`f{.}\mathsf{locals}{}[x]`.


:math:`(s, f){}[{.}\mathsf{locals}{}[x] = v]`
.............................................


1. Replace :math:`f{.}\mathsf{locals}{}[x]` with :math:`v`.


:math:`(s, f){}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = v]`
...............................................................


1. Replace :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]{.}\mathsf{value}` with :math:`v`.


:math:`(s, f){}[{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i] = r]`
..................................................................


1. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]{.}\mathsf{refs}{}[i]` with :math:`r`.


:math:`(s, f){}[{.}\mathsf{tables}{}[x] = {\mathit{ti}}]`
.........................................................


1. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]` with :math:`{\mathit{ti}}`.


:math:`(s, f){}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i : j] = {b^\ast}]`
............................................................................


1. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]{.}\mathsf{bytes}{}[i : j]` with :math:`{b^\ast}`.


:math:`(s, f){}[{.}\mathsf{mems}{}[x] = {\mathit{mi}}]`
.......................................................


1. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]` with :math:`{\mathit{mi}}`.


:math:`(s, f){}[{.}\mathsf{elems}{}[x]{.}\mathsf{refs} = {r^\ast}]`
...................................................................


1. Replace :math:`s{.}\mathsf{elems}{}[f{.}\mathsf{module}{.}\mathsf{elems}{}[x]]{.}\mathsf{refs}` with :math:`{r^\ast}`.


:math:`(s, f){}[{.}\mathsf{datas}{}[x]{.}\mathsf{bytes} = {b^\ast}]`
....................................................................


1. Replace :math:`s{.}\mathsf{datas}{}[f{.}\mathsf{module}{.}\mathsf{datas}{}[x]]{.}\mathsf{bytes}` with :math:`{b^\ast}`.


:math:`(s, f){}[{.}\mathsf{structs}{}[a]{.}\mathsf{fields}{}[i] = {\mathit{fv}}]`
.................................................................................


1. Replace :math:`s{.}\mathsf{structs}{}[a]{.}\mathsf{fields}{}[i]` with :math:`{\mathit{fv}}`.


:math:`(s, f){}[{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}{}[i] = {\mathit{fv}}]`
................................................................................


1. Replace :math:`s{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}{}[i]` with :math:`{\mathit{fv}}`.


:math:`(s, f){}[{.}\mathsf{structs} \mathrel{{=}{\oplus}} {{\mathit{si}}^\ast}]`
................................................................................


1. Append :math:`{{\mathit{si}}^\ast}` to :math:`s{.}\mathsf{structs}`.


:math:`(s, f){}[{.}\mathsf{arrays} \mathrel{{=}{\oplus}} {{\mathit{ai}}^\ast}]`
...............................................................................


1. Append :math:`{{\mathit{ai}}^\ast}` to :math:`s{.}\mathsf{arrays}`.


:math:`(s, f){}[{.}\mathsf{exns} \mathrel{{=}{\oplus}} {{\mathit{exn}}^\ast}]`
..............................................................................


1. Append :math:`{{\mathit{exn}}^\ast}` to :math:`s{.}\mathsf{exns}`.


:math:`{\mathrm{growtable}}({\mathit{tableinst}}, n, r)`
........................................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({\mathit{at}}~{}[~i~..~j~]~{\mathit{rt}}),\; \mathsf{refs}~{{r'}^\ast} \}\end{array}` be :math:`{\mathit{tableinst}}`.

#. If :math:`{|{{r'}^\ast}|} + n \leq j`, then:

   a. Let :math:`{i'}` be :math:`{|{{r'}^\ast}|} + n`.

   #. Let :math:`{\mathit{tableinst}'}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({\mathit{at}}~{}[~{i'}~..~j~]~{\mathit{rt}}),\; \mathsf{refs}~{{r'}^\ast}~{r^{n}} \}\end{array}`.

   #. Return :math:`{\mathit{tableinst}'}`.


:math:`{\mathrm{growmem}}({\mathit{meminst}}, n)`
.................................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({\mathit{at}}~{}[~i~..~j~]~\mathsf{page}),\; \mathsf{bytes}~{b^\ast} \}\end{array}` be :math:`{\mathit{meminst}}`.

#. If :math:`{|{b^\ast}|} / (64 \, {\mathrm{Ki}}) + n \leq j`, then:

   a. Let :math:`{i'}` be :math:`{|{b^\ast}|} / (64 \, {\mathrm{Ki}}) + n`.

   #. Let :math:`{\mathit{meminst}'}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({\mathit{at}}~{}[~{i'}~..~j~]~\mathsf{page}),\; \mathsf{bytes}~{b^\ast}~{\mathtt{0x00}^{n \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

   #. Return :math:`{\mathit{meminst}'}`.


:math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
.........................................................................................


1. If :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is , then:

   a. Let :math:`x` be :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is :math:`\mathsf{func}`.

   #. Let :math:`(\mathsf{func}~{\mathit{ft}})` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

   #. Return :math:`{\mathit{ft}}`.

#. Assert: Due to validation, :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is .

#. Let :math:`{t^?}` be :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`\epsilon~\rightarrow~{t^?}`.


:math:`{{{\mathrm{alloctype}}^\ast}}{({{\mathit{type}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
.......................................................................................................


1. If :math:`{{\mathit{type}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{{\mathit{type}'}^\ast}~{\mathit{type}}` be :math:`{{\mathit{type}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`(\mathsf{type}~{\mathit{rectype}})` be :math:`{\mathit{type}}`.

#. Let :math:`{{\mathit{deftype}'}^\ast}` be :math:`{{{\mathrm{alloctype}}^\ast}}{({{\mathit{type}'}^\ast})}`.

#. Let :math:`x` be :math:`{|{{\mathit{deftype}'}^\ast}|}`.

#. Let :math:`{{\mathit{deftype}}^\ast}` be :math:`{{{{{\mathrm{roll}}}_{x}^\ast}}{({\mathit{rectype}})}}{{}[ {:=}\, {{\mathit{deftype}'}^\ast} ]}`.

#. Return :math:`{{\mathit{deftype}'}^\ast}~{{\mathit{deftype}}^\ast}`.


:math:`{\mathrm{allocfunc}}(s, {\mathit{deftype}}, {\mathit{code}}, {\mathit{moduleinst}})`
...........................................................................................


1. Let :math:`{\mathit{funcinst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{deftype}},\; \mathsf{module}~{\mathit{moduleinst}},\; \mathsf{code}~{\mathit{code}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{funcs}|}`.

#. Append :math:`{\mathit{funcinst}}` to :math:`s{.}\mathsf{funcs}`.

#. Return :math:`a`.


:math:`{{{\mathrm{allocfunc}}^\ast}}{(s, {{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {{{\mathit{code}}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {{\mathit{moduleinst}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
................................................................................................................................................................................................................................................


1. If :math:`{{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Assert: Due to validation, :math:`{{{\mathit{code}}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`.

   #. Assert: Due to validation, :math:`{{\mathit{moduleinst}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`.

   #. Return :math:`\epsilon`.

#. Else:

   a. Let :math:`{\mathit{dt}}~{{\mathit{dt}'}^\ast}` be :math:`{{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

   #. Assert: Due to validation, :math:`{|{{{\mathit{code}}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

   #. Let :math:`{\mathit{code}}~{{{\mathit{code}}'}^\ast}` be :math:`{{{\mathit{code}}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

   #. Assert: Due to validation, :math:`{|{{\mathit{moduleinst}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

   #. Let :math:`{\mathit{moduleinst}}~{{\mathit{moduleinst}'}^\ast}` be :math:`{{\mathit{moduleinst}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

   #. Let :math:`{\mathit{fa}}` be :math:`{\mathrm{allocfunc}}(s, {\mathit{dt}}, {\mathit{code}}, {\mathit{moduleinst}})`.

   #. Let :math:`{{\mathit{fa}'}^\ast}` be :math:`{{{\mathrm{allocfunc}}^\ast}}{(s, {{\mathit{dt}'}^\ast}, {{{\mathit{code}}'}^\ast}, {{\mathit{moduleinst}'}^\ast})}`.

   #. Return :math:`{\mathit{fa}}~{{\mathit{fa}'}^\ast}`.


:math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`
........................................................................


1. Let :math:`{\mathit{globalinst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{globaltype}},\; \mathsf{value}~{\mathit{val}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{globals}|}`.

#. Append :math:`{\mathit{globalinst}}` to :math:`s{.}\mathsf{globals}`.

#. Return :math:`a`.


:math:`{{{\mathrm{allocglobal}}^\ast}}{(s, {{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
............................................................................................................................................................


1. If :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Assert: Due to validation, :math:`{v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`.

   #. Return :math:`\epsilon`.

#. Else:

   a. Let :math:`{\mathit{globaltype}}~{{\mathit{globaltype}'}^\ast}` be :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

   #. Assert: Due to validation, :math:`{|{v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

   #. Let :math:`{\mathit{val}}~{{\mathit{val}'}^\ast}` be :math:`{v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

   #. Let :math:`{\mathit{ga}}` be :math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`.

   #. Let :math:`{{\mathit{ga}'}^\ast}` be :math:`{{{\mathrm{allocglobal}}^\ast}}{(s, {{\mathit{globaltype}'}^\ast}, {{\mathit{val}'}^\ast})}`.

   #. Return :math:`{\mathit{ga}}~{{\mathit{ga}'}^\ast}`.


:math:`{\mathrm{alloctable}}(s, {\mathit{at}}~{}[~i~..~j~]~{\mathit{rt}}, {\mathit{ref}})`
..........................................................................................


1. Let :math:`{\mathit{tableinst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({\mathit{at}}~{}[~i~..~j~]~{\mathit{rt}}),\; \mathsf{refs}~{{\mathit{ref}}^{i}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{tables}|}`.

#. Append :math:`{\mathit{tableinst}}` to :math:`s{.}\mathsf{tables}`.

#. Return :math:`a`.


:math:`{{{\mathrm{alloctable}}^\ast}}{(s, {{\mathit{tt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
...........................................................................................................................................................


1. If :math:`{{\mathit{tt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon` and :math:`{r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{ref}}~{{\mathit{ref}'}^\ast}` be :math:`{r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{tt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{tabletype}}~{{\mathit{tabletype}'}^\ast}` be :math:`{{\mathit{tt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{ta}}` be :math:`{\mathrm{alloctable}}(s, {\mathit{tabletype}}, {\mathit{ref}})`.

#. Let :math:`{{\mathit{ta}'}^\ast}` be :math:`{{{\mathrm{alloctable}}^\ast}}{(s, {{\mathit{tabletype}'}^\ast}, {{\mathit{ref}'}^\ast})}`.

#. Return :math:`{\mathit{ta}}~{{\mathit{ta}'}^\ast}`.


:math:`{\mathrm{allocmem}}(s, {\mathit{at}}~{}[~i~..~j~]~\mathsf{page})`
........................................................................


1. Let :math:`{\mathit{meminst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({\mathit{at}}~{}[~i~..~j~]~\mathsf{page}),\; \mathsf{bytes}~{\mathtt{0x00}^{i \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{mems}|}`.

#. Append :math:`{\mathit{meminst}}` to :math:`s{.}\mathsf{mems}`.

#. Return :math:`a`.


:math:`{{{\mathrm{allocmem}}^\ast}}{(s, {{\mathit{mt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
.......................................................................................................


1. If :math:`{{\mathit{mt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{memtype}}~{{\mathit{memtype}'}^\ast}` be :math:`{{\mathit{mt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{ma}}` be :math:`{\mathrm{allocmem}}(s, {\mathit{memtype}})`.

#. Let :math:`{{\mathit{ma}'}^\ast}` be :math:`{{{\mathrm{allocmem}}^\ast}}{(s, {{\mathit{memtype}'}^\ast})}`.

#. Return :math:`{\mathit{ma}}~{{\mathit{ma}'}^\ast}`.


:math:`{\mathrm{alloctag}}(s, {\mathit{tagtype}})`
..................................................


1. Let :math:`{\mathit{taginst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{tagtype}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{tags}|}`.

#. Append :math:`{\mathit{taginst}}` to :math:`s{.}\mathsf{tags}`.

#. Return :math:`a`.


:math:`{{{\mathrm{alloctag}}^\ast}}{(s, {{\mathit{jt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
.......................................................................................................


1. If :math:`{{\mathit{jt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{jt}}~{{\mathit{jt}'}^\ast}` be :math:`{{\mathit{jt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{ja}}` be :math:`{\mathrm{alloctag}}(s, {\mathit{jt}})`.

#. Let :math:`{{\mathit{ja}'}^\ast}` be :math:`{{{\mathrm{alloctag}}^\ast}}{(s, {{\mathit{jt}'}^\ast})}`.

#. Return :math:`{\mathit{ja}}~{{\mathit{ja}'}^\ast}`.


:math:`{\mathrm{allocelem}}(s, {\mathit{elemtype}}, {{\mathit{ref}}^\ast})`
...........................................................................


1. Let :math:`{\mathit{eleminst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{elemtype}},\; \mathsf{refs}~{{\mathit{ref}}^\ast} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{elems}|}`.

#. Append :math:`{\mathit{eleminst}}` to :math:`s{.}\mathsf{elems}`.

#. Return :math:`a`.


:math:`{{{\mathrm{allocelem}}^\ast}}{(s, {{\mathit{elemtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
................................................................................................................................................................


1. If :math:`{{\mathit{elemtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon` and :math:`{r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{{\mathit{ref}}^\ast}~{{{\mathit{ref}'}^\ast}^\ast}` be :math:`{r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{elemtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{rt}}~{{\mathit{rt}'}^\ast}` be :math:`{{\mathit{elemtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{ea}}` be :math:`{\mathrm{allocelem}}(s, {\mathit{rt}}, {{\mathit{ref}}^\ast})`.

#. Let :math:`{{\mathit{ea}'}^\ast}` be :math:`{{{\mathrm{allocelem}}^\ast}}{(s, {{\mathit{rt}'}^\ast}, {{{\mathit{ref}'}^\ast}^\ast})}`.

#. Return :math:`{\mathit{ea}}~{{\mathit{ea}'}^\ast}`.


:math:`{\mathrm{allocdata}}(s, \mathsf{ok}, {{\mathit{byte}}^\ast})`
....................................................................


1. Let :math:`{\mathit{datainst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{bytes}~{{\mathit{byte}}^\ast} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{datas}|}`.

#. Append :math:`{\mathit{datainst}}` to :math:`s{.}\mathsf{datas}`.

#. Return :math:`a`.


:math:`{{{\mathrm{allocdata}}^\ast}}{(s, {{\mathit{ok}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
..........................................................................................................................................................


1. If :math:`{{\mathit{ok}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon` and :math:`{b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{b^\ast}~{{{b'}^\ast}^\ast}` be :math:`{b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{ok}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{ok}}~{{\mathit{ok}'}^\ast}` be :math:`{{\mathit{ok}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{da}}` be :math:`{\mathrm{allocdata}}(s, {\mathit{ok}}, {b^\ast})`.

#. Let :math:`{{\mathit{da}'}^\ast}` be :math:`{{{\mathrm{allocdata}}^\ast}}{(s, {{\mathit{ok}'}^\ast}, {{{b'}^\ast}^\ast})}`.

#. Return :math:`{\mathit{da}}~{{\mathit{da}'}^\ast}`.


:math:`{\mathrm{allocexport}}({\mathit{moduleinst}}, \mathsf{export}~{\mathit{name}}~{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
............................................................................................................................................


1. If :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{func}`, then:

   a. Let :math:`(\mathsf{func}~x)` be :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{func}~{\mathit{moduleinst}}{.}\mathsf{funcs}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{global}`, then:

   a. Let :math:`(\mathsf{global}~x)` be :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{global}~{\mathit{moduleinst}}{.}\mathsf{globals}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{table}`, then:

   a. Let :math:`(\mathsf{table}~x)` be :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{table}~{\mathit{moduleinst}}{.}\mathsf{tables}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{mem}`, then:

   a. Let :math:`(\mathsf{mem}~x)` be :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

   #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{mem}~{\mathit{moduleinst}}{.}\mathsf{mems}{}[x]) \}\end{array}`.

#. Assert: Due to validation, :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{tag}`.

#. Let :math:`(\mathsf{tag}~x)` be :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{tag}~{\mathit{moduleinst}}{.}\mathsf{tags}{}[x]) \}\end{array}`.


:math:`{{{\mathrm{allocexport}}^\ast}}{({\mathit{moduleinst}}, {{\mathit{export}}^\ast})}`
..........................................................................................


1. Return :math:`{{\mathrm{allocexport}}({\mathit{moduleinst}}, {\mathit{export}})^\ast}`.


:math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}_{\mathsf{g}}^\ast}, {{\mathit{ref}}_{\mathsf{t}}^\ast}, {{{\mathit{ref}}_{\mathsf{e}}^\ast}^\ast})`
.....................................................................................................................................................................................................


1. Let :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{tag}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be :math:`{\mathit{module}}`.

#. Let :math:`{{\mathit{fa}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ga}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{globals}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{aa}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{tags}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ma}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{mems}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ta}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{tables}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{fa}}^\ast}` be :math:`{({|s{.}\mathsf{funcs}|} + i_{\mathsf{f}})^{i_{\mathsf{f}}<{|{{\mathit{func}}^\ast}|}}}`.

#. Let :math:`{{\mathit{ga}}^\ast}` be :math:`{({|s{.}\mathsf{globals}|} + i_{\mathsf{g}})^{i_{\mathsf{g}}<{|{{\mathit{global}}^\ast}|}}}`.

#. Let :math:`{{\mathit{ta}}^\ast}` be :math:`{({|s{.}\mathsf{tables}|} + i_{\mathsf{t}})^{i_{\mathsf{t}}<{|{{\mathit{table}}^\ast}|}}}`.

#. Let :math:`{{\mathit{aa}}^\ast}` be :math:`{({|s{.}\mathsf{tags}|} + i_{\mathsf{a}})^{i_{\mathsf{a}}<{|{{\mathit{tag}}^\ast}|}}}`.

#. Let :math:`{{\mathit{ma}}^\ast}` be :math:`{({|s{.}\mathsf{mems}|} + i_{\mathsf{m}})^{i_{\mathsf{m}}<{|{{\mathit{mem}}^\ast}|}}}`.

#. Let :math:`{{\mathit{ea}}^\ast}` be :math:`{({|s{.}\mathsf{elems}|} + i_{\mathsf{e}})^{i_{\mathsf{e}}<{|{{\mathit{elem}}^\ast}|}}}`.

#. Let :math:`{{\mathit{da}}^\ast}` be :math:`{({|s{.}\mathsf{datas}|} + i_{\mathsf{d}})^{i_{\mathsf{d}}<{|{{\mathit{data}}^\ast}|}}}`.

#. Let :math:`{(\mathsf{memory}~{\mathit{memtype}})^\ast}` be :math:`{{\mathit{mem}}^\ast}`.

#. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{{{\mathrm{alloctype}}^\ast}}{({{\mathit{type}}^\ast})}`.

#. Let :math:`{(\mathsf{tag}~y)^\ast}` be :math:`{{\mathit{tag}}^\ast}`.

#. Let :math:`{(\mathsf{data}~{{\mathit{byte}}^\ast}~{\mathit{datamode}})^\ast}` be :math:`{{\mathit{data}}^\ast}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_{\mathsf{g}})^\ast}` be :math:`{{\mathit{global}}^\ast}`.

#. Let :math:`{(\mathsf{table}~{\mathit{tabletype}}~{\mathit{expr}}_{\mathsf{t}})^\ast}` be :math:`{{\mathit{table}}^\ast}`.

#. Let :math:`{(\mathsf{elem}~{\mathit{elemtype}}~{{\mathit{expr}}_{\mathsf{e}}^\ast}~{\mathit{elemmode}})^\ast}` be :math:`{{\mathit{elem}}^\ast}`.

#. Let :math:`{(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}}_{\mathsf{f}})^\ast}` be :math:`{{\mathit{func}}^\ast}`.

#. Let :math:`{{\mathit{xi}}^\ast}` be :math:`{{{\mathrm{allocexport}}^\ast}}{(\{ \begin{array}[t]{@{}l@{}}\mathsf{funcs}~{{\mathit{fa}}_{\mathsf{i}}^\ast}~{{\mathit{fa}}^\ast},\; \mathsf{globals}~{{\mathit{ga}}_{\mathsf{i}}^\ast}~{{\mathit{ga}}^\ast},\; \mathsf{tables}~{{\mathit{ta}}_{\mathsf{i}}^\ast}~{{\mathit{ta}}^\ast},\; \mathsf{mems}~{{\mathit{ma}}_{\mathsf{i}}^\ast}~{{\mathit{ma}}^\ast},\; \mathsf{tags}~{{\mathit{aa}}_{\mathsf{i}}^\ast}~{{\mathit{aa}}^\ast} \}\end{array}, {{\mathit{export}}^\ast})}`.

#. Let :math:`{\mathit{moduleinst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{dt}}^\ast},\; \mathsf{funcs}~{{\mathit{fa}}_{\mathsf{i}}^\ast}~{{\mathit{fa}}^\ast},\; \mathsf{globals}~{{\mathit{ga}}_{\mathsf{i}}^\ast}~{{\mathit{ga}}^\ast},\; \mathsf{tables}~{{\mathit{ta}}_{\mathsf{i}}^\ast}~{{\mathit{ta}}^\ast},\; \mathsf{mems}~{{\mathit{ma}}_{\mathsf{i}}^\ast}~{{\mathit{ma}}^\ast},\; \mathsf{tags}~{{\mathit{aa}}_{\mathsf{i}}^\ast}~{{\mathit{aa}}^\ast},\; \mathsf{elems}~{{\mathit{ea}}^\ast},\; \mathsf{datas}~{{\mathit{da}}^\ast},\; \mathsf{exports}~{{\mathit{xi}}^\ast} \}\end{array}`.

#. Let :math:`{{\mathit{funcaddr}}_0^\ast}` be :math:`{{{\mathrm{allocfunc}}^\ast}}{(s, {{{\mathit{dt}}^\ast}{}[x]^\ast}, {(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}}_{\mathsf{f}})^\ast}, {{\mathit{moduleinst}}^{{|{{\mathit{func}}^\ast}|}}})}`.

#. Assert: Due to validation, :math:`{{\mathit{funcaddr}}_0^\ast} = {{\mathit{fa}}^\ast}`.

#. Let :math:`{{\mathit{globaladdr}}_0^\ast}` be :math:`{{{\mathrm{allocglobal}}^\ast}}{(s, {{{\mathit{globaltype}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}^\ast}, {{\mathit{val}}_{\mathsf{g}}^\ast})}`.

#. Assert: Due to validation, :math:`{{\mathit{globaladdr}}_0^\ast} = {{\mathit{ga}}^\ast}`.

#. Let :math:`{{\mathit{tableaddr}}_0^\ast}` be :math:`{{{\mathrm{alloctable}}^\ast}}{(s, {{{\mathit{tabletype}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}^\ast}, {{\mathit{ref}}_{\mathsf{t}}^\ast})}`.

#. Assert: Due to validation, :math:`{{\mathit{tableaddr}}_0^\ast} = {{\mathit{ta}}^\ast}`.

#. Let :math:`{{\mathit{memaddr}}_0^\ast}` be :math:`{{{\mathrm{allocmem}}^\ast}}{(s, {{{\mathit{memtype}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}^\ast})}`.

#. Assert: Due to validation, :math:`{{\mathit{memaddr}}_0^\ast} = {{\mathit{ma}}^\ast}`.

#. Let :math:`{{\mathit{tagaddr}}_0^\ast}` be :math:`{{{\mathrm{alloctag}}^\ast}}{(s, {{{\mathit{dt}}^\ast}{}[y]^\ast})}`.

#. Assert: Due to validation, :math:`{{\mathit{tagaddr}}_0^\ast} = {{\mathit{aa}}^\ast}`.

#. Let :math:`{{\mathit{elemaddr}}_0^\ast}` be :math:`{{{\mathrm{allocelem}}^\ast}}{(s, {{{\mathit{elemtype}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}^\ast}, {{{\mathit{ref}}_{\mathsf{e}}^\ast}^\ast})}`.

#. Assert: Due to validation, :math:`{{\mathit{elemaddr}}_0^\ast} = {{\mathit{ea}}^\ast}`.

#. Let :math:`{{\mathit{dataaddr}}_0^\ast}` be :math:`{{{\mathrm{allocdata}}^\ast}}{(s, {\mathsf{ok}^{{|{{\mathit{data}}^\ast}|}}}, {{{\mathit{byte}}^\ast}^\ast})}`.

#. Assert: Due to validation, :math:`{{\mathit{dataaddr}}_0^\ast} = {{\mathit{da}}^\ast}`.

#. Return :math:`{\mathit{moduleinst}}`.


:math:`{{\mathrm{runelem}}}_{x}(\mathsf{elem}~{\mathit{rt}}~{e^{n}}~{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
.................................................................................................................................


1. If :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{passive}`, then:

   a. Return :math:`\epsilon`.

#. If :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{declare}`, then:

   a. Return :math:`(\mathsf{elem{.}drop}~x)`.

#. Assert: Due to validation, :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{active}`.

#. Let :math:`(\mathsf{active}~y~{{\mathit{instr}}^\ast})` be :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{\mathit{instr}}^\ast}~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)~(\mathsf{table{.}init}~y~x)~(\mathsf{elem{.}drop}~x)`.


:math:`{{\mathrm{rundata}}}_{x}(\mathsf{data}~{b^{n}}~{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
...................................................................................................................


1. If :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{passive}`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{active}`.

#. Let :math:`(\mathsf{active}~y~{{\mathit{instr}}^\ast})` be :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{\mathit{instr}}^\ast}~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)~(\mathsf{memory{.}init}~y~x)~(\mathsf{data{.}drop}~x)`.


:math:`{{{\mathrm{evalglobal}}^\ast}}{(z, {{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {e_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
...........................................................................................................................................................


1. If :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon` and :math:`{e_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{e_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{expr}}~{{\mathit{expr}'}^\ast}` be :math:`{e_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{gt}}~{{\mathit{gt}'}^\ast}` be :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`(s, f)` be :math:`z`.

#. Let :math:`{\mathit{val}}` be the result of :ref:`evaluating <exec-expr>` :math:`{\mathit{expr}}` with state :math:`z`.

#. Let :math:`a` be :math:`{\mathrm{allocglobal}}(s, {\mathit{gt}}, {\mathit{val}})`.

#. Append :math:`a` to :math:`f{.}\mathsf{module}{.}\mathsf{globals}`.

#. Let :math:`{{\mathit{val}'}^\ast}` be :math:`{{{\mathrm{evalglobal}}^\ast}}{((s, f), {{\mathit{gt}'}^\ast}, {{\mathit{expr}'}^\ast})}`.

#. Return :math:`{\mathit{val}}~{{\mathit{val}'}^\ast}`.


:math:`{\mathrm{instantiate}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast})`
..................................................................................


1. If :math:`{\mathit{module}}` is not :ref:`valid <valid-val>`, then:

   a. Fail.

#. Let :math:`{{\mathit{xt}}_{\mathsf{i}}^\ast}~\rightarrow~{{\mathit{xt}}_{\mathsf{e}}^\ast}` be the type of :math:`{\mathit{module}}`.

#. Let :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{tag}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be :math:`{\mathit{module}}`.

#. If :math:`{|{{\mathit{externaddr}}^\ast}|} \neq {|{{\mathit{xt}}_{\mathsf{i}}^\ast}|}`, then:

   a. Fail.

#. For all :math:`{\mathit{externaddr}}`, and :math:`{\mathit{xt}}_{\mathsf{i}}` in :math:`{({\mathit{externaddr}}, {\mathit{xt}}_{\mathsf{i}})^\ast}`:

   a. If :math:`{\mathit{externaddr}}` is not :ref:`valid <valid-val>` with type :math:`{\mathit{xt}}_{\mathsf{i}}`, then:

      1) Fail.

#. Let :math:`{{\mathit{instr}}_{\mathsf{d}}^\ast}` be the concatenation of :math:`{{{\mathrm{rundata}}}_{i_{\mathsf{d}}}({{\mathit{data}}^\ast}{}[i_{\mathsf{d}}])^{i_{\mathsf{d}}<{|{{\mathit{data}}^\ast}|}}}`.

#. Let :math:`{{\mathit{instr}}_{\mathsf{e}}^\ast}` be the concatenation of :math:`{{{\mathrm{runelem}}}_{i_{\mathsf{e}}}({{\mathit{elem}}^\ast}{}[i_{\mathsf{e}}])^{i_{\mathsf{e}}<{|{{\mathit{elem}}^\ast}|}}}`.

#. Let :math:`{(\mathsf{start}~x)^?}` be :math:`{{\mathit{start}}^?}`.

#. Let :math:`{\mathit{moduleinst}}_0` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{{\mathrm{alloctype}}^\ast}}{({{\mathit{type}}^\ast})},\; \mathsf{funcs}~{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})~{({|s{.}\mathsf{funcs}|} + i_{\mathsf{f}})^{i_{\mathsf{f}}<{|{{\mathit{func}}^\ast}|}}},\; \mathsf{globals}~{\mathrm{globals}}({{\mathit{externaddr}}^\ast}) \}\end{array}`.

#. Let :math:`{(\mathsf{table}~{\mathit{tabletype}}~{\mathit{expr}}_{\mathsf{t}})^\ast}` be :math:`{{\mathit{table}}^\ast}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_{\mathsf{g}})^\ast}` be :math:`{{\mathit{global}}^\ast}`.

#. Let :math:`{(\mathsf{elem}~{\mathit{reftype}}~{{\mathit{expr}}_{\mathsf{e}}^\ast}~{\mathit{elemmode}})^\ast}` be :math:`{{\mathit{elem}}^\ast}`.

#. Let :math:`{{\mathit{instr}}_{\mathsf{s}}^?}` be :math:`{(\mathsf{call}~x)^?}`.

#. Let :math:`z` be :math:`(s, \{ \begin{array}[t]{@{}l@{}}\mathsf{module}~{\mathit{moduleinst}}_0 \}\end{array})`.

#. Push the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~z{.}\mathsf{frame}~\})` to the stack.

#. Let :math:`{{\mathit{val}}_{\mathsf{g}}^\ast}` be :math:`{{{\mathrm{evalglobal}}^\ast}}{(z, {{\mathit{globaltype}}^\ast}, {{\mathit{expr}}_{\mathsf{g}}^\ast})}`.

#. Pop the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~f~\})` from the stack.

#. Push the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~f~\})` to the stack.

#. Let :math:`{{\mathit{ref}}_{\mathsf{t}}^\ast}` be the result of :ref:`evaluating <exec-expr>` :math:`{{\mathit{expr}}_{\mathsf{t}}^\ast}` with state :math:`z`.

#. Pop the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~f~\})` from the stack.

#. Push the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~f~\})` to the stack.

#. Let :math:`{{{\mathit{ref}}_{\mathsf{e}}^\ast}^\ast}` be the result of :ref:`evaluating <exec-expr>` :math:`{{{\mathit{expr}}_{\mathsf{e}}^\ast}^\ast}` with state :math:`z`.

#. Pop the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~f~\})` from the stack.

#. Let :math:`{\mathit{moduleinst}}` be :math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}_{\mathsf{g}}^\ast}, {{\mathit{ref}}_{\mathsf{t}}^\ast}, {{{\mathit{ref}}_{\mathsf{e}}^\ast}^\ast})`.

#. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{module}~{\mathit{moduleinst}} \}\end{array}`.

#. Push the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~f~\})` to the stack.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{e}}^\ast}`.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{d}}^\ast}`.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{s}}^?}`.

#. Pop the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{0}\,\{~f~\})` from the stack.

#. Return :math:`f{.}\mathsf{module}`.


:math:`{\mathrm{invoke}}(s, {\mathit{funcaddr}}, {{\mathit{val}}^\ast})`
........................................................................


1. Assert: Due to validation, :math:`{\mathrm{expand}}(s{.}\mathsf{funcs}{}[{\mathit{funcaddr}}]{.}\mathsf{type})` is :math:`\mathsf{func}`.

#. Let :math:`(\mathsf{func}~{\mathit{functype}}_0)` be :math:`{\mathrm{expand}}(s{.}\mathsf{funcs}{}[{\mathit{funcaddr}}]{.}\mathsf{type})`.

#. Let :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` be :math:`{\mathit{functype}}_0`.

#. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{module}~\{ \begin{array}[t]{@{}l@{}} \}\end{array} \}\end{array}`.

#. If :math:`{|{t_1^\ast}|} \neq {|{{\mathit{val}}^\ast}|}`, then:

   a. Fail.

#. For all :math:`t_1`, and :math:`{\mathit{val}}` in :math:`{(t_1, {\mathit{val}})^\ast}`:

   a. If :math:`{\mathit{val}}` is not :ref:`valid <valid-val>` with type :math:`t_1`, then:

      1) Fail.

#. Let :math:`k` be :math:`{|{t_2^\ast}|}`.

#. Push the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{k}\,\{~f~\})` to the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

#. Push the value :math:`(\mathsf{ref{.}func}~{\mathit{funcaddr}})` to the stack.

#. Execute the instruction :math:`(\mathsf{call\_ref}~s{.}\mathsf{funcs}{}[{\mathit{funcaddr}}]{.}\mathsf{type})`.

#. Pop all values :math:`{{\mathit{val}}_0^\ast}` from the top of the stack.

#. Pop the :ref:`frame <syntax-frame>` :math:`({\mathsf{frame}}_{k}\,\{~f~\})` from the stack.

#. Push the values :math:`{{\mathit{val}}_0^\ast}` to the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Return :math:`{{\mathit{val}}^{k}}`.


:math:`{{{\mathrm{allocX}}^\ast}}{(s, {X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {Y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
...........................................................................................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

   a. Assert: Due to validation, :math:`{Y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`.

   #. Return :math:`\epsilon`.

#. Else:

   a. Let :math:`X~{{X'}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

   #. Assert: Due to validation, :math:`{|{Y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

   #. Let :math:`Y~{{Y'}^\ast}` be :math:`{Y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

   #. Let :math:`a` be :math:`{\mathrm{allocX}}(X, Y, s, X, Y)`.

   #. Let :math:`{{a'}^\ast}` be :math:`{{{\mathrm{allocX}}^\ast}}{(s, {{X'}^\ast}, {{Y'}^\ast})}`.

   #. Return :math:`a~{{a'}^\ast}`.


:math:`X`
.........


1. Return :math:`0`.


:math:`\mathsf{eval\_expr}~{{\mathit{instr}}^\ast}`
...................................................


1. Execute the instruction :math:`{{\mathit{instr}}^\ast}`.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Return :math:`{\mathit{val}}`.


== Complete.
watsup 0.4 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...
Untranslated relation Expand: `%~~%`(deftype, comptype)
Numtype_ok
- the number type numtype is valid.

Vectype_ok
- the vector type vectype is valid.

Heaptype_ok
- the heap type ht_u1 is valid if:
  - Either:
    - ht_u1 is absheaptype.
  - Or:
    - ht_u1 is (_IDX typeidx).
    - the defined type C.TYPES[typeidx] exists.
    - C.TYPES[typeidx] is dt.
  - Or:
    - ht_u1 is (REC i).
    - the sub type C.RECS[i] exists.
    - C.RECS[i] is st.

Heaptype_ok/abs
- the heap type absheaptype is valid.

Heaptype_ok/typeidx
- the heap type (_IDX typeidx) is valid if:
  - the defined type C.TYPES[typeidx] exists.
  - C.TYPES[typeidx] is dt.

Heaptype_ok/rec
- the heap type (REC i) is valid if:
  - the sub type C.RECS[i] exists.
  - C.RECS[i] is st.

Reftype_ok
- the reference type (REF NULL? heaptype) is valid if:
  - the heap type heaptype is valid.

Valtype_ok
- the value type t_u1 is valid if:
  - Either:
    - t_u1 is numtype.
    - the number type numtype is valid.
  - Or:
    - t_u1 is vectype.
    - the vector type vectype is valid.
  - Or:
    - t_u1 is reftype.
    - the reference type reftype is valid.
  - Or:
    - t_u1 is BOT.

Valtype_ok/num
- the value type numtype is valid if:
  - numtype is valid.

Valtype_ok/vec
- the value type vectype is valid if:
  - vectype is valid.

Valtype_ok/ref
- the value type reftype is valid if:
  - reftype is valid.

Valtype_ok/bot
- the value type BOT is valid.

Resulttype_ok
- the result type t* is valid if:
  - For all t in t*:
    - the value type t is valid.

Instrtype_ok
- the instruction type t_1* ->_ x* t_2* is valid if:
  - the result type t_1* is valid.
  - the result type t_2* is valid.
  - |lct*| is |x*|.
  - For all x in x*:
    - the local type C.LOCALS[x] exists.
  - For all lct in lct* and x in x*:
    - C.LOCALS[x] is lct.

Packtype_ok
- the packed type packtype is valid.

Storagetype_ok
- the storage type zt_u1 is valid if:
  - Either:
    - zt_u1 is valtype.
    - the value type valtype is valid.
  - Or:
    - zt_u1 is packtype.
    - the packed type packtype is valid.

Storagetype_ok/val
- the storage type valtype is valid if:
  - valtype is valid.

Storagetype_ok/pack
- the storage type packtype is valid if:
  - packtype is valid.

Fieldtype_ok
- the field type (MUT? storagetype) is valid if:
  - the storage type storagetype is valid.

Functype_ok
- the function type t_1* -> t_2* is valid if:
  - the result type t_1* is valid.
  - the result type t_2* is valid.

Comptype_ok
- the composite type ct_u1 is valid if:
  - Either:
    - ct_u1 is (STRUCT fieldtype*).
    - For all fieldtype in fieldtype*:
      - the field type fieldtype is valid.
  - Or:
    - ct_u1 is (ARRAY fieldtype).
    - fieldtype is valid.
  - Or:
    - ct_u1 is (FUNC functype).
    - the function type functype is valid.

Comptype_ok/struct
- the composite type (STRUCT fieldtype*) is valid if:
  - For all fieldtype in fieldtype*:
    - the field type fieldtype is valid.

Comptype_ok/array
- the composite type (ARRAY fieldtype) is valid if:
  - the field type fieldtype is valid.

Comptype_ok/func
- the composite type (FUNC functype) is valid if:
  - the function type functype is valid.

Packtype_sub
- the packed type packtype matches itself.

Numtype_sub
- the number type numtype matches itself.

Deftype_sub
- the defined type deftype_1 matches the defined type deftype_2 if:
  - Either:
    - the defined type $clos_deftype(C, deftype_1) is $clos_deftype(C, deftype_2).
  - Or:
    - the sub type $unrolldt(deftype_1) is (SUB fin typeuse* ct).
    - |typeuse*| is greater than i.
    - the type use typeuse*[i] matches deftype_2.

Deftype_sub/refl
- the defined type deftype_1 matches the defined type deftype_2 if:
  - the defined type $clos_deftype(C, deftype_1) is $clos_deftype(C, deftype_2).

Deftype_sub/super
- the defined type deftype_1 matches the defined type deftype_2 if:
  - the sub type $unrolldt(deftype_1) is (SUB fin typeuse* ct).
  - |typeuse*| is greater than i.
  - the type use typeuse*[i] matches deftype_2.

Heaptype_sub
- the heap type ht_u1 matches the heap type ht_u2 if:
  - Either:
    - ht_u1 is heaptype.
    - ht_u2 is heaptype.
  - Or:
    - ht_u1 is heaptype_1.
    - ht_u2 is heaptype_2.
    - the heap type heaptype' is valid.
    - the heap type heaptype_1 matches heaptype'.
    - heaptype' matches the heap type heaptype_2.
  - Or:
    - ht_u1 is EQ.
    - ht_u2 is ANY.
  - Or:
    - ht_u1 is I31.
    - ht_u2 is EQ.
  - Or:
    - ht_u1 is STRUCT.
    - ht_u2 is EQ.
  - Or:
    - ht_u1 is ARRAY.
    - ht_u2 is EQ.
  - Or:
    - ht_u1 is deftype.
    - ht_u2 is STRUCT.
    - The :ref:`expansion <aux-expand-deftype>` of the defined type deftype is the composite type (STRUCT fieldtype*).
  - Or:
    - ht_u1 is deftype.
    - ht_u2 is ARRAY.
    - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (ARRAY fieldtype).
  - Or:
    - ht_u1 is deftype.
    - ht_u2 is FUNC.
    - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (FUNC functype).
  - Or:
    - ht_u1 is deftype_1.
    - ht_u2 is deftype_2.
    - the defined type deftype_1 matches the defined type deftype_2.
  - Or:
    - ht_u1 is (_IDX typeidx).
    - ht_u2 is heaptype.
    - the defined type C.TYPES[typeidx] exists.
    - C.TYPES[typeidx] matches the heap type heaptype.
  - Or:
    - ht_u1 is heaptype.
    - ht_u2 is (_IDX typeidx).
    - C.TYPES[typeidx] exists.
    - heaptype matches C.TYPES[typeidx].
  - Or:
    - ht_u1 is (REC i).
    - ht_u2 is typeuse*[j].
    - |typeuse*| is greater than j.
    - the sub type C.RECS[i] exists.
    - C.RECS[i] is (SUB fin typeuse* ct).
  - Or:
    - ht_u1 is NONE.
    - ht_u2 is heaptype.
    - heaptype matches the heap type ANY.
  - Or:
    - ht_u1 is NOFUNC.
    - ht_u2 is heaptype.
    - heaptype matches the heap type FUNC.
  - Or:
    - ht_u1 is NOEXTERN.
    - ht_u2 is heaptype.
    - heaptype matches the heap type EXTERN.
  - Or:
    - ht_u1 is BOT.
    - ht_u2 is heaptype.

Heaptype_sub/refl
- heaptype matches itself.

Heaptype_sub/trans
- the heap type heaptype_1 matches the heap type heaptype_2 if:
  - the heap type heaptype' is valid.
  - heaptype_1 matches heaptype'.
  - heaptype' matches heaptype_2.

Heaptype_sub/eq
- the heap type EQ matches the heap type ANY.

Heaptype_sub/i31
- the heap type I31 matches EQ.

Heaptype_sub/struct
- the heap type STRUCT matches EQ.

Heaptype_sub/array
- the heap type ARRAY matches EQ.

Heaptype_sub/struct
- the heap type deftype matches the heap type STRUCT if:
  - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (STRUCT fieldtype*).

Heaptype_sub/array
- the heap type deftype matches the heap type ARRAY if:
  - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (ARRAY fieldtype).

Heaptype_sub/func
- the heap type deftype matches the heap type FUNC if:
  - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (FUNC functype).

Heaptype_sub/def
- the heap type deftype_1 matches the heap type deftype_2 if:
  - deftype_1 matches deftype_2.

Heaptype_sub/typeidx
- the heap type (_IDX typeidx) matches the heap type heaptype if:
  - the defined type C.TYPES[typeidx] exists.
  - C.TYPES[typeidx] matches heaptype.

Heaptype_sub/typeidx
- the heap type heaptype matches the heap type (_IDX typeidx) if:
  - the defined type C.TYPES[typeidx] exists.
  - heaptype matches C.TYPES[typeidx].

Heaptype_sub/rec
- the heap type (REC i) matches the type use typeuse*[j] if:
  - |typeuse*| is greater than j.
  - the sub type C.RECS[i] exists.
  - C.RECS[i] is (SUB fin typeuse* ct).

Heaptype_sub/none
- the heap type NONE matches the heap type heaptype if:
  - heaptype matches the heap type ANY.

Heaptype_sub/nofunc
- the heap type NOFUNC matches the heap type heaptype if:
  - heaptype matches the heap type FUNC.

Heaptype_sub/noextern
- the heap type NOEXTERN matches the heap type heaptype if:
  - heaptype matches the heap type EXTERN.

Heaptype_sub/bot
- the heap type BOT matches heaptype.

Reftype_sub
- the reference type (REF nul_u1 ht_1) matches the reference type (REF nul_u2 ht_2) if:
  - the heap type ht_1 matches the heap type ht_2.
  - Either:
    - nul_u1 is ?().
    - nul_u2 is ?().
  - Or:
    - nul_u1 is NULL?.
    - nul_u2 is ?(NULL).

Reftype_sub/nonnull
- the reference type (REF ?() ht_1) matches the reference type (REF ?() ht_2) if:
  - the heap type ht_1 matches the heap type ht_2.

Reftype_sub/null
- the reference type (REF NULL? ht_1) matches the reference type (REF ?(NULL) ht_2) if:
  - the heap type ht_1 matches the heap type ht_2.

Vectype_sub
- the vector type vectype matches itself.

Valtype_sub
- the value type t_u1 matches the value type t_u2 if:
  - Either:
    - t_u1 is numtype_1.
    - t_u2 is numtype_2.
    - the number type numtype_1 matches the number type numtype_2.
  - Or:
    - t_u1 is vectype_1.
    - t_u2 is vectype_2.
    - the vector type vectype_1 matches the vector type vectype_2.
  - Or:
    - t_u1 is reftype_1.
    - t_u2 is reftype_2.
    - the reference type reftype_1 matches the reference type reftype_2.
  - Or:
    - t_u1 is BOT.
    - t_u2 is valtype.

Valtype_sub/num
- the value type numtype_1 matches the value type numtype_2 if:
  - numtype_1 matches numtype_2.

Valtype_sub/vec
- the value type vectype_1 matches the value type vectype_2 if:
  - vectype_1 matches vectype_2.

Valtype_sub/ref
- the value type reftype_1 matches the value type reftype_2 if:
  - reftype_1 matches reftype_2.

Valtype_sub/bot
- the value type BOT matches the value type valtype.

Storagetype_sub
- the storage type zt_u1 matches the storage type zt_u2 if:
  - Either:
    - zt_u1 is valtype_1.
    - zt_u2 is valtype_2.
    - the value type valtype_1 matches the value type valtype_2.
  - Or:
    - zt_u1 is packtype_1.
    - zt_u2 is packtype_2.
    - the packed type packtype_1 matches the packed type packtype_2.

Storagetype_sub/val
- the storage type valtype_1 matches the storage type valtype_2 if:
  - valtype_1 matches valtype_2.

Storagetype_sub/pack
- the storage type packtype_1 matches the storage type packtype_2 if:
  - packtype_1 matches packtype_2.

Fieldtype_sub
- the field type (mut_u1 zt_1) matches the field type (mut_u2 zt_2) if:
  - the storage type zt_1 matches the storage type zt_2.
  - Either:
    - mut_u1 is ?().
    - mut_u2 is ?().
  - Or:
    - mut_u1 is ?(MUT).
    - mut_u2 is ?(MUT).
    - zt_2 matches zt_1.

Fieldtype_sub/const
- the field type (?() zt_1) matches the field type (?() zt_2) if:
  - the storage type zt_1 matches the storage type zt_2.

Fieldtype_sub/var
- the field type (?(MUT) zt_1) matches the field type (?(MUT) zt_2) if:
  - the storage type zt_1 matches the storage type zt_2.
  - zt_2 matches zt_1.

Resulttype_sub
- the value type sequence t_1* matches the value type sequence t_2* if:
  - |t_1*| is |t_2*|.
  - For all t_1 in t_1* and t_2 in t_2*:
    - the value type t_1 matches the value type t_2.

Functype_sub
- the function type t_11* -> t_12* matches the function type t_21* -> t_22* if:
  - the value type sequence t_21* matches the value type sequence t_11*.
  - the value type sequence t_12* matches the value type sequence t_22*.

Comptype_sub
- the composite type ct_u1 matches the composite type ct_u2 if:
  - Either:
    - ct_u1 is (STRUCT yt_1* :: [yt'_1]).
    - ct_u2 is (STRUCT yt_2*).
    - |yt_1*| is |yt_2*|.
    - For all yt_1 in yt_1* and yt_2 in yt_2*:
      - the field type yt_1 matches the field type yt_2.
  - Or:
    - ct_u1 is (ARRAY yt_1).
    - ct_u2 is (ARRAY yt_2).
    - yt_1 matches yt_2.
  - Or:
    - ct_u1 is (FUNC ft_1).
    - ct_u2 is (FUNC ft_2).
    - the function type ft_1 matches the function type ft_2.

Comptype_sub/struct
- the composite type (STRUCT yt_1* :: [yt'_1]) matches the composite type (STRUCT yt_2*) if:
  - |yt_1*| is |yt_2*|.
  - For all yt_1 in yt_1* and yt_2 in yt_2*:
    - the field type yt_1 matches the field type yt_2.

Comptype_sub/array
- the composite type (ARRAY yt_1) matches the composite type (ARRAY yt_2) if:
  - the field type yt_1 matches the field type yt_2.

Comptype_sub/func
- the composite type (FUNC ft_1) matches the composite type (FUNC ft_2) if:
  - the function type ft_1 matches the function type ft_2.

Subtype_ok
- the sub type (SUB FINAL? (_IDX x)* comptype) is valid with (OK x_0) if:
  - |x*| is less than or equal to 1.
  - For all x in x*:
    - the index x is less than x_0.
  - |comptype'*| is |x*|.
  - |comptype'*| is |x'**|.
  - For all x in x*:
    - the defined type C.TYPES[x] exists.
  - For all comptype' in comptype'* and x in x* and x'* in x'**:
    - the sub type $unrolldt(C.TYPES[x]) is (SUB ?() (_IDX x')* comptype').
  - the composite type comptype is valid.
  - For all comptype' in comptype'*:
    - comptype matches the composite type comptype'.

Subtype_ok2
- the sub type (SUB FINAL? typeuse* compttype) is valid with (OK x i) if:
  - |typeuse*| is less than or equal to 1.
  - For all typeuse in typeuse*:
    - $before(typeuse, x, i) is true.
  - |comptype'*| is |typeuse*|.
  - |comptype'*| is |typeuse'**|.
  - For all comptype' in comptype'* and typeuse in typeuse* and typeuse'* in typeuse'**:
    - the sub type $unrollht(C, typeuse) is (SUB ?() typeuse'* comptype').
  - the composite type comptype is valid.
  - For all comptype' in comptype'*:
    - comptype matches the composite type comptype'.

Rectype_ok2
- the recursive type (REC st_u1*) is valid with (OK x i) if:
  - Either:
    - the sub type sequence st_u1* is [].
  - Or:
    - st_u1* is [subtype_1] :: subtype*.
    - the sub type subtype_1 is valid with (OK x i).
    - the recursive type (REC subtype*) is valid with (OK (x + 1) (i + 1)).

Rectype_ok2/empty
- the recursive type (REC []) is valid with (OK x i).

Rectype_ok2/cons
- the recursive type (REC [subtype_1] :: subtype*) is valid with (OK x i) if:
  - the sub type subtype_1 is valid with (OK x i).
  - the recursive type (REC subtype*) is valid with (OK (x + 1) (i + 1)).

Rectype_ok
- the recursive type (REC st_u1*) is valid for (OK x) if:
  - Either:
    - the sub type sequence st_u1* is [].
  - Or:
    - st_u1* is [subtype_1] :: subtype*.
    - the sub type subtype_1 is valid with (OK x).
    - the recursive type (REC subtype*) is valid for (OK (x + 1)).

Rectype_ok/empty
- the recursive type (REC []) is valid for (OK x).

Rectype_ok/cons
- the recursive type (REC [subtype_1] :: subtype*) is valid for (OK x) if:
  - the sub type subtype_1 is valid with (OK x).
  - the recursive type (REC subtype*) is valid for (OK (x + 1)).

Deftype_ok
- the defined type (DEF rectype i) is valid if:
  - the recursive type rectype is valid for (OK x).
  - rectype is (REC subtype^n).
  - i is less than n.

Limits_ok
- the limits ([ n .. m ]) is valid within k if:
  - n is less than or equal to m.
  - m is less than or equal to k.

Globaltype_ok
- the global type (MUT? t) is valid if:
  - the value type t is valid.

Tabletype_ok
- the table type (addrtype limits reftype) is valid if:
  - the limits limits is valid within ((2 ^ 32) - 1).
  - the reference type reftype is valid.

Memtype_ok
- the memory type addrtype limits PAGE is valid if:
  - the limits limits is valid within (2 ^ 16).

Tagtype_ok
- the tag type deftype is valid if:
  - deftype is valid.
  - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (FUNC functype).

Externtype_ok
- the external type xt_u1 is valid if:
  - Either:
    - xt_u1 is (FUNC deftype).
    - the defined type deftype is valid.
    - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (FUNC functype).
  - Or:
    - xt_u1 is (GLOBAL globaltype).
    - the global type globaltype is valid.
  - Or:
    - xt_u1 is (TABLE tabletype).
    - the table type tabletype is valid.
  - Or:
    - xt_u1 is (MEM memtype).
    - the memory type memtype is valid.
  - Or:
    - xt_u1 is (TAG tagtype).
    - the tag type tagtype is valid.

Externtype_ok/func
- the external type (FUNC deftype) is valid if:
  - the defined type deftype is valid.
  - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (FUNC functype).

Externtype_ok/global
- the external type (GLOBAL globaltype) is valid if:
  - the global type globaltype is valid.

Externtype_ok/table
- the external type (TABLE tabletype) is valid if:
  - the table type tabletype is valid.

Externtype_ok/mem
- the external type (MEM memtype) is valid if:
  - the memory type memtype is valid.

Externtype_ok/tag
- the external type (TAG tagtype) is valid if:
  - the tag type tagtype is valid.

Instrtype_sub
- the instruction type t_11* ->_ x_1* t_12* matches the instruction type t_21* ->_ x_2* t_22* if:
  - the value type sequence t_21* matches the value type sequence t_11*.
  - the value type sequence t_12* matches the value type sequence t_22*.
  - the local index sequence x* is $setminus_(localidx, x_2*, x_1*).
  - |t*| is |x*|.
  - For all x in x*:
    - the local type C.LOCALS[x] exists.
  - For all t in t* and x in x*:
    - C.LOCALS[x] is (SET t).

Limits_sub
- the limits ([ n_1 .. m_1 ]) matches the limits ([ n_2 .. m_2 ]) if:
  - n_1 is greater than or equal to n_2.
  - m_1 is less than or equal to m_2.

Globaltype_sub
- the global type (mut_u1 valtype_1) matches the global type (mut_u2 valtype_2) if:
  - the value type valtype_1 matches the value type valtype_2.
  - Either:
    - mut_u1 is ?().
    - mut_u2 is ?().
  - Or:
    - mut_u1 is ?(MUT).
    - mut_u2 is ?(MUT).
    - valtype_2 matches valtype_1.

Globaltype_sub/const
- the global type (?() valtype_1) matches the global type (?() valtype_2) if:
  - the value type valtype_1 matches the value type valtype_2.

Globaltype_sub/var
- the global type (?(MUT) valtype_1) matches the global type (?(MUT) valtype_2) if:
  - the value type valtype_1 matches the value type valtype_2.
  - valtype_2 matches valtype_1.

Tabletype_sub
- the table type (addrtype limits_1 reftype_1) matches the table type (addrtype limits_2 reftype_2) if:
  - the limits limits_1 matches the limits limits_2.
  - the reference type reftype_1 matches the reference type reftype_2.
  - reftype_2 matches reftype_1.

Memtype_sub
- the memory type addrtype limits_1 PAGE matches the memory type addrtype limits_2 PAGE if:
  - the limits limits_1 matches the limits limits_2.

Tagtype_sub
- the tag type deftype_1 matches the tag type deftype_2 if:
  - deftype_1 matches deftype_2.
  - deftype_2 matches deftype_1.

Externtype_sub
- the external type xt_u1 matches the external type xt_u2 if:
  - Either:
    - xt_u1 is (FUNC deftype_1).
    - xt_u2 is (FUNC deftype_2).
    - the defined type deftype_1 matches the defined type deftype_2.
  - Or:
    - xt_u1 is (GLOBAL globaltype_1).
    - xt_u2 is (GLOBAL globaltype_2).
    - the global type globaltype_1 matches the global type globaltype_2.
  - Or:
    - xt_u1 is (TABLE tabletype_1).
    - xt_u2 is (TABLE tabletype_2).
    - the table type tabletype_1 matches the table type tabletype_2.
  - Or:
    - xt_u1 is (MEM memtype_1).
    - xt_u2 is (MEM memtype_2).
    - the memory type memtype_1 matches the memory type memtype_2.
  - Or:
    - xt_u1 is (TAG tagtype_1).
    - xt_u2 is (TAG tagtype_2).
    - the tag type tagtype_1 matches the tag type tagtype_2.

Externtype_sub/func
- the external type (FUNC deftype_1) matches the external type (FUNC deftype_2) if:
  - the defined type deftype_1 matches the defined type deftype_2.

Externtype_sub/global
- the external type (GLOBAL globaltype_1) matches the external type (GLOBAL globaltype_2) if:
  - the global type globaltype_1 matches the global type globaltype_2.

Externtype_sub/table
- the external type (TABLE tabletype_1) matches the external type (TABLE tabletype_2) if:
  - the table type tabletype_1 matches the table type tabletype_2.

Externtype_sub/mem
- the external type (MEM memtype_1) matches the external type (MEM memtype_2) if:
  - the memory type memtype_1 matches the memory type memtype_2.

Externtype_sub/tag
- the external type (TAG tagtype_1) matches the external type (TAG tagtype_2) if:
  - the tag type tagtype_1 matches the tag type tagtype_2.

Blocktype_ok
- the block type bt_u1 is valid as the instruction type t_u1* -> t_u2* if:
  - Either:
    - bt_u1 is (_RESULT valtype?).
    - the value type sequence t_u1* is [].
    - the value type sequence t_u2* is valtype?.
    - If valtype is defined, then:
      - the value type valtype is valid.
  - Or:
    - bt_u1 is (_IDX typeidx).
    - t_u1* is t_1*.
    - t_u2* is t_2*.
    - the defined type C.TYPES[typeidx] exists.
    - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[typeidx] is the composite type (FUNC t_1* -> t_2*).

Blocktype_ok/valtype
- the block type (_RESULT valtype?) is valid as the instruction type [] -> valtype? if:
  - If valtype is defined, then:
    - the value type valtype is valid.

Blocktype_ok/typeidx
- the block type (_IDX typeidx) is valid as the instruction type t_1* -> t_2* if:
  - the defined type C.TYPES[typeidx] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[typeidx] is the composite type (FUNC t_1* -> t_2*).

Catch_ok
- the catch clause catch_u1 is valid if:
  - the result type C.LABELS[l] exists.
  - Either:
    - catch_u1 is (CATCH x l).
    - the tag type C.TAGS[x] exists.
    - The :ref:`expansion <aux-expand-deftype>` of C.TAGS[x] is the composite type (FUNC t* -> []).
    - the value type sequence t* matches C.LABELS[l].
  - Or:
    - catch_u1 is (CATCH_REF x l).
    - C.TAGS[x] exists.
    - The :ref:`expansion <aux-expand-deftype>` of C.TAGS[x] is (FUNC t* -> []).
    - the value type sequence t* :: [(REF ?() EXN)] matches C.LABELS[l].
  - Or:
    - catch_u1 is (CATCH_ALL l).
    - the value type sequence [] matches C.LABELS[l].
  - Or:
    - catch_u1 is (CATCH_ALL_REF l).
    - the value type sequence [(REF ?() EXN)] matches C.LABELS[l].

Catch_ok/catch
- the catch clause (CATCH x l) is valid if:
  - the tag type C.TAGS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TAGS[x] is the composite type (FUNC t* -> []).
  - the result type C.LABELS[l] exists.
  - the value type sequence t* matches C.LABELS[l].

Catch_ok/catch_ref
- the catch clause (CATCH_REF x l) is valid if:
  - the tag type C.TAGS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TAGS[x] is the composite type (FUNC t* -> []).
  - the result type C.LABELS[l] exists.
  - the value type sequence t* :: [(REF ?() EXN)] matches C.LABELS[l].

Catch_ok/catch_all
- the catch clause (CATCH_ALL l) is valid if:
  - the result type C.LABELS[l] exists.
  - the value type sequence [] matches C.LABELS[l].

Catch_ok/catch_all_ref
- the catch clause (CATCH_ALL_REF l) is valid if:
  - the result type C.LABELS[l] exists.
  - the value type sequence [(REF ?() EXN)] matches C.LABELS[l].

Defaultable
- the value type t is defaultable if:
  - the value $default_(t) is not ?().

Instr_ok/nop
- the instruction NOP is valid with the instruction type [] -> [].

Instr_ok/unreachable
- the instruction UNREACHABLE is valid with the instruction type t_1* -> t_2* if:
  - t_1* -> t_2* is valid.

Instr_ok/drop
- the instruction DROP is valid with the instruction type [t] -> [] if:
  - the value type t is valid.

Instr_ok/select
- the instruction (SELECT t_u1?) is valid with the instruction type [t, t, I32] -> [t] if:
  - the value type t is valid.
  - Either:
    - the value type sequence t_u1? is ?([t]).
  - Or:
    - t_u1? is ?().
    - t matches the value type t'.
    - t' is numtype or t' is vectype.

Instr_ok/block
- the instruction (BLOCK bt instr*) is valid with the instruction type t_1* -> t_2* if:
  - the block type bt is valid as t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr* is valid with the instruction type t_1* ->_ x* t_2*.

Instr_ok/loop
- the instruction (LOOP bt instr*) is valid with the instruction type t_1* -> t_2* if:
  - the block type bt is valid as t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_1*].
  - Under the context C', the instruction sequence instr* is valid with the instruction type t_1* ->_ x* t_2*.

Instr_ok/if
- the instruction (IF bt instr_1* ELSE instr_2*) is valid with the instruction type t_1* :: [I32] -> t_2* if:
  - the block type bt is valid as the instruction type t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr_1* is valid with the instruction type t_1* ->_ x_1* t_2*.
  - Under the context C', the instruction sequence instr_2* is valid with the instruction type t_1* ->_ x_2* t_2*.

Instr_ok/br
- the instruction (BR l) is valid with the instruction type t_1* :: t* -> t_2* if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t*.
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/br_if
- the instruction (BR_IF l) is valid with the instruction type t* :: [I32] -> t* if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t*.

Instr_ok/br_table
- the instruction (BR_TABLE l* l') is valid with the instruction type t_1* :: t* :: [I32] -> t_2* if:
  - For all l in l*:
    - the result type C.LABELS[l] exists.
  - For all l in l*:
    - the value type sequence t* matches C.LABELS[l].
  - the result type C.LABELS[l'] exists.
  - t* matches C.LABELS[l'].
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/br_on_null
- the instruction (BR_ON_NULL l) is valid with the instruction type t* :: [(REF ?(NULL) ht)] -> t* :: [(REF ?() ht)] if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t*.
  - the heap type ht is valid.

Instr_ok/br_on_non_null
- the instruction (BR_ON_NON_NULL l) is valid with the instruction type t* :: [(REF ?(NULL) ht)] -> t* if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t* :: [(REF ?() ht)].

Instr_ok/br_on_cast
- the instruction (BR_ON_CAST l rt_1 rt_2) is valid with the instruction type t* :: [rt_1] -> t* :: [t'] if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t* :: [rt].
  - the reference type rt_1 is valid.
  - the reference type rt_2 is valid.
  - rt_2 matches rt_1.
  - rt_2 matches the reference type rt.
  - Let t' be the reference type $diffrt(rt_1, rt_2).

Instr_ok/br_on_cast_fail
- the instruction (BR_ON_CAST_FAIL l rt_1 rt_2) is valid with the instruction type t* :: [rt_1] -> t* :: [rt_2] if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t* :: [rt].
  - the reference type rt_1 is valid.
  - the reference type rt_2 is valid.
  - rt_2 matches rt_1.
  - the reference type $diffrt(rt_1, rt_2) matches the reference type rt.

Instr_ok/call
- the instruction (CALL x) is valid with the instruction type t_1* -> t_2* if:
  - the defined type C.FUNCS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.FUNCS[x] is the composite type (FUNC t_1* -> t_2*).

Instr_ok/call_ref
- the instruction (CALL_REF (_IDX x)) is valid with the instruction type t_1* :: [(REF ?(NULL) (_IDX x))] -> t_2* if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (FUNC t_1* -> t_2*).

Instr_ok/call_indirect
- the instruction (CALL_INDIRECT x (_IDX y)) is valid with the instruction type t_1* :: [at] -> t_2* if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt).
  - the reference type rt matches the reference type (REF ?(NULL) FUNC).
  - the defined type C.TYPES[y] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[y] is the composite type (FUNC t_1* -> t_2*).

Instr_ok/return
- the instruction RETURN is valid with the instruction type t_1* :: t* -> t_2* if:
  - the result type C.RETURN is ?(t*).
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/return_call
- the instruction (RETURN_CALL x) is valid with the instruction type t_3* :: t_1* -> t_4* if:
  - the defined type C.FUNCS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.FUNCS[x] is the composite type (FUNC t_1* -> t_2*).
  - the result type C.RETURN is ?(t'_2*).
  - the value type sequence t_2* matches the value type sequence t'_2*.
  - the instruction type t_3* -> t_4* is valid.

Instr_ok/return_call_ref
- the instruction (RETURN_CALL_REF (_IDX x)) is valid with the instruction type t_3* :: t_1* :: [(REF ?(NULL) (_IDX x))] -> t_4* if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (FUNC t_1* -> t_2*).
  - the result type C.RETURN is ?(t'_2*).
  - the value type sequence t_2* matches the value type sequence t'_2*.
  - the instruction type t_3* -> t_4* is valid.

Instr_ok/return_call_indirect
- the instruction (RETURN_CALL_INDIRECT x (_IDX y)) is valid with the instruction type t_3* :: t_1* :: [at] -> t_4* if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt).
  - the reference type rt matches the reference type (REF ?(NULL) FUNC).
  - the defined type C.TYPES[y] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[y] is the composite type (FUNC t_1* -> t_2*).
  - the result type C.RETURN is ?(t'_2*).
  - the value type sequence t_2* matches the value type sequence t'_2*.
  - the instruction type t_3* -> t_4* is valid.

Instr_ok/throw
- the instruction (THROW x) is valid with the instruction type t_1* :: t* -> t_2* if:
  - the tag type C.TAGS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TAGS[x] is the composite type (FUNC t* -> []).
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/throw_ref
- the instruction THROW_REF is valid with the instruction type t_1* :: [(REF ?(NULL) EXN)] -> t_2* if:
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/try_table
- the instruction (TRY_TABLE bt catch* instr*) is valid with the instruction type t_1* -> t_2* if:
  - the block type bt is valid as t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr* is valid with the instruction type t_1* ->_ x* t_2*.
  - For all catch in catch*:
    - the catch clause catch is valid.

Instr_ok/const
- the instruction (nt.CONST c_nt) is valid with the instruction type [] -> [nt].

Instr_ok/unop
- the instruction (UNOP nt unop_nt) is valid with the instruction type [nt] -> [nt].

Instr_ok/binop
- the instruction (BINOP nt binop_nt) is valid with the instruction type [nt, nt] -> [nt].

Instr_ok/testop
- the instruction (TESTOP nt testop_nt) is valid with the instruction type [nt] -> [I32].

Instr_ok/relop
- the instruction (RELOP nt relop_nt) is valid with the instruction type [nt, nt] -> [I32].

Instr_ok/cvtop
- the instruction (CVTOP nt_1 nt_2 cvtop) is valid with the instruction type [nt_2] -> [nt_1].

Instr_ok/ref.null
- the instruction (REF.NULL ht) is valid with the instruction type [] -> [(REF ?(NULL) ht)] if:
  - the heap type ht is valid.

Instr_ok/ref.func
- the instruction (REF.FUNC x) is valid with the instruction type [] -> [(REF ?() dt)] if:
  - the defined type C.FUNCS[x] exists.
  - C.FUNCS[x] is dt.
  - x is contained in C.REFS.

Instr_ok/ref.i31
- the instruction REF.I31 is valid with the instruction type [I32] -> [(REF ?() I31)].

Instr_ok/ref.is_null
- the instruction REF.IS_NULL is valid with the instruction type [(REF ?(NULL) ht)] -> [I32] if:
  - the heap type ht is valid.

Instr_ok/ref.as_non_null
- the instruction REF.AS_NON_NULL is valid with the instruction type [(REF ?(NULL) ht)] -> [(REF ?() ht)] if:
  - the heap type ht is valid.

Instr_ok/ref.eq
- the instruction REF.EQ is valid with the instruction type [(REF ?(NULL) EQ), (REF ?(NULL) EQ)] -> [I32].

Instr_ok/ref.test
- the instruction (REF.TEST rt) is valid with the instruction type [rt'] -> [I32] if:
  - the reference type rt is valid.
  - the reference type rt' is valid.
  - rt matches rt'.

Instr_ok/ref.cast
- the instruction (REF.CAST rt) is valid with the instruction type [rt'] -> [rt] if:
  - the reference type rt is valid.
  - the reference type rt' is valid.
  - rt matches rt'.

Instr_ok/i31.get
- the instruction (I31.GET sx) is valid with the instruction type [(REF ?(NULL) I31)] -> [I32].

Instr_ok/struct.new
- the instruction (STRUCT.NEW x) is valid with the instruction type t* -> [(REF ?() (_IDX x))] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (STRUCT (mut zt)*).
  - Let t* be the value type sequence $unpack(zt)*.

Instr_ok/struct.new_default
- the instruction (STRUCT.NEW_DEFAULT x) is valid with the instruction type [] -> [(REF ?() (_IDX x))] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (STRUCT (mut zt)*).
  - For all zt in zt*:
    - A :ref:`default value <aux-default>` for the value type $unpack(zt) is defined.

Instr_ok/struct.get
- the instruction (STRUCT.GET sx? x i) is valid with the instruction type [(REF ?(NULL) (_IDX x))] -> [t] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (STRUCT yt*).
  - |yt*| is greater than i.
  - the field type yt*[i] is (mut zt).
  - the signedness sx? is ?() if and only if the storage type zt is $unpack(zt).
  - Let t be the value type $unpack(zt).

Instr_ok/struct.set
- the instruction (STRUCT.SET x i) is valid with the instruction type [(REF ?(NULL) (_IDX x)), t] -> [] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (STRUCT yt*).
  - |yt*| is greater than i.
  - the field type yt*[i] is (?(MUT) zt).
  - Let t be the value type $unpack(zt).

Instr_ok/array.new
- the instruction (ARRAY.NEW x) is valid with the instruction type [t, I32] -> [(REF ?() (_IDX x))] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (mut zt)).
  - Let t be the value type $unpack(zt).

Instr_ok/array.new_default
- the instruction (ARRAY.NEW_DEFAULT x) is valid with the instruction type [I32] -> [(REF ?() (_IDX x))] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (mut zt)).
  - A :ref:`default value <aux-default>` for the value type $unpack(zt) is defined.

Instr_ok/array.new_fixed
- the instruction (ARRAY.NEW_FIXED x n) is valid with the instruction type t^n -> [(REF ?() (_IDX x))] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (mut zt)).
  - Let t be the value type $unpack(zt).

Instr_ok/array.new_elem
- the instruction (ARRAY.NEW_ELEM x y) is valid with the instruction type [I32, I32] -> [(REF ?() (_IDX x))] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (mut rt)).
  - the element type C.ELEMS[y] exists.
  - C.ELEMS[y] matches the reference type rt.

Instr_ok/array.new_data
- the instruction (ARRAY.NEW_DATA x y) is valid with the instruction type [I32, I32] -> [(REF ?() (_IDX x))] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (mut zt)).
  - $unpack(zt) is numtype or the value type $unpack(zt) is vectype.
  - the data type C.DATAS[y] exists.
  - C.DATAS[y] is OK.

Instr_ok/array.get
- the instruction (ARRAY.GET sx? x) is valid with the instruction type [(REF ?(NULL) (_IDX x)), I32] -> [t] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (mut zt)).
  - the signedness sx? is ?() if and only if the storage type zt is $unpack(zt).
  - Let t be the value type $unpack(zt).

Instr_ok/array.set
- the instruction (ARRAY.SET x) is valid with the instruction type [(REF ?(NULL) (_IDX x)), I32, t] -> [] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (?(MUT) zt)).
  - Let t be the value type $unpack(zt).

Instr_ok/array.len
- the instruction ARRAY.LEN is valid with the instruction type [(REF ?(NULL) ARRAY)] -> [I32].

Instr_ok/array.fill
- the instruction (ARRAY.FILL x) is valid with the instruction type [(REF ?(NULL) (_IDX x)), I32, t, I32] -> [] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (?(MUT) zt)).
  - Let t be the value type $unpack(zt).

Instr_ok/array.copy
- the instruction (ARRAY.COPY x_1 x_2) is valid with the instruction type [(REF ?(NULL) (_IDX x_1)), I32, (REF ?(NULL) (_IDX x_2)), I32, I32] -> [] if:
  - the defined type C.TYPES[x_1] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x_1] is the composite type (ARRAY (?(MUT) zt_1)).
  - the defined type C.TYPES[x_2] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x_2] is the composite type (ARRAY (mut zt_2)).
  - the storage type zt_2 matches the storage type zt_1.

Instr_ok/array.init_elem
- the instruction (ARRAY.INIT_ELEM x y) is valid with the instruction type [(REF ?(NULL) (_IDX x)), I32, I32, I32] -> [] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (?(MUT) zt)).
  - the element type C.ELEMS[y] exists.
  - C.ELEMS[y] matches the storage type zt.

Instr_ok/array.init_data
- the instruction (ARRAY.INIT_DATA x y) is valid with the instruction type [(REF ?(NULL) (_IDX x)), I32, I32, I32] -> [] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (?(MUT) zt)).
  - $unpack(zt) is numtype or the value type $unpack(zt) is vectype.
  - the data type C.DATAS[y] exists.
  - C.DATAS[y] is OK.

Instr_ok/extern.convert_any
- the instruction EXTERN.CONVERT_ANY is valid with the instruction type [(REF nul1 ANY)] -> [(REF nul2 EXTERN)] if:
  - nul1 is nul2.

Instr_ok/any.convert_extern
- the instruction ANY.CONVERT_EXTERN is valid with the instruction type [(REF nul1 EXTERN)] -> [(REF nul2 ANY)] if:
  - nul1 is nul2.

Instr_ok/vconst
- the instruction (V128.CONST c) is valid with the instruction type [] -> [V128].

Instr_ok/vvunop
- the instruction (VVUNOP V128 vvunop) is valid with the instruction type [V128] -> [V128].

Instr_ok/vvbinop
- the instruction (VVBINOP V128 vvbinop) is valid with the instruction type [V128, V128] -> [V128].

Instr_ok/vvternop
- the instruction (VVTERNOP V128 vvternop) is valid with the instruction type [V128, V128, V128] -> [V128].

Instr_ok/vvtestop
- the instruction (VVTESTOP V128 vvtestop) is valid with the instruction type [V128] -> [I32].

Instr_ok/vunop
- the instruction (VUNOP sh vunop) is valid with [V128] -> [V128].

Instr_ok/vbinop
- the instruction (VBINOP sh vbinop) is valid with [V128, V128] -> [V128].

Instr_ok/vternop
- the instruction (VTERNOP sh vternop) is valid with [V128, V128, V128] -> [V128].

Instr_ok/vtestop
- the instruction (VTESTOP sh vtestop) is valid with [V128] -> [I32].

Instr_ok/vrelop
- the instruction (VRELOP sh vrelop) is valid with [V128, V128] -> [V128].

Instr_ok/vshiftop
- the instruction (VSHIFTOP sh vshiftop) is valid with the instruction type [V128, I32] -> [V128].

Instr_ok/vbitmask
- the instruction (VBITMASK sh) is valid with [V128] -> [I32].

Instr_ok/vswizzlop
- the instruction (VSWIZZLOP sh vswizzlop) is valid with [V128, V128] -> [V128].

Instr_ok/vshuffle
- the instruction (VSHUFFLE sh i*) is valid with the instruction type [V128, V128] -> [V128] if:
  - For all i in i*:
    - the lane index i is less than (2 * $dim(sh)).

Instr_ok/vsplat
- the instruction (VSPLAT sh) is valid with the instruction type [t] -> [V128] if:
  - Let t be the number type $unpackshape(sh).

Instr_ok/vextract_lane
- the instruction (VEXTRACT_LANE sh sx? i) is valid with the instruction type [V128] -> [t] if:
  - the lane index i is less than $dim(sh).
  - Let t be the number type $unpackshape(sh).

Instr_ok/vreplace_lane
- the instruction (VREPLACE_LANE sh i) is valid with the instruction type [V128, t] -> [V128] if:
  - the lane index i is less than $dim(sh).
  - Let t be the number type $unpackshape(sh).

Instr_ok/vextunop
- the instruction (VEXTUNOP sh_1 sh_2 vextunop) is valid with the instruction type [V128] -> [V128].

Instr_ok/vextbinop
- the instruction (VEXTBINOP sh_1 sh_2 vextbinop) is valid with the instruction type [V128, V128] -> [V128].

Instr_ok/vextternop
- the instruction (VEXTTERNOP sh_1 sh_2 vextternop) is valid with the instruction type [V128, V128, V128] -> [V128].

Instr_ok/vnarrow
- the instruction (VNARROW sh_1 sh_2 sx) is valid with [V128, V128] -> [V128].

Instr_ok/vcvtop
- the instruction (VCVTOP sh_1 sh_2 vcvtop half? zero?) is valid with [V128] -> [V128].

Instr_ok/local.get
- the instruction (LOCAL.GET x) is valid with the instruction type [] -> [t] if:
  - the local type C.LOCALS[x] exists.
  - C.LOCALS[x] is (SET t).

Instr_ok/local.set
- the instruction (LOCAL.SET x) is valid with the instruction type [t] ->_ [x] [] if:
  - the local type C.LOCALS[x] exists.
  - C.LOCALS[x] is (init t).

Instr_ok/local.tee
- the instruction (LOCAL.TEE x) is valid with the instruction type [t] ->_ [x] [t] if:
  - the local type C.LOCALS[x] exists.
  - C.LOCALS[x] is (init t).

Instr_ok/global.get
- the instruction (GLOBAL.GET x) is valid with the instruction type [] -> [t] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (mut t).

Instr_ok/global.set
- the instruction (GLOBAL.SET x) is valid with the instruction type [t] -> [] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?(MUT) t).

Instr_ok/table.get
- the instruction (TABLE.GET x) is valid with the instruction type [at] -> [rt] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt).

Instr_ok/table.set
- the instruction (TABLE.SET x) is valid with the instruction type [at, rt] -> [] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt).

Instr_ok/table.size
- the instruction (TABLE.SIZE x) is valid with the instruction type [] -> [at] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt).

Instr_ok/table.grow
- the instruction (TABLE.GROW x) is valid with the instruction type [rt, at] -> [at] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt).

Instr_ok/table.fill
- the instruction (TABLE.FILL x) is valid with the instruction type [at, rt, at] -> [] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt).

Instr_ok/table.copy
- the instruction (TABLE.COPY x_1 x_2) is valid with the instruction type [at_1, at_2, t] -> [] if:
  - the table type C.TABLES[x_1] exists.
  - C.TABLES[x_1] is (at_1 lim_1 rt_1).
  - the table type C.TABLES[x_2] exists.
  - C.TABLES[x_2] is (at_2 lim_2 rt_2).
  - the reference type rt_2 matches the reference type rt_1.
  - Let t be the address type $minat(at_1, at_2).

Instr_ok/table.init
- the instruction (TABLE.INIT x y) is valid with the instruction type [at, I32, I32] -> [] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt_1).
  - the element type C.ELEMS[y] exists.
  - C.ELEMS[y] is rt_2.
  - the reference type rt_2 matches the reference type rt_1.

Instr_ok/elem.drop
- the instruction (ELEM.DROP x) is valid with the instruction type [] -> [] if:
  - the element type C.ELEMS[x] exists.
  - C.ELEMS[x] is rt.

Instr_ok/memory.size
- the instruction (MEMORY.SIZE x) is valid with the instruction type [] -> [at] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.

Instr_ok/memory.grow
- the instruction (MEMORY.GROW x) is valid with the instruction type [at] -> [at] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.

Instr_ok/memory.fill
- the instruction (MEMORY.FILL x) is valid with the instruction type [at, I32, at] -> [] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.

Instr_ok/memory.copy
- the instruction (MEMORY.COPY x_1 x_2) is valid with the instruction type [at_1, at_2, t] -> [] if:
  - the memory type C.MEMS[x_1] exists.
  - C.MEMS[x_1] is at_1 lim_1 PAGE.
  - the memory type C.MEMS[x_2] exists.
  - C.MEMS[x_2] is at_2 lim_2 PAGE.
  - Let t be the address type $minat(at_1, at_2).

Instr_ok/memory.init
- the instruction (MEMORY.INIT x y) is valid with the instruction type [at, I32, I32] -> [] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - the data type C.DATAS[y] exists.
  - C.DATAS[y] is OK.

Instr_ok/data.drop
- the instruction (DATA.DROP x) is valid with the instruction type [] -> [] if:
  - the data type C.DATAS[x] exists.
  - C.DATAS[x] is OK.

Instr_ok/load
- the instruction (LOAD nt_u1 loadop_u1? x memarg) is valid with the instruction type [at] -> [t_u1] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - Either:
    - the number type nt_u1 is nt.
    - loadop_u1? is ?().
    - the value type t_u1 is nt.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - Or:
    - nt_u1 is Inn.
    - loadop_u1? is ?(M _ sx).
    - t_u1 is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store
- the instruction (STORE nt_u1 storeop_u1? x memarg) is valid with the instruction type [at, t_u1] -> [] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - Either:
    - the number type nt_u1 is nt.
    - storeop_u1? is ?().
    - the value type t_u1 is nt.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - Or:
    - nt_u1 is Inn.
    - storeop_u1? is ?(M).
    - t_u1 is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/vload
- the instruction (VLOAD V128 vloadop_u1? x memarg) is valid with the instruction type [at] -> [V128] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - Either:
    - vloadop_u1? is ?().
    - (2 ^ memarg.ALIGN) is less than or equal to ($vsize(V128) / 8).
  - Or:
    - vloadop_u1? is ?((SHAPE M X N _ sx)).
    - (2 ^ memarg.ALIGN) is less than or equal to ((M / 8) * N).
  - Or:
    - vloadop_u1? is ?((SPLAT N)).
    - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).
  - Or:
    - vloadop_u1? is ?((ZERO N)).
    - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).

Instr_ok/vload_lane
- the instruction (VLOAD_LANE V128 N x memarg i) is valid with the instruction type [at, V128] -> [V128] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).
  - i is less than (128 / N).

Instr_ok/vstore
- the instruction (VSTORE V128 x memarg) is valid with the instruction type [at, V128] -> [] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to ($vsize(V128) / 8).

Instr_ok/vstore_lane
- the instruction (VSTORE_LANE V128 N x memarg i) is valid with the instruction type [at, V128] -> [] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).
  - i is less than (128 / N).

Instr_ok/select-expl
- the instruction (SELECT ?([t])) is valid with the instruction type [t, t, I32] -> [t] if:
  - the value type t is valid.

Instr_ok/select-impl
- the instruction (SELECT ?()) is valid with the instruction type [t, t, I32] -> [t] if:
  - the value type t is valid.
  - t matches the value type t'.
  - t' is numtype or t' is vectype.

Instr_ok/load-val
- the instruction (LOAD nt ?() x memarg) is valid with the instruction type [at] -> [nt] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).

Instr_ok/load-pack
- the instruction (LOAD Inn ?(M _ sx) x memarg) is valid with the instruction type [at] -> [Inn] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store-val
- the instruction (STORE nt ?() x memarg) is valid with the instruction type [at, nt] -> [] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).

Instr_ok/store-pack
- the instruction (STORE Inn ?(M) x memarg) is valid with the instruction type [at, Inn] -> [] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/vload-val
- the instruction (VLOAD V128 ?() x memarg) is valid with the instruction type [at] -> [V128] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to ($vsize(V128) / 8).

Instr_ok/vload-pack
- the instruction (VLOAD V128 ?((SHAPE M X N _ sx)) x memarg) is valid with the instruction type [at] -> [V128] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to ((M / 8) * N).

Instr_ok/vload-splat
- the instruction (VLOAD V128 ?((SPLAT N)) x memarg) is valid with the instruction type [at] -> [V128] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).

Instr_ok/vload-zero
- the instruction (VLOAD V128 ?((ZERO N)) x memarg) is valid with the instruction type [at] -> [V128] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).

Instrs_ok
- the instruction sequence instr_u1* is valid with the instruction type instrtype_u1 if:
  - Either:
    - instr_u1* is [].
    - instrtype_u1 is [] -> [].
  - Or:
    - instr_u1* is [instr_1] :: instr_2*.
    - instrtype_u1 is t_1* ->_ x_1* :: x_2* t_3*.
    - the instruction instr_1 is valid with the instruction type t_1* ->_ x_1* t_2*.
    - |init*| is |t*|.
    - |init*| is |x_1*|.
    - For all x_1 in x_1*:
      - the local type C.LOCALS[x_1] exists.
    - For all init in init* and t in t* and x_1 in x_1*:
      - C.LOCALS[x_1] is (init t).
    - Under the context $with_locals(C, x_1*, (SET t)*), the instruction sequence instr_2* is valid with the instruction type t_2* ->_ x_2* t_3*.
  - Or:
    - instr_u1* is instr*.
    - instrtype_u1 is it'.
    - the instruction sequence instr* is valid with the instruction type it.
    - it matches the instruction type it'.
    - it' is valid.
  - Or:
    - instr_u1* is instr*.
    - instrtype_u1 is t* :: t_1* ->_ x* t* :: t_2*.
    - instr* is valid with the instruction type t_1* ->_ x* t_2*.
    - the result type t* is valid.

Instrs_ok/empty
- the instruction sequence [] is valid with the instruction type [] -> [].

Instrs_ok/seq
- the instruction sequence [instr_1] :: instr_2* is valid with the instruction type t_1* ->_ x_1* :: x_2* t_3* if:
  - the instruction instr_1 is valid with the instruction type t_1* ->_ x_1* t_2*.
  - |init*| is |t*|.
  - |init*| is |x_1*|.
  - For all x_1 in x_1*:
    - the local type C.LOCALS[x_1] exists.
  - For all init in init* and t in t* and x_1 in x_1*:
    - C.LOCALS[x_1] is (init t).
  - Under the context $with_locals(C, x_1*, (SET t)*), the instruction sequence instr_2* is valid with the instruction type t_2* ->_ x_2* t_3*.

Instrs_ok/sub
- the instruction sequence instr* is valid with the instruction type it' if:
  - instr* is valid with the instruction type it.
  - it matches it'.
  - it' is valid.

Instrs_ok/frame
- the instruction sequence instr* is valid with the instruction type t* :: t_1* ->_ x* t* :: t_2* if:
  - instr* is valid with the instruction type t_1* ->_ x* t_2*.
  - the result type t* is valid.

Expr_ok
- the expression instr* is valid with the result type t* if:
  - instr* is valid with the instruction type [] -> t*.

Nondefaultable
- the value type t is not defaultable if:
  - the value $default_(t) is ?().

Instr_const
- the instruction instr_u1 is constant if:
  - Either:
    - instr_u1 is (nt.CONST c_nt).
  - Or:
    - instr_u1 is (vt.CONST c_vt).
  - Or:
    - instr_u1 is (REF.NULL ht).
  - Or:
    - instr_u1 is REF.I31.
  - Or:
    - instr_u1 is (REF.FUNC x).
  - Or:
    - instr_u1 is (STRUCT.NEW x).
  - Or:
    - instr_u1 is (STRUCT.NEW_DEFAULT x).
  - Or:
    - instr_u1 is (ARRAY.NEW x).
  - Or:
    - instr_u1 is (ARRAY.NEW_DEFAULT x).
  - Or:
    - instr_u1 is (ARRAY.NEW_FIXED x n).
  - Or:
    - instr_u1 is ANY.CONVERT_EXTERN.
  - Or:
    - instr_u1 is EXTERN.CONVERT_ANY.
  - Or:
    - instr_u1 is (GLOBAL.GET x).
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is (?() t).
  - Or:
    - instr_u1 is (BINOP Inn binop).
    - Inn is contained in [I32, I64].
    - binop is contained in [ADD, SUB, MUL].

Instr_const/const
- the instruction (nt.CONST c_nt) is constant.

Instr_const/vconst
- the instruction (vt.CONST c_vt) is constant.

Instr_const/ref.null
- the instruction (REF.NULL ht) is constant.

Instr_const/ref.i31
- the instruction REF.I31 is constant.

Instr_const/ref.func
- the instruction (REF.FUNC x) is constant.

Instr_const/struct.new
- the instruction (STRUCT.NEW x) is constant.

Instr_const/struct.new_default
- the instruction (STRUCT.NEW_DEFAULT x) is constant.

Instr_const/array.new
- the instruction (ARRAY.NEW x) is constant.

Instr_const/array.new_default
- the instruction (ARRAY.NEW_DEFAULT x) is constant.

Instr_const/array.new_fixed
- the instruction (ARRAY.NEW_FIXED x n) is constant.

Instr_const/any.convert_extern
- the instruction ANY.CONVERT_EXTERN is constant.

Instr_const/extern.convert_any
- the instruction EXTERN.CONVERT_ANY is constant.

Instr_const/global.get
- the instruction (GLOBAL.GET x) is constant if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?() t).

Instr_const/binop
- the instruction (BINOP Inn binop) is constant if:
  - Inn is contained in [I32, I64].
  - binop is contained in [ADD, SUB, MUL].

Expr_const
- the expression instr* is constant if:
  - For all instr in instr*:
    - the instruction instr is constant.

Type_ok
- the type definition (TYPE rectype) is valid with the defined type sequence dt* if:
  - |C.TYPES| is x.
  - dt* is $rolldt(x, rectype).
  - the context C' is the context C with .TYPES appended by dt*.
  - Under the context C', the recursive type rectype is valid for (OK x).

Local_ok
- the local (LOCAL t) is valid with the local type (init_u1 t) if:
  - Either:
    - the initialization status init_u1 is SET.
    - A :ref:`default value <aux-default>` for the value type t is defined.
  - Or:
    - init_u1 is UNSET.
    - A :ref:`default value <aux-default>` for t is not defined.

Local_ok/set
- the local (LOCAL t) is valid with the local type (SET t) if:
  - A :ref:`default value <aux-default>` for the value type t is defined.

Local_ok/unset
- the local (LOCAL t) is valid with the local type (UNSET t) if:
  - A :ref:`default value <aux-default>` for the value type t is not defined.

Func_ok
- the function (FUNC x local* expr) is valid with the defined type C.TYPES[x] if:
  - C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (FUNC t_1* -> t_2*).
  - |lct*| is |local*|.
  - For all lct in lct* and local in local*:
    - the local local is valid with the local type lct.
  - Under the context C with .LOCALS appended by (SET t_1)* :: lct* with .LABELS appended by [t_2*] with .RETURN appended by ?(t_2*), the expression expr is valid with the result type t_2*.

Global_ok
- the global (GLOBAL globaltype expr) is valid with the global type globaltype if:
  - the global type gt is valid.
  - globaltype is (mut t).
  - the expression expr is valid with the value type t.
  - expr is constant.

Table_ok
- the table (TABLE tabletype expr) is valid with the table type tabletype if:
  - tabletype is valid.
  - tabletype is (at lim rt).
  - the expression expr is valid with the value type rt.
  - expr is constant.

Mem_ok
- the memory (MEMORY memtype) is valid with the memory type memtype if:
  - memtype is valid.

Tag_ok
- the tag (TAG x) is valid with the tag type C.TYPES[x] if:
  - C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (FUNC functype).

Elemmode_ok
- the element mode elemmode_u1 is valid with the element type rt if:
  - Either:
    - elemmode_u1 is (ACTIVE x expr).
    - the table type C.TABLES[x] exists.
    - C.TABLES[x] is (at lim rt').
    - rt matches the reference type rt'.
    - the expression expr is valid with the value type I32.
    - expr is constant.
  - Or:
    - elemmode_u1 is PASSIVE.
  - Or:
    - elemmode_u1 is DECLARE.

Elemmode_ok/active
- the element mode (ACTIVE x expr) is valid with the element type rt if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (at lim rt').
  - rt matches the reference type rt'.
  - the expression expr is valid with the value type I32.
  - expr is constant.

Elemmode_ok/passive
- the element mode PASSIVE is valid with rt.

Elemmode_ok/declare
- the element mode DECLARE is valid with rt.

Elem_ok
- the element segment (ELEM elemtype expr* elemmode) is valid with the element type elemtype if:
  - elemtype is valid.
  - For all expr in expr*:
    - the expression expr is valid with elemtype.
    - expr is constant.
  - the element mode elemmode is valid with elemtype.

Datamode_ok
- the data mode datamode_u1 is valid with the data type OK if:
  - Either:
    - datamode_u1 is (ACTIVE x expr).
    - the memory type C.MEMS[x] exists.
    - C.MEMS[x] is mt.
    - the expression expr is valid with the value type I32.
    - expr is constant.
  - Or:
    - datamode_u1 is PASSIVE.

Datamode_ok/active
- the data mode (ACTIVE x expr) is valid with the data type OK if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is mt.
  - the expression expr is valid with the value type I32.
  - expr is constant.

Datamode_ok/passive
- the data mode PASSIVE is valid with OK.

Data_ok
- the data segment (DATA b* datamode) is valid with the data type OK if:
  - the data mode datamode is valid with OK.

Start_ok
- the start function (START x) is valid if:
  - the defined type C.FUNCS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.FUNCS[x] is the composite type (FUNC [] -> []).

Import_ok
- the import (IMPORT name_1 name_2 xt) is valid with the external type xt if:
  - xt is valid.

Externidx_ok
- the external index xx_u1 is valid with the external type xt_u1 if:
  - Either:
    - xx_u1 is (FUNC x).
    - xt_u1 is (FUNC dt).
    - the defined type C.FUNCS[x] exists.
    - C.FUNCS[x] is dt.
  - Or:
    - xx_u1 is (GLOBAL x).
    - xt_u1 is (GLOBAL gt).
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is gt.
  - Or:
    - xx_u1 is (TABLE x).
    - xt_u1 is (TABLE tt).
    - the table type C.TABLES[x] exists.
    - C.TABLES[x] is tt.
  - Or:
    - xx_u1 is (MEM x).
    - xt_u1 is (MEM mt).
    - the memory type C.MEMS[x] exists.
    - C.MEMS[x] is mt.
  - Or:
    - xx_u1 is (TAG x).
    - xt_u1 is (TAG jt).
    - the tag type C.TAGS[x] exists.
    - C.TAGS[x] is jt.

Externidx_ok/func
- the external index (FUNC x) is valid with the external type (FUNC dt) if:
  - the defined type C.FUNCS[x] exists.
  - C.FUNCS[x] is dt.

Externidx_ok/global
- the external index (GLOBAL x) is valid with the external type (GLOBAL gt) if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is gt.

Externidx_ok/table
- the external index (TABLE x) is valid with the external type (TABLE tt) if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is tt.

Externidx_ok/mem
- the external index (MEM x) is valid with the external type (MEM mt) if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is mt.

Externidx_ok/tag
- the external index (TAG x) is valid with the external type (TAG jt) if:
  - the tag type C.TAGS[x] exists.
  - C.TAGS[x] is jt.

Export_ok
- the export (EXPORT name externidx) is valid with the name name and the external type xt if:
  - the external index externidx is valid with xt.

Globals_ok
- the global sequence global_u1* is valid with the global type sequence gt_u1* if:
  - Either:
    - global_u1* is [].
    - gt_u1* is [].
  - Or:
    - global_u1* is [global_1] :: global*.
    - gt_u1* is [gt_1] :: gt*.
    - the global global_1 is valid with the global type gt_1.
    - the context C' is the context C with .GLOBALS appended by [gt_1].
    - Under the context C', the global sequence global* is valid with the global type sequence gt*.

Globals_ok/empty
- [] is valid with the global type sequence [].

Globals_ok/cons
- the global sequence [global_1] :: global* is valid with the global type sequence [gt_1] :: gt* if:
  - the global global_1 is valid with the global type gt_1.
  - the context C' is the context C with .GLOBALS appended by [gt_1].
  - Under the context C', the global sequence global* is valid with the global type sequence gt*.

Types_ok
- the type definition sequence type_u1* is valid with the defined type sequence dt_u1* if:
  - Either:
    - type_u1* is [].
    - dt_u1* is [].
  - Or:
    - type_u1* is [type_1] :: type*.
    - dt_u1* is dt_1* :: dt*.
    - the type definition type_1 is valid with the defined type sequence dt_1*.
    - the context C' is the context C with .TYPES appended by dt_1*.
    - Under the context C', the type definition sequence type* is valid with the defined type sequence dt*.

Types_ok/empty
- [] is valid with the defined type sequence [].

Types_ok/cons
- the type definition sequence [type_1] :: type* is valid with the defined type sequence dt_1* :: dt* if:
  - the type definition type_1 is valid with the defined type sequence dt_1*.
  - the context C' is the context C with .TYPES appended by dt_1*.
  - Under the context C', the type definition sequence type* is valid with the defined type sequence dt*.

Module_ok
- the module (MODULE type* import* func* global* table* mem* tag* elem* data* start? export*) is valid with the module type t if:
  - Under the context { RETURN: ?() }, the type definition sequence type* is valid with the defined type sequence dt'*.
  - |import*| is |xt_I*|.
  - For all import in import* and xt_I in xt_I*:
    - Under the context { TYPES: dt'*; RETURN: ?() }, the import import is valid with the external type xt_I.
  - Under the context C', the global sequence global* is valid with the global type sequence gt*.
  - |table*| is |tt*|.
  - For all table in table* and tt in tt*:
    - Under the context C', the table table is valid with the table type tt.
  - |mem*| is |mt*|.
  - For all mem in mem* and mt in mt*:
    - Under the context C', the memory mem is valid with the memory type mt.
  - |jt*| is |tag*|.
  - For all jt in jt* and tag in tag*:
    - Under the context C', the tag tag is valid with the tag type jt.
  - |dt*| is |func*|.
  - For all dt in dt* and func in func*:
    - the function func is valid with the defined type dt.
  - |elem*| is |rt*|.
  - For all elem in elem* and rt in rt*:
    - the element segment elem is valid with the element type rt.
  - |data*| is |ok*|.
  - For all data in data* and ok in ok*:
    - the data segment data is valid.
  - If start is defined, then:
    - the start function start is valid.
  - |export*| is |nm*|.
  - |export*| is |xt_E*|.
  - For all export in export* and nm in nm* and xt_E in xt_E*:
    - the export export is valid with the name nm and the external type xt_E.
  - $disjoint_(name, nm*) is true.
  - C is C' with .GLOBALS appended by gt* with .TABLES appended by tt_I* :: tt* with .MEMS appended by mt_I* :: mt* with .TAGS appended by jt_I* :: jt* with .ELEMS appended by rt* with .DATAS appended by ok*.
  - the context C' is { TYPES: dt'*; FUNCS: dt_I* :: dt*; GLOBALS: gt_I*; RETURN: ?(); REFS: x* }.
  - the function index sequence x* is $funcidx_nonfuncs((global* table* mem* elem* data*)).
  - the defined type sequence dt_I* is $funcsxt(xt_I*).
  - the global type sequence gt_I* is $globalsxt(xt_I*).
  - the table type sequence tt_I* is $tablesxt(xt_I*).
  - the memory type sequence mt_I* is $memsxt(xt_I*).
  - the tag type sequence jt_I* is $tagsxt(xt_I*).
  - Let t be the module type $clos_moduletype(C, xt_I* -> xt_E*).

Num_type
- the number value (nt.CONST c) is valid with the number type nt.

Vec_type
- the vector value (vt.CONST c) is valid with the vector type vt.

Ref_type
- the reference value r_u1 is valid with the reference type rt_u1 if:
  - Either:
    - r_u1 is (REF.NULL ht).
    - rt_u1 is (REF ?(NULL) ht').
    - the heap type ht' matches the heap type ht.
  - Or:
    - r_u1 is (REF.I31_NUM i).
    - rt_u1 is (REF ?() I31).
  - Or:
    - r_u1 is (REF.STRUCT_ADDR a).
    - rt_u1 is (REF ?() dt).
    - the structure instance s.STRUCTS[a] exists.
    - the defined type s.STRUCTS[a].TYPE is dt.
  - Or:
    - r_u1 is (REF.ARRAY_ADDR a).
    - rt_u1 is (REF ?() dt).
    - the array instance s.ARRAYS[a] exists.
    - the defined type s.ARRAYS[a].TYPE is dt.
  - Or:
    - r_u1 is (REF.FUNC_ADDR a).
    - rt_u1 is (REF ?() dt).
    - the function instance s.FUNCS[a] exists.
    - the defined type s.FUNCS[a].TYPE is dt.
  - Or:
    - r_u1 is (REF.EXN_ADDR a).
    - rt_u1 is (REF ?() EXN).
  - Or:
    - r_u1 is (REF.HOST_ADDR a).
    - rt_u1 is (REF ?() ANY).
  - Or:
    - r_u1 is (REF.EXTERN addrref).
    - rt_u1 is (REF ?() EXTERN).
  - Or:
    - r_u1 is ref.
    - rt_u1 is rt.
    - Under the context s, the reference value ref is valid with the reference type rt'.
    - rt' matches the reference type rt.

Ref_type/null
- the reference value (REF.NULL ht) is valid with the reference type (REF ?(NULL) ht') if:
  - the heap type ht' matches the heap type ht.

Ref_type/i31
- the reference value (REF.I31_NUM i) is valid with the reference type (REF ?() I31).

Ref_type/struct
- the reference value (REF.STRUCT_ADDR a) is valid with the reference type (REF ?() dt) if:
  - the structure instance s.STRUCTS[a] exists.
  - the defined type s.STRUCTS[a].TYPE is dt.

Ref_type/array
- the reference value (REF.ARRAY_ADDR a) is valid with the reference type (REF ?() dt) if:
  - the array instance s.ARRAYS[a] exists.
  - the defined type s.ARRAYS[a].TYPE is dt.

Ref_type/func
- the reference value (REF.FUNC_ADDR a) is valid with the reference type (REF ?() dt) if:
  - the function instance s.FUNCS[a] exists.
  - the defined type s.FUNCS[a].TYPE is dt.

Ref_type/exn
- the reference value (REF.EXN_ADDR a) is valid with the reference type (REF ?() EXN).

Ref_type/host
- the reference value (REF.HOST_ADDR a) is valid with the reference type (REF ?() ANY).

Ref_type/extern
- the reference value (REF.EXTERN addrref) is valid with the reference type (REF ?() EXTERN).

Ref_type/sub
- the reference value ref is valid with the reference type rt if:
  - Under the context s, ref is valid with the reference type rt'.
  - rt' matches rt.

Val_type
- the value v_u1 is valid with the value type t_u1 if:
  - Either:
    - v_u1 is num.
    - t_u1 is nt.
    - Under the context s, the number value num is valid with the number type nt.
  - Or:
    - v_u1 is vec.
    - t_u1 is vt.
    - Under the context s, the vector value vec is valid with the vector type vt.
  - Or:
    - v_u1 is ref.
    - t_u1 is rt.
    - Under the context s, the reference value ref is valid with the reference type rt.

Val_type/num
- the value num is valid with the value type nt if:
  - Under the context s, num is valid with nt.

Val_type/vec
- the value vec is valid with the value type vt if:
  - Under the context s, vec is valid with vt.

Val_type/ref
- the value ref is valid with the value type rt if:
  - Under the context s, ref is valid with rt.

Externaddr_type
- the external address xa_u1 is valid with the external type xt_u1 if:
  - Either:
    - xa_u1 is (FUNC a).
    - xt_u1 is (FUNC funcinst.TYPE).
    - the function instance s.FUNCS[a] exists.
    - s.FUNCS[a] is funcinst.
  - Or:
    - xa_u1 is (GLOBAL a).
    - xt_u1 is (GLOBAL globalinst.TYPE).
    - the global instance s.GLOBALS[a] exists.
    - s.GLOBALS[a] is globalinst.
  - Or:
    - xa_u1 is (TABLE a).
    - xt_u1 is (TABLE tableinst.TYPE).
    - the table instance s.TABLES[a] exists.
    - s.TABLES[a] is tableinst.
  - Or:
    - xa_u1 is (MEM a).
    - xt_u1 is (MEM meminst.TYPE).
    - the memory instance s.MEMS[a] exists.
    - s.MEMS[a] is meminst.
  - Or:
    - xa_u1 is (TAG a).
    - xt_u1 is (TAG taginst.TYPE).
    - the tag instance s.TAGS[a] exists.
    - s.TAGS[a] is taginst.
  - Or:
    - xa_u1 is externaddr.
    - xt_u1 is xt.
    - Under the context s, the external address externaddr is valid with the external type xt'.
    - xt' matches the external type xt.

Externaddr_type/func
- the external address (FUNC a) is valid with the external type (FUNC funcinst.TYPE) if:
  - the function instance s.FUNCS[a] exists.
  - s.FUNCS[a] is funcinst.

Externaddr_type/global
- the external address (GLOBAL a) is valid with the external type (GLOBAL globalinst.TYPE) if:
  - the global instance s.GLOBALS[a] exists.
  - s.GLOBALS[a] is globalinst.

Externaddr_type/table
- the external address (TABLE a) is valid with the external type (TABLE tableinst.TYPE) if:
  - the table instance s.TABLES[a] exists.
  - s.TABLES[a] is tableinst.

Externaddr_type/mem
- the external address (MEM a) is valid with the external type (MEM meminst.TYPE) if:
  - the memory instance s.MEMS[a] exists.
  - s.MEMS[a] is meminst.

Externaddr_type/tag
- the external address (TAG a) is valid with the external type (TAG taginst.TYPE) if:
  - the tag instance s.TAGS[a] exists.
  - s.TAGS[a] is taginst.

Externaddr_type/sub
- the external address externaddr is valid with the external type xt if:
  - Under the context s, externaddr is valid with the external type xt'.
  - xt' matches xt.

NotationTypingInstrScheme
- the instruction sequence [instr_u1] is valid with the function type t_u1* -> t_u3* if:
  - Either:
    - the instruction instr_u1 is (BINOP I32 ADD).
    - the value type sequence t_u1* is [I32, I32].
    - the value type sequence t_u3* is [I32].
  - Or:
    - instr_u1 is (GLOBAL.GET x).
    - t_u1* is [].
    - t_u3* is [t].
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is (mut t).
  - Or:
    - instr_u1 is (BLOCK blocktype instr*).
    - t_u1* is t_1*.
    - t_u3* is t_2*.
    - the block type blocktype is valid as the instruction type t_1* -> t_2*.
    - the context C' is the context C with .LABELS prepended by [t_2*].
    - Under the context C', the instruction sequence instr* is valid with t_1* -> t_2*.

NotationTypingInstrScheme/i32.add
- the instruction sequence [(BINOP I32 ADD)] is valid with the function type [I32, I32] -> [I32].

NotationTypingInstrScheme/global.get
- the instruction sequence [(GLOBAL.GET x)] is valid with the function type [] -> [t] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (mut t).

NotationTypingInstrScheme/block
- the instruction sequence [(BLOCK blocktype instr*)] is valid with the function type t_1* -> t_2* if:
  - the block type blocktype is valid as t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr* is valid with t_1* -> t_2*.

Step_pure/unreachable
1. Trap.

Step_pure/nop
1. Do nothing.

Step_pure/drop
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Do nothing.

Step_pure/select t*?
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. Assert: Due to validation, a value is on the top of the stack.
4. Pop the value val_2 from the stack.
5. Assert: Due to validation, a value is on the top of the stack.
6. Pop the value val_1 from the stack.
7. If (c =/= 0), then:
  a. Push the value val_1 to the stack.
8. Else:
  a. Push the value val_2 to the stack.

Step_pure/if bt instr_1* instr_2*
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BLOCK bt instr_1*).
4. Else:
  a. Execute the instruction (BLOCK bt instr_2*).

Step_pure/label
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
3. Pop the current LABEL_ context from the stack.
4. Push the values val* to the stack.

Step_pure/br l
1. If the first non-value entry of the stack is a LABEL_, then:
  a. Let (LABEL_ n { instr'* }) be the current LABEL_ context.
  b. If (l = 0), then:
    1) Assert: Due to validation, there are at least n values on the top of the stack.
    2) Pop the values val^n from the stack.
    3) Pop all values val'* from the top of the stack.
    4) Pop the current LABEL_ context from the stack.
    5) Push the values val^n to the stack.
    6) Execute the instruction instr'*.
  c. Else:
    1) Pop all values val* from the top of the stack.
    2) If (l > 0), then:
      a) Pop the current LABEL_ context from the stack.
      b) Push the values val* to the stack.
      c) Execute the instruction (BR (l - 1)).
2. Else if the first non-value entry of the stack is a HANDLER_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the current HANDLER_ context from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction (BR l).

Step_pure/br_if l
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BR l).
4. Else:
  a. Do nothing.

Step_pure/br_table l* l'
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. If (i < |l*|), then:
  a. Execute the instruction (BR l*[i]).
4. Else:
  a. Execute the instruction (BR l').

Step_pure/br_on_null l
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. If val is REF.NULL, then:
  a. Execute the instruction (BR l).
4. Else:
  a. Push the value val to the stack.

Step_pure/br_on_non_null l
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. If val is REF.NULL, then:
  a. Do nothing.
4. Else:
  a. Push the value val to the stack.
  b. Execute the instruction (BR l).

Step_pure/call_indirect x yy
1. Execute the instruction (TABLE.GET x).
2. Execute the instruction (REF.CAST (REF ?(NULL) yy)).
3. Execute the instruction (CALL_REF yy).

Step_pure/return_call_indirect x yy
1. Execute the instruction (TABLE.GET x).
2. Execute the instruction (REF.CAST (REF ?(NULL) yy)).
3. Execute the instruction (RETURN_CALL_REF yy).

Step_pure/frame
1. Let (FRAME_ n { f }) be the current FRAME_ context.
2. Assert: Due to validation, there are at least n values on the top of the stack.
3. Assert: Due to validation, there are at least n values on the top of the stack.
4. Pop the values val^n from the stack.
5. Assert: Due to validation, the first non-value entry of the stack is a FRAME_.
6. Pop the current FRAME_ context from the stack.
7. Push the values val^n to the stack.

Step_pure/return
1. If the first non-value entry of the stack is a FRAME_, then:
  a. Let (FRAME_ n { f }) be the current FRAME_ context.
  b. Assert: Due to validation, there are at least n values on the top of the stack.
  c. Pop the values val^n from the stack.
  d. Pop all values val'* from the top of the stack.
  e. Pop the current FRAME_ context from the stack.
  f. Push the values val^n to the stack.
2. Else if the first non-value entry of the stack is a LABEL_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the current LABEL_ context from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction RETURN.
3. Else if the first non-value entry of the stack is a HANDLER_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the current HANDLER_ context from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction RETURN.

Step_pure/handler
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, the first non-value entry of the stack is a HANDLER_.
3. Pop the current HANDLER_ context from the stack.
4. Push the values val* to the stack.

Step_pure/unop nt unop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. If (|$unop_(nt, unop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $unop_(nt, unop, c_1).
5. Push the value (nt.CONST c) to the stack.

Step_pure/binop nt binop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type numtype_0 is on the top of the stack.
4. Pop the value (numtype_0.CONST c_1) from the stack.
5. If (|$binop_(nt, binop, c_1, c_2)| <= 0), then:
  a. Trap.
6. Let c be an element of $binop_(nt, binop, c_1, c_2).
7. Push the value (nt.CONST c) to the stack.

Step_pure/testop nt testop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. Let c be $testop_(nt, testop, c_1).
4. Push the value (I32.CONST c) to the stack.

Step_pure/relop nt relop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type numtype_0 is on the top of the stack.
4. Pop the value (numtype_0.CONST c_1) from the stack.
5. Let c be $relop_(nt, relop, c_1, c_2).
6. Push the value (I32.CONST c) to the stack.

Step_pure/cvtop nt_2 nt_1 cvtop
1. Assert: Due to validation, a value of value type nt_1 is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. If (|$cvtop__(nt_1, nt_2, cvtop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $cvtop__(nt_1, nt_2, cvtop, c_1).
5. Push the value (nt_2.CONST c) to the stack.

Step_pure/ref.i31
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. Push the value (REF.I31_NUM $wrap__(32, 31, i)) to the stack.

Step_pure/ref.is_null
1. Assert: Due to validation, a value of value type ref is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is REF.NULL, then:
  a. Push the value (I32.CONST 1) to the stack.
4. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_pure/ref.as_non_null
1. Assert: Due to validation, a value of value type ref is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is REF.NULL, then:
  a. Trap.
4. Push the value ref to the stack.

Step_pure/ref.eq
1. Assert: Due to validation, a value of value type ref is on the top of the stack.
2. Pop the value ref_2 from the stack.
3. Assert: Due to validation, a value of value type ref is on the top of the stack.
4. Pop the value ref_1 from the stack.
5. If ref_1 is REF.NULL, then:
  a. If ref_2 is REF.NULL, then:
    1) Push the value (I32.CONST 1) to the stack.
  b. Else if (ref_1 = ref_2), then:
    1) Push the value (I32.CONST 1) to the stack.
  c. Else:
    1) Push the value (I32.CONST 0) to the stack.
6. Else if (ref_1 = ref_2), then:
  a. Push the value (I32.CONST 1) to the stack.
7. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_pure/i31.get sx
1. Assert: Due to validation, a value of value type instr is on the top of the stack.
2. Pop the value instr_u1 from the stack.
3. If instr_u1 is REF.NULL, then:
  a. Trap.
4. If instr_u1 is REF.I31_NUM, then:
  a. Let (REF.I31_NUM i) be instr_u1.
  b. Push the value (I32.CONST $extend__(31, 32, sx, i)) to the stack.

Step_pure/array.new x
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST n) from the stack.
3. Assert: Due to validation, a value is on the top of the stack.
4. Pop the value val from the stack.
5. Push the values val^n to the stack.
6. Execute the instruction (ARRAY.NEW_FIXED x n).

Step_pure/extern.convert_any
1. Assert: Due to validation, a value of value type instr is on the top of the stack.
2. Pop the value instr_u1 from the stack.
3. If instr_u1 is REF.NULL, then:
  a. Push the value (REF.NULL EXTERN) to the stack.
4. If instr_u1 is addrref, then:
  a. Let addrref be instr_u1.
  b. Push the value (REF.EXTERN addrref) to the stack.

Step_pure/any.convert_extern
1. Assert: Due to validation, a value of value type instr is on the top of the stack.
2. Pop the value instr_u1 from the stack.
3. If instr_u1 is REF.NULL, then:
  a. Push the value (REF.NULL ANY) to the stack.
4. If instr_u1 is REF.EXTERN, then:
  a. Let (REF.EXTERN addrref) be instr_u1.
  b. Push the value addrref to the stack.

Step_pure/vvunop V128 vvunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Assert: Due to validation, (|$vvunop_(V128, vvunop, c_1)| > 0).
4. Let c be an element of $vvunop_(V128, vvunop, c_1).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vvbinop V128 vvbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Assert: Due to validation, (|$vvbinop_(V128, vvbinop, c_1, c_2)| > 0).
6. Let c be an element of $vvbinop_(V128, vvbinop, c_1, c_2).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vvternop V128 vvternop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_3) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_2) from the stack.
5. Assert: Due to validation, a value of value type V128 is on the top of the stack.
6. Pop the value (V128.CONST c_1) from the stack.
7. Assert: Due to validation, (|$vvternop_(V128, vvternop, c_1, c_2, c_3)| > 0).
8. Let c be an element of $vvternop_(V128, vvternop, c_1, c_2, c_3).
9. Push the value (V128.CONST c) to the stack.

Step_pure/vvtestop V128 ANY_TRUE
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $ine_($vsize(V128), c_1, 0).
4. Push the value (I32.CONST c) to the stack.

Step_pure/vunop sh vunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (|$vunop_(sh, vunop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $vunop_(sh, vunop, c_1).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vbinop sh vbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. If (|$vbinop_(sh, vbinop, c_1, c_2)| <= 0), then:
  a. Trap.
6. Let c be an element of $vbinop_(sh, vbinop, c_1, c_2).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vternop sh vternop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_3) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_2) from the stack.
5. Assert: Due to validation, a value of value type V128 is on the top of the stack.
6. Pop the value (V128.CONST c_1) from the stack.
7. If (|$vternop_(sh, vternop, c_1, c_2, c_3)| <= 0), then:
  a. Trap.
8. Let c be an element of $vternop_(sh, vternop, c_1, c_2, c_3).
9. Push the value (V128.CONST c) to the stack.

Step_pure/vtestop sh vtestop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let i be $vtestop_(sh, vtestop, c_1).
4. Push the value (I32.CONST i) to the stack.

Step_pure/vrelop sh vrelop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vrelop_(sh, vrelop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vshiftop sh vshiftop
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vshiftop_(sh, vshiftop, c_1, i).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vbitmask sh
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vbitmaskop_(sh, c_1).
4. Push the value (I32.CONST c) to the stack.

Step_pure/vswizzlop sh vswizzlop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vswizzlop_(sh, vswizzlop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vshuffle sh i*
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vshufflop_(sh, i*, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vsplat Lnn X M
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. Assert: Due to validation, (numtype_0 = $lunpack(Lnn)).
4. Let c be $invlanes_(Lnn X M, $lpacknum_(Lnn, c_1)^M).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vextract_lane lt_u1 X M sx_u1? i
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (sx_u1? is not defined /\ lt_u1 is numtype), then:
  a. Let nt be lt_u1.
  b. If (i < |$lanes_(nt X M, c_1)|), then:
    1) Let c_2 be $lanes_(nt X M, c_1)[i].
    2) Push the value (nt.CONST c_2) to the stack.
4. If lt_u1 is packtype, then:
  a. Let pt be lt_u1.
  b. If sx_u1? is defined, then:
    1) Let ?(sx) be sx_u1?.
    2) If (i < |$lanes_(pt X M, c_1)|), then:
      a) Let c_2 be $extend__($psize(pt), 32, sx, $lanes_(pt X M, c_1)[i]).
      b) Push the value (I32.CONST c_2) to the stack.

Step_pure/vreplace_lane Lnn X M i
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, (numtype_0 = $lunpack(Lnn)).
4. Assert: Due to validation, a value of value type V128 is on the top of the stack.
5. Pop the value (V128.CONST c_1) from the stack.
6. Let c be $invlanes_(Lnn X M, $lanes_(Lnn X M, c_1) with [i] replaced by $lpacknum_(Lnn, c_2)).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vextunop sh_2 sh_1 vextunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vextunop__(sh_1, sh_2, vextunop, c_1).
4. Push the value (V128.CONST c) to the stack.

Step_pure/vextbinop sh_2 sh_1 vextbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vextbinop__(sh_1, sh_2, vextbinop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vextternop sh_2 sh_1 vextternop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_3) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_2) from the stack.
5. Assert: Due to validation, a value of value type V128 is on the top of the stack.
6. Pop the value (V128.CONST c_1) from the stack.
7. Let c be $vextternop__(sh_1, sh_2, vextternop, c_1, c_2, c_3).
8. Push the value (V128.CONST c) to the stack.

Step_pure/vnarrow sh_2 sh_1 sx
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vnarrowop__(sh_1, sh_2, sx, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vcvtop sh_2 sh_1 vcvtop half? zero?
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vcvtop__(sh_1, sh_2, vcvtop, half?, zero?, c_1).
4. Push the value (V128.CONST c) to the stack.

Step_pure/local.tee x
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Push the value val to the stack.
4. Push the value val to the stack.
5. Execute the instruction (LOCAL.SET x).

Step_read/block bt instr*
1. Let z be the current state.
2. Let t_1^m -> t_2^n be $blocktype_(z, bt).
3. Assert: Due to validation, there are at least m values on the top of the stack.
4. Pop the values val^m from the stack.
5. Enter val^m :: instr* with label (LABEL_ n { [] }).

Step_read/loop bt instr*
1. Let z be the current state.
2. Let t_1^m -> t_2^n be $blocktype_(z, bt).
3. Assert: Due to validation, there are at least m values on the top of the stack.
4. Pop the values val^m from the stack.
5. Enter val^m :: instr* with label (LABEL_ m { [(LOOP bt instr*)] }).

Step_read/br_on_cast l rt_1 rt_2
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Let rt be $Ref_type(ref).
5. Push the value ref to the stack.
6. If rt does not match $inst_reftype(f.MODULE, rt_2), then:
  a. Do nothing.
7. Else:
  a. Execute the instruction (BR l).

Step_read/br_on_cast_fail l rt_1 rt_2
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Let rt be $Ref_type(ref).
5. Push the value ref to the stack.
6. If rt matches $inst_reftype(f.MODULE, rt_2), then:
  a. Do nothing.
7. Else:
  a. Execute the instruction (BR l).

Step_read/call x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$moduleinst(z).FUNCS|).
3. Let a be $moduleinst(z).FUNCS[x].
4. Assert: Due to validation, (a < |$funcinst(z)|).
5. Push the value (REF.FUNC_ADDR a) to the stack.
6. Execute the instruction (CALL_REF $funcinst(z)[a].TYPE).

Step_read/call_ref yy
1. Let z be the current state.
2. Assert: Due to validation, a value of value type instr is on the top of the stack.
3. Pop the value instr_u1 from the stack.
4. If instr_u1 is REF.NULL, then:
  a. Trap.
5. If instr_u1 is REF.FUNC_ADDR, then:
  a. Let (REF.FUNC_ADDR a) be instr_u1.
  b. If (a < |$funcinst(z)|), then:
    1) Let fi be $funcinst(z)[a].
    2) Assert: Due to validation, fi.CODE is FUNC.
    3) Let (FUNC x local_0* instr*) be fi.CODE.
    4) Let (LOCAL t)* be local_0*.
    5) Assert: Due to validation, $expanddt(fi.TYPE) is FUNC.
    6) Let (FUNC functype_0) be $expanddt(fi.TYPE).
    7) Let t_1^n -> t_2^m be functype_0.
    8) Assert: Due to validation, there are at least n values on the top of the stack.
    9) Pop the values val^n from the stack.
    10) Let f be { LOCALS: ?(val)^n :: $default_(t)*; MODULE: fi.MODULE }.
    11) Push the :ref:`frame <syntax-frame>` (FRAME_ m { f }) to the stack.
    12) Enter instr* with label (LABEL_ m { [] }).

Step_read/return_call x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$moduleinst(z).FUNCS|).
3. Let a be $moduleinst(z).FUNCS[x].
4. Assert: Due to validation, (a < |$funcinst(z)|).
5. Push the value (REF.FUNC_ADDR a) to the stack.
6. Execute the instruction (RETURN_CALL_REF $funcinst(z)[a].TYPE).

Step_read/return_call_ref yy
1. Let z be the current state.
2. If the first non-value entry of the stack is a LABEL_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the current LABEL_ context from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction (RETURN_CALL_REF yy).
3. Else if the first non-value entry of the stack is a HANDLER_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the current HANDLER_ context from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction (RETURN_CALL_REF yy).
4. Else if the first non-value entry of the stack is a FRAME_, then:
  a. Assert: Due to validation, a value of value type instr is on the top of the stack.
  b. Pop the value instr_u1 from the stack.
  c. If instr_u1 is REF.NULL, then:
    1) Pop all values val* from the top of the stack.
    2) Pop the current FRAME_ context from the stack.
    3) Trap.
  d. If instr_u1 is REF.FUNC_ADDR, then:
    1) Let (REF.FUNC_ADDR a) be instr_u1.
    2) If (a < |$funcinst(z)|), then:
      a) Assert: Due to validation, $expanddt($funcinst(z)[a].TYPE) is FUNC.
      b) Let (FUNC functype_0) be $expanddt($funcinst(z)[a].TYPE).
      c) Let t_1^n -> t_2^m be functype_0.
      d) Assert: Due to validation, there are at least n values on the top of the stack.
      e) Pop the values val^n from the stack.
      f) Pop all values val'* from the top of the stack.
      g) Pop the current FRAME_ context from the stack.
      h) Push the values val^n to the stack.
      i) Push the value (REF.FUNC_ADDR a) to the stack.
      j) Execute the instruction (CALL_REF yy).

Step_read/throw_ref
1. Let z be the current state.
2. Assert: Due to validation, a value of value type instr is on the top of the stack.
3. Pop the value instr_u1 from the stack.
4. If instr_u1 is REF.NULL, then:
  a. Trap.
5. If instr_u1 is REF.EXN_ADDR, then:
  a. Let (REF.EXN_ADDR a) be instr_u1.
  b. Pop all values val* from the top of the stack.
  c. If (val* =/= []), then:
    1) Push the value (REF.EXN_ADDR a) to the stack.
    2) Execute the instruction THROW_REF.
  d. Else if the first non-value entry of the stack is a LABEL_, then:
    1) Pop the current LABEL_ context from the stack.
    2) Push the value (REF.EXN_ADDR a) to the stack.
    3) Execute the instruction THROW_REF.
  e. Else if the first non-value entry of the stack is a FRAME_, then:
    1) Pop the current FRAME_ context from the stack.
    2) Push the value (REF.EXN_ADDR a) to the stack.
    3) Execute the instruction THROW_REF.
  f. Else if not the first non-value entry of the stack is a HANDLER_, then:
    1) Throw the exception instr_u1 as a result.
  g. Else:
    1) Let (HANDLER_ n { catch_u1* }) be the current HANDLER_ context.
    2) If (catch_u1* = []), then:
      a) Pop the current HANDLER_ context from the stack.
      b) Push the value (REF.EXN_ADDR a) to the stack.
      c) Execute the instruction THROW_REF.
    3) Else if (a >= |$exninst(z)|), then:
      a) Let [catch_0] :: catch'* be catch_u1*.
      b) If catch_0 is CATCH_ALL, then:
        1. Let (CATCH_ALL l) be catch_0.
        2. Pop the current HANDLER_ context from the stack.
        3. Execute the instruction (BR l).
      c) Else if catch_0 is not CATCH_ALL_REF, then:
        1. Let [catch] :: catch'* be catch_u1*.
        2. Pop the current HANDLER_ context from the stack.
        3. Push the :ref:`handler <syntax-handler>` (HANDLER_ n { catch'* }) to the stack.
        4. Push the value (REF.EXN_ADDR a) to the stack.
        5. Execute the instruction THROW_REF.
      d) Else:
        1. Let (CATCH_ALL_REF l) be catch_0.
        2. Pop the current HANDLER_ context from the stack.
        3. Push the value (REF.EXN_ADDR a) to the stack.
        4. Execute the instruction (BR l).
    4) Else:
      a) Let val* be $exninst(z)[a].FIELDS.
      b) Let [catch_0] :: catch'* be catch_u1*.
      c) If catch_0 is CATCH, then:
        1. Let (CATCH x l) be catch_0.
        2. If ((x < |$tagaddr(z)|) /\ ($exninst(z)[a].TAG = $tagaddr(z)[x])), then:
          a. Pop the current HANDLER_ context from the stack.
          b. Push the values val* to the stack.
          c. Execute the instruction (BR l).
        3. Else:
          a. Let [catch] :: catch'* be catch_u1*.
          b. Pop the current HANDLER_ context from the stack.
          c. Push the :ref:`handler <syntax-handler>` (HANDLER_ n { catch'* }) to the stack.
          d. Push the value (REF.EXN_ADDR a) to the stack.
          e. Execute the instruction THROW_REF.
      d) Else if catch_0 is CATCH_REF, then:
        1. Let (CATCH_REF x l) be catch_0.
        2. If (x >= |$tagaddr(z)|), then:
          a. Let [catch] :: catch'* be catch_u1*.
          b. Pop the current HANDLER_ context from the stack.
          c. Push the :ref:`handler <syntax-handler>` (HANDLER_ n { catch'* }) to the stack.
          d. Push the value (REF.EXN_ADDR a) to the stack.
          e. Execute the instruction THROW_REF.
        3. Else if ($exninst(z)[a].TAG =/= $tagaddr(z)[x]), then:
          a. Let [catch] :: catch'* be catch_u1*.
          b. Pop the current HANDLER_ context from the stack.
          c. Push the :ref:`handler <syntax-handler>` (HANDLER_ n { catch'* }) to the stack.
          d. Push the value (REF.EXN_ADDR a) to the stack.
          e. Execute the instruction THROW_REF.
        4. Else:
          a. Pop the current HANDLER_ context from the stack.
          b. Push the values val* to the stack.
          c. Push the value (REF.EXN_ADDR a) to the stack.
          d. Execute the instruction (BR l).
      e) Else if catch_0 is CATCH_ALL, then:
        1. Let (CATCH_ALL l) be catch_0.
        2. Pop the current HANDLER_ context from the stack.
        3. Execute the instruction (BR l).
      f) Else if catch_0 is not CATCH_ALL_REF, then:
        1. Let [catch] :: catch'* be catch_u1*.
        2. Pop the current HANDLER_ context from the stack.
        3. Push the :ref:`handler <syntax-handler>` (HANDLER_ n { catch'* }) to the stack.
        4. Push the value (REF.EXN_ADDR a) to the stack.
        5. Execute the instruction THROW_REF.
      g) Else:
        1. Let (CATCH_ALL_REF l) be catch_0.
        2. Pop the current HANDLER_ context from the stack.
        3. Push the value (REF.EXN_ADDR a) to the stack.
        4. Execute the instruction (BR l).
6. Else if ((not the first non-value entry of the stack is a LABEL_ /\ not the first non-value entry of the stack is a FRAME_) /\ not the first non-value entry of the stack is a HANDLER_), then:
  a. Throw the exception instr_u1 as a result.

Step_read/try_table bt catch* instr*
1. Let z be the current state.
2. Let t_1^m -> t_2^n be $blocktype_(z, bt).
3. Assert: Due to validation, there are at least m values on the top of the stack.
4. Pop the values val^m from the stack.
5. Push the :ref:`handler <syntax-handler>` (HANDLER_ n { catch* }) to the stack.
6. Enter val^m :: instr* with label (LABEL_ n { [] }).

Step_read/ref.null (_IDX x)
1. Let z be the current state.
2. Push the value (REF.NULL $type(z, x)) to the stack.

Step_read/ref.func x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$moduleinst(z).FUNCS|).
3. Push the value (REF.FUNC_ADDR $moduleinst(z).FUNCS[x]) to the stack.

Step_read/ref.test rt
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Let rt' be $Ref_type(ref).
5. If rt' matches $inst_reftype(f.MODULE, rt), then:
  a. Push the value (I32.CONST 1) to the stack.
6. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_read/ref.cast rt
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Let rt' be $Ref_type(ref).
5. If rt' does not match $inst_reftype(f.MODULE, rt), then:
  a. Trap.
6. Push the value ref to the stack.

Step_read/struct.new_default x
1. Let z be the current state.
2. Assert: Due to validation, $expanddt($type(z, x)) is STRUCT.
3. Let (STRUCT structtype_0) be $expanddt($type(z, x)).
4. Let (mut zt)* be structtype_0.
5. Assert: Due to validation, $default_($unpack(zt)) is defined*.
6. Let ?(val)* be $default_($unpack(zt))*.
7. Assert: Due to validation, (|val*| = |zt*|).
8. Push the values val* to the stack.
9. Execute the instruction (STRUCT.NEW x).

Step_read/struct.get sx? x i
1. Let z be the current state.
2. Assert: Due to validation, a value of value type instr is on the top of the stack.
3. Pop the value instr_u1 from the stack.
4. If instr_u1 is REF.NULL, then:
  a. Trap.
5. If instr_u1 is REF.STRUCT_ADDR, then:
  a. Let (REF.STRUCT_ADDR a) be instr_u1.
  b. If ((i < |$structinst(z)[a].FIELDS|) /\ (a < |$structinst(z)|)), then:
    1) Assert: Due to validation, $expanddt($type(z, x)) is STRUCT.
    2) Let (STRUCT structtype_0) be $expanddt($type(z, x)).
    3) Let (mut zt)* be structtype_0.
    4) If (i < |zt*|), then:
      a) Push the value $unpackfield_(zt*[i], sx?, $structinst(z)[a].FIELDS[i]) to the stack.

Step_read/array.new_default x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, $expanddt($type(z, x)) is ARRAY.
5. Let (ARRAY arraytype_0) be $expanddt($type(z, x)).
6. Let (mut zt) be arraytype_0.
7. Assert: Due to validation, $default_($unpack(zt)) is defined.
8. Let ?(val) be $default_($unpack(zt)).
9. Push the values val^n to the stack.
10. Execute the instruction (ARRAY.NEW_FIXED x n).

Step_read/array.new_elem x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If ((i + n) > |$elem(z, y).REFS|), then:
  a. Trap.
7. Assert: Due to validation, (|$elem(z, y).REFS[i : n]| = n).
8. Let ref* be $elem(z, y).REFS[i : n].
9. Push the values ref^n to the stack.
10. Execute the instruction (ARRAY.NEW_FIXED x n).

Step_read/array.new_data x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, $expanddt($type(z, x)) is ARRAY.
7. Let (ARRAY arraytype_0) be $expanddt($type(z, x)).
8. Let (mut zt) be arraytype_0.
9. If ((i + ((n * $zsize(zt)) / 8)) > |$data(z, y).BYTES|), then:
  a. Trap.
10. Assert: Due to validation, (|$concatn__1^-1(byte, ($zsize(zt) / 8), $data(z, y).BYTES[i : ((n * $zsize(zt)) / 8)])| = n).
11. Let byte** be $concatn__1^-1(byte, ($zsize(zt) / 8), $data(z, y).BYTES[i : ((n * $zsize(zt)) / 8)]).
12. Let c* be $zbytes__1^-1(zt, byte*)*.
13. Push the values $const($cunpack(zt), $cunpacknum_(zt, c))^n to the stack.
14. Execute the instruction (ARRAY.NEW_FIXED x n).

Step_read/array.get sx? x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. Assert: Due to validation, a value of value type instr is on the top of the stack.
5. Pop the value instr_u1 from the stack.
6. If instr_u1 is REF.NULL, then:
  a. Trap.
7. If instr_u1 is REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be instr_u1.
  b. If ((a < |$arrayinst(z)|) /\ (i >= |$arrayinst(z)[a].FIELDS|)), then:
    1) Trap.
  c. If ((i < |$arrayinst(z)[a].FIELDS|) /\ (a < |$arrayinst(z)|)), then:
    1) Assert: Due to validation, $expanddt($type(z, x)) is ARRAY.
    2) Let (ARRAY arraytype_0) be $expanddt($type(z, x)).
    3) Let (mut zt) be arraytype_0.
    4) Push the value $unpackfield_(zt, sx?, $arrayinst(z)[a].FIELDS[i]) to the stack.

Step_read/array.len
1. Let z be the current state.
2. Assert: Due to validation, a value of value type instr is on the top of the stack.
3. Pop the value instr_u1 from the stack.
4. If instr_u1 is REF.NULL, then:
  a. Trap.
5. If instr_u1 is REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be instr_u1.
  b. If (a < |$arrayinst(z)|), then:
    1) Push the value (I32.CONST |$arrayinst(z)[a].FIELDS|) to the stack.

Step_read/array.fill x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. Assert: Due to validation, a value of value type instr is on the top of the stack.
9. Pop the value instr_u1 from the stack.
10. If instr_u1 is REF.NULL, then:
  a. Trap.
11. If instr_u1 is REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be instr_u1.
  b. If (a >= |$arrayinst(z)|), then:
    1) Do nothing.
  c. Else if ((i + n) > |$arrayinst(z)[a].FIELDS|), then:
    1) Trap.
  d. If (n = 0), then:
    1) Do nothing.
  e. Else:
    1) Push the value (REF.ARRAY_ADDR a) to the stack.
    2) Push the value (I32.CONST i) to the stack.
    3) Push the value val to the stack.
    4) Execute the instruction (ARRAY.SET x).
    5) Push the value (REF.ARRAY_ADDR a) to the stack.
    6) Push the value (I32.CONST (i + 1)) to the stack.
    7) Push the value val to the stack.
    8) Push the value (I32.CONST (n - 1)) to the stack.
    9) Execute the instruction (ARRAY.FILL x).

Step_read/array.copy x_1 x_2
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i_2) from the stack.
6. Assert: Due to validation, a value of value type instr is on the top of the stack.
7. Pop the value instr_u1 from the stack.
8. Assert: Due to validation, a value of value type I32 is on the top of the stack.
9. Pop the value (I32.CONST i_1) from the stack.
10. Assert: Due to validation, a value of value type instr is on the top of the stack.
11. Pop the value instr_u2 from the stack.
12. If (instr_u2 is REF.NULL /\ instr_u1 is ref), then:
  a. Trap.
13. If (instr_u1 is REF.NULL /\ instr_u2 is ref), then:
  a. Trap.
14. If instr_u2 is REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a_1) be instr_u2.
  b. If instr_u1 is REF.ARRAY_ADDR, then:
    1) If ((a_1 < |$arrayinst(z)|) /\ ((i_1 + n) > |$arrayinst(z)[a_1].FIELDS|)), then:
      a) Trap.
    2) Let (REF.ARRAY_ADDR a_2) be instr_u1.
    3) If (a_2 >= |$arrayinst(z)|), then:
      a) Do nothing.
    4) Else if ((i_2 + n) > |$arrayinst(z)[a_2].FIELDS|), then:
      a) Trap.
    5) If (n = 0), then:
      a) Do nothing.
    6) Else if ((i_1 <= i_2) /\ $expanddt($type(z, x_2)) is ARRAY), then:
      a) Let (ARRAY arraytype_0) be $expanddt($type(z, x_2)).
      b) Let (mut zt_2) be arraytype_0.
      c) Let sx? be $sx(zt_2).
      d) Push the value (REF.ARRAY_ADDR a_1) to the stack.
      e) Push the value (I32.CONST i_1) to the stack.
      f) Push the value (REF.ARRAY_ADDR a_2) to the stack.
      g) Push the value (I32.CONST i_2) to the stack.
      h) Execute the instruction (ARRAY.GET sx? x_2).
      i) Execute the instruction (ARRAY.SET x_1).
      j) Push the value (REF.ARRAY_ADDR a_1) to the stack.
      k) Push the value (I32.CONST (i_1 + 1)) to the stack.
      l) Push the value (REF.ARRAY_ADDR a_2) to the stack.
      m) Push the value (I32.CONST (i_2 + 1)) to the stack.
      n) Push the value (I32.CONST (n - 1)) to the stack.
      o) Execute the instruction (ARRAY.COPY x_1 x_2).
    7) Else if $expanddt($type(z, x_2)) is ARRAY, then:
      a) Let (ARRAY arraytype_0) be $expanddt($type(z, x_2)).
      b) Let (mut zt_2) be arraytype_0.
      c) Let sx? be $sx(zt_2).
      d) Push the value (REF.ARRAY_ADDR a_1) to the stack.
      e) Push the value (I32.CONST ((i_1 + n) - 1)) to the stack.
      f) Push the value (REF.ARRAY_ADDR a_2) to the stack.
      g) Push the value (I32.CONST ((i_2 + n) - 1)) to the stack.
      h) Execute the instruction (ARRAY.GET sx? x_2).
      i) Execute the instruction (ARRAY.SET x_1).
      j) Push the value (REF.ARRAY_ADDR a_1) to the stack.
      k) Push the value (I32.CONST i_1) to the stack.
      l) Push the value (REF.ARRAY_ADDR a_2) to the stack.
      m) Push the value (I32.CONST i_2) to the stack.
      n) Push the value (I32.CONST (n - 1)) to the stack.
      o) Execute the instruction (ARRAY.COPY x_1 x_2).
  c. Else if (n =/= 0), then:
    1) Do nothing.

Step_read/array.init_elem x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST j) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. Assert: Due to validation, a value of value type instr is on the top of the stack.
9. Pop the value instr_u1 from the stack.
10. If instr_u1 is REF.NULL, then:
  a. Trap.
11. If instr_u1 is REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be instr_u1.
  b. If ((a < |$arrayinst(z)|) /\ ((i + n) > |$arrayinst(z)[a].FIELDS|)), then:
    1) Trap.
  c. If ((j + n) > |$elem(z, y).REFS|), then:
    1) Trap.
  d. If (n = 0), then:
    1) Do nothing.
  e. Else if (j < |$elem(z, y).REFS|), then:
    1) Let ref be $elem(z, y).REFS[j].
    2) Push the value (REF.ARRAY_ADDR a) to the stack.
    3) Push the value (I32.CONST i) to the stack.
    4) Push the value ref to the stack.
    5) Execute the instruction (ARRAY.SET x).
    6) Push the value (REF.ARRAY_ADDR a) to the stack.
    7) Push the value (I32.CONST (i + 1)) to the stack.
    8) Push the value (I32.CONST (j + 1)) to the stack.
    9) Push the value (I32.CONST (n - 1)) to the stack.
    10) Execute the instruction (ARRAY.INIT_ELEM x y).

Step_read/array.init_data x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST j) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. Assert: Due to validation, a value of value type instr is on the top of the stack.
9. Pop the value instr_u1 from the stack.
10. If instr_u1 is REF.NULL, then:
  a. Trap.
11. If instr_u1 is REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be instr_u1.
  b. If ((a < |$arrayinst(z)|) /\ ((i + n) > |$arrayinst(z)[a].FIELDS|)), then:
    1) Trap.
  c. If $expanddt($type(z, x)) is ARRAY, then:
    1) Let (ARRAY arraytype_0) be $expanddt($type(z, x)).
    2) Let (mut zt) be arraytype_0.
    3) If ((j + ((n * $zsize(zt)) / 8)) > |$data(z, y).BYTES|), then:
      a) Trap.
    4) If (n = 0), then:
      a) Do nothing.
    5) Else:
      a) Let c be $zbytes__1^-1(zt, $data(z, y).BYTES[j : ($zsize(zt) / 8)]).
      b) Push the value (REF.ARRAY_ADDR a) to the stack.
      c) Push the value (I32.CONST i) to the stack.
      d) Push the value $const($cunpack(zt), $cunpacknum_(zt, c)) to the stack.
      e) Execute the instruction (ARRAY.SET x).
      f) Push the value (REF.ARRAY_ADDR a) to the stack.
      g) Push the value (I32.CONST (i + 1)) to the stack.
      h) Push the value (I32.CONST (j + ($zsize(zt) / 8))) to the stack.
      i) Push the value (I32.CONST (n - 1)) to the stack.
      j) Execute the instruction (ARRAY.INIT_DATA x y).
  d. Else if (n = 0), then:
    1) Do nothing.

Step_read/local.get x
1. Let z be the current state.
2. Assert: Due to validation, $local(z, x) is defined.
3. Let ?(val) be $local(z, x).
4. Push the value val to the stack.

Step_read/global.get x
1. Let z be the current state.
2. Let val be $global(z, x).VALUE.
3. Push the value val to the stack.

Step_read/table.get x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type at is on the top of the stack.
3. Pop the value (at.CONST i) from the stack.
4. If (i >= |$table(z, x).REFS|), then:
  a. Trap.
5. Push the value $table(z, x).REFS[i] to the stack.

Step_read/table.size x
1. Let z be the current state.
2. Let (at lim rt) be $table(z, x).TYPE.
3. Let n be |$table(z, x).REFS|.
4. Push the value (at.CONST n) to the stack.

Step_read/table.fill x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type at is on the top of the stack.
3. Pop the value (at.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type at is on the top of the stack.
7. Pop the value (numtype_0.CONST i) from the stack.
8. If ((i + n) > |$table(z, x).REFS|), then:
  a. Trap.
9. If (n = 0), then:
  a. Do nothing.
10. Else:
  a. Push the value (at.CONST i) to the stack.
  b. Push the value val to the stack.
  c. Execute the instruction (TABLE.SET x).
  d. Push the value (at.CONST (i + 1)) to the stack.
  e. Push the value val to the stack.
  f. Push the value (at.CONST (n - 1)) to the stack.
  g. Execute the instruction (TABLE.FILL x).

Step_read/table.copy x_1 x_2
1. Let z be the current state.
2. Assert: Due to validation, a value of value type at' is on the top of the stack.
3. Pop the value (at'.CONST n) from the stack.
4. Assert: Due to validation, a value of value type at_2 is on the top of the stack.
5. Pop the value (at_2.CONST i_2) from the stack.
6. Assert: Due to validation, a value of value type at_1 is on the top of the stack.
7. Pop the value (at_1.CONST i_1) from the stack.
8. If ((i_1 + n) > |$table(z, x_1).REFS|), then:
  a. Trap.
9. If ((i_2 + n) > |$table(z, x_2).REFS|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else:
  a. If (i_1 <= i_2), then:
    1) Push the value (at_1.CONST i_1) to the stack.
    2) Push the value (at_2.CONST i_2) to the stack.
    3) Execute the instruction (TABLE.GET x_2).
    4) Execute the instruction (TABLE.SET x_1).
    5) Push the value (at_1.CONST (i_1 + 1)) to the stack.
    6) Push the value (at_2.CONST (i_2 + 1)) to the stack.
  b. Else:
    1) Push the value (at_1.CONST ((i_1 + n) - 1)) to the stack.
    2) Push the value (at_2.CONST ((i_2 + n) - 1)) to the stack.
    3) Execute the instruction (TABLE.GET x_2).
    4) Execute the instruction (TABLE.SET x_1).
    5) Push the value (at_1.CONST i_1) to the stack.
    6) Push the value (at_2.CONST i_2) to the stack.
  c. Push the value (at'.CONST (n - 1)) to the stack.
  d. Execute the instruction (TABLE.COPY x_1 x_2).

Step_read/table.init x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST j) from the stack.
6. Assert: Due to validation, a value of value type at is on the top of the stack.
7. Pop the value (at.CONST i) from the stack.
8. If ((i + n) > |$table(z, x).REFS|), then:
  a. Trap.
9. If ((j + n) > |$elem(z, y).REFS|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else if (j < |$elem(z, y).REFS|), then:
  a. Push the value (at.CONST i) to the stack.
  b. Push the value $elem(z, y).REFS[j] to the stack.
  c. Execute the instruction (TABLE.SET x).
  d. Push the value (at.CONST (i + 1)) to the stack.
  e. Push the value (I32.CONST (j + 1)) to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (TABLE.INIT x y).

Step_read/load nt_u1 loadop_u1? x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type at is on the top of the stack.
3. Pop the value (at.CONST i) from the stack.
4. If loadop_u1? is not defined, then:
  a. Let nt be nt_u1.
  b. If (((i + ao.OFFSET) + ($size(nt) / 8)) > |$mem(z, x).BYTES|), then:
    1) Trap.
  c. Let c be $nbytes__1^-1(nt, $mem(z, x).BYTES[(i + ao.OFFSET) : ($size(nt) / 8)]).
  d. Push the value (nt.CONST c) to the stack.
5. If nt_u1 is Inn, then:
  a. If loadop_u1? is defined, then:
    1) Let ?(loadop__0) be loadop_u1?.
    2) Let n _ sx be loadop__0.
    3) If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, x).BYTES|), then:
      a) Trap.
  b. Let Inn be nt_u1.
  c. If loadop_u1? is defined, then:
    1) Let ?(loadop__0) be loadop_u1?.
    2) Let n _ sx be loadop__0.
    3) Let c be $ibytes__1^-1(n, $mem(z, x).BYTES[(i + ao.OFFSET) : (n / 8)]).
    4) Push the value (Inn.CONST $extend__(n, $size(Inn), sx, c)) to the stack.

Step_read/vload V128 vloadop_u1? x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type at is on the top of the stack.
3. Pop the value (at.CONST i) from the stack.
4. If ((((i + ao.OFFSET) + ($vsize(V128) / 8)) > |$mem(z, x).BYTES|) /\ vloadop_u1? is not defined), then:
  a. Trap.
5. If vloadop_u1? is not defined, then:
  a. Let c be $vbytes__1^-1(V128, $mem(z, x).BYTES[(i + ao.OFFSET) : ($vsize(V128) / 8)]).
  b. Push the value (V128.CONST c) to the stack.
6. Else:
  a. Let ?(vloadop__0) be vloadop_u1?.
  b. If vloadop__0 is SHAPE, then:
    1) Let (SHAPE M X K _ sx) be vloadop__0.
    2) If (((i + ao.OFFSET) + ((M * K) / 8)) > |$mem(z, x).BYTES|), then:
      a) Trap.
    3) Let j^K be $ibytes__1^-1(M, $mem(z, x).BYTES[((i + ao.OFFSET) + ((k * M) / 8)) : (M / 8)])^(k<K).
    4) If $lsizenn^-1((M * 2)) is Jnn, then:
      a) Let Jnn be $lsizenn^-1((M * 2)).
      b) Let c be $invlanes_(Jnn X K, $extend__(M, $lsizenn(Jnn), sx, j)^K).
      c) Push the value (V128.CONST c) to the stack.
  c. If vloadop__0 is SPLAT, then:
    1) Let (SPLAT N) be vloadop__0.
    2) If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, x).BYTES|), then:
      a) Trap.
    3) Let M be (128 / N).
    4) If $lsize^-1(N) is Jnn, then:
      a) Let Jnn be $lsize^-1(N).
      b) Let j be $ibytes__1^-1(N, $mem(z, x).BYTES[(i + ao.OFFSET) : (N / 8)]).
      c) Let c be $invlanes_(Jnn X M, j^M).
      d) Push the value (V128.CONST c) to the stack.
  d. If vloadop__0 is ZERO, then:
    1) Let (ZERO N) be vloadop__0.
    2) If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, x).BYTES|), then:
      a) Trap.
    3) Let j be $ibytes__1^-1(N, $mem(z, x).BYTES[(i + ao.OFFSET) : (N / 8)]).
    4) Let c be $extend__(N, 128, U, j).
    5) Push the value (V128.CONST c) to the stack.

Step_read/vload_lane V128 N x ao j
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c_1) from the stack.
4. Assert: Due to validation, a value of value type at is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, x).BYTES|), then:
  a. Trap.
7. Let M be ($vsize(V128) / N).
8. If $lsize^-1(N) is Jnn, then:
  a. Let Jnn be $lsize^-1(N).
  b. Let k be $ibytes__1^-1(N, $mem(z, x).BYTES[(i + ao.OFFSET) : (N / 8)]).
  c. Let c be $invlanes_(Jnn X M, $lanes_(Jnn X M, c_1) with [j] replaced by k).
  d. Push the value (V128.CONST c) to the stack.

Step_read/memory.size x
1. Let z be the current state.
2. Let at lim PAGE be $mem(z, x).TYPE.
3. Let (n * (64 * $Ki())) be |$mem(z, x).BYTES|.
4. Push the value (at.CONST n) to the stack.

Step_read/memory.fill x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type at is on the top of the stack.
3. Pop the value (at.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type at is on the top of the stack.
7. Pop the value (numtype_0.CONST i) from the stack.
8. If ((i + n) > |$mem(z, x).BYTES|), then:
  a. Trap.
9. If (n = 0), then:
  a. Do nothing.
10. Else:
  a. Push the value (at.CONST i) to the stack.
  b. Push the value val to the stack.
  c. Execute the instruction (STORE I32 ?(8) x $memarg0()).
  d. Push the value (at.CONST (i + 1)) to the stack.
  e. Push the value val to the stack.
  f. Push the value (at.CONST (n - 1)) to the stack.
  g. Execute the instruction (MEMORY.FILL x).

Step_read/memory.copy x_1 x_2
1. Let z be the current state.
2. Assert: Due to validation, a value of value type at' is on the top of the stack.
3. Pop the value (at'.CONST n) from the stack.
4. Assert: Due to validation, a value of value type at_2 is on the top of the stack.
5. Pop the value (at_2.CONST i_2) from the stack.
6. Assert: Due to validation, a value of value type at_1 is on the top of the stack.
7. Pop the value (at_1.CONST i_1) from the stack.
8. If ((i_1 + n) > |$mem(z, x_1).BYTES|), then:
  a. Trap.
9. If ((i_2 + n) > |$mem(z, x_2).BYTES|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else:
  a. If (i_1 <= i_2), then:
    1) Push the value (at_1.CONST i_1) to the stack.
    2) Push the value (at_2.CONST i_2) to the stack.
    3) Execute the instruction (LOAD I32 ?(8 _ U) x_2 $memarg0()).
    4) Execute the instruction (STORE I32 ?(8) x_1 $memarg0()).
    5) Push the value (at_1.CONST (i_1 + 1)) to the stack.
    6) Push the value (at_2.CONST (i_2 + 1)) to the stack.
  b. Else:
    1) Push the value (at_1.CONST ((i_1 + n) - 1)) to the stack.
    2) Push the value (at_2.CONST ((i_2 + n) - 1)) to the stack.
    3) Execute the instruction (LOAD I32 ?(8 _ U) x_2 $memarg0()).
    4) Execute the instruction (STORE I32 ?(8) x_1 $memarg0()).
    5) Push the value (at_1.CONST i_1) to the stack.
    6) Push the value (at_2.CONST i_2) to the stack.
  c. Push the value (at'.CONST (n - 1)) to the stack.
  d. Execute the instruction (MEMORY.COPY x_1 x_2).

Step_read/memory.init x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST j) from the stack.
6. Assert: Due to validation, a value of value type at is on the top of the stack.
7. Pop the value (at.CONST i) from the stack.
8. If ((i + n) > |$mem(z, x).BYTES|), then:
  a. Trap.
9. If ((j + n) > |$data(z, y).BYTES|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else if (j < |$data(z, y).BYTES|), then:
  a. Push the value (at.CONST i) to the stack.
  b. Push the value (I32.CONST $data(z, y).BYTES[j]) to the stack.
  c. Execute the instruction (STORE I32 ?(8) x $memarg0()).
  d. Push the value (at.CONST (i + 1)) to the stack.
  e. Push the value (I32.CONST (j + 1)) to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (MEMORY.INIT x y).

Step/throw x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$tagaddr(z)|).
3. Assert: Due to validation, $expanddt($tag(z, x).TYPE) is FUNC.
4. Let (FUNC functype_0) be $expanddt($tag(z, x).TYPE).
5. Let t^n -> resulttype_1 be functype_0.
6. Assert: Due to validation, (resulttype_1 = []).
7. Let a be |$exninst(z)|.
8. Assert: Due to validation, there are at least n values on the top of the stack.
9. Pop the values val^n from the stack.
10. Let exn be { TAG: $tagaddr(z)[x]; FIELDS: val^n }.
11. Perform $add_exninst(z, [exn]).
12. Push the value (REF.EXN_ADDR a) to the stack.
13. Execute the instruction THROW_REF.

Step/struct.new x
1. Let z be the current state.
2. Assert: Due to validation, $expanddt($type(z, x)) is STRUCT.
3. Let (STRUCT structtype_0) be $expanddt($type(z, x)).
4. Let (mut zt)^n be structtype_0.
5. Let a be |$structinst(z)|.
6. Assert: Due to validation, there are at least n values on the top of the stack.
7. Pop the values val^n from the stack.
8. Let si be { TYPE: $type(z, x); FIELDS: $packfield_(zt, val)^n }.
9. Push the value (REF.STRUCT_ADDR a) to the stack.
10. Perform $add_structinst(z, [si]).

Step/struct.set x i
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Assert: Due to validation, a value of value type instr is on the top of the stack.
5. Pop the value instr_u1 from the stack.
6. If instr_u1 is REF.NULL, then:
  a. Trap.
7. If instr_u1 is REF.STRUCT_ADDR, then:
  a. Let (REF.STRUCT_ADDR a) be instr_u1.
  b. Assert: Due to validation, $expanddt($type(z, x)) is STRUCT.
  c. Let (STRUCT structtype_0) be $expanddt($type(z, x)).
  d. Let (mut zt)* be structtype_0.
  e. If (i < |zt*|), then:
    1) Perform $with_struct(z, a, i, $packfield_(zt*[i], val)).

Step/array.new_fixed x n
1. Let z be the current state.
2. Assert: Due to validation, $expanddt($type(z, x)) is ARRAY.
3. Let (ARRAY arraytype_0) be $expanddt($type(z, x)).
4. Let (mut zt) be arraytype_0.
5. Let a be |$arrayinst(z)|.
6. Assert: Due to validation, there are at least n values on the top of the stack.
7. Pop the values val^n from the stack.
8. Let ai be { TYPE: $type(z, x); FIELDS: $packfield_(zt, val)^n }.
9. Push the value (REF.ARRAY_ADDR a) to the stack.
10. Perform $add_arrayinst(z, [ai]).

Step/array.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type instr is on the top of the stack.
7. Pop the value instr_u1 from the stack.
8. If instr_u1 is REF.NULL, then:
  a. Trap.
9. If instr_u1 is REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be instr_u1.
  b. If ((a < |$arrayinst(z)|) /\ (i >= |$arrayinst(z)[a].FIELDS|)), then:
    1) Trap.
  c. Assert: Due to validation, $expanddt($type(z, x)) is ARRAY.
  d. Let (ARRAY arraytype_0) be $expanddt($type(z, x)).
  e. Let (mut zt) be arraytype_0.
  f. Perform $with_array(z, a, i, $packfield_(zt, val)).

Step/local.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_local(z, x, val).

Step/global.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_global(z, x, val).

Step/table.set x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Assert: Due to validation, a value of value type at is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. If (i >= |$table(z, x).REFS|), then:
  a. Trap.
7. Perform $with_table(z, x, i, ref).

Step/table.grow x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type at is on the top of the stack.
3. Pop the value (at.CONST n) from the stack.
4. Assert: Due to validation, a value of value type ref is on the top of the stack.
5. Pop the value ref from the stack.
6. Either:
  a. Let ti be $growtable($table(z, x), n, ref).
  b. Push the value (at.CONST |$table(z, x).REFS|) to the stack.
  c. Perform $with_tableinst(z, x, ti).
7. Or:
  a. Push the value (at.CONST $invsigned_($size(at), (- 1))) to the stack.

Step/elem.drop x
1. Let z be the current state.
2. Perform $with_elem(z, x, []).

Step/store nt_u1 storeop_u1? x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type nt_u3 is on the top of the stack.
3. Pop the value (nt_u3.CONST c) from the stack.
4. Assert: Due to validation, a value of value type at is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. Let nt be nt_u3.
7. If ((((i + ao.OFFSET) + ($size(nt) / 8)) > |$mem(z, x).BYTES|) /\ ((nt_u1 = nt) /\ storeop_u1? is not defined)), then:
  a. Trap.
8. If ((nt_u1 = nt) /\ storeop_u1? is not defined), then:
  a. Let b* be $nbytes_(nt, c).
  b. Perform $with_mem(z, x, (i + ao.OFFSET), ($size(nt) / 8), b*).
9. If nt_u3 is Inn, then:
  a. Let Inn be nt_u3.
  b. If ((nt_u1 = Inn) /\ storeop_u1? is defined), then:
    1) Let ?(n) be storeop_u1?.
    2) If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, x).BYTES|), then:
      a) Trap.
    3) Let b* be $ibytes_(n, $wrap__($size(Inn), n, c)).
    4) Perform $with_mem(z, x, (i + ao.OFFSET), (n / 8), b*).

Step/vstore V128 x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c) from the stack.
4. Assert: Due to validation, a value of value type at is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. If (((i + ao.OFFSET) + ($vsize(V128) / 8)) > |$mem(z, x).BYTES|), then:
  a. Trap.
7. Let b* be $vbytes_(V128, c).
8. Perform $with_mem(z, x, (i + ao.OFFSET), ($vsize(V128) / 8), b*).

Step/vstore_lane V128 N x ao j
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c) from the stack.
4. Assert: Due to validation, a value of value type at is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. If (((i + ao.OFFSET) + N) > |$mem(z, x).BYTES|), then:
  a. Trap.
7. Let M be (128 / N).
8. If $lsize^-1(N) is Jnn, then:
  a. Let Jnn be $lsize^-1(N).
  b. If (j < |$lanes_(Jnn X M, c)|), then:
    1) Let b* be $ibytes_(N, $lanes_(Jnn X M, c)[j]).
    2) Perform $with_mem(z, x, (i + ao.OFFSET), (N / 8), b*).

Step/memory.grow x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type at is on the top of the stack.
3. Pop the value (at.CONST n) from the stack.
4. Either:
  a. Let mi be $growmem($mem(z, x), n).
  b. Push the value (at.CONST (|$mem(z, x).BYTES| / (64 * $Ki()))) to the stack.
  c. Perform $with_meminst(z, x, mi).
5. Or:
  a. Push the value (at.CONST $invsigned_($size(at), (- 1))) to the stack.

Step/data.drop x
1. Let z be the current state.
2. Perform $with_data(z, x, []).

min i j
1. If (i <= j), then:
  a. Return i.
2. Return j.

sum n_u1*
1. If (n_u1* = []), then:
  a. Return 0.
2. Let [n] :: n'* be n_u1*.
3. Return (n + $sum(n'*)).

prod n_u1*
1. If (n_u1* = []), then:
  a. Return 1.
2. Let [n] :: n'* be n_u1*.
3. Return (n * $prod(n'*)).

opt_ X X_u1*
1. If (X_u1* = []), then:
  a. Return ?().
2. Assert: Due to validation, (|X_u1*| = 1).
3. Let [w] be X_u1*.
4. Return ?(w).

concat_ X X_u1*
1. If (X_u1* = []), then:
  a. Return [].
2. Let [w*] :: w'** be X_u1*.
3. Return w* :: $concat_(X, w'**).

concatn_ X X_u1* n
1. If (X_u1* = []), then:
  a. Return [].
2. Let [w^n] :: w'^n* be X_u1*.
3. Return w^n :: $concatn_(X, w'^n*, n).

disjoint_ X X_u1*
1. If (X_u1* = []), then:
  a. Return true.
2. Let [w] :: w'* be X_u1*.
3. Return (w is not contained in w'* /\ $disjoint_(X, w'*)).

setminus1_ X w X_u1*
1. If (X_u1* = []), then:
  a. Return [w].
2. Let [w_1] :: w'* be X_u1*.
3. If (w = w_1), then:
  a. Return [].
4. Return $setminus1_(X, w, w'*).

setminus_ X X_u1* w*
1. If (X_u1* = []), then:
  a. Return [].
2. Let [w_1] :: w'* be X_u1*.
3. Return $setminus1_(X, w_1, w*) :: $setminus_(X, w'*, w*).

setproduct2_ X w_1 X_u1*
1. If (X_u1* = []), then:
  a. Return [].
2. Let [w'*] :: w** be X_u1*.
3. Return [[w_1] :: w'*] :: $setproduct2_(X, w_1, w**).

setproduct1_ X X_u1* w**
1. If (X_u1* = []), then:
  a. Return [].
2. Let [w_1] :: w'* be X_u1*.
3. Return $setproduct2_(X, w_1, w**) :: $setproduct1_(X, w'*, w**).

setproduct_ X X_u1*
1. If (X_u1* = []), then:
  a. Return [[]].
2. Let [w_1*] :: w** be X_u1*.
3. Return $setproduct1_(X, w_1*, $setproduct_(X, w**)).

signif N_u1
1. If (N_u1 = 32), then:
  a. Return 23.
2. Assert: Due to validation, (N_u1 = 64).
3. Return 52.

expon N_u1
1. If (N_u1 = 32), then:
  a. Return 8.
2. Assert: Due to validation, (N_u1 = 64).
3. Return 11.

M N
1. Return $signif(N).

E N
1. Return $expon(N).

fzero N
1. Return (POS (SUBNORM 0)).

fone N
1. Return (POS (NORM 1 0)).

fnat N n
1. Return (POS (NORM n 0)).

canon_ N
1. Return (2 ^ ($signif(N) - 1)).

cont b
1. Assert: Due to validation, (128 < b).
2. Assert: Due to validation, (b < 192).
3. Return (b - 128).

ANYREF
1. Return (REF ?(NULL) ANY).

EQREF
1. Return (REF ?(NULL) EQ).

I31REF
1. Return (REF ?(NULL) I31).

STRUCTREF
1. Return (REF ?(NULL) STRUCT).

ARRAYREF
1. Return (REF ?(NULL) ARRAY).

FUNCREF
1. Return (REF ?(NULL) FUNC).

EXNREF
1. Return (REF ?(NULL) EXTERN).

EXTERNREF
1. Return (REF ?(NULL) EXTERN).

NULLREF
1. Return (REF ?(NULL) NONE).

NULLFUNCREF
1. Return (REF ?(NULL) NOFUNC).

NULLEXNREF
1. Return (REF ?(NULL) NOEXN).

NULLEXTERNREF
1. Return (REF ?(NULL) NOEXTERN).

size nt_u1
1. If (nt_u1 = I32), then:
  a. Return 32.
2. If (nt_u1 = I64), then:
  a. Return 64.
3. If (nt_u1 = F32), then:
  a. Return 32.
4. Assert: Due to validation, (nt_u1 = F64).
5. Return 64.

vsize V128
1. Return 128.

psize pt_u1
1. If (pt_u1 = I8), then:
  a. Return 8.
2. Assert: Due to validation, (pt_u1 = I16).
3. Return 16.

lsize lt_u1
1. If lt_u1 is numtype, then:
  a. Let numtype be lt_u1.
  b. Return $size(numtype).
2. Assert: Due to validation, lt_u1 is packtype.
3. Let packtype be lt_u1.
4. Return $psize(packtype).

zsize zt_u1
1. If zt_u1 is numtype, then:
  a. Let numtype be zt_u1.
  b. Return $size(numtype).
2. If zt_u1 is vectype, then:
  a. Let vectype be zt_u1.
  b. Return $vsize(vectype).
3. Assert: Due to validation, zt_u1 is packtype.
4. Let packtype be zt_u1.
5. Return $psize(packtype).

sizenn nt
1. Return $size(nt).

sizenn1 nt
1. Return $size(nt).

sizenn2 nt
1. Return $size(nt).

vsizenn vt
1. Return $vsize(vt).

psizenn pt
1. Return $psize(pt).

lsizenn lt
1. Return $lsize(lt).

lsizenn1 lt
1. Return $lsize(lt).

lsizenn2 lt
1. Return $lsize(lt).

lunpack lt_u1
1. If lt_u1 is numtype, then:
  a. Let numtype be lt_u1.
  b. Return numtype.
2. Assert: Due to validation, lt_u1 is packtype.
3. Return I32.

unpack zt_u1
1. If zt_u1 is valtype, then:
  a. Let valtype be zt_u1.
  b. Return valtype.
2. Assert: Due to validation, zt_u1 is packtype.
3. Return I32.

nunpack zt_u1
1. If zt_u1 is numtype, then:
  a. Let numtype be zt_u1.
  b. Return numtype.
2. If zt_u1 is packtype, then:
  a. Return I32.

vunpack vectype
1. Return vectype.

cunpack zt_u1
1. If zt_u1 is consttype, then:
  a. Let consttype be zt_u1.
  b. Return consttype.
2. If zt_u1 is packtype, then:
  a. Return I32.
3. If zt_u1 is lanetype, then:
  a. Let lanetype be zt_u1.
  b. Return $lunpack(lanetype).

dim Lnn X N
1. Return N.

lanetype Lnn X N
1. Return Lnn.

unpackshape Lnn X N
1. Return $lunpack(Lnn).

funcsxx xx_u1*
1. If (xx_u1* = []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be xx_u1*.
3. If externidx_0 is FUNC, then:
  a. Let (FUNC x) be externidx_0.
  b. Return [x] :: $funcsxx(xx*).
4. Let [externidx] :: xx* be xx_u1*.
5. Return $funcsxx(xx*).

globalsxx xx_u1*
1. If (xx_u1* = []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be xx_u1*.
3. If externidx_0 is GLOBAL, then:
  a. Let (GLOBAL x) be externidx_0.
  b. Return [x] :: $globalsxx(xx*).
4. Let [externidx] :: xx* be xx_u1*.
5. Return $globalsxx(xx*).

tablesxx xx_u1*
1. If (xx_u1* = []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be xx_u1*.
3. If externidx_0 is TABLE, then:
  a. Let (TABLE x) be externidx_0.
  b. Return [x] :: $tablesxx(xx*).
4. Let [externidx] :: xx* be xx_u1*.
5. Return $tablesxx(xx*).

memsxx xx_u1*
1. If (xx_u1* = []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be xx_u1*.
3. If externidx_0 is MEM, then:
  a. Let (MEM x) be externidx_0.
  b. Return [x] :: $memsxx(xx*).
4. Let [externidx] :: xx* be xx_u1*.
5. Return $memsxx(xx*).

tagsxx xx_u1*
1. If (xx_u1* = []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be xx_u1*.
3. If externidx_0 is TAG, then:
  a. Let (TAG x) be externidx_0.
  b. Return [x] :: $tagsxx(xx*).
4. Let [externidx] :: xx* be xx_u1*.
5. Return $tagsxx(xx*).

IN N_u1
1. If (N_u1 = 32), then:
  a. Return I32.
2. Assert: Due to validation, (N_u1 = 64).
3. Return I64.

FN N_u1
1. If (N_u1 = 32), then:
  a. Return F32.
2. Assert: Due to validation, (N_u1 = 64).
3. Return F64.

JN N_u1
1. If (N_u1 = 8), then:
  a. Return I8.
2. If (N_u1 = 16), then:
  a. Return I16.
3. If (N_u1 = 32), then:
  a. Return I32.
4. Assert: Due to validation, (N_u1 = 64).
5. Return I64.

minat at_1 at_2
1. If ($size(at_1) <= $size(at_2)), then:
  a. Return at_1.
2. Return at_2.

diffrt (REF nul1 ht_1) (REF nul_u1 ht_2)
1. If (nul_u1 = ?(NULL)), then:
  a. Return (REF ?() ht_1).
2. Assert: Due to validation, nul_u1 is not defined.
3. Return (REF nul1 ht_1).

funcsxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is FUNC, then:
  a. Let (FUNC dt) be externtype_0.
  b. Return [dt] :: $funcsxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $funcsxt(xt*).

globalsxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is GLOBAL, then:
  a. Let (GLOBAL gt) be externtype_0.
  b. Return [gt] :: $globalsxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $globalsxt(xt*).

tablesxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is TABLE, then:
  a. Let (TABLE tt) be externtype_0.
  b. Return [tt] :: $tablesxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $tablesxt(xt*).

memsxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is MEM, then:
  a. Let (MEM mt) be externtype_0.
  b. Return [mt] :: $memsxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $memsxt(xt*).

tagsxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is TAG, then:
  a. Let (TAG jt) be externtype_0.
  b. Return [jt] :: $tagsxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $tagsxt(xt*).

subst_typevar tv tv_u1* yy_u1*
1. If ((tv_u1* = []) /\ (yy_u1* = [])), then:
  a. Return tv.
2. Assert: Due to validation, (|yy_u1*| >= 1).
3. Let [tu_1] :: tu'* be yy_u1*.
4. Assert: Due to validation, (|tv_u1*| >= 1).
5. Let [tv_1] :: tv'* be tv_u1*.
6. If (tv = tv_1), then:
  a. Return tu_1.
7. Return $subst_typevar(tv, tv'*, tu'*).

subst_packtype pt tv* tu*
1. Return pt.

subst_numtype nt tv* tu*
1. Return nt.

subst_vectype vt tv* tu*
1. Return vt.

subst_typeuse yy_u1 tv* tu*
1. If yy_u1 is typevar, then:
  a. Let tv' be yy_u1.
  b. Return $subst_typevar(tv', tv*, tu*).
2. Assert: Due to validation, yy_u1 is deftype.
3. Let dt be yy_u1.
4. Return $subst_deftype(dt, tv*, tu*).

subst_heaptype ht_u1 tv* tu*
1. If ht_u1 is typevar, then:
  a. Let tv' be ht_u1.
  b. Return $subst_typevar(tv', tv*, tu*).
2. If ht_u1 is deftype, then:
  a. Let dt be ht_u1.
  b. Return $subst_deftype(dt, tv*, tu*).
3. Let ht be ht_u1.
4. Return ht.

subst_reftype (REF nul ht) tv* tu*
1. Return (REF nul $subst_heaptype(ht, tv*, tu*)).

subst_valtype t_u1 tv* tu*
1. If t_u1 is numtype, then:
  a. Let nt be t_u1.
  b. Return $subst_numtype(nt, tv*, tu*).
2. If t_u1 is vectype, then:
  a. Let vt be t_u1.
  b. Return $subst_vectype(vt, tv*, tu*).
3. If t_u1 is reftype, then:
  a. Let rt be t_u1.
  b. Return $subst_reftype(rt, tv*, tu*).
4. Assert: Due to validation, (t_u1 = BOT).
5. Return BOT.

subst_storagetype zt_u1 tv* tu*
1. If zt_u1 is valtype, then:
  a. Let t be zt_u1.
  b. Return $subst_valtype(t, tv*, tu*).
2. Assert: Due to validation, zt_u1 is packtype.
3. Let pt be zt_u1.
4. Return $subst_packtype(pt, tv*, tu*).

subst_fieldtype (mut zt) tv* tu*
1. Return (mut $subst_storagetype(zt, tv*, tu*)).

subst_comptype ct_u1 tv* tu*
1. If ct_u1 is STRUCT, then:
  a. Let (STRUCT yt*) be ct_u1.
  b. Return (STRUCT $subst_fieldtype(yt, tv*, tu*)*).
2. If ct_u1 is ARRAY, then:
  a. Let (ARRAY yt) be ct_u1.
  b. Return (ARRAY $subst_fieldtype(yt, tv*, tu*)).
3. Assert: Due to validation, ct_u1 is FUNC.
4. Let (FUNC ft) be ct_u1.
5. Return (FUNC $subst_functype(ft, tv*, tu*)).

subst_subtype (SUB fin tu'* ct) tv* tu*
1. Return (SUB fin $subst_typeuse(tu', tv*, tu*)* $subst_comptype(ct, tv*, tu*)).

subst_rectype (REC st*) tv* tu*
1. Return (REC $subst_subtype(st, tv*, tu*)*).

subst_deftype (DEF qt i) tv* tu*
1. Return (DEF $subst_rectype(qt, tv*, tu*) i).

subst_functype t_1* -> t_2* tv* tu*
1. Return $subst_valtype(t_1, tv*, tu*)* -> $subst_valtype(t_2, tv*, tu*)*.

subst_addrtype at tv* tu*
1. Return at.

subst_globaltype (mut t) tv* tu*
1. Return (mut $subst_valtype(t, tv*, tu*)).

subst_tabletype (at lim rt) tv* tu*
1. Return (at lim $subst_reftype(rt, tv*, tu*)).

subst_memtype at lim PAGE tv* tu*
1. Return at lim PAGE.

subst_tagtype dt tv* tu*
1. Return $subst_deftype(dt, tv*, tu*).

subst_externtype xt_u1 tv* tu*
1. If xt_u1 is FUNC, then:
  a. Let (FUNC dt) be xt_u1.
  b. Return (FUNC $subst_deftype(dt, tv*, tu*)).
2. If xt_u1 is GLOBAL, then:
  a. Let (GLOBAL gt) be xt_u1.
  b. Return (GLOBAL $subst_globaltype(gt, tv*, tu*)).
3. If xt_u1 is TABLE, then:
  a. Let (TABLE tt) be xt_u1.
  b. Return (TABLE $subst_tabletype(tt, tv*, tu*)).
4. If xt_u1 is MEM, then:
  a. Let (MEM mt) be xt_u1.
  b. Return (MEM $subst_memtype(mt, tv*, tu*)).
5. Assert: Due to validation, xt_u1 is TAG.
6. Let (TAG jt) be xt_u1.
7. Return (TAG $subst_tagtype(jt, tv*, tu*)).

subst_moduletype xt_1* -> xt_2* tv* tu*
1. Return $subst_externtype(xt_1, tv*, tu*)* -> $subst_externtype(xt_2, tv*, tu*)*.

subst_all_valtype t tu^n
1. Return $subst_valtype(t, (_IDX i)^(i<n), tu^n).

subst_all_reftype rt tu^n
1. Return $subst_reftype(rt, (_IDX i)^(i<n), tu^n).

subst_all_deftype dt tu^n
1. Return $subst_deftype(dt, (_IDX i)^(i<n), tu^n).

subst_all_globaltype gt tu^n
1. Return $subst_globaltype(gt, (_IDX i)^(i<n), tu^n).

subst_all_tabletype tt tu^n
1. Return $subst_tabletype(tt, (_IDX i)^(i<n), tu^n).

subst_all_memtype mt tu^n
1. Return $subst_memtype(mt, (_IDX i)^(i<n), tu^n).

subst_all_moduletype mmt tu^n
1. Return $subst_moduletype(mmt, (_IDX i)^(i<n), tu^n).

subst_all_deftypes dt_u1* tu*
1. If (dt_u1* = []), then:
  a. Return [].
2. Let [dt_1] :: dt* be dt_u1*.
3. Return [$subst_all_deftype(dt_1, tu*)] :: $subst_all_deftypes(dt*, tu*).

rollrt x rectype
1. Let (REC subtype^n) be rectype.
2. Return (REC $subst_subtype(subtype, (_IDX (x + i))^(i<n), (REC i)^(i<n))^n).

unrollrt rectype
1. Let (REC subtype^n) be rectype.
2. Return (REC $subst_subtype(subtype, (REC i)^(i<n), (DEF rectype i)^(i<n))^n).

rolldt x rectype
1. Let (REC subtype^n) be $rollrt(x, rectype).
2. Return (DEF (REC subtype^n) i)^(i<n).

unrolldt (DEF rectype i)
1. Let (REC subtype*) be $unrollrt(rectype).
2. Return subtype*[i].

expanddt deftype
1. Let (SUB fin typeuse* comptype) be $unrolldt(deftype).
2. Return comptype.

memarg0
1. Return { ALIGN: 0; OFFSET: 0 }.

const consttype_u1 c
1. If consttype_u1 is numtype, then:
  a. Let numtype be consttype_u1.
  b. Return (numtype.CONST c).
2. Assert: Due to validation, consttype_u1 is vectype.
3. Let vectype be consttype_u1.
4. Return (vectype.CONST c).

free_opt free_u1?
1. If free_u1? is not defined, then:
  a. Return {}.
2. Let ?(free) be free_u1?.
3. Return free.

free_list free_u1*
1. If (free_u1* = []), then:
  a. Return {}.
2. Let [free] :: free'* be free_u1*.
3. Return free ++ $free_list(free'*).

free_typeidx typeidx
1. Return { TYPES: [typeidx] }.

free_funcidx funcidx
1. Return { FUNCS: [funcidx] }.

free_globalidx globalidx
1. Return { GLOBALS: [globalidx] }.

free_tableidx tableidx
1. Return { TABLES: [tableidx] }.

free_memidx memidx
1. Return { MEMS: [memidx] }.

free_elemidx elemidx
1. Return { ELEMS: [elemidx] }.

free_dataidx dataidx
1. Return { DATAS: [dataidx] }.

free_localidx localidx
1. Return { LOCALS: [localidx] }.

free_labelidx labelidx
1. Return { LABELS: [labelidx] }.

free_externidx xx_u1
1. If xx_u1 is FUNC, then:
  a. Let (FUNC funcidx) be xx_u1.
  b. Return $free_funcidx(funcidx).
2. If xx_u1 is GLOBAL, then:
  a. Let (GLOBAL globalidx) be xx_u1.
  b. Return $free_globalidx(globalidx).
3. If xx_u1 is TABLE, then:
  a. Let (TABLE tableidx) be xx_u1.
  b. Return $free_tableidx(tableidx).
4. Assert: Due to validation, xx_u1 is MEM.
5. Let (MEM memidx) be xx_u1.
6. Return $free_memidx(memidx).

free_addrtype addrtype
1. Return {}.

free_numtype numtype
1. Return {}.

free_packtype packtype
1. Return {}.

free_lanetype lt_u1
1. If lt_u1 is numtype, then:
  a. Let numtype be lt_u1.
  b. Return $free_numtype(numtype).
2. Assert: Due to validation, lt_u1 is packtype.
3. Let packtype be lt_u1.
4. Return $free_packtype(packtype).

free_vectype vectype
1. Return {}.

free_consttype consttype_u1
1. If consttype_u1 is numtype, then:
  a. Let numtype be consttype_u1.
  b. Return $free_numtype(numtype).
2. Assert: Due to validation, consttype_u1 is vectype.
3. Let vectype be consttype_u1.
4. Return $free_vectype(vectype).

free_absheaptype absheaptype
1. Return {}.

free_typevar tv_u1
1. If tv_u1 is _IDX, then:
  a. Let (_IDX typeidx) be tv_u1.
  b. Return $free_typeidx(typeidx).
2. Assert: Due to validation, tv_u1 is REC.
3. Return {}.

free_heaptype ht_u1
1. If ht_u1 is absheaptype, then:
  a. Let absheaptype be ht_u1.
  b. Return $free_absheaptype(absheaptype).
2. Assert: Due to validation, ht_u1 is typeuse.
3. Let typeuse be ht_u1.
4. Return $free_typeuse(typeuse).

free_reftype (REF nul heaptype)
1. Return $free_heaptype(heaptype).

free_typeuse yy_u1
1. If yy_u1 is typevar, then:
  a. Let typevar be yy_u1.
  b. Return $free_typevar(typevar).
2. Assert: Due to validation, yy_u1 is deftype.
3. Let deftype be yy_u1.
4. Return $free_deftype(deftype).

free_valtype t_u1
1. If t_u1 is numtype, then:
  a. Let numtype be t_u1.
  b. Return $free_numtype(numtype).
2. If t_u1 is vectype, then:
  a. Let vectype be t_u1.
  b. Return $free_vectype(vectype).
3. If t_u1 is reftype, then:
  a. Let reftype be t_u1.
  b. Return $free_reftype(reftype).
4. Assert: Due to validation, (t_u1 = BOT).
5. Return {}.

free_resulttype valtype*
1. Return $free_list($free_valtype(valtype)*).

free_storagetype zt_u1
1. If zt_u1 is valtype, then:
  a. Let valtype be zt_u1.
  b. Return $free_valtype(valtype).
2. Assert: Due to validation, zt_u1 is packtype.
3. Let packtype be zt_u1.
4. Return $free_packtype(packtype).

free_fieldtype (mut storagetype)
1. Return $free_storagetype(storagetype).

free_structtype fieldtype*
1. Return $free_list($free_fieldtype(fieldtype)*).

free_arraytype fieldtype
1. Return $free_fieldtype(fieldtype).

free_functype resulttype_1 -> resulttype_2
1. Return $free_resulttype(resulttype_1) ++ $free_resulttype(resulttype_2).

free_comptype ct_u1
1. If ct_u1 is STRUCT, then:
  a. Let (STRUCT structtype) be ct_u1.
  b. Return $free_structtype(structtype).
2. If ct_u1 is ARRAY, then:
  a. Let (ARRAY arraytype) be ct_u1.
  b. Return $free_arraytype(arraytype).
3. Assert: Due to validation, ct_u1 is FUNC.
4. Let (FUNC functype) be ct_u1.
5. Return $free_functype(functype).

free_subtype (SUB fin typeuse* comptype)
1. Return $free_list($free_typeuse(typeuse)*) ++ $free_comptype(comptype).

free_rectype (REC subtype*)
1. Return $free_list($free_subtype(subtype)*).

free_deftype (DEF rectype n)
1. Return $free_rectype(rectype).

free_globaltype (mut valtype)
1. Return $free_valtype(valtype).

free_tabletype (addrtype limits reftype)
1. Return $free_addrtype(addrtype) ++ $free_reftype(reftype).

free_memtype addrtype limits PAGE
1. Return $free_addrtype(addrtype).

free_tagtype deftype
1. Return $free_deftype(deftype).

free_elemtype reftype
1. Return $free_reftype(reftype).

free_datatype OK
1. Return {}.

free_externtype xt_u1
1. If xt_u1 is FUNC, then:
  a. Let (FUNC typeuse) be xt_u1.
  b. Return $free_typeuse(typeuse).
2. If xt_u1 is GLOBAL, then:
  a. Let (GLOBAL globaltype) be xt_u1.
  b. Return $free_globaltype(globaltype).
3. If xt_u1 is TABLE, then:
  a. Let (TABLE tabletype) be xt_u1.
  b. Return $free_tabletype(tabletype).
4. If xt_u1 is MEM, then:
  a. Let (MEM memtype) be xt_u1.
  b. Return $free_memtype(memtype).
5. Assert: Due to validation, xt_u1 is TAG.
6. Let (TAG tagtype) be xt_u1.
7. Return $free_tagtype(tagtype).

free_moduletype externtype_1* -> externtype_2*
1. Return $free_list($free_externtype(externtype_1)*) ++ $free_list($free_externtype(externtype_2)*).

free_shape lanetype X dim
1. Return $free_lanetype(lanetype).

free_blocktype bt_u1
1. If bt_u1 is _RESULT, then:
  a. Let (_RESULT valtype?) be bt_u1.
  b. Return $free_opt($free_valtype(valtype)?).
2. Assert: Due to validation, bt_u1 is _IDX.
3. Let (_IDX funcidx) be bt_u1.
4. Return $free_funcidx(funcidx).

shift_labelidxs l_u1*
1. If (l_u1* = []), then:
  a. Return [].
2. Let [labelidx_0] :: labelidx'* be l_u1*.
3. If (labelidx_0 = 0), then:
  a. Return $shift_labelidxs(labelidx'*).
4. Let [labelidx] :: labelidx'* be l_u1*.
5. Return [(labelidx - 1)] :: $shift_labelidxs(labelidx'*).

free_instr instr_u1
1. If (instr_u1 = NOP), then:
  a. Return {}.
2. If (instr_u1 = UNREACHABLE), then:
  a. Return {}.
3. If (instr_u1 = DROP), then:
  a. Return {}.
4. If instr_u1 is SELECT, then:
  a. Let (SELECT valtype*?) be instr_u1.
  b. Return $free_opt($free_list($free_valtype(valtype)*)?).
5. If instr_u1 is BLOCK, then:
  a. Let (BLOCK blocktype instr*) be instr_u1.
  b. Return $free_blocktype(blocktype) ++ $free_block(instr*).
6. If instr_u1 is LOOP, then:
  a. Let (LOOP blocktype instr*) be instr_u1.
  b. Return $free_blocktype(blocktype) ++ $free_block(instr*).
7. If instr_u1 is IF, then:
  a. Let (IF blocktype instr_1* ELSE instr_2*) be instr_u1.
  b. Return $free_blocktype(blocktype) ++ $free_block(instr_1*) ++ $free_block(instr_2*).
8. If instr_u1 is BR, then:
  a. Let (BR labelidx) be instr_u1.
  b. Return $free_labelidx(labelidx).
9. If instr_u1 is BR_IF, then:
  a. Let (BR_IF labelidx) be instr_u1.
  b. Return $free_labelidx(labelidx).
10. If instr_u1 is BR_TABLE, then:
  a. Let (BR_TABLE labelidx* labelidx') be instr_u1.
  b. Return $free_list($free_labelidx(labelidx)*) ++ $free_labelidx(labelidx).
11. If instr_u1 is BR_ON_NULL, then:
  a. Let (BR_ON_NULL labelidx) be instr_u1.
  b. Return $free_labelidx(labelidx).
12. If instr_u1 is BR_ON_NON_NULL, then:
  a. Let (BR_ON_NON_NULL labelidx) be instr_u1.
  b. Return $free_labelidx(labelidx).
13. If instr_u1 is BR_ON_CAST, then:
  a. Let (BR_ON_CAST labelidx reftype_1 reftype_2) be instr_u1.
  b. Return $free_labelidx(labelidx) ++ $free_reftype(reftype_1) ++ $free_reftype(reftype_2).
14. If instr_u1 is BR_ON_CAST_FAIL, then:
  a. Let (BR_ON_CAST_FAIL labelidx reftype_1 reftype_2) be instr_u1.
  b. Return $free_labelidx(labelidx) ++ $free_reftype(reftype_1) ++ $free_reftype(reftype_2).
15. If instr_u1 is CALL, then:
  a. Let (CALL funcidx) be instr_u1.
  b. Return $free_funcidx(funcidx).
16. If instr_u1 is CALL_REF, then:
  a. Let (CALL_REF typeuse) be instr_u1.
  b. Return $free_typeuse(typeuse).
17. If instr_u1 is CALL_INDIRECT, then:
  a. Let (CALL_INDIRECT tableidx typeuse) be instr_u1.
  b. Return $free_tableidx(tableidx) ++ $free_typeuse(typeuse).
18. If (instr_u1 = RETURN), then:
  a. Return {}.
19. If instr_u1 is RETURN_CALL, then:
  a. Let (RETURN_CALL funcidx) be instr_u1.
  b. Return $free_funcidx(funcidx).
20. If instr_u1 is RETURN_CALL_REF, then:
  a. Let (RETURN_CALL_REF typeuse) be instr_u1.
  b. Return $free_typeuse(typeuse).
21. If instr_u1 is RETURN_CALL_INDIRECT, then:
  a. Let (RETURN_CALL_INDIRECT tableidx typeuse) be instr_u1.
  b. Return $free_tableidx(tableidx) ++ $free_typeuse(typeuse).
22. If instr_u1 is CONST, then:
  a. Let (numtype.CONST numlit) be instr_u1.
  b. Return $free_numtype(numtype).
23. If instr_u1 is UNOP, then:
  a. Let (UNOP numtype unop) be instr_u1.
  b. Return $free_numtype(numtype).
24. If instr_u1 is BINOP, then:
  a. Let (BINOP numtype binop) be instr_u1.
  b. Return $free_numtype(numtype).
25. If instr_u1 is TESTOP, then:
  a. Let (TESTOP numtype testop) be instr_u1.
  b. Return $free_numtype(numtype).
26. If instr_u1 is RELOP, then:
  a. Let (RELOP numtype relop) be instr_u1.
  b. Return $free_numtype(numtype).
27. If instr_u1 is CVTOP, then:
  a. Let (CVTOP numtype_1 numtype_2 cvtop) be instr_u1.
  b. Return $free_numtype(numtype_1) ++ $free_numtype(numtype_2).
28. If instr_u1 is VCONST, then:
  a. Let (vectype.CONST veclit) be instr_u1.
  b. Return $free_vectype(vectype).
29. If instr_u1 is VVUNOP, then:
  a. Let (VVUNOP vectype vvunop) be instr_u1.
  b. Return $free_vectype(vectype).
30. If instr_u1 is VVBINOP, then:
  a. Let (VVBINOP vectype vvbinop) be instr_u1.
  b. Return $free_vectype(vectype).
31. If instr_u1 is VVTERNOP, then:
  a. Let (VVTERNOP vectype vvternop) be instr_u1.
  b. Return $free_vectype(vectype).
32. If instr_u1 is VVTESTOP, then:
  a. Let (VVTESTOP vectype vvtestop) be instr_u1.
  b. Return $free_vectype(vectype).
33. If instr_u1 is VUNOP, then:
  a. Let (VUNOP shape vunop) be instr_u1.
  b. Return $free_shape(shape).
34. If instr_u1 is VBINOP, then:
  a. Let (VBINOP shape vbinop) be instr_u1.
  b. Return $free_shape(shape).
35. If instr_u1 is VTERNOP, then:
  a. Let (VTERNOP shape vternop) be instr_u1.
  b. Return $free_shape(shape).
36. If instr_u1 is VTESTOP, then:
  a. Let (VTESTOP shape vtestop) be instr_u1.
  b. Return $free_shape(shape).
37. If instr_u1 is VRELOP, then:
  a. Let (VRELOP shape vrelop) be instr_u1.
  b. Return $free_shape(shape).
38. If instr_u1 is VSHIFTOP, then:
  a. Let (VSHIFTOP ishape vshiftop) be instr_u1.
  b. Return $free_shape(ishape).
39. If instr_u1 is VBITMASK, then:
  a. Let (VBITMASK ishape) be instr_u1.
  b. Return $free_shape(ishape).
40. If instr_u1 is VSWIZZLOP, then:
  a. Let (VSWIZZLOP bshape vswizzlop) be instr_u1.
  b. Return $free_shape(bshape).
41. If instr_u1 is VSHUFFLE, then:
  a. Let (VSHUFFLE bshape laneidx*) be instr_u1.
  b. Return $free_shape(bshape).
42. If instr_u1 is VEXTUNOP, then:
  a. Let (VEXTUNOP ishape_1 ishape_2 vextunop) be instr_u1.
  b. Return $free_shape(ishape_1) ++ $free_shape(ishape_2).
43. If instr_u1 is VEXTBINOP, then:
  a. Let (VEXTBINOP ishape_1 ishape_2 vextbinop) be instr_u1.
  b. Return $free_shape(ishape_1) ++ $free_shape(ishape_2).
44. If instr_u1 is VNARROW, then:
  a. Let (VNARROW ishape_1 ishape_2 sx) be instr_u1.
  b. Return $free_shape(ishape_1) ++ $free_shape(ishape_2).
45. If instr_u1 is VCVTOP, then:
  a. Let (VCVTOP shape_1 shape_2 vcvtop half? zero?) be instr_u1.
  b. Return $free_shape(shape_1) ++ $free_shape(shape_2).
46. If instr_u1 is VSPLAT, then:
  a. Let (VSPLAT shape) be instr_u1.
  b. Return $free_shape(shape).
47. If instr_u1 is VEXTRACT_LANE, then:
  a. Let (VEXTRACT_LANE shape sx? laneidx) be instr_u1.
  b. Return $free_shape(shape).
48. If instr_u1 is VREPLACE_LANE, then:
  a. Let (VREPLACE_LANE shape laneidx) be instr_u1.
  b. Return $free_shape(shape).
49. If instr_u1 is REF.NULL, then:
  a. Let (REF.NULL heaptype) be instr_u1.
  b. Return $free_heaptype(heaptype).
50. If (instr_u1 = REF.IS_NULL), then:
  a. Return {}.
51. If (instr_u1 = REF.AS_NON_NULL), then:
  a. Return {}.
52. If (instr_u1 = REF.EQ), then:
  a. Return {}.
53. If instr_u1 is REF.TEST, then:
  a. Let (REF.TEST reftype) be instr_u1.
  b. Return $free_reftype(reftype).
54. If instr_u1 is REF.CAST, then:
  a. Let (REF.CAST reftype) be instr_u1.
  b. Return $free_reftype(reftype).
55. If instr_u1 is REF.FUNC, then:
  a. Let (REF.FUNC funcidx) be instr_u1.
  b. Return $free_funcidx(funcidx).
56. If (instr_u1 = REF.I31), then:
  a. Return {}.
57. If instr_u1 is I31.GET, then:
  a. Return {}.
58. If instr_u1 is STRUCT.NEW, then:
  a. Return {}.
59. If instr_u1 is STRUCT.NEW_DEFAULT, then:
  a. Let (STRUCT.NEW_DEFAULT typeidx) be instr_u1.
  b. Return $free_typeidx(typeidx).
60. If instr_u1 is STRUCT.GET, then:
  a. Let (STRUCT.GET sx? typeidx u32) be instr_u1.
  b. Return $free_typeidx(typeidx).
61. If instr_u1 is STRUCT.SET, then:
  a. Let (STRUCT.SET typeidx u32) be instr_u1.
  b. Return $free_typeidx(typeidx).
62. If instr_u1 is ARRAY.NEW, then:
  a. Let (ARRAY.NEW typeidx) be instr_u1.
  b. Return $free_typeidx(typeidx).
63. If instr_u1 is ARRAY.NEW_DEFAULT, then:
  a. Let (ARRAY.NEW_DEFAULT typeidx) be instr_u1.
  b. Return $free_typeidx(typeidx).
64. If instr_u1 is ARRAY.NEW_FIXED, then:
  a. Let (ARRAY.NEW_FIXED typeidx u32) be instr_u1.
  b. Return $free_typeidx(typeidx).
65. If instr_u1 is ARRAY.NEW_DATA, then:
  a. Let (ARRAY.NEW_DATA typeidx dataidx) be instr_u1.
  b. Return $free_typeidx(typeidx) ++ $free_dataidx(dataidx).
66. If instr_u1 is ARRAY.NEW_ELEM, then:
  a. Let (ARRAY.NEW_ELEM typeidx elemidx) be instr_u1.
  b. Return $free_typeidx(typeidx) ++ $free_elemidx(elemidx).
67. If instr_u1 is ARRAY.GET, then:
  a. Let (ARRAY.GET sx? typeidx) be instr_u1.
  b. Return $free_typeidx(typeidx).
68. If instr_u1 is ARRAY.SET, then:
  a. Let (ARRAY.SET typeidx) be instr_u1.
  b. Return $free_typeidx(typeidx).
69. If (instr_u1 = ARRAY.LEN), then:
  a. Return {}.
70. If instr_u1 is ARRAY.FILL, then:
  a. Let (ARRAY.FILL typeidx) be instr_u1.
  b. Return $free_typeidx(typeidx).
71. If instr_u1 is ARRAY.COPY, then:
  a. Let (ARRAY.COPY typeidx_1 typeidx_2) be instr_u1.
  b. Return $free_typeidx(typeidx_1) ++ $free_typeidx(typeidx_2).
72. If instr_u1 is ARRAY.INIT_DATA, then:
  a. Let (ARRAY.INIT_DATA typeidx dataidx) be instr_u1.
  b. Return $free_typeidx(typeidx) ++ $free_dataidx(dataidx).
73. If instr_u1 is ARRAY.INIT_ELEM, then:
  a. Let (ARRAY.INIT_ELEM typeidx elemidx) be instr_u1.
  b. Return $free_typeidx(typeidx) ++ $free_elemidx(elemidx).
74. If (instr_u1 = EXTERN.CONVERT_ANY), then:
  a. Return {}.
75. If (instr_u1 = ANY.CONVERT_EXTERN), then:
  a. Return {}.
76. If instr_u1 is LOCAL.GET, then:
  a. Let (LOCAL.GET localidx) be instr_u1.
  b. Return $free_localidx(localidx).
77. If instr_u1 is LOCAL.SET, then:
  a. Let (LOCAL.SET localidx) be instr_u1.
  b. Return $free_localidx(localidx).
78. If instr_u1 is LOCAL.TEE, then:
  a. Let (LOCAL.TEE localidx) be instr_u1.
  b. Return $free_localidx(localidx).
79. If instr_u1 is GLOBAL.GET, then:
  a. Let (GLOBAL.GET globalidx) be instr_u1.
  b. Return $free_globalidx(globalidx).
80. If instr_u1 is GLOBAL.SET, then:
  a. Let (GLOBAL.SET globalidx) be instr_u1.
  b. Return $free_globalidx(globalidx).
81. If instr_u1 is TABLE.GET, then:
  a. Let (TABLE.GET tableidx) be instr_u1.
  b. Return $free_tableidx(tableidx).
82. If instr_u1 is TABLE.SET, then:
  a. Let (TABLE.SET tableidx) be instr_u1.
  b. Return $free_tableidx(tableidx).
83. If instr_u1 is TABLE.SIZE, then:
  a. Let (TABLE.SIZE tableidx) be instr_u1.
  b. Return $free_tableidx(tableidx).
84. If instr_u1 is TABLE.GROW, then:
  a. Let (TABLE.GROW tableidx) be instr_u1.
  b. Return $free_tableidx(tableidx).
85. If instr_u1 is TABLE.FILL, then:
  a. Let (TABLE.FILL tableidx) be instr_u1.
  b. Return $free_tableidx(tableidx).
86. If instr_u1 is TABLE.COPY, then:
  a. Let (TABLE.COPY tableidx_1 tableidx_2) be instr_u1.
  b. Return $free_tableidx(tableidx_1) ++ $free_tableidx(tableidx_2).
87. If instr_u1 is TABLE.INIT, then:
  a. Let (TABLE.INIT tableidx elemidx) be instr_u1.
  b. Return $free_tableidx(tableidx) ++ $free_elemidx(elemidx).
88. If instr_u1 is ELEM.DROP, then:
  a. Let (ELEM.DROP elemidx) be instr_u1.
  b. Return $free_elemidx(elemidx).
89. If instr_u1 is LOAD, then:
  a. Let (LOAD numtype loadop? memidx memarg) be instr_u1.
  b. Return $free_numtype(numtype) ++ $free_memidx(memidx).
90. If instr_u1 is STORE, then:
  a. Let (STORE numtype storeop? memidx memarg) be instr_u1.
  b. Return $free_numtype(numtype) ++ $free_memidx(memidx).
91. If instr_u1 is VLOAD, then:
  a. Let (VLOAD vectype vloadop? memidx memarg) be instr_u1.
  b. Return $free_vectype(vectype) ++ $free_memidx(memidx).
92. If instr_u1 is VLOAD_LANE, then:
  a. Let (VLOAD_LANE vectype sz memidx memarg laneidx) be instr_u1.
  b. Return $free_vectype(vectype) ++ $free_memidx(memidx).
93. If instr_u1 is VSTORE, then:
  a. Let (VSTORE vectype memidx memarg) be instr_u1.
  b. Return $free_vectype(vectype) ++ $free_memidx(memidx).
94. If instr_u1 is VSTORE_LANE, then:
  a. Let (VSTORE_LANE vectype sz memidx memarg laneidx) be instr_u1.
  b. Return $free_vectype(vectype) ++ $free_memidx(memidx).
95. If instr_u1 is MEMORY.SIZE, then:
  a. Let (MEMORY.SIZE memidx) be instr_u1.
  b. Return $free_memidx(memidx).
96. If instr_u1 is MEMORY.GROW, then:
  a. Let (MEMORY.GROW memidx) be instr_u1.
  b. Return $free_memidx(memidx).
97. If instr_u1 is MEMORY.FILL, then:
  a. Let (MEMORY.FILL memidx) be instr_u1.
  b. Return $free_memidx(memidx).
98. If instr_u1 is MEMORY.COPY, then:
  a. Let (MEMORY.COPY memidx_1 memidx_2) be instr_u1.
  b. Return $free_memidx(memidx_1) ++ $free_memidx(memidx_2).
99. If instr_u1 is MEMORY.INIT, then:
  a. Let (MEMORY.INIT memidx dataidx) be instr_u1.
  b. Return $free_memidx(memidx) ++ $free_dataidx(dataidx).
100. Assert: Due to validation, instr_u1 is DATA.DROP.
101. Let (DATA.DROP dataidx) be instr_u1.
102. Return $free_dataidx(dataidx).

free_block instr*
1. Let free be $free_list($free_instr(instr)*).
2. Return free with .LABELS replaced by $shift_labelidxs(free.LABELS).

free_expr instr*
1. Return $free_list($free_instr(instr)*).

free_type (TYPE rectype)
1. Return $free_rectype(rectype).

free_local (LOCAL t)
1. Return $free_valtype(t).

free_func (FUNC typeidx local* expr)
1. Return $free_typeidx(typeidx) ++ $free_list($free_local(local)*) ++ $free_block(expr) with .LOCALS replaced by [].

free_global (GLOBAL globaltype expr)
1. Return $free_globaltype(globaltype) ++ $free_expr(expr).

free_table (TABLE tabletype expr)
1. Return $free_tabletype(tabletype) ++ $free_expr(expr).

free_mem (MEMORY memtype)
1. Return $free_memtype(memtype).

free_tag (TAG typeidx)
1. Return $free_typeidx(typeidx).

free_elemmode elemmode_u1
1. If elemmode_u1 is ACTIVE, then:
  a. Let (ACTIVE tableidx expr) be elemmode_u1.
  b. Return $free_tableidx(tableidx) ++ $free_expr(expr).
2. If (elemmode_u1 = PASSIVE), then:
  a. Return {}.
3. Assert: Due to validation, (elemmode_u1 = DECLARE).
4. Return {}.

free_elem (ELEM reftype expr* elemmode)
1. Return $free_reftype(reftype) ++ $free_list($free_expr(expr)*) ++ $free_elemmode(elemmode).

free_datamode datamode_u1
1. If datamode_u1 is ACTIVE, then:
  a. Let (ACTIVE memidx expr) be datamode_u1.
  b. Return $free_memidx(memidx) ++ $free_expr(expr).
2. Assert: Due to validation, (datamode_u1 = PASSIVE).
3. Return {}.

free_data (DATA byte* datamode)
1. Return $free_datamode(datamode).

free_start (START funcidx)
1. Return $free_funcidx(funcidx).

free_export (EXPORT name externidx)
1. Return $free_externidx(externidx).

free_import (IMPORT name_1 name_2 externtype)
1. Return $free_externtype(externtype).

free_module (MODULE type* import* func* global* table* mem* tag* elem* data* start? export*)
1. Return $free_list($free_type(type)*) ++ $free_list($free_import(import)*) ++ $free_list($free_func(func)*) ++ $free_list($free_global(global)*) ++ $free_list($free_table(table)*) ++ $free_list($free_mem(mem)*) ++ $free_list($free_tag(tag)*) ++ $free_list($free_elem(elem)*) ++ $free_list($free_data(data)*) ++ $free_opt($free_start(start)?) ++ $free_list($free_export(export)*).

funcidx_module module
1. Return $free_module(module).FUNCS.

dataidx_funcs func*
1. Return $free_list($free_func(func)*).DATAS.

with_locals C localidx_u1* lct_u1*
1. If ((localidx_u1* = []) /\ (lct_u1* = [])), then:
  a. Return C.
2. Assert: Due to validation, (|lct_u1*| >= 1).
3. Let [lct_1] :: lct* be lct_u1*.
4. Assert: Due to validation, (|localidx_u1*| >= 1).
5. Let [x_1] :: x* be localidx_u1*.
6. Return $with_locals(C with .LOCALS[x_1] replaced by lct_1, x*, lct*).

clos_deftypes dt_u1*
1. If (dt_u1* = []), then:
  a. Return [].
2. Let dt* :: [dt_n] be dt_u1*.
3. Let dt'* be $clos_deftypes(dt*).
4. Return dt'* :: [$subst_all_deftype(dt_n, dt'*)].

clos_valtype C t
1. Let dt* be $clos_deftypes(C.TYPES).
2. Return $subst_all_valtype(t, dt*).

clos_deftype C dt
1. Let dt'* be $clos_deftypes(C.TYPES).
2. Return $subst_all_deftype(dt, dt'*).

clos_moduletype C mmt
1. Let dt* be $clos_deftypes(C.TYPES).
2. Return $subst_all_moduletype(mmt, dt*).

before yy_u1 x i
1. If yy_u1 is deftype, then:
  a. Return true.
2. If yy_u1 is _IDX, then:
  a. Let (_IDX typeidx) be yy_u1.
  b. Return (typeidx < x).
3. Assert: Due to validation, yy_u1 is REC.
4. Let (REC j) be yy_u1.
5. Return (j < i).

unrollht C ht_u1
1. If ht_u1 is deftype, then:
  a. Let deftype be ht_u1.
  b. Return $unrolldt(deftype).
2. If ht_u1 is _IDX, then:
  a. Let (_IDX typeidx) be ht_u1.
  b. Return $unrolldt(C.TYPES[typeidx]).
3. Assert: Due to validation, ht_u1 is REC.
4. Let (REC i) be ht_u1.
5. Return C.RECS[i].

default_ t_u1
1. If t_u1 is Inn, then:
  a. Let Inn be t_u1.
  b. Return ?((Inn.CONST 0)).
2. If t_u1 is Fnn, then:
  a. Let Fnn be t_u1.
  b. Return ?((Fnn.CONST $fzero($size(Fnn)))).
3. If t_u1 is Vnn, then:
  a. Let Vnn be t_u1.
  b. Return ?((Vnn.CONST 0)).
4. Assert: Due to validation, t_u1 is REF.
5. Let (REF NULL_opt_0 ht) be t_u1.
6. If (NULL_opt_0 = ?(NULL)), then:
  a. Return ?((REF.NULL ht)).
7. Assert: Due to validation, NULL_opt_0 is not defined.
8. Return ?().

funcidx_nonfuncs (global* table* mem* elem* data*)
1. Return $funcidx_module((MODULE [] [] [] global* table* mem* [] elem* data* ?() [])).

relaxed2 i X X_1 X_2
1. If $ND(), then:
  a. Return [X_1, X_2][i].
2. Return [X_1, X_2][0].

relaxed4 i X X_1 X_2 X_3 X_4
1. If $ND(), then:
  a. Return [X_1, X_2, X_3, X_4][i].
2. Return [X_1, X_2, X_3, X_4][0].

invibytes_ N b*
1. Let n be $ibytes__1^-1(N, b*).
2. Return n.

invfbytes_ N b*
1. Let p be $fbytes__1^-1(N, b*).
2. Return p.

signed_ N i
1. If (i < (2 ^ (N - 1))), then:
  a. Return i.
2. Assert: Due to validation, ((2 ^ (N - 1)) <= i).
3. Assert: Due to validation, (i < (2 ^ N)).
4. Return (i - (2 ^ N)).

invsigned_ N i
1. Let j be $signed__1^-1(N, i).
2. Return j.

sx zt_u1
1. If zt_u1 is consttype, then:
  a. Return ?().
2. Assert: Due to validation, zt_u1 is packtype.
3. Return ?(S).

zero lt_u1
1. If lt_u1 is Jnn, then:
  a. Return 0.
2. Assert: Due to validation, lt_u1 is Fnn.
3. Let Fnn be lt_u1.
4. Return $fzero($size(Fnn)).

bool b_u1
1. If (b_u1 = false), then:
  a. Return 0.
2. Assert: Due to validation, (b_u1 = true).
3. Return 1.

sat_u_ N i
1. If (i < 0), then:
  a. Return 0.
2. If (i > ((2 ^ N) - 1)), then:
  a. Return ((2 ^ N) - 1).
3. Return i.

sat_s_ N i
1. If (i < (- (2 ^ (N - 1)))), then:
  a. Return (- (2 ^ (N - 1))).
2. If (i > ((2 ^ (N - 1)) - 1)), then:
  a. Return ((2 ^ (N - 1)) - 1).
3. Return i.

ineg_ N i_1
1. Return $invsigned_(N, (- $signed_(N, i_1))).

iabs_ N i_1
1. If ($signed_(N, i_1) >= 0), then:
  a. Return i_1.
2. Return $ineg_(N, i_1).

iextend_ N M sx_u1 i
1. If (sx_u1 = U), then:
  a. Return (i \ (2 ^ M)).
2. Assert: Due to validation, (sx_u1 = S).
3. Return $invsigned_(N, $signed_(M, (i \ (2 ^ M)))).

iadd_ N i_1 i_2
1. Return ((i_1 + i_2) \ (2 ^ N)).

isub_ N i_1 i_2
1. Return ((((2 ^ N) + i_1) - i_2) \ (2 ^ N)).

imul_ N i_1 i_2
1. Return ((i_1 * i_2) \ (2 ^ N)).

iadd_sat_ N sx_u1 i_1 i_2
1. If (sx_u1 = U), then:
  a. Return $sat_u_(N, (i_1 + i_2)).
2. Assert: Due to validation, (sx_u1 = S).
3. Return $invsigned_(N, $sat_s_(N, ($signed_(N, i_1) + $signed_(N, i_2)))).

isub_sat_ N sx_u1 i_1 i_2
1. If (sx_u1 = U), then:
  a. Return $sat_u_(N, (i_1 - i_2)).
2. Assert: Due to validation, (sx_u1 = S).
3. Return $invsigned_(N, $sat_s_(N, ($signed_(N, i_1) - $signed_(N, i_2)))).

ieqz_ N i_1
1. Return $bool((i_1 = 0)).

inez_ N i_1
1. Return $bool((i_1 =/= 0)).

ieq_ N i_1 i_2
1. Return $bool((i_1 = i_2)).

ine_ N i_1 i_2
1. Return $bool((i_1 =/= i_2)).

ilt_ N sx_u1 i_1 i_2
1. If (sx_u1 = U), then:
  a. Return $bool((i_1 < i_2)).
2. Assert: Due to validation, (sx_u1 = S).
3. Return $bool(($signed_(N, i_1) < $signed_(N, i_2))).

igt_ N sx_u1 i_1 i_2
1. If (sx_u1 = U), then:
  a. Return $bool((i_1 > i_2)).
2. Assert: Due to validation, (sx_u1 = S).
3. Return $bool(($signed_(N, i_1) > $signed_(N, i_2))).

ile_ N sx_u1 i_1 i_2
1. If (sx_u1 = U), then:
  a. Return $bool((i_1 <= i_2)).
2. Assert: Due to validation, (sx_u1 = S).
3. Return $bool(($signed_(N, i_1) <= $signed_(N, i_2))).

ige_ N sx_u1 i_1 i_2
1. If (sx_u1 = U), then:
  a. Return $bool((i_1 >= i_2)).
2. Assert: Due to validation, (sx_u1 = S).
3. Return $bool(($signed_(N, i_1) >= $signed_(N, i_2))).

lpacknum_ lt_u1 c
1. If lt_u1 is numtype, then:
  a. Return c.
2. Assert: Due to validation, lt_u1 is packtype.
3. Let packtype be lt_u1.
4. Return $wrap__($size($lunpack(packtype)), $psize(packtype), c).

lunpacknum_ lt_u1 c
1. If lt_u1 is numtype, then:
  a. Return c.
2. Assert: Due to validation, lt_u1 is packtype.
3. Let packtype be lt_u1.
4. Return $extend__($psize(packtype), $size($lunpack(packtype)), U, c).

cpacknum_ zt_u1 c
1. If zt_u1 is consttype, then:
  a. Return c.
2. Assert: Due to validation, zt_u1 is packtype.
3. Let packtype be zt_u1.
4. Return $wrap__($size($lunpack(packtype)), $psize(packtype), c).

cunpacknum_ zt_u1 c
1. If zt_u1 is consttype, then:
  a. Return c.
2. Assert: Due to validation, zt_u1 is packtype.
3. Let packtype be zt_u1.
4. Return $extend__($psize(packtype), $size($lunpack(packtype)), U, c).

unop_ nt_u1 unop_u1 i_u1
1. If nt_u1 is Inn, then:
  a. Let Inn be nt_u1.
  b. Let i be i_u1.
  c. If (unop_u1 = CLZ), then:
    1) Return [$iclz_($sizenn(Inn), i)].
  d. If (unop_u1 = CTZ), then:
    1) Return [$ictz_($sizenn(Inn), i)].
  e. If (unop_u1 = POPCNT), then:
    1) Return [$ipopcnt_($sizenn(Inn), i)].
  f. Assert: Due to validation, unop_u1 is EXTEND.
  g. Let (EXTEND M) be unop_u1.
  h. Return [$iextend_($sizenn(Inn), M, S, i)].
2. Assert: Due to validation, nt_u1 is Fnn.
3. Let Fnn be nt_u1.
4. Let f be i_u1.
5. If (unop_u1 = ABS), then:
  a. Return $fabs_($sizenn(Fnn), f).
6. If (unop_u1 = NEG), then:
  a. Return $fneg_($sizenn(Fnn), f).
7. If (unop_u1 = SQRT), then:
  a. Return $fsqrt_($sizenn(Fnn), f).
8. If (unop_u1 = CEIL), then:
  a. Return $fceil_($sizenn(Fnn), f).
9. If (unop_u1 = FLOOR), then:
  a. Return $ffloor_($sizenn(Fnn), f).
10. If (unop_u1 = TRUNC), then:
  a. Return $ftrunc_($sizenn(Fnn), f).
11. Assert: Due to validation, (unop_u1 = NEAREST).
12. Return $fnearest_($sizenn(Fnn), f).

binop_ nt_u1 binop_u1 i_u1 i_u2
1. If nt_u1 is Inn, then:
  a. Let Inn be nt_u1.
  b. Let i_1 be i_u1.
  c. Let i_2 be i_u2.
  d. If (binop_u1 = ADD), then:
    1) Return [$iadd_($sizenn(Inn), i_1, i_2)].
  e. If (binop_u1 = SUB), then:
    1) Return [$isub_($sizenn(Inn), i_1, i_2)].
  f. If (binop_u1 = MUL), then:
    1) Return [$imul_($sizenn(Inn), i_1, i_2)].
  g. If binop_u1 is DIV, then:
    1) Let (DIV sx) be binop_u1.
    2) Return $idiv_($sizenn(Inn), sx, i_1, i_2).
  h. If binop_u1 is REM, then:
    1) Let (REM sx) be binop_u1.
    2) Return $irem_($sizenn(Inn), sx, i_1, i_2).
  i. If (binop_u1 = AND), then:
    1) Return [$iand_($sizenn(Inn), i_1, i_2)].
  j. If (binop_u1 = OR), then:
    1) Return [$ior_($sizenn(Inn), i_1, i_2)].
  k. If (binop_u1 = XOR), then:
    1) Return [$ixor_($sizenn(Inn), i_1, i_2)].
  l. If (binop_u1 = SHL), then:
    1) Return [$ishl_($sizenn(Inn), i_1, i_2)].
  m. If binop_u1 is SHR, then:
    1) Let (SHR sx) be binop_u1.
    2) Return [$ishr_($sizenn(Inn), sx, i_1, i_2)].
  n. If (binop_u1 = ROTL), then:
    1) Return [$irotl_($sizenn(Inn), i_1, i_2)].
  o. If (binop_u1 = ROTR), then:
    1) Return [$irotr_($sizenn(Inn), i_1, i_2)].
2. Assert: Due to validation, nt_u1 is Fnn.
3. Let Fnn be nt_u1.
4. Let f_1 be i_u1.
5. Let f_2 be i_u2.
6. If (binop_u1 = ADD), then:
  a. Return $fadd_($sizenn(Fnn), f_1, f_2).
7. If (binop_u1 = SUB), then:
  a. Return $fsub_($sizenn(Fnn), f_1, f_2).
8. If (binop_u1 = MUL), then:
  a. Return $fmul_($sizenn(Fnn), f_1, f_2).
9. If (binop_u1 = DIV), then:
  a. Return $fdiv_($sizenn(Fnn), f_1, f_2).
10. If (binop_u1 = MIN), then:
  a. Return $fmin_($sizenn(Fnn), f_1, f_2).
11. If (binop_u1 = MAX), then:
  a. Return $fmax_($sizenn(Fnn), f_1, f_2).
12. Assert: Due to validation, (binop_u1 = COPYSIGN).
13. Return $fcopysign_($sizenn(Fnn), f_1, f_2).

testop_ Inn EQZ i
1. Return $ieqz_($sizenn(Inn), i).

relop_ nt_u1 relop_u1 i_u1 i_u2
1. If nt_u1 is Inn, then:
  a. Let Inn be nt_u1.
  b. Let i_1 be i_u1.
  c. Let i_2 be i_u2.
  d. If (relop_u1 = EQ), then:
    1) Return $ieq_($sizenn(Inn), i_1, i_2).
  e. If (relop_u1 = NE), then:
    1) Return $ine_($sizenn(Inn), i_1, i_2).
  f. If relop_u1 is LT, then:
    1) Let (LT sx) be relop_u1.
    2) Return $ilt_($sizenn(Inn), sx, i_1, i_2).
  g. If relop_u1 is GT, then:
    1) Let (GT sx) be relop_u1.
    2) Return $igt_($sizenn(Inn), sx, i_1, i_2).
  h. If relop_u1 is LE, then:
    1) Let (LE sx) be relop_u1.
    2) Return $ile_($sizenn(Inn), sx, i_1, i_2).
  i. If relop_u1 is GE, then:
    1) Let (GE sx) be relop_u1.
    2) Return $ige_($sizenn(Inn), sx, i_1, i_2).
2. Assert: Due to validation, nt_u1 is Fnn.
3. Let Fnn be nt_u1.
4. Let f_1 be i_u1.
5. Let f_2 be i_u2.
6. If (relop_u1 = EQ), then:
  a. Return $feq_($sizenn(Fnn), f_1, f_2).
7. If (relop_u1 = NE), then:
  a. Return $fne_($sizenn(Fnn), f_1, f_2).
8. If (relop_u1 = LT), then:
  a. Return $flt_($sizenn(Fnn), f_1, f_2).
9. If (relop_u1 = GT), then:
  a. Return $fgt_($sizenn(Fnn), f_1, f_2).
10. If (relop_u1 = LE), then:
  a. Return $fle_($sizenn(Fnn), f_1, f_2).
11. Assert: Due to validation, (relop_u1 = GE).
12. Return $fge_($sizenn(Fnn), f_1, f_2).

cvtop__ nt_u1 nt_u3 cvtop_u1 i_u1
1. If nt_u1 is Inn, then:
  a. Let Inn_1 be nt_u1.
  b. If nt_u3 is Inn, then:
    1) Let Inn_2 be nt_u3.
    2) If cvtop_u1 is EXTEND, then:
      a) Let (EXTEND sx) be cvtop_u1.
      b) Let i_1 be i_u1.
      c) Return [$extend__($sizenn1(Inn_1), $sizenn2(Inn_2), sx, i_1)].
    3) Let i_1 be i_u1.
    4) If (cvtop_u1 = WRAP), then:
      a) Return [$wrap__($sizenn1(Inn_1), $sizenn2(Inn_2), i_1)].
2. If nt_u1 is Fnn, then:
  a. Let Fnn_1 be nt_u1.
  b. If nt_u3 is Inn, then:
    1) Let Inn_2 be nt_u3.
    2) If cvtop_u1 is TRUNC, then:
      a) Let (TRUNC sx) be cvtop_u1.
      b) Let f_1 be i_u1.
      c) Return $trunc__($sizenn1(Fnn_1), $sizenn2(Inn_2), sx, f_1).
    3) If cvtop_u1 is TRUNC_SAT, then:
      a) Let (TRUNC_SAT sx) be cvtop_u1.
      b) Let f_1 be i_u1.
      c) Return $trunc_sat__($sizenn1(Fnn_1), $sizenn2(Inn_2), sx, f_1).
3. If nt_u1 is Inn, then:
  a. Let Inn_1 be nt_u1.
  b. If nt_u3 is Fnn, then:
    1) Let Fnn_2 be nt_u3.
    2) If cvtop_u1 is CONVERT, then:
      a) Let (CONVERT sx) be cvtop_u1.
      b) Let i_1 be i_u1.
      c) Return [$convert__($sizenn1(Inn_1), $sizenn2(Fnn_2), sx, i_1)].
4. If nt_u1 is Fnn, then:
  a. Let Fnn_1 be nt_u1.
  b. If nt_u3 is Fnn, then:
    1) Let Fnn_2 be nt_u3.
    2) Let f_1 be i_u1.
    3) If (cvtop_u1 = PROMOTE), then:
      a) Return $promote__($sizenn1(Fnn_1), $sizenn2(Fnn_2), f_1).
    4) If (cvtop_u1 = DEMOTE), then:
      a) Return $demote__($sizenn1(Fnn_1), $sizenn2(Fnn_2), f_1).
5. If nt_u1 is Inn, then:
  a. Let Inn_1 be nt_u1.
  b. If nt_u3 is Fnn, then:
    1) Let Fnn_2 be nt_u3.
    2) Let i_1 be i_u1.
    3) If ((cvtop_u1 = REINTERPRET) /\ ($size(Inn_1) = $size(Fnn_2))), then:
      a) Return [$reinterpret__(Inn_1, Fnn_2, i_1)].
6. Assert: Due to validation, nt_u1 is Fnn.
7. Let Fnn_1 be nt_u1.
8. Assert: Due to validation, nt_u3 is Inn.
9. Let Inn_2 be nt_u3.
10. Let f_1 be i_u1.
11. Assert: Due to validation, (cvtop_u1 = REINTERPRET).
12. Assert: Due to validation, ($size(Fnn_1) = $size(Inn_2)).
13. Return [$reinterpret__(Fnn_1, Inn_2, f_1)].

invlanes_ sh c*
1. Let vc be $lanes__1^-1(sh, c*).
2. Return vc.

half__ lt_u1 X M_1 lt_u2 X M_2 half_u1 i j
1. If (lt_u1 is Jnn /\ lt_u2 is Jnn), then:
  a. If (half_u1 = LOW), then:
    1) Return i.
  b. If (half_u1 = HIGH), then:
    1) Return j.
2. Assert: Due to validation, lt_u2 is Fnn.
3. Assert: Due to validation, (half_u1 = LOW).
4. Return i.

iswizzle_lane_ N c* i
1. If (i < |c*|), then:
  a. Return c*[i].
2. Return 0.

irelaxed_swizzle_lane_ N c* i
1. If (i < |c*|), then:
  a. Return c*[i].
2. If ($signed_(N, i) < 0), then:
  a. Return 0.
3. Return $relaxed2($R_swizzle(), iN(N), 0, c*[(i \ |c*|)]).

ivunop_ Jnn X M $f_ v_1
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c* be $f_($lsizenn(Jnn), c_1)*.
3. Return [$invlanes_(Jnn X M, c*)].

fvunop_ Fnn X M $f_ v_1
1. Let c_1* be $lanes_(Fnn X M, v_1).
2. Let c** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $f_($sizenn(Fnn), c_1)*).
3. Return $invlanes_(Fnn X M, c*)*.

ivbinop_ Jnn X M $f_ v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be $f_($lsizenn(Jnn), c_1, c_2)*.
4. Return [$invlanes_(Jnn X M, c*)].

ivbinopsx_ Jnn X M $f_ sx v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be $f_($lsizenn(Jnn), sx, c_1, c_2)*.
4. Return [$invlanes_(Jnn X M, c*)].

ivbinopsxnd_ Jnn X M $f_ sx v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c** be $setproduct_(lane_((Jnn : Jnn <: lanetype)), $f_($lsizenn(Jnn), sx, c_1, c_2)*).
4. Return $invlanes_(Jnn X M, c*)*.

fvbinop_ Fnn X M $f_ v_1 v_2
1. Let c_1* be $lanes_(Fnn X M, v_1).
2. Let c_2* be $lanes_(Fnn X M, v_2).
3. Let c** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $f_($sizenn(Fnn), c_1, c_2)*).
4. Return $invlanes_(Fnn X M, c*)*.

ivternopnd_ Jnn X M $f_ v_1 v_2 v_3
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c_3* be $lanes_(Jnn X M, v_3).
4. Let c** be $setproduct_(lane_((Jnn : Jnn <: lanetype)), $f_($lsizenn(Jnn), c_1, c_2, c_3)*).
5. Return $invlanes_(Jnn X M, c*)*.

fvternop_ Fnn X M $f_ v_1 v_2 v_3
1. Let c_1* be $lanes_(Fnn X M, v_1).
2. Let c_2* be $lanes_(Fnn X M, v_2).
3. Let c_3* be $lanes_(Fnn X M, v_3).
4. Let c** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $f_($sizenn(Fnn), c_1, c_2, c_3)*).
5. Return $invlanes_(Fnn X M, c*)*.

ivtestop_ Jnn X M $f_ v_1
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c* be $f_($lsizenn(Jnn), c_1)*.
3. Return $prod(c*).

fvtestop_ Fnn X M $f_ v_1
1. Let c_1* be $lanes_(Fnn X M, v_1).
2. Let c* be $f_($sizenn(Fnn), c_1)*.
3. Return $prod(c*).

ivrelop_ Jnn X M $f_ v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be $extend__(1, $lsizenn(Jnn), S, $f_($lsizenn(Jnn), c_1, c_2))*.
4. Return $invlanes_(Jnn X M, c*).

ivrelopsx_ Jnn X M $f_ sx v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be $extend__(1, $lsizenn(Jnn), S, $f_($lsizenn(Jnn), sx, c_1, c_2))*.
4. Return $invlanes_(Jnn X M, c*).

fvrelop_ Fnn X M $f_ v_1 v_2
1. Let c_1* be $lanes_(Fnn X M, v_1).
2. Let c_2* be $lanes_(Fnn X M, v_2).
3. Assert: Due to validation, $size^-1($size(Fnn)) is Inn.
4. Let Inn be $size^-1($size(Fnn)).
5. Let c* be $extend__(1, $sizenn(Fnn), S, $f_($sizenn(Fnn), c_1, c_2))*.
6. Return $invlanes_(Inn X M, c*).

ivshiftop_ Jnn X M $f_ v_1 i
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c* be $f_($lsizenn(Jnn), c_1, i)*.
3. Return $invlanes_(Jnn X M, c*).

ivshiftopsx_ Jnn X M $f_ sx v_1 i
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c* be $f_($lsizenn(Jnn), sx, c_1, i)*.
3. Return $invlanes_(Jnn X M, c*).

ivbitmaskop_ Jnn X M v_1
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c be $ibits__1^-1(32, $ilt_($lsizenn(Jnn), S, c_1, 0)* :: 0^(32 - M)).
3. Return $irev_(32, c).

ivswizzlop_ Jnn X M $f_ v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be $f_($lsizenn(Jnn), c_1*, c_2)*.
4. Return $invlanes_(Jnn X M, c*).

ivshufflop_ Jnn X M i* v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be c_1* :: c_2*[i]*.
4. Return $invlanes_(Jnn X M, c*).

vvunop_ Vnn NOT v
1. Return [$inot_($vsizenn(Vnn), v)].

vvbinop_ Vnn vvbinop_u1 v_1 v_2
1. If (vvbinop_u1 = AND), then:
  a. Return [$iand_($vsizenn(Vnn), v_1, v_2)].
2. If (vvbinop_u1 = ANDNOT), then:
  a. Return [$iandnot_($vsizenn(Vnn), v_1, v_2)].
3. If (vvbinop_u1 = OR), then:
  a. Return [$ior_($vsizenn(Vnn), v_1, v_2)].
4. Assert: Due to validation, (vvbinop_u1 = XOR).
5. Return [$ixor_($vsizenn(Vnn), v_1, v_2)].

vvternop_ Vnn BITSELECT v_1 v_2 v_3
1. Return [$ibitselect_($vsizenn(Vnn), v_1, v_2, v_3)].

vunop_ lt_u1 X M vunop_u1 v
1. If lt_u1 is Fnn, then:
  a. Let Fnn be lt_u1.
  b. If (vunop_u1 = ABS), then:
    1) Return $fvunop_(Fnn X M, $fabs_, v).
  c. If (vunop_u1 = NEG), then:
    1) Return $fvunop_(Fnn X M, $fneg_, v).
  d. If (vunop_u1 = SQRT), then:
    1) Return $fvunop_(Fnn X M, $fsqrt_, v).
  e. If (vunop_u1 = CEIL), then:
    1) Return $fvunop_(Fnn X M, $fceil_, v).
  f. If (vunop_u1 = FLOOR), then:
    1) Return $fvunop_(Fnn X M, $ffloor_, v).
  g. If (vunop_u1 = TRUNC), then:
    1) Return $fvunop_(Fnn X M, $ftrunc_, v).
  h. If (vunop_u1 = NEAREST), then:
    1) Return $fvunop_(Fnn X M, $fnearest_, v).
2. Assert: Due to validation, lt_u1 is Jnn.
3. Let Jnn be lt_u1.
4. If (vunop_u1 = ABS), then:
  a. Return $ivunop_(Jnn X M, $iabs_, v).
5. If (vunop_u1 = NEG), then:
  a. Return $ivunop_(Jnn X M, $ineg_, v).
6. Assert: Due to validation, (vunop_u1 = POPCNT).
7. Return $ivunop_(Jnn X M, $ipopcnt_, v).

vbinop_ lt_u1 X M vbinop_u1 v_1 v_2
1. If lt_u1 is Jnn, then:
  a. Let Jnn be lt_u1.
  b. If (vbinop_u1 = ADD), then:
    1) Return $ivbinop_(Jnn X M, $iadd_, v_1, v_2).
  c. If (vbinop_u1 = SUB), then:
    1) Return $ivbinop_(Jnn X M, $isub_, v_1, v_2).
  d. If (vbinop_u1 = MUL), then:
    1) Return $ivbinop_(Jnn X M, $imul_, v_1, v_2).
  e. If vbinop_u1 is ADD_SAT, then:
    1) Let (ADD_SAT sx) be vbinop_u1.
    2) Return $ivbinopsx_(Jnn X M, $iadd_sat_, sx, v_1, v_2).
  f. If vbinop_u1 is SUB_SAT, then:
    1) Let (SUB_SAT sx) be vbinop_u1.
    2) Return $ivbinopsx_(Jnn X M, $isub_sat_, sx, v_1, v_2).
  g. If vbinop_u1 is MIN, then:
    1) Let (MIN sx) be vbinop_u1.
    2) Return $ivbinopsx_(Jnn X M, $imin_, sx, v_1, v_2).
  h. If vbinop_u1 is MAX, then:
    1) Let (MAX sx) be vbinop_u1.
    2) Return $ivbinopsx_(Jnn X M, $imax_, sx, v_1, v_2).
  i. If (vbinop_u1 = AVGRU), then:
    1) Return $ivbinopsx_(Jnn X M, $iavgr_, U, v_1, v_2).
  j. If (vbinop_u1 = Q15MULR_SATS), then:
    1) Return $ivbinopsx_(Jnn X M, $iq15mulr_sat_, S, v_1, v_2).
  k. If (vbinop_u1 = RELAXED_Q15MULRS), then:
    1) Return $ivbinopsxnd_(Jnn X M, $irelaxed_q15mulr_, S, v_1, v_2).
2. Assert: Due to validation, lt_u1 is Fnn.
3. Let Fnn be lt_u1.
4. If (vbinop_u1 = ADD), then:
  a. Return $fvbinop_(Fnn X M, $fadd_, v_1, v_2).
5. If (vbinop_u1 = SUB), then:
  a. Return $fvbinop_(Fnn X M, $fsub_, v_1, v_2).
6. If (vbinop_u1 = MUL), then:
  a. Return $fvbinop_(Fnn X M, $fmul_, v_1, v_2).
7. If (vbinop_u1 = DIV), then:
  a. Return $fvbinop_(Fnn X M, $fdiv_, v_1, v_2).
8. If (vbinop_u1 = MIN), then:
  a. Return $fvbinop_(Fnn X M, $fmin_, v_1, v_2).
9. If (vbinop_u1 = MAX), then:
  a. Return $fvbinop_(Fnn X M, $fmax_, v_1, v_2).
10. If (vbinop_u1 = PMIN), then:
  a. Return $fvbinop_(Fnn X M, $fpmin_, v_1, v_2).
11. If (vbinop_u1 = PMAX), then:
  a. Return $fvbinop_(Fnn X M, $fpmax_, v_1, v_2).
12. If (vbinop_u1 = RELAXED_MIN), then:
  a. Return $fvbinop_(Fnn X M, $frelaxed_min_, v_1, v_2).
13. Assert: Due to validation, (vbinop_u1 = RELAXED_MAX).
14. Return $fvbinop_(Fnn X M, $frelaxed_max_, v_1, v_2).

vternop_ lt_u1 X M vternop_u1 v_1 v_2 v_3
1. If lt_u1 is Jnn, then:
  a. Let Jnn be lt_u1.
  b. If (vternop_u1 = RELAXED_LANESELECT), then:
    1) Return $ivternopnd_(Jnn X M, $irelaxed_laneselect_, v_1, v_2, v_3).
2. Assert: Due to validation, lt_u1 is Fnn.
3. Let Fnn be lt_u1.
4. If (vternop_u1 = RELAXED_MADD), then:
  a. Return $fvternop_(Fnn X M, $frelaxed_madd_, v_1, v_2, v_3).
5. Assert: Due to validation, (vternop_u1 = RELAXED_NMADD).
6. Return $fvternop_(Fnn X M, $frelaxed_nmadd_, v_1, v_2, v_3).

vtestop_ Jnn X M ALL_TRUE v
1. Return $ivtestop_(Jnn X M, $inez_, v).

vrelop_ lt_u1 X M vrelop_u1 v_1 v_2
1. If lt_u1 is Jnn, then:
  a. Let Jnn be lt_u1.
  b. If (vrelop_u1 = EQ), then:
    1) Return $ivrelop_(Jnn X M, $ieq_, v_1, v_2).
  c. If (vrelop_u1 = NE), then:
    1) Return $ivrelop_(Jnn X M, $ine_, v_1, v_2).
  d. If vrelop_u1 is LT, then:
    1) Let (LT sx) be vrelop_u1.
    2) Return $ivrelopsx_(Jnn X M, $ilt_, sx, v_1, v_2).
  e. If vrelop_u1 is GT, then:
    1) Let (GT sx) be vrelop_u1.
    2) Return $ivrelopsx_(Jnn X M, $igt_, sx, v_1, v_2).
  f. If vrelop_u1 is LE, then:
    1) Let (LE sx) be vrelop_u1.
    2) Return $ivrelopsx_(Jnn X M, $ile_, sx, v_1, v_2).
  g. If vrelop_u1 is GE, then:
    1) Let (GE sx) be vrelop_u1.
    2) Return $ivrelopsx_(Jnn X M, $ige_, sx, v_1, v_2).
2. Assert: Due to validation, lt_u1 is Fnn.
3. Let Fnn be lt_u1.
4. If (vrelop_u1 = EQ), then:
  a. Return $fvrelop_(Fnn X M, $feq_, v_1, v_2).
5. If (vrelop_u1 = NE), then:
  a. Return $fvrelop_(Fnn X M, $fne_, v_1, v_2).
6. If (vrelop_u1 = LT), then:
  a. Return $fvrelop_(Fnn X M, $flt_, v_1, v_2).
7. If (vrelop_u1 = GT), then:
  a. Return $fvrelop_(Fnn X M, $fgt_, v_1, v_2).
8. If (vrelop_u1 = LE), then:
  a. Return $fvrelop_(Fnn X M, $fle_, v_1, v_2).
9. Assert: Due to validation, (vrelop_u1 = GE).
10. Return $fvrelop_(Fnn X M, $fge_, v_1, v_2).

lcvtop__ lt_u3 X M_1 lt_u1 X M_2 vcvtop_u1 c_1
1. If lt_u3 is Jnn, then:
  a. Let Jnn_1 be lt_u3.
  b. If lt_u1 is Jnn, then:
    1) Let Jnn_2 be lt_u1.
    2) If vcvtop_u1 is EXTEND, then:
      a) Let (EXTEND sx) be vcvtop_u1.
      b) Let c be $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), sx, c_1).
      c) Return [c].
  c. If lt_u1 is Fnn, then:
    1) Let Fnn_2 be lt_u1.
    2) If vcvtop_u1 is CONVERT, then:
      a) Let (CONVERT sx) be vcvtop_u1.
      b) Let c be $convert__($lsizenn1(Jnn_1), $lsizenn2(Fnn_2), sx, c_1).
      c) Return [c].
2. Assert: Due to validation, lt_u3 is Fnn.
3. Let Fnn_1 be lt_u3.
4. If lt_u1 is Inn, then:
  a. Let Inn_2 be lt_u1.
  b. If vcvtop_u1 is TRUNC_SAT, then:
    1) Let (TRUNC_SAT sx) be vcvtop_u1.
    2) Let c? be $trunc_sat__($lsizenn1(Fnn_1), $lsizenn2(Inn_2), sx, c_1).
    3) Return c?.
  c. If vcvtop_u1 is RELAXED_TRUNC, then:
    1) Let (RELAXED_TRUNC sx) be vcvtop_u1.
    2) Let c? be $relaxed_trunc__($lsizenn1(Fnn_1), $lsizenn2(Inn_2), sx, c_1).
    3) Return c?.
5. Assert: Due to validation, lt_u1 is Fnn.
6. Let Fnn_2 be lt_u1.
7. If (vcvtop_u1 = DEMOTE), then:
  a. Let c* be $demote__($lsizenn1(Fnn_1), $lsizenn2(Fnn_2), c_1).
  b. Return c*.
8. Assert: Due to validation, (vcvtop_u1 = PROMOTE).
9. Let c* be $promote__($lsizenn1(Fnn_1), $lsizenn2(Fnn_2), c_1).
10. Return c*.

vcvtop__ Lnn_1 X n_u1 Lnn_2 X n_u2 vcvtop half_u1? zero_u1? v_1
1. Let M be n_u2.
2. If (half_u1? is not defined /\ (zero_u1? is not defined /\ (n_u1 = M))), then:
  a. Let c_1* be $lanes_(Lnn_1 X M, v_1).
  b. Let c** be $setproduct_(lane_(Lnn_2), $lcvtop__(Lnn_1 X M, Lnn_2 X M, vcvtop, c_1)*).
  c. Let v be an element of $invlanes_(Lnn_2 X M, c*)*.
  d. Return v.
3. Let M_1 be n_u1.
4. Let M_2 be n_u2.
5. If (zero_u1? is not defined /\ half_u1? is defined), then:
  a. Let ?(half) be half_u1?.
  b. Let c_1* be $lanes_(Lnn_1 X M_1, v_1)[$half__(Lnn_1 X M_1, Lnn_2 X M_2, half, 0, M_2) : M_2].
  c. Let c** be $setproduct_(lane_(Lnn_2), $lcvtop__(Lnn_1 X M_1, Lnn_2 X M_2, vcvtop, c_1)*).
  d. Let v be an element of $invlanes_(Lnn_2 X M_2, c*)*.
  e. Return v.
6. Assert: Due to validation, half_u1? is not defined.
7. Assert: Due to validation, zero_u1? is defined.
8. Let c_1* be $lanes_(Lnn_1 X M_1, v_1).
9. Let c** be $setproduct_(lane_(Lnn_2), $lcvtop__(Lnn_1 X M_1, Lnn_2 X M_2, vcvtop, c_1)* :: [$zero(Lnn_2)]^M_1).
10. Let v be an element of $invlanes_(Lnn_2 X M_2, c*)*.
11. Return v.

vshiftop_ Jnn X M vshiftop_u1 v i
1. If (vshiftop_u1 = SHL), then:
  a. Return $ivshiftop_(Jnn X M, $ishl_, v, i).
2. Assert: Due to validation, vshiftop_u1 is SHR.
3. Let (SHR sx) be vshiftop_u1.
4. Return $ivshiftopsx_(Jnn X M, $ishr_, sx, v, i).

vbitmaskop_ Jnn X M v
1. Return $ivbitmaskop_(Jnn X M, v).

vswizzlop_ I8 X M vswizzlop_u1 v_1 v_2
1. If (vswizzlop_u1 = SWIZZLE), then:
  a. Return $ivswizzlop_(I8 X M, $iswizzle_lane_, v_1, v_2).
2. Assert: Due to validation, (vswizzlop_u1 = RELAXED_SWIZZLE).
3. Return $ivswizzlop_(I8 X M, $irelaxed_swizzle_lane_, v_1, v_2).

vshufflop_ I8 X M i* v_1 v_2
1. Return $ivshufflop_(I8 X M, i*, v_1, v_2).

vnarrowop__ Jnn_1 X M_1 Jnn_2 X M_2 sx v_1 v_2
1. Let c_1* be $lanes_(Jnn_1 X M_1, v_1).
2. Let c_2* be $lanes_(Jnn_1 X M_1, v_2).
3. Let c'_1* be $narrow__($lsize(Jnn_1), $lsize(Jnn_2), sx, c_1)*.
4. Let c'_2* be $narrow__($lsize(Jnn_1), $lsize(Jnn_2), sx, c_2)*.
5. Let v be $invlanes_(Jnn_2 X M_2, c'_1* :: c'_2*).
6. Return v.

ivadd_pairwise_ N i*
1. Let [j_1, j_2]* be $concat__1^-1(N, i*).
2. Return $iadd_(N, j_1, j_2)*.

ivextunop__ Jnn_1 X M_1 Jnn_2 X M_2 $f_ sx v_1
1. Let c_1* be $lanes_(Jnn_1 X M_1, v_1).
2. Let c'_1* be $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), sx, c_1)*.
3. Let c* be $f_($lsizenn2(Jnn_2), c'_1*).
4. Return $invlanes_(Jnn_2 X M_2, c*).

vextunop__ Jnn_1 X M_1 Jnn_2 X M_2 (EXTADD_PAIRWISE sx) v_1
1. Return $ivextunop__(Jnn_1 X M_1, Jnn_2 X M_2, $ivadd_pairwise_, sx, v_1).

ivdot_ N i_1* i_2*
1. Let [j_1, j_2]* be $concat__1^-1(iN(N), $imul_(N, i_1, i_2)*).
2. Return $iadd_(N, j_1, j_2)*.

ivdot_sat_ N i_1* i_2*
1. Let [j_1, j_2]* be $concat__1^-1(iN(N), $imul_(N, i_1, i_2)*).
2. Return $iadd_sat_(N, S, j_1, j_2)*.

ivextbinop__ Jnn_1 X M_1 Jnn_2 X M_2 $f_ sx_1 sx_2 i k v_1 v_2
1. Let c_1* be $lanes_(Jnn_1 X M_1, v_1)[i : k].
2. Let c_2* be $lanes_(Jnn_1 X M_1, v_2)[i : k].
3. Let c'_1* be $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), sx_1, c_1)*.
4. Let c'_2* be $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), sx_2, c_2)*.
5. Let c* be $f_($lsizenn2(Jnn_2), c'_1*, c'_2*).
6. Return $invlanes_(Jnn_2 X M_2, c*).

ivmul_ N i_1* i_2*
1. Return $imul_(N, i_1, i_2)*.

vextbinop__ Jnn_1 X M_1 Jnn_2 X M_2 vextbinop_u1 v_1 v_2
1. If vextbinop_u1 is EXTMUL, then:
  a. Let (EXTMUL sx half) be vextbinop_u1.
  b. Let i be $half__(Jnn_1 X M_1, Jnn_2 X M_2, half, 0, M_2).
  c. Return $ivextbinop__(Jnn_1 X M_1, Jnn_2 X M_2, $ivmul_, sx, sx, i, M_2, v_1, v_2).
2. If (vextbinop_u1 = DOTS), then:
  a. Return $ivextbinop__(Jnn_1 X M_1, Jnn_2 X M_2, $ivdot_, S, S, 0, M_1, v_1, v_2).
3. Assert: Due to validation, (vextbinop_u1 = RELAXED_DOTS).
4. Return $ivextbinop__(Jnn_1 X M_1, Jnn_2 X M_2, $ivdot_sat_, S, $relaxed2($R_idot(), sx, S, U), 0, M_1, v_1, v_2).

vextternop__ Jnn_1 X M_1 Jnn_2 X M_2 RELAXED_DOT_ADDS c_1 c_2 c_3
1. Let M be (2 * M_2).
2. Assert: Due to validation, $lsizenn^-1((2 * $lsizenn1(Jnn_1))) is Jnn.
3. Let Jnn be $lsizenn^-1((2 * $lsizenn1(Jnn_1))).
4. Let c' be $vextbinop__(Jnn_1 X M_1, Jnn X M, RELAXED_DOTS, c_1, c_2).
5. Let c'' be $vextunop__(Jnn X M, Jnn_2 X M_2, (EXTADD_PAIRWISE S), c').
6. Let c be an element of $vbinop_(Jnn_2 X M_2, ADD, c'', c_3).
7. Return c.

inst_valtype moduleinst t
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_valtype(t, dt*).

inst_reftype moduleinst rt
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_reftype(rt, dt*).

inst_globaltype moduleinst gt
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_globaltype(gt, dt*).

inst_tabletype moduleinst tt
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_tabletype(tt, dt*).

inst_memtype moduleinst mt
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_memtype(mt, dt*).

Ki
1. Return 1024.

packfield_ zt_u1 v_u1
1. If zt_u1 is valtype, then:
  a. Let val be v_u1.
  b. Return val.
2. Assert: Due to validation, zt_u1 is packtype.
3. Let packtype be zt_u1.
4. Assert: Due to validation, v_u1 is CONST.
5. Let (numtype_0.CONST i) be v_u1.
6. Assert: Due to validation, (numtype_0 = I32).
7. Return (PACK packtype $wrap__(32, $psize(packtype), i)).

unpackfield_ zt_u1 sx_u1? fv_u1
1. If (zt_u1 is valtype /\ fv_u1 is val), then:
  a. Let val be fv_u1.
  b. If sx_u1? is not defined, then:
    1) Return val.
2. Assert: Due to validation, fv_u1 is PACK.
3. Let (PACK packtype i) be fv_u1.
4. Assert: Due to validation, sx_u1? is defined.
5. Let ?(sx) be sx_u1?.
6. Assert: Due to validation, (zt_u1 = packtype).
7. Return (I32.CONST $extend__($psize(packtype), 32, sx, i)).

funcsxa xa_u1*
1. If (xa_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be xa_u1*.
3. If externaddr_0 is FUNC, then:
  a. Let (FUNC a) be externaddr_0.
  b. Return [a] :: $funcsxa(xa*).
4. Let [externaddr] :: xa* be xa_u1*.
5. Return $funcsxa(xa*).

globalsxa xa_u1*
1. If (xa_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be xa_u1*.
3. If externaddr_0 is GLOBAL, then:
  a. Let (GLOBAL a) be externaddr_0.
  b. Return [a] :: $globalsxa(xa*).
4. Let [externaddr] :: xa* be xa_u1*.
5. Return $globalsxa(xa*).

tablesxa xa_u1*
1. If (xa_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be xa_u1*.
3. If externaddr_0 is TABLE, then:
  a. Let (TABLE a) be externaddr_0.
  b. Return [a] :: $tablesxa(xa*).
4. Let [externaddr] :: xa* be xa_u1*.
5. Return $tablesxa(xa*).

memsxa xa_u1*
1. If (xa_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be xa_u1*.
3. If externaddr_0 is MEM, then:
  a. Let (MEM a) be externaddr_0.
  b. Return [a] :: $memsxa(xa*).
4. Let [externaddr] :: xa* be xa_u1*.
5. Return $memsxa(xa*).

tagsxa xa_u1*
1. If (xa_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be xa_u1*.
3. If externaddr_0 is TAG, then:
  a. Let (TAG a) be externaddr_0.
  b. Return [a] :: $tagsxa(xa*).
4. Let [externaddr] :: xa* be xa_u1*.
5. Return $tagsxa(xa*).

store (s, f)
1. Return.

frame (s, f)
1. Return f.

tagaddr (s, f)
1. Return f.MODULE.TAGS.

moduleinst (s, f)
1. Return f.MODULE.

funcinst (s, f)
1. Return s.FUNCS.

globalinst (s, f)
1. Return s.GLOBALS.

tableinst (s, f)
1. Return s.TABLES.

meminst (s, f)
1. Return s.MEMS.

taginst (s, f)
1. Return s.TAGS.

eleminst (s, f)
1. Return s.ELEMS.

datainst (s, f)
1. Return s.DATAS.

structinst (s, f)
1. Return s.STRUCTS.

arrayinst (s, f)
1. Return s.ARRAYS.

exninst (s, f)
1. Return s.EXNS.

type (s, f) x
1. Return f.MODULE.TYPES[x].

func (s, f) x
1. Return s.FUNCS[f.MODULE.FUNCS[x]].

global (s, f) x
1. Return s.GLOBALS[f.MODULE.GLOBALS[x]].

table (s, f) x
1. Return s.TABLES[f.MODULE.TABLES[x]].

mem (s, f) x
1. Return s.MEMS[f.MODULE.MEMS[x]].

tag (s, f) x
1. Return s.TAGS[f.MODULE.TAGS[x]].

elem (s, f) x
1. Return s.ELEMS[f.MODULE.ELEMS[x]].

data (s, f) x
1. Return s.DATAS[f.MODULE.DATAS[x]].

local (s, f) x
1. Return f.LOCALS[x].

with_local (s, f) x v
1. Replace f.LOCALS[x] with ?(v).

with_global (s, f) x v
1. Replace s.GLOBALS[f.MODULE.GLOBALS[x]].VALUE with v.

with_table (s, f) x i r
1. Replace s.TABLES[f.MODULE.TABLES[x]].REFS[i] with r.

with_tableinst (s, f) x ti
1. Replace s.TABLES[f.MODULE.TABLES[x]] with ti.

with_mem (s, f) x i j b*
1. Replace s.MEMS[f.MODULE.MEMS[x]].BYTES[i : j] with b*.

with_meminst (s, f) x mi
1. Replace s.MEMS[f.MODULE.MEMS[x]] with mi.

with_elem (s, f) x r*
1. Replace s.ELEMS[f.MODULE.ELEMS[x]].REFS with r*.

with_data (s, f) x b*
1. Replace s.DATAS[f.MODULE.DATAS[x]].BYTES with b*.

with_struct (s, f) a i fv
1. Replace s.STRUCTS[a].FIELDS[i] with fv.

with_array (s, f) a i fv
1. Replace s.ARRAYS[a].FIELDS[i] with fv.

add_structinst (s, f) si*
1. Append si* to the s.STRUCTS.

add_arrayinst (s, f) ai*
1. Append ai* to the s.ARRAYS.

add_exninst (s, f) exn*
1. Append exn* to the s.EXNS.

growtable tableinst n r
1. Let { TYPE: (at ([ i .. j ]) rt); REFS: r'* } be tableinst.
2. If ((|r'*| + n) <= j), then:
  a. Let i' be (|r'*| + n).
  b. Let tableinst' be { TYPE: (at ([ i' .. j ]) rt); REFS: r'* :: r^n }.
  c. Return tableinst'.

growmem meminst n
1. Let { TYPE: at ([ i .. j ]) PAGE; BYTES: b* } be meminst.
2. If (((|b*| / (64 * $Ki())) + n) <= j), then:
  a. Let i' be ((|b*| / (64 * $Ki())) + n).
  b. Let meminst' be { TYPE: at ([ i' .. j ]) PAGE; BYTES: b* :: 0^(n * (64 * $Ki())) }.
  c. Return meminst'.

blocktype_ z bt_u1
1. If bt_u1 is _IDX, then:
  a. Let (_IDX x) be bt_u1.
  b. Assert: Due to validation, $expanddt($type(z, x)) is FUNC.
  c. Let (FUNC ft) be $expanddt($type(z, x)).
  d. Return ft.
2. Assert: Due to validation, bt_u1 is _RESULT.
3. Let (_RESULT t?) be bt_u1.
4. Return [] -> t?.

alloctypes type_u1*
1. If (type_u1* = []), then:
  a. Return [].
2. Let type'* :: [type] be type_u1*.
3. Let (TYPE rectype) be type.
4. Let deftype'* be $alloctypes(type'*).
5. Let x be |deftype'*|.
6. Let deftype* be $subst_all_deftypes($rolldt(x, rectype), deftype'*).
7. Return deftype'* :: deftype*.

allocfunc s deftype funccode moduleinst
1. Let funcinst be { TYPE: deftype; MODULE: moduleinst; CODE: funccode }.
2. Let a be |s.FUNCS|.
3. Append funcinst to the s.FUNCS.
4. Return a.

allocfuncs s dt_u1* funccode_u1* moduleinst_u1*
1. If (dt_u1* = []), then:
  a. Assert: Due to validation, (funccode_u1* = []).
  b. Assert: Due to validation, (moduleinst_u1* = []).
  c. Return [].
2. Else:
  a. Let [dt] :: dt'* be dt_u1*.
  b. Assert: Due to validation, (|funccode_u1*| >= 1).
  c. Let [funccode] :: funccode'* be funccode_u1*.
  d. Assert: Due to validation, (|moduleinst_u1*| >= 1).
  e. Let [moduleinst] :: moduleinst'* be moduleinst_u1*.
  f. Let fa be $allocfunc(s, dt, funccode, moduleinst).
  g. Let fa'* be $allocfuncs(s, dt'*, funccode'*, moduleinst'*).
  h. Return [fa] :: fa'*.

allocglobal s globaltype val
1. Let globalinst be { TYPE: globaltype; VALUE: val }.
2. Let a be |s.GLOBALS|.
3. Append globalinst to the s.GLOBALS.
4. Return a.

allocglobals s gt_u1* v_u1*
1. If (gt_u1* = []), then:
  a. Assert: Due to validation, (v_u1* = []).
  b. Return [].
2. Else:
  a. Let [globaltype] :: globaltype'* be gt_u1*.
  b. Assert: Due to validation, (|v_u1*| >= 1).
  c. Let [val] :: val'* be v_u1*.
  d. Let ga be $allocglobal(s, globaltype, val).
  e. Let ga'* be $allocglobals(s, globaltype'*, val'*).
  f. Return [ga] :: ga'*.

alloctable s (at ([ i .. j ]) rt) ref
1. Let tableinst be { TYPE: (at ([ i .. j ]) rt); REFS: ref^i }.
2. Let a be |s.TABLES|.
3. Append tableinst to the s.TABLES.
4. Return a.

alloctables s tt_u1* r_u1*
1. If ((tt_u1* = []) /\ (r_u1* = [])), then:
  a. Return [].
2. Assert: Due to validation, (|r_u1*| >= 1).
3. Let [ref] :: ref'* be r_u1*.
4. Assert: Due to validation, (|tt_u1*| >= 1).
5. Let [tabletype] :: tabletype'* be tt_u1*.
6. Let ta be $alloctable(s, tabletype, ref).
7. Let ta'* be $alloctables(s, tabletype'*, ref'*).
8. Return [ta] :: ta'*.

allocmem s at ([ i .. j ]) PAGE
1. Let meminst be { TYPE: at ([ i .. j ]) PAGE; BYTES: 0^(i * (64 * $Ki())) }.
2. Let a be |s.MEMS|.
3. Append meminst to the s.MEMS.
4. Return a.

allocmems s mt_u1*
1. If (mt_u1* = []), then:
  a. Return [].
2. Let [memtype] :: memtype'* be mt_u1*.
3. Let ma be $allocmem(s, memtype).
4. Let ma'* be $allocmems(s, memtype'*).
5. Return [ma] :: ma'*.

alloctag s tagtype
1. Let taginst be { TYPE: tagtype }.
2. Let a be |s.TAGS|.
3. Append taginst to the s.TAGS.
4. Return a.

alloctags s jt_u1*
1. If (jt_u1* = []), then:
  a. Return [].
2. Let [jt] :: jt'* be jt_u1*.
3. Let ja be $alloctag(s, jt).
4. Let ja'* be $alloctags(s, jt'*).
5. Return [ja] :: ja'*.

allocelem s elemtype ref*
1. Let eleminst be { TYPE: elemtype; REFS: ref* }.
2. Let a be |s.ELEMS|.
3. Append eleminst to the s.ELEMS.
4. Return a.

allocelems s elemtype_u1* r_u1*
1. If ((elemtype_u1* = []) /\ (r_u1* = [])), then:
  a. Return [].
2. Assert: Due to validation, (|r_u1*| >= 1).
3. Let [ref*] :: ref'** be r_u1*.
4. Assert: Due to validation, (|elemtype_u1*| >= 1).
5. Let [rt] :: rt'* be elemtype_u1*.
6. Let ea be $allocelem(s, rt, ref*).
7. Let ea'* be $allocelems(s, rt'*, ref'**).
8. Return [ea] :: ea'*.

allocdata s OK byte*
1. Let datainst be { BYTES: byte* }.
2. Let a be |s.DATAS|.
3. Append datainst to the s.DATAS.
4. Return a.

allocdatas s ok_u1* b_u1*
1. If ((ok_u1* = []) /\ (b_u1* = [])), then:
  a. Return [].
2. Assert: Due to validation, (|b_u1*| >= 1).
3. Let [b*] :: b'** be b_u1*.
4. Assert: Due to validation, (|ok_u1*| >= 1).
5. Let [ok] :: ok'* be ok_u1*.
6. Let da be $allocdata(s, ok, b*).
7. Let da'* be $allocdatas(s, ok'*, b'**).
8. Return [da] :: da'*.

allocexport moduleinst (EXPORT name xx_u1)
1. If xx_u1 is FUNC, then:
  a. Let (FUNC x) be xx_u1.
  b. Return { NAME: name; ADDR: (FUNC moduleinst.FUNCS[x]) }.
2. If xx_u1 is GLOBAL, then:
  a. Let (GLOBAL x) be xx_u1.
  b. Return { NAME: name; ADDR: (GLOBAL moduleinst.GLOBALS[x]) }.
3. If xx_u1 is TABLE, then:
  a. Let (TABLE x) be xx_u1.
  b. Return { NAME: name; ADDR: (TABLE moduleinst.TABLES[x]) }.
4. If xx_u1 is MEM, then:
  a. Let (MEM x) be xx_u1.
  b. Return { NAME: name; ADDR: (MEM moduleinst.MEMS[x]) }.
5. Assert: Due to validation, xx_u1 is TAG.
6. Let (TAG x) be xx_u1.
7. Return { NAME: name; ADDR: (TAG moduleinst.TAGS[x]) }.

allocexports moduleinst export*
1. Return $allocexport(moduleinst, export)*.

allocmodule s module externaddr* val_G* ref_T* ref_E**
1. Let (MODULE type* import* func* global* table* mem* tag* elem* data* start? export*) be module.
2. Let fa_I* be $funcsxa(externaddr*).
3. Let ga_I* be $globalsxa(externaddr*).
4. Let aa_I* be $tagsxa(externaddr*).
5. Let ma_I* be $memsxa(externaddr*).
6. Let ta_I* be $tablesxa(externaddr*).
7. Let fa* be (|s.FUNCS| + i_F)^(i_F<|func*|).
8. Let ga* be (|s.GLOBALS| + i_G)^(i_G<|global*|).
9. Let ta* be (|s.TABLES| + i_T)^(i_T<|table*|).
10. Let aa* be (|s.TAGS| + i_A)^(i_A<|tag*|).
11. Let ma* be (|s.MEMS| + i_M)^(i_M<|mem*|).
12. Let ea* be (|s.ELEMS| + i_E)^(i_E<|elem*|).
13. Let da* be (|s.DATAS| + i_D)^(i_D<|data*|).
14. Let (MEMORY memtype)* be mem*.
15. Let dt* be $alloctypes(type*).
16. Let (TAG y)* be tag*.
17. Let (DATA byte* datamode)* be data*.
18. Let (GLOBAL globaltype expr_G)* be global*.
19. Let (TABLE tabletype expr_T)* be table*.
20. Let (ELEM elemtype expr_E* elemmode)* be elem*.
21. Let (FUNC x local* expr_F)* be func*.
22. Let xi* be $allocexports({ FUNCS: fa_I* :: fa*; GLOBALS: ga_I* :: ga*; TABLES: ta_I* :: ta*; MEMS: ma_I* :: ma*; TAGS: aa_I* :: aa* }, export*).
23. Let moduleinst be { TYPES: dt*; FUNCS: fa_I* :: fa*; GLOBALS: ga_I* :: ga*; TABLES: ta_I* :: ta*; MEMS: ma_I* :: ma*; TAGS: aa_I* :: aa*; ELEMS: ea*; DATAS: da*; EXPORTS: xi* }.
24. Let funcaddr_0* be $allocfuncs(s, dt*[x]*, (FUNC x local* expr_F)*, moduleinst^|func*|).
25. Assert: Due to validation, (funcaddr_0* = fa*).
26. Let globaladdr_0* be $allocglobals(s, $subst_all_globaltype(globaltype, dt*)*, val_G*).
27. Assert: Due to validation, (globaladdr_0* = ga*).
28. Let tableaddr_0* be $alloctables(s, $subst_all_tabletype(tabletype, dt*)*, ref_T*).
29. Assert: Due to validation, (tableaddr_0* = ta*).
30. Let memaddr_0* be $allocmems(s, $subst_all_memtype(memtype, dt*)*).
31. Assert: Due to validation, (memaddr_0* = ma*).
32. Let tagaddr_0* be $alloctags(s, dt*[y]*).
33. Assert: Due to validation, (tagaddr_0* = aa*).
34. Let elemaddr_0* be $allocelems(s, $subst_all_reftype(elemtype, dt*)*, ref_E**).
35. Assert: Due to validation, (elemaddr_0* = ea*).
36. Let dataaddr_0* be $allocdatas(s, OK^|data*|, byte**).
37. Assert: Due to validation, (dataaddr_0* = da*).
38. Return moduleinst.

runelem_ x (ELEM rt e^n elemmode_u1)
1. If (elemmode_u1 = PASSIVE), then:
  a. Return [].
2. If (elemmode_u1 = DECLARE), then:
  a. Return [(ELEM.DROP x)].
3. Assert: Due to validation, elemmode_u1 is ACTIVE.
4. Let (ACTIVE y instr*) be elemmode_u1.
5. Return instr* :: [(I32.CONST 0), (I32.CONST n), (TABLE.INIT y x), (ELEM.DROP x)].

rundata_ x (DATA b^n datamode_u1)
1. If (datamode_u1 = PASSIVE), then:
  a. Return [].
2. Assert: Due to validation, datamode_u1 is ACTIVE.
3. Let (ACTIVE y instr*) be datamode_u1.
4. Return instr* :: [(I32.CONST 0), (I32.CONST n), (MEMORY.INIT y x), (DATA.DROP x)].

evalglobals z gt_u1* e_u1*
1. If ((gt_u1* = []) /\ (e_u1* = [])), then:
  a. Return [].
2. Assert: Due to validation, (|e_u1*| >= 1).
3. Let [expr] :: expr'* be e_u1*.
4. Assert: Due to validation, (|gt_u1*| >= 1).
5. Let [gt] :: gt'* be gt_u1*.
6. Let (s, f) be z.
7. Let [val] be $Eval_expr(z, expr).
8. Let a be $allocglobal(s, gt, val).
9. Append a to the f.MODULE.GLOBALS.
10. Let val'* be $evalglobals((s, f), gt'*, expr'*).
11. Return [val] :: val'*.

instantiate s module externaddr*
1. Let xt_I* -> xt_E* be $Module_ok(module).
2. Let (MODULE type* import* func* global* table* mem* tag* elem* data* start? export*) be module.
3. If not $Externaddr_type(externaddr, xt_I)*, then:
  a. Fail.
4. Let instr_D* be $concat_(instr, $rundata_(i_D, data*[i_D])^(i_D<|data*|)).
5. Let instr_E* be $concat_(instr, $runelem_(i_E, elem*[i_E])^(i_E<|elem*|)).
6. Let (START x)? be start?.
7. Let moduleinst_0 be { TYPES: $alloctypes(type*); FUNCS: $funcsxa(externaddr*) :: (|s.FUNCS| + i_F)^(i_F<|func*|); GLOBALS: $globalsxa(externaddr*) }.
8. Let (TABLE tabletype expr_T)* be table*.
9. Let (GLOBAL globaltype expr_G)* be global*.
10. Let (ELEM reftype expr_E* elemmode)* be elem*.
11. Let instr_S? be (CALL x)?.
12. Let z be (s, { MODULE: moduleinst_0 }).
13. Push the :ref:`frame <syntax-frame>` (FRAME_ 0 { $frame(z) }) to the stack.
14. Let val_G* be $evalglobals(z, globaltype*, expr_G*).
15. Pop the :ref:`frame <syntax-frame>` (FRAME_ 0 { f }) from the stack.
16. Push the :ref:`frame <syntax-frame>` (FRAME_ 0 { f }) to the stack.
17. Let [ref_T]* be $Eval_expr(z, expr_T)*.
18. Pop the :ref:`frame <syntax-frame>` (FRAME_ 0 { f }) from the stack.
19. Push the :ref:`frame <syntax-frame>` (FRAME_ 0 { f }) to the stack.
20. Let [ref_E]** be $Eval_expr(z, expr_E)**.
21. Pop the :ref:`frame <syntax-frame>` (FRAME_ 0 { f }) from the stack.
22. Let moduleinst be $allocmodule(s, module, externaddr*, val_G*, ref_T*, ref_E**).
23. Let f be { MODULE: moduleinst }.
24. Push the :ref:`frame <syntax-frame>` (FRAME_ 0 { f }) to the stack.
25. Execute the sequence (instr_E*).
26. Execute the sequence (instr_D*).
27. Execute the sequence (instr_S?).
28. Pop the :ref:`frame <syntax-frame>` (FRAME_ 0 { f }) from the stack.
29. Return f.MODULE.

invoke s funcaddr val*
1. Assert: Due to validation, $expanddt(s.FUNCS[funcaddr].TYPE) is FUNC.
2. Let (FUNC functype_0) be $expanddt(s.FUNCS[funcaddr].TYPE).
3. Let t_1* -> t_2* be functype_0.
4. Let f be { MODULE: {} }.
5. If not $Val_type(val, t_1)*, then:
  a. Fail.
6. Let k be |t_2*|.
7. Push the :ref:`frame <syntax-frame>` (FRAME_ k { f }) to the stack.
8. Push the values val* to the stack.
9. Push the value (REF.FUNC_ADDR funcaddr) to the stack.
10. Execute the instruction (CALL_REF s.FUNCS[funcaddr].TYPE).
11. Pop all values val_0* from the top of the stack.
12. Pop the :ref:`frame <syntax-frame>` (FRAME_ k { f }) from the stack.
13. Push the values val_0* to the stack.
14. Pop the values val^k from the stack.
15. Return val^k.

allocXs X Y s X_u1* Y_u1*
1. If (X_u1* = []), then:
  a. Assert: Due to validation, (Y_u1* = []).
  b. Return [].
2. Else:
  a. Let [X] :: X'* be X_u1*.
  b. Assert: Due to validation, (|Y_u1*| >= 1).
  c. Let [Y] :: Y'* be Y_u1*.
  d. Let a be $allocX(X, Y, s, X, Y).
  e. Let a'* be $allocXs(X, Y, s, X'*, Y'*).
  f. Return [a] :: a'*.

var X
1. Return 0.

Eval_expr instr*
1. Execute the instruction instr*.
2. Pop the value val from the stack.
3. Return [val].

== Complete.
```
