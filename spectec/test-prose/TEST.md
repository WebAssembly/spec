# Preview

```sh
$ for v in 1 2 3; do ( \
>   echo "Generating prose for Wasm $v.0..." && \
>   cd ../spec/wasm-$v.0 && \
>   ../../src/exe-watsup/main.exe *.watsup -v -l --prose-rst && \
>   ../../src/exe-watsup/main.exe *.watsup -v -l --prose \
> ) done
Generating prose for Wasm 1.0...
watsup 0.4 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...

* The limits :math:`(n, m)` is valid with the nat :math:`k` if:


  * :math:`n` is less than or equal to :math:`m`.

  * :math:`m` is less than or equal to :math:`k`.


* The function type :math:`{t_1^\ast}~\rightarrow~{t_2^?}` is valid.


* The global type :math:`((\mathsf{mut}~{()^?}~{}^?)~t)` is valid.


* The table type :math:`{\mathit{limits}}` is valid if:


  * The limits :math:`{\mathit{limits}}` is valid with the nat :math:`{2^{32}} - 1`.


* The memory type :math:`{\mathit{limits}}` is valid if:


  * The limits :math:`{\mathit{limits}}` is valid with the nat :math:`{2^{16}}`.


* The external type :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valid if:


  * Either:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{func}~{\mathit{functype}})`.

    * The function type :math:`{\mathit{functype}}` is valid.

  * Or:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{global}~{\mathit{globaltype}})`.

    * The global type :math:`{\mathit{globaltype}}` is valid.
  * Or:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{table}~{\mathit{tabletype}})`.

    * The table type :math:`{\mathit{tabletype}}` is valid.
  * Or:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{mem}~{\mathit{memtype}})`.

    * The memory type :math:`{\mathit{memtype}}` is valid.


* The limits :math:`(n_{11}, n_{12})` matches the limits :math:`(n_{21}, n_{22})` if:


  * :math:`n_{11}` is greater than or equal to :math:`n_{21}`.

  * :math:`n_{12}` is less than or equal to :math:`n_{22}`.


* The function type :math:`{\mathit{ft}}` matches the function type :math:`{\mathit{ft}}`.


* The global type :math:`{\mathit{gt}}` matches the global type :math:`{\mathit{gt}}`.


* The table type :math:`{\mathit{lim}}_1` matches the table type :math:`{\mathit{lim}}_2` if:


  * The limits :math:`{\mathit{lim}}_1` matches the limits :math:`{\mathit{lim}}_2`.


* The memory type :math:`{\mathit{lim}}_1` matches the memory type :math:`{\mathit{lim}}_2` if:


  * The limits :math:`{\mathit{lim}}_1` matches the limits :math:`{\mathit{lim}}_2`.


* The external type :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` matches the external type :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


  * Either:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{func}~{\mathit{ft}}_1)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{func}~{\mathit{ft}}_2)`.

    * The function type :math:`{\mathit{ft}}_1` matches the function type :math:`{\mathit{ft}}_2`.

  * Or:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{global}~{\mathit{gt}}_1)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{global}~{\mathit{gt}}_2)`.

    * The global type :math:`{\mathit{gt}}_1` matches the global type :math:`{\mathit{gt}}_2`.
  * Or:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{table}~{\mathit{tt}}_1)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{table}~{\mathit{tt}}_2)`.

    * The table type :math:`{\mathit{tt}}_1` matches the table type :math:`{\mathit{tt}}_2`.
  * Or:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{mem}~{\mathit{mt}}_1)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{mem}~{\mathit{mt}}_2)`.

    * The memory type :math:`{\mathit{mt}}_1` matches the memory type :math:`{\mathit{mt}}_2`.


* The instruction :math:`\mathsf{nop}` is valid with the function type :math:`\epsilon~\rightarrow~\epsilon`.


* The instruction :math:`\mathsf{unreachable}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.


* The instruction :math:`\mathsf{drop}` is valid with the function type :math:`t~\rightarrow~\epsilon`.


* The instruction :math:`\mathsf{select}` is valid with the function type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t`.


* The instruction :math:`(\mathsf{block}~{t^?}~{{\mathit{instr}}^\ast})` is valid with the function type :math:`\epsilon~\rightarrow~{t^?}` if:


  * Under the context :math:`C{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t^?}]`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`\epsilon~\rightarrow~{t^?}`.


* The instruction :math:`(\mathsf{loop}~{t^?}~{{\mathit{instr}}^\ast})` is valid with the function type :math:`\epsilon~\rightarrow~{t^?}` if:


  * Under the context :math:`C{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} \epsilon]`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`\epsilon~\rightarrow~\epsilon`.


* The instruction :math:`(\mathsf{if}~{t^?}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{t^?}` if:


  * Under the context :math:`C{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t^?}]`, the instruction sequence :math:`{{\mathit{instr}}_1^\ast}` is valid with the function type :math:`\epsilon~\rightarrow~{t^?}`.

  * Under the context :math:`C{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t^?}]`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the function type :math:`\epsilon~\rightarrow~{t^?}`.


* The instruction :math:`(\mathsf{br}~l)` is valid with the function type :math:`{t_1^\ast}~{t^?}~\rightarrow~{t_2^\ast}` if:


  * :math:`{|C{.}\mathsf{labels}|}` is greater than :math:`l`.

  * :math:`C{.}\mathsf{labels}{}[l]` is :math:`{t^?}`.


* The instruction :math:`(\mathsf{br\_if}~l)` is valid with the function type :math:`{t^?}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t^?}` if:


  * :math:`{|C{.}\mathsf{labels}|}` is greater than :math:`l`.

  * :math:`C{.}\mathsf{labels}{}[l]` is :math:`{t^?}`.


* The instruction :math:`(\mathsf{br\_table}~{l^\ast}~{l'})` is valid with the function type :math:`{t_1^\ast}~{t^?}~\rightarrow~{t_2^\ast}` if:


  * :math:`{|C{.}\mathsf{labels}|}` is greater than :math:`{l'}`.

  * :math:`{t^?}` is :math:`C{.}\mathsf{labels}{}[{l'}]`.

  * For all :math:`l` in :math:`{l^\ast}`, :math:`{|C{.}\mathsf{labels}|}` is greater than :math:`l`.

  * For all :math:`l` in :math:`{l^\ast}`, :math:`{t^?}` is :math:`C{.}\mathsf{labels}{}[l]`.


* The instruction :math:`(\mathsf{call}~x)` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^?}` if:


  * :math:`{|C{.}\mathsf{funcs}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{funcs}{}[x]` is :math:`{t_1^\ast}~\rightarrow~{t_2^?}`.


* The instruction :math:`(\mathsf{call\_indirect}~x)` is valid with the function type :math:`{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^?}` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{types}{}[x]` is :math:`{t_1^\ast}~\rightarrow~{t_2^?}`.


* The instruction :math:`\mathsf{return}` is valid with the function type :math:`{t_1^\ast}~{t^?}~\rightarrow~{t_2^\ast}` if:


  * :math:`C{.}\mathsf{return}` is :math:`{t^?}`.


* The instruction :math:`(t{.}\mathsf{const}~c_t)` is valid with the function type :math:`\epsilon~\rightarrow~t`.


* The instruction :math:`(t {.} {\mathit{unop}}_t)` is valid with the function type :math:`t~\rightarrow~t`.


* The instruction :math:`(t {.} {\mathit{binop}}_t)` is valid with the function type :math:`t~t~\rightarrow~t`.


* The instruction :math:`(t {.} {\mathit{testop}}_t)` is valid with the function type :math:`t~\rightarrow~\mathsf{i{\scriptstyle 32}}`.


* The instruction :math:`(t {.} {\mathit{relop}}_t)` is valid with the function type :math:`t~t~\rightarrow~\mathsf{i{\scriptstyle 32}}`.


* The instruction :math:`({\mathit{nt}}_1 {.} {{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}{\mathsf{\_}}{{\mathit{nt}}_2})` is valid with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1` if:


  * Either:

    * :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{reinterpret}`.

    * :math:`{|{\mathit{nt}}_1|}` is :math:`{|{\mathit{nt}}_2|}`.

  * Or: :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{cvtop}}`.


* The instruction :math:`(\mathsf{local{.}get}~x)` is valid with the function type :math:`\epsilon~\rightarrow~t` if:


  * :math:`{|C{.}\mathsf{locals}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{locals}{}[x]` is :math:`t`.


* The instruction :math:`(\mathsf{local{.}set}~x)` is valid with the function type :math:`t~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{locals}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{locals}{}[x]` is :math:`t`.


* The instruction :math:`(\mathsf{local{.}tee}~x)` is valid with the function type :math:`t~\rightarrow~t` if:


  * :math:`{|C{.}\mathsf{locals}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{locals}{}[x]` is :math:`t`.


* The instruction :math:`(\mathsf{global{.}get}~x)` is valid with the function type :math:`\epsilon~\rightarrow~t` if:


  * :math:`{|C{.}\mathsf{globals}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{globals}{}[x]` is :math:`({\mathit{mut}}~t)`.


* The instruction :math:`(\mathsf{global{.}set}~x)` is valid with the function type :math:`t~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{globals}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{globals}{}[x]` is :math:`(\mathsf{mut}~t)`.


* The instruction :math:`\mathsf{memory{.}size}` is valid with the function type :math:`\epsilon~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`0`.

  * :math:`C{.}\mathsf{mems}{}[0]` is :math:`{\mathit{mt}}`.


* The instruction :math:`\mathsf{memory{.}grow}` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`0`.

  * :math:`C{.}\mathsf{mems}{}[0]` is :math:`{\mathit{mt}}`.


* The instruction :math:`({{\mathit{nt}}{.}\mathsf{load}}{{(n, {\mathit{sx}})^?}}~{}^?~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathit{nt}}` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`0`.

  * :math:`C{.}\mathsf{mems}{}[0]` is :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

  * If :math:`n` is defined,

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.

    * :math:`n / 8` is less than :math:`{|{\mathit{nt}}|} / 8`.

  * If :math:`n` is defined, :math:`{\mathit{nt}}` is :math:`{\mathsf{i}}{n}`.


* The instruction :math:`({\mathit{nt}}{.}\mathsf{store}~{n^?}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathit{nt}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`0`.

  * :math:`C{.}\mathsf{mems}{}[0]` is :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

  * If :math:`n` is defined,

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.

    * :math:`n / 8` is less than :math:`{|{\mathit{nt}}|} / 8`.

  * If :math:`n` is defined, :math:`{\mathit{nt}}` is :math:`{\mathsf{i}}{n}`.


* The instruction sequence :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is valid with the function type :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}~\rightarrow~{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` if:


  * Either:

    * :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\epsilon`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is :math:`\epsilon`.

  * Or:

    * :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`{t_1^\ast}`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is :math:`{t_3^\ast}`.

    * The instruction :math:`{\mathit{instr}}_1` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

    * The instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the function type :math:`{t_2^\ast}~\rightarrow~{t_3^\ast}`.
  * Or:

    * :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`{{\mathit{instr}}^\ast}`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`{t^\ast}~{t_1^\ast}`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is :math:`{t^\ast}~{t_2^\ast}`.

    * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.


* The expression :math:`{{\mathit{instr}}^\ast}` is valid with the result type :math:`{t^?}` if:


  * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`\epsilon~\rightarrow~{t^?}`.


* :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is const if:


  * Either: :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(t{.}\mathsf{const}~c)`.

  * Or:

    * :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{global{.}get}~x)`.

    * :math:`{|C{.}\mathsf{globals}|}` is greater than :math:`x`.

    * :math:`C{.}\mathsf{globals}{}[x]` is :math:`(t)`.


* :math:`{{\mathit{instr}}^\ast}` is const if:


  * For all :math:`{\mathit{instr}}` in :math:`{{\mathit{instr}}^\ast}`, :math:`{\mathit{instr}}` is const.


* The type :math:`(\mathsf{type}~{\mathit{ft}})` is valid with the function type :math:`{\mathit{ft}}` if:


  * The function type :math:`{\mathit{ft}}` is valid.


* The function :math:`(\mathsf{func}~x~{(\mathsf{local}~t)^\ast}~{\mathit{expr}})` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^?}` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{types}{}[x]` is :math:`{t_1^\ast}~\rightarrow~{t_2^?}`.

  * Under the context :math:`C{}[{.}\mathsf{locals} \mathrel{{=}{\oplus}} {t_1^\ast}~{t^\ast}]{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_2^?}]{}[{.}\mathsf{return} \mathrel{{=}{\oplus}} {t_2^?}]`, the expression :math:`{\mathit{expr}}` is valid with the result type :math:`{t_2^?}`.


* The global :math:`(\mathsf{global}~{\mathit{gt}}~{\mathit{expr}})` is valid with the global type :math:`{\mathit{gt}}` if:


  * The global type :math:`{\mathit{gt}}` is valid.

  * :math:`{\mathit{gt}}` is :math:`({\mathit{mut}}~t)`.

  * The expression :math:`{\mathit{expr}}` is valid with the number type sequence :math:`t`.

  * :math:`{\mathit{expr}}` is const.


* The table :math:`(\mathsf{table}~{\mathit{tt}})` is valid with the table type :math:`{\mathit{tt}}` if:


  * The table type :math:`{\mathit{tt}}` is valid.


* The memory :math:`(\mathsf{memory}~{\mathit{mt}})` is valid with the memory type :math:`{\mathit{mt}}` if:


  * The memory type :math:`{\mathit{mt}}` is valid.


* The table segment :math:`(\mathsf{elem}~{\mathit{expr}}~{x^\ast})` is valid if:


  * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`0`.

  * :math:`C{.}\mathsf{tables}{}[0]` is :math:`{\mathit{lim}}`.

  * The expression :math:`{\mathit{expr}}` is valid with the number type sequence :math:`\mathsf{i{\scriptstyle 32}}`.

  * :math:`{\mathit{expr}}` is const.

  * :math:`{|{\mathit{x*}}|}` is :math:`{|{\mathit{ft*}}|}`.

  * For all :math:`x` in :math:`{x^\ast}`, :math:`{|C{.}\mathsf{funcs}|}` is greater than :math:`x`.

  * For all :math:`{\mathit{ft}}` in :math:`{{\mathit{ft}}^\ast}` and :math:`x` in :math:`{x^\ast}`, :math:`C{.}\mathsf{funcs}{}[x]` is :math:`{\mathit{ft}}`.


* The memory segment :math:`(\mathsf{data}~{\mathit{expr}}~{b^\ast})` is valid if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`0`.

  * :math:`C{.}\mathsf{mems}{}[0]` is :math:`{\mathit{lim}}`.

  * The expression :math:`{\mathit{expr}}` is valid with the number type sequence :math:`\mathsf{i{\scriptstyle 32}}`.

  * :math:`{\mathit{expr}}` is const.


* The start function :math:`(\mathsf{start}~x)` is valid if:


  * :math:`{|C{.}\mathsf{funcs}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{funcs}{}[x]` is :math:`\epsilon~\rightarrow~\epsilon`.


* The import :math:`(\mathsf{import}~{\mathit{name}}_1~{\mathit{name}}_2~{\mathit{xt}})` is valid with the external type :math:`{\mathit{xt}}` if:


  * The external type :math:`{\mathit{xt}}` is valid.


* The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valid with the external type :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


  * Either:

    * :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{func}~x)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{func}~{\mathit{ft}})`.

    * :math:`{|C{.}\mathsf{funcs}|}` is greater than :math:`x`.

    * :math:`C{.}\mathsf{funcs}{}[x]` is :math:`{\mathit{ft}}`.

  * Or:

    * :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{global}~x)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{global}~{\mathit{gt}})`.

    * :math:`{|C{.}\mathsf{globals}|}` is greater than :math:`x`.

    * :math:`C{.}\mathsf{globals}{}[x]` is :math:`{\mathit{gt}}`.
  * Or:

    * :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{table}~x)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{table}~{\mathit{tt}})`.

    * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x`.

    * :math:`C{.}\mathsf{tables}{}[x]` is :math:`{\mathit{tt}}`.
  * Or:

    * :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{mem}~x)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{mem}~{\mathit{mt}})`.

    * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`x`.

    * :math:`C{.}\mathsf{mems}{}[x]` is :math:`{\mathit{mt}}`.


* The export :math:`(\mathsf{export}~{\mathit{name}}~{\mathit{externidx}})` is valid with the external type :math:`{\mathit{xt}}` if:


  * The external index :math:`{\mathit{externidx}}` is valid with the external type :math:`{\mathit{xt}}`.


* The module :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` is valid if:


  * :math:`{|{\mathit{type*}}|}` is :math:`{|{\mathit{ft'*}}|}`.

  * For all :math:`{\mathit{ft}'}` in :math:`{{\mathit{ft}'}^\ast}` and :math:`{\mathit{type}}` in :math:`{{\mathit{type}}^\ast}`, the type :math:`{\mathit{type}}` is valid with the function type :math:`{\mathit{ft}'}`.

  * :math:`{|{\mathit{ixt*}}|}` is :math:`{|{\mathit{import*}}|}`.

  * For all :math:`{\mathit{import}}` in :math:`{{\mathit{import}}^\ast}` and :math:`{\mathit{ixt}}` in :math:`{{\mathit{ixt}}^\ast}`, under the context :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon,\; \mathsf{return}~\epsilon \}\end{array}`, the import :math:`{\mathit{import}}` is valid with the external type :math:`{\mathit{ixt}}`.

  * :math:`{|{\mathit{gt*}}|}` is :math:`{|{\mathit{global*}}|}`.

  * For all :math:`{\mathit{global}}` in :math:`{{\mathit{global}}^\ast}` and :math:`{\mathit{gt}}` in :math:`{{\mathit{gt}}^\ast}`, under the context :math:`{C'}`, the global :math:`{\mathit{global}}` is valid with the global type :math:`{\mathit{gt}}`.

  * :math:`{|{\mathit{func*}}|}` is :math:`{|{\mathit{ft*}}|}`.

  * For all :math:`{\mathit{ft}}` in :math:`{{\mathit{ft}}^\ast}` and :math:`{\mathit{func}}` in :math:`{{\mathit{func}}^\ast}`, the function :math:`{\mathit{func}}` is valid with the function type :math:`{\mathit{ft}}`.

  * :math:`{|{\mathit{tt*}}|}` is :math:`{|{\mathit{table*}}|}`.

  * For all :math:`{\mathit{table}}` in :math:`{{\mathit{table}}^\ast}` and :math:`{\mathit{tt}}` in :math:`{{\mathit{tt}}^\ast}`, the table :math:`{\mathit{table}}` is valid with the table type :math:`{\mathit{tt}}`.

  * :math:`{|{\mathit{mt*}}|}` is :math:`{|{\mathit{mem*}}|}`.

  * For all :math:`{\mathit{mem}}` in :math:`{{\mathit{mem}}^\ast}` and :math:`{\mathit{mt}}` in :math:`{{\mathit{mt}}^\ast}`, the memory :math:`{\mathit{mem}}` is valid with the memory type :math:`{\mathit{mt}}`.

  * For all :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}`, the table segment :math:`{\mathit{elem}}` is valid.

  * For all :math:`{\mathit{data}}` in :math:`{{\mathit{data}}^\ast}`, the memory segment :math:`{\mathit{data}}` is valid.

  * If :math:`{\mathit{start}}` is defined, the start function :math:`{\mathit{start}}` is valid.

  * :math:`{|{\mathit{xt*}}|}` is :math:`{|{\mathit{export*}}|}`.

  * For all :math:`{\mathit{export}}` in :math:`{{\mathit{export}}^\ast}` and :math:`{\mathit{xt}}` in :math:`{{\mathit{xt}}^\ast}`, the export :math:`{\mathit{export}}` is valid with the external type :math:`{\mathit{xt}}`.

  * :math:`{|{{\mathit{tt}}^\ast}|}` is less than or equal to :math:`1`.

  * :math:`{|{{\mathit{mt}}^\ast}|}` is less than or equal to :math:`1`.

  * :math:`C` is :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{funcs}~{{\mathit{ift}}^\ast}~{{\mathit{ft}}^\ast},\; \mathsf{globals}~{{\mathit{igt}}^\ast}~{{\mathit{gt}}^\ast},\; \mathsf{tables}~{{\mathit{itt}}^\ast}~{{\mathit{tt}}^\ast},\; \mathsf{mems}~{{\mathit{imt}}^\ast}~{{\mathit{mt}}^\ast},\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon,\; \mathsf{return}~\epsilon \}\end{array}`.

  * :math:`{C'}` is :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{funcs}~{{\mathit{ift}}^\ast}~{{\mathit{ft}}^\ast},\; \mathsf{globals}~{{\mathit{igt}}^\ast},\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon,\; \mathsf{return}~\epsilon \}\end{array}`.

  * :math:`{{\mathit{ift}}^\ast}` is :math:`{\mathrm{funcs}}({{\mathit{ixt}}^\ast})`.

  * :math:`{{\mathit{igt}}^\ast}` is :math:`{\mathrm{globals}}({{\mathit{ixt}}^\ast})`.

  * :math:`{{\mathit{itt}}^\ast}` is :math:`{\mathrm{tables}}({{\mathit{ixt}}^\ast})`.

  * :math:`{{\mathit{imt}}^\ast}` is :math:`{\mathrm{mems}}({{\mathit{ixt}}^\ast})`.


:math:`\mathsf{unreachable}`
............................


1. Trap.


:math:`\mathsf{nop}`
....................


1. Do nothing.


:math:`\mathsf{drop}`
.....................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Do nothing.


:math:`\mathsf{select}`
.......................


1. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_2` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_1` from the stack.

#. If :math:`c` is not :math:`0`, then:

  a. Push the value :math:`{\mathit{val}}_1` to the stack.

#. Else:

  a. Push the value :math:`{\mathit{val}}_2` to the stack.


:math:`\mathsf{if}~{t^?}~{{\mathit{instr}}_1^\ast}~{{\mathit{instr}}_2^\ast}`
.............................................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c` is not :math:`0`, then:

  a. Execute the instruction :math:`(\mathsf{block}~{t^?}~{{\mathit{instr}}_1^\ast})`.

#. Else:

  a. Execute the instruction :math:`(\mathsf{block}~{t^?}~{{\mathit{instr}}_2^\ast})`.


:math:`\mathsf{label}`
......................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, a label is now on the top of the stack.

#. Pop the current label from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.


:math:`\mathsf{br}~n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`
.............................................................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, the top of the stack is a :math:`\mathsf{label}`.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

#. Let :math:`L` be the current label.

#. Let :math:`n` be the arity of :math:`L`.

#. Let :math:`{{\mathit{instr}'}^\ast}` be the continuation of :math:`L`.

#. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`0`, then:

  a. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

  #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

  #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

  #. Pop the current label from the stack.

  #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

  #. Execute the instruction :math:`{{\mathit{instr}'}^\ast}`.

#. Else:

  a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

  #. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is greater than or equal to :math:`1`, then:

    1) Let :math:`l` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 0}}} - 1`.

    #) Pop the current label from the stack.

    #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

    #) Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{br\_if}~l`
.........................


1. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c` is not :math:`0`, then:

  a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

  a. Do nothing.


:math:`\mathsf{br\_table}~{l^\ast}~{l'}`
........................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i` is less than :math:`{|{l^\ast}|}`, then:

  a. Execute the instruction :math:`(\mathsf{br}~{l^\ast}{}[i])`.

#. Else:

  a. Execute the instruction :math:`(\mathsf{br}~{l'})`.


:math:`\mathsf{frame}`
......................


1. Let :math:`F` be the current frame.

#. Let :math:`n` be the arity of :math:`F`.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Assert: Due to validation, a frame is now on the top of the stack.

#. Pop the current frame from the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.


:math:`\mathsf{return}`
.......................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. If the top of the stack is a :math:`\mathsf{frame}`, then:

  a. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Let :math:`F` be the current frame.

  #. Let :math:`n` be the arity of :math:`F`.

  #. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

  #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

  #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

  #. Pop the current frame from the stack.

  #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Else if the top of the stack is a :math:`\mathsf{label}`, then:

  a. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

  #. Pop the current label from the stack.

  #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Execute the instruction :math:`\mathsf{return}`.


:math:`t {.} {\mathit{unop}}`
.............................


1. Assert: Due to validation, a value of value type :math:`t` is on the top of the stack.

#. Pop the value :math:`(t{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{unop}}}{{}_{t}}{(c_1)}|}` is less than or equal to :math:`0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{unop}}}{{}_{t}}{(c_1)}`.

#. Push the value :math:`(t{.}\mathsf{const}~c)` to the stack.


:math:`t {.} {\mathit{binop}}`
..............................


1. Assert: Due to validation, a value of value type :math:`t` is on the top of the stack.

#. Pop the value :math:`(t{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`{\mathit{valtype}}_0` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{binop}}}{{}_{t}}{(c_1, c_2)}|}` is less than or equal to :math:`0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{binop}}}{{}_{t}}{(c_1, c_2)}`.

#. Push the value :math:`(t{.}\mathsf{const}~c)` to the stack.


:math:`t {.} {\mathit{testop}}`
...............................


1. Assert: Due to validation, a value of value type :math:`t` is on the top of the stack.

#. Pop the value :math:`(t{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{testop}}}{{}_{t}}{(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`t {.} {\mathit{relop}}`
..............................


1. Assert: Due to validation, a value of value type :math:`t` is on the top of the stack.

#. Pop the value :math:`(t{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`{\mathit{valtype}}_0` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{relop}}}{{}_{t}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`t_2 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{t_1}`
....................................................


1. Assert: Due to validation, a value of value type :math:`t_1` is on the top of the stack.

#. Pop the value :math:`(t_1{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{cvtop}}}{{}_{t_1, t_2}}{(c_1)}|}` is less than or equal to :math:`0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{cvtop}}}{{}_{t_1, t_2}}{(c_1)}`.

#. Push the value :math:`(t_2{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{local{.}tee}~x`
..............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Execute the instruction :math:`(\mathsf{local{.}set}~x)`.


:math:`\mathsf{block}~{t^?}~{{\mathit{instr}}^\ast}`
....................................................


1. Let :math:`n` be :math:`0`.

#. If :math:`{t^?}` is not defined, then:

  a. Let :math:`L` be the label whose arity is :math:`n` and whose continuation is :math:`\epsilon`.

  #. Enter :math:`{{\mathit{instr}}^\ast}` with label :math:`L`.

#. Let :math:`n` be :math:`1`.

#. If :math:`{t^?}` is not :math:`\epsilon`, then:

  a. Let :math:`L` be the label whose arity is :math:`n` and whose continuation is :math:`\epsilon`.

  #. Enter :math:`{{\mathit{instr}}^\ast}` with label :math:`L`.


:math:`\mathsf{loop}~{t^?}~{{\mathit{instr}}^\ast}`
...................................................


1. Let :math:`L` be the label whose arity is :math:`0` and whose continuation is :math:`(\mathsf{loop}~{t^?}~{{\mathit{instr}}^\ast})`.

#. Enter :math:`{{\mathit{instr}}^\ast}` with label :math:`L`.


:math:`\mathsf{call}~x`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x` is less than :math:`{|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Execute the instruction :math:`(\mathsf{call}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x])`.


:math:`\mathsf{call\_indirect}~x`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i` is greater than or equal to :math:`{|z{.}\mathsf{tables}{}[0]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`z{.}\mathsf{tables}{}[0]{.}\mathsf{refs}{}[i]` is not defined, then:

  a. Trap.

#. Let :math:`a` be :math:`z{.}\mathsf{tables}{}[0]{.}\mathsf{refs}{}[i]`.

#. If :math:`a` is greater than or equal to :math:`{|z{.}\mathsf{funcs}|}`, then:

  a. Trap.

#. If :math:`z{.}\mathsf{types}{}[x]` is not :math:`z{.}\mathsf{funcs}{}[a]{.}\mathsf{type}`, then:

  a. Trap.

#. Execute the instruction :math:`(\mathsf{call}~a)`.


:math:`\mathsf{call}~a`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`a` is less than :math:`{|z{.}\mathsf{funcs}|}`.

#. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{t_1^{k}}~\rightarrow~{t_2^{n}},\; \mathsf{module}~{\mathit{mm}},\; \mathsf{code}~{\mathit{func}} \}\end{array}` be :math:`z{.}\mathsf{funcs}{}[a]`.

#. Assert: Due to validation, there are at least :math:`k` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Assert: Due to validation, :math:`{\mathit{func}}` is of the case :math:`\mathsf{func}`.

#. Let :math:`(\mathsf{func}~x~{{\mathit{local}}_0^\ast}~{{\mathit{instr}}^\ast})` be :math:`{\mathit{func}}`.

#. Assert: Due to validation, for all :math:`{({\mathit{local}}_0)^\ast}`, :math:`{\mathit{local}}_0` is of the case :math:`\mathsf{local}`.

#. Let :math:`{(\mathsf{local}~t)^\ast}` be :math:`{{\mathit{local}}_0^\ast}`.

#. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~{{\mathit{val}}^{k}}~{{{\mathrm{default}}}_{t}^\ast},\; \mathsf{module}~{\mathit{mm}} \}\end{array}`.

#. Let :math:`F` be the activation of :math:`f` with arity :math:`n`.

#. Push :math:`F` to the stack.

#. Let :math:`L` be the label whose arity is :math:`n` and whose continuation is :math:`\epsilon`.

#. Enter :math:`{{\mathit{instr}}^\ast}` with label :math:`L`.


:math:`\mathsf{local{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Push the value :math:`z{.}\mathsf{locals}{}[x]` to the stack.


:math:`\mathsf{global{.}get}~x`
...............................


1. Let :math:`z` be the current state.

#. Push the value :math:`z{.}\mathsf{globals}{}[x]{.}\mathsf{value}` to the stack.


:math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}{.}\mathsf{load}~{{\mathit{sz}}_{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}^?}~{\mathit{ao}}`
..........................................................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`{{\mathit{sz}}_{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}^?}` is not defined, then:

  a. Let :math:`t` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|t|} / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

    1) Trap.

  #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{t}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|t|} / 8]`.

  #. Push the value :math:`(t{.}\mathsf{const}~c)` to the stack.

#. If the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Inn, then:

  a. If :math:`{{\mathit{sz}}_{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}^?}` is defined, then:

    1) Let :math:`{\mathit{sz}}_{{\mathit{sx}}_0}` be :math:`{{\mathit{sz}}_{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}^?}`.

    #) Let :math:`(n, {\mathit{sx}})` be :math:`{\mathit{sz}}_{{\mathit{sx}}_0}`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      a) Trap.

  #. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If :math:`{{\mathit{sz}}_{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}^?}` is defined, then:

    1) Let :math:`{\mathit{sz}}_{{\mathit{sx}}_0}` be :math:`{{\mathit{sz}}_{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}^?}`.

    #) Let :math:`(n, {\mathit{sx}})` be :math:`{\mathit{sz}}_{{\mathit{sx}}_0}`.

    #) Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8]`.

    #) Push the value :math:`({\mathsf{i}}{n}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{n, {|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{(c)})` to the stack.


:math:`\mathsf{memory{.}size}`
..............................


1. Let :math:`z` be the current state.

#. Let :math:`n \cdot 64 \cdot {\mathrm{Ki}}` be :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{local{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{locals}{}[x] = {\mathit{val}}]`.


:math:`\mathsf{global{.}set}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = {\mathit{val}}]`.


:math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}{.}\mathsf{store}~{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}~{\mathit{ao}}`
...........................................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Let :math:`t` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|t|} / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}` and :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`t` and :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Trap.

#. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`t` and :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{t}(c)`.

  #. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|t|} / 8] = {b^\ast}]`.

#. If the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathsf{i}}{n}` and :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

    1) Let :math:`n` be :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      a) Trap.

    #) Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}({{\mathrm{wrap}}}_{{|{\mathsf{i}}{n}|}, n}(c))`.

    #) Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8] = {b^\ast}]`.


:math:`\mathsf{memory{.}grow}`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Either:

  a. Let :math:`{\mathit{mi}}` be :math:`{\mathrm{growmemory}}(z{.}\mathsf{mems}{}[0], n)`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|} / 64 \, {\mathrm{Ki}})` to the stack.

  #. Perform :math:`z{}[{.}\mathsf{mems}{}[0] = {\mathit{mi}}]`.

#. Or:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{32}^{{-1}}}}{({-1})})` to the stack.


:math:`{\mathrm{Ki}}`
.....................


1. Return :math:`1024`.


:math:`{\mathrm{min}}(n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}, n_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
............................................................................................................


1. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`0`, then:

  a. Return :math:`0`.

#. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`0`, then:

  a. Return :math:`0`.

#. Assert: Due to validation, :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is greater than or equal to :math:`1`.

#. Let :math:`i` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 0}}} - 1`.

#. Assert: Due to validation, :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is greater than or equal to :math:`1`.

#. Let :math:`j` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}} - 1`.

#. Return :math:`{\mathrm{min}}(i, j)`.


:math:`{\mathrm{sum}}({n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
........................................................................


1. If :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`0`.

#. Let :math:`n~{{n'}^\ast}` be :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`n + {\mathrm{sum}}({{n'}^\ast})`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`
........................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}|}` is :math:`1`.

#. Let :math:`w` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`w`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}`
.....................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is not defined, then:

  a. Return :math:`\epsilon`.

#. Let :math:`w` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}`.

#. Return :math:`w`.


:math:`{\mathrm{concat}}({X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
...........................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{w^\ast}~{{{w'}^\ast}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{w^\ast}~{\mathrm{concat}}({{{w'}^\ast}^\ast})`.


:math:`{\mathrm{signif}}(N_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
....................................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`32`, then:

  a. Return :math:`23`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`64`.

#. Return :math:`52`.


:math:`{\mathrm{expon}}(N_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
...................................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`32`, then:

  a. Return :math:`8`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`64`.

#. Return :math:`11`.


:math:`M`
.........


1. Return :math:`{\mathrm{signif}}(N)`.


:math:`E`
.........


1. Return :math:`{\mathrm{expon}}(N)`.


:math:`{+0}`
............


1. Return :math:`({+((0 + 0 \cdot {2^{{-M}}}) \cdot {2^{n}})})`.


:math:`{+1}`
............


1. Return :math:`({+((1 + 1 \cdot {2^{{-M}}}) \cdot {2^{0}})})`.


:math:`{{\mathrm{canon}}}_{N}`
..............................


1. Return :math:`{2^{{\mathrm{signif}}(N) - 1}}`.


:math:`{|{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}|}`
......................................................................


1. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{i{\scriptstyle 32}}`, then:

  a. Return :math:`32`.

#. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{i{\scriptstyle 64}}`, then:

  a. Return :math:`64`.

#. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{f{\scriptstyle 32}}`, then:

  a. Return :math:`32`.

#. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{f{\scriptstyle 64}}`, then:

  a. Return :math:`64`.


:math:`{\mathrm{funcs}}({{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
..............................................................................................


1. If :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~{\mathit{ft}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{ft}}~{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
................................................................................................


1. If :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~{\mathit{gt}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{gt}}~{\mathrm{globals}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
...............................................................................................


1. If :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~{\mathit{tt}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{tt}}~{\mathrm{tables}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
.............................................................................................


1. If :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~{\mathit{mt}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{mt}}~{\mathrm{mems}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xt}}^\ast})`.






1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{align}~0,\; \mathsf{offset}~0 \}\end{array}`.


:math:`{{\mathrm{signed}}}_{N}(i)`
..................................


1. If :math:`0` is less than or equal to :math:`{2^{N - 1}}`, then:

  a. Return :math:`i`.

#. Assert: Due to validation, :math:`{2^{N - 1}}` is less than or equal to :math:`i`.

#. Assert: Due to validation, :math:`i` is less than :math:`{2^{N}}`.

#. Return :math:`i - {2^{N}}`.


:math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{(i)}`
...............................................


1. Let :math:`j` be the result for which :math:`{{\mathrm{signed}}}_{N}(j)` :math:`=` :math:`i`.

#. Return :math:`j`.


:math:`{{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}}{{}_{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}{({\mathit{val\_u{\kern-0.1em\scriptstyle 3}}})}`
........................................................................................................................................................................


1. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{clz}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{iclz}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ctz}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{ictz}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{popcnt}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{ipopcnt}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{abs}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{fabs}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{neg}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{fneg}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{sqrt}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{fsqrt}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ceil}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{fceil}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{floor}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{ffloor}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{trunc}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{ftrunc}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}})`.

#. Assert: Due to validation, :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{nearest}`.

#. Assert: Due to validation, the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

#. Return :math:`{{\mathrm{fnearest}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}})`.


:math:`{{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}}{{}_{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}{({\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}, {\mathit{val\_u{\kern-0.1em\scriptstyle 5}}})}`
.......................................................................................................................................................................................................................


1. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{add}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{iadd}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{sub}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{isub}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{mul}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{imul}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{div}`, then:

    1) Let :math:`({\mathsf{div}}{{\mathit{sx}}})` be :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{{{\mathrm{idiv}}}_{{|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{rem}`, then:

    1) Let :math:`({\mathsf{rem}}{{\mathit{sx}}})` be :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{{{\mathrm{irem}}}_{{|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{and}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{iand}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{or}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{ior}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{xor}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{ixor}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{shl}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{ishl}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{shr}`, then:

    1) Let :math:`({\mathsf{shr}}{{\mathit{sx}}})` be :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{{{\mathrm{ishr}}}_{{|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{rotl}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{irotl}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{rotr}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{irotr}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{add}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fadd}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{sub}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fsub}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{mul}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fmul}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{div}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fdiv}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{min}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fmin}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{max}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fmax}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{copysign}`.

#. Assert: Due to validation, the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

#. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

#. Return :math:`{{\mathrm{fcopysign}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.


:math:`{\mathsf{eqz}}{{}_{{\mathsf{i}}{n}}}{({\mathit{iN}})}`
.............................................................


1. Return :math:`{{\mathrm{ieqz}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}})`.


:math:`{{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}}{{}_{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}{({\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}, {\mathit{val\_u{\kern-0.1em\scriptstyle 5}}})}`
.......................................................................................................................................................................................................................


1. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{eq}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{ieq}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ne}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{ine}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{lt}`, then:

    1) Let :math:`({\mathsf{lt}}{{\mathit{sx}}})` be :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{{{\mathrm{ilt}}}_{{|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{gt}`, then:

    1) Let :math:`({\mathsf{gt}}{{\mathit{sx}}})` be :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{{{\mathrm{igt}}}_{{|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{le}`, then:

    1) Let :math:`({\mathsf{le}}{{\mathit{sx}}})` be :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{{{\mathrm{ile}}}_{{|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ge}`, then:

    1) Let :math:`({\mathsf{ge}}{{\mathit{sx}}})` be :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{{{\mathrm{ige}}}_{{|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

#. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{eq}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{feq}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ne}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fne}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{lt}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{flt}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{gt}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fgt}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{le}` and the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fle}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ge}`.

#. Assert: Due to validation, the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 3}}}`.

#. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 5}}}`.

#. Return :math:`{{\mathrm{fge}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.


:math:`{{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}}{{}_{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}, {\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}{({\mathit{val\_u{\kern-0.1em\scriptstyle 4}}})}`
...............................................................................................................................................................................................................................................


1. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{i{\scriptstyle 32}}` and :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{i{\scriptstyle 64}}`, then:

  a. Let :math:`{\mathit{iN}}` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 4}}}`.

  #. If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is of the case :math:`\mathsf{extend}`, then:

    1) Let :math:`(\mathsf{extend}~{\mathit{sx}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

    #) Return :math:`{{{{\mathrm{extend}}}_{32, 64}^{{\mathit{sx}}}}}{({\mathit{iN}})}`.

#. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{i{\scriptstyle 64}}` and :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{i{\scriptstyle 32}}` and :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is :math:`\mathsf{wrap}`, then:

  a. Let :math:`{\mathit{iN}}` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 4}}}`.

  #. Return :math:`{{\mathrm{wrap}}}_{64, 32}({\mathit{iN}})`.

#. If the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

    1) Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Let :math:`{\mathit{fN}}` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 4}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is of the case :math:`\mathsf{trunc}`, then:

      a) Let :math:`(\mathsf{trunc}~{\mathit{sx}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

      #) Return :math:`{{{{\mathrm{trunc}}}_{{|{\mathsf{f}}{n}|}, {|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{fN}})}`.

#. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{f{\scriptstyle 32}}` and :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{f{\scriptstyle 64}}` and :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is :math:`\mathsf{promote}`, then:

  a. Let :math:`{\mathit{fN}}` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 4}}}`.

  #. Return :math:`{{\mathrm{promote}}}_{32, 64}({\mathit{fN}})`.

#. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{f{\scriptstyle 64}}` and :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{f{\scriptstyle 32}}` and :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is :math:`\mathsf{demote}`, then:

  a. Let :math:`{\mathit{fN}}` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 4}}}`.

  #. Return :math:`{{\mathrm{demote}}}_{64, 32}({\mathit{fN}})`.

#. If the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Inn, then:

    1) Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

    #) Let :math:`{\mathit{iN}}` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 4}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is of the case :math:`\mathsf{convert}`, then:

      a) Let :math:`(\mathsf{convert}~{\mathit{sx}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

      #) Return :math:`{{{{\mathrm{convert}}}_{{|{\mathsf{i}}{n}|}, {|{\mathsf{f}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}})}`.

#. Assert: Due to validation, :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is :math:`\mathsf{reinterpret}`.

#. If the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Inn, then:

    1) Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

    #) Let :math:`{\mathit{iN}}` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 4}}}`.

    #) If :math:`{|{\mathsf{i}}{n}|}` is :math:`{|{\mathsf{f}}{n}|}`, then:

      a) Return :math:`{{\mathrm{reinterpret}}}_{{\mathsf{i}}{n}, {\mathsf{f}}{n}}({\mathit{iN}})`.

#. Assert: Due to validation, the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Assert: Due to validation, the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn.

#. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}` be :math:`{\mathit{val\_u{\kern-0.1em\scriptstyle 4}}}`.

#. Assert: Due to validation, :math:`{|{\mathsf{i}}{n}|}` is :math:`{|{\mathsf{f}}{n}|}`.

#. Return :math:`{{\mathrm{reinterpret}}}_{{\mathsf{f}}{n}, {\mathsf{i}}{n}}({\mathit{fN}})`.


:math:`{{\mathrm{invibytes}}}_{N}({b^\ast})`
............................................


1. Let :math:`n` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(n)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`n`.


:math:`{{\mathrm{invfbytes}}}_{N}({b^\ast})`
............................................


1. Let :math:`p` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{f}}{N}}(p)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`p`.


:math:`{{\mathrm{default}}}_{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}`
.........................................................................................


1. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{i{\scriptstyle 32}}`, then:

  a. Return :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)`.

#. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{i{\scriptstyle 64}}`, then:

  a. Return :math:`(\mathsf{i{\scriptstyle 64}}{.}\mathsf{const}~0)`.

#. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{f{\scriptstyle 32}}`, then:

  a. Return :math:`(\mathsf{f{\scriptstyle 32}}{.}\mathsf{const}~{+0})`.

#. Assert: Due to validation, :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{f{\scriptstyle 64}}`.

#. Return :math:`(\mathsf{f{\scriptstyle 64}}{.}\mathsf{const}~{+0})`.


:math:`{\mathrm{funcs}}({{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
..............................................................................................


1. If :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~{\mathit{fa}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{fa}}~{\mathrm{funcs}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
................................................................................................


1. If :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~{\mathit{ga}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ga}}~{\mathrm{globals}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
...............................................................................................


1. If :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~{\mathit{ta}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ta}}~{\mathrm{tables}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
.............................................................................................


1. If :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~{\mathit{ma}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ma}}~{\mathrm{mems}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{store}}`
........................


1. Return.


:math:`{\mathrm{frame}}`
........................


1. Let :math:`f` be the current frame.

#. Return :math:`f`.


:math:`{\mathrm{funcaddr}}`
...........................


1. Let :math:`f` be the current frame.

#. Return :math:`f{.}\mathsf{module}{.}\mathsf{funcs}`.


:math:`{\mathrm{funcinst}}`
...........................


1. Return :math:`s{.}\mathsf{funcs}`.


:math:`{\mathrm{globalinst}}`
.............................


1. Return :math:`s{.}\mathsf{globals}`.


:math:`{\mathrm{tableinst}}`
............................


1. Return :math:`s{.}\mathsf{tables}`.


:math:`{\mathrm{meminst}}`
..........................


1. Return :math:`s{.}\mathsf{mems}`.


:math:`{\mathrm{moduleinst}}`
.............................


1. Let :math:`f` be the current frame.

#. Return :math:`f{.}\mathsf{module}`.


:math:`{\mathrm{type}}(x)`
..........................


1. Let :math:`f` be the current frame.

#. Return :math:`f{.}\mathsf{module}{.}\mathsf{types}{}[x]`.


:math:`{\mathrm{func}}(x)`
..........................


1. Let :math:`f` be the current frame.

#. Return :math:`s{.}\mathsf{funcs}{}[f{.}\mathsf{module}{.}\mathsf{funcs}{}[x]]`.


:math:`{\mathrm{global}}(x)`
............................


1. Let :math:`f` be the current frame.

#. Return :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]`.


:math:`{\mathrm{table}}(x)`
...........................


1. Let :math:`f` be the current frame.

#. Return :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]`.


:math:`{\mathrm{mem}}(x)`
.........................


1. Let :math:`f` be the current frame.

#. Return :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]`.


:math:`{\mathrm{local}}(x)`
...........................


1. Let :math:`f` be the current frame.

#. Return :math:`f{.}\mathsf{locals}{}[x]`.


:math:`{\mathrm{with}}_{\mathit{local}}(x, v)`
..............................................


1. Let :math:`f` be the current frame.

#. Replace :math:`f{.}\mathsf{locals}{}[x]` with :math:`v`.


:math:`{\mathrm{with}}_{\mathit{global}}(x, v)`
...............................................


1. Let :math:`f` be the current frame.

#. Replace :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]{.}\mathsf{value}` with :math:`v`.


:math:`{\mathrm{with}}_{\mathit{table}}(x, i, a)`
.................................................


1. Let :math:`f` be the current frame.

#. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]{.}\mathsf{refs}{}[i]` with :math:`a`.


:math:`{\mathrm{with}}_{\mathit{tableinst}}(x, {\mathit{ti}})`
..............................................................


1. Let :math:`f` be the current frame.

#. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]` with :math:`{\mathit{ti}}`.


:math:`{\mathrm{with}}_{\mathit{mem}}(x, i, j, {b^\ast})`
.........................................................


1. Let :math:`f` be the current frame.

#. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]{.}\mathsf{bytes}{}[i : j]` with :math:`{b^\ast}`.


:math:`{\mathrm{with}}_{\mathit{meminst}}(x, {\mathit{mi}})`
............................................................


1. Let :math:`f` be the current frame.

#. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]` with :math:`{\mathit{mi}}`.


:math:`{\mathrm{growtable}}({\mathit{ti}}, n)`
..............................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~(i, j),\; \mathsf{refs}~{a^\ast} \}\end{array}` be :math:`{\mathit{ti}}`.

#. Let :math:`{i'}` be :math:`{|{a^\ast}|} + n`.

#. If :math:`{i'}` is less than or equal to :math:`j`, then:

  a. Let :math:`{\mathit{ti}'}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({i'}, j),\; \mathsf{refs}~{a^\ast}~{\epsilon^{n}} \}\end{array}`.

  #. Return :math:`{\mathit{ti}'}`.


:math:`{\mathrm{growmemory}}({\mathit{mi}}, n)`
...............................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~(i, j),\; \mathsf{bytes}~{b^\ast} \}\end{array}` be :math:`{\mathit{mi}}`.

#. Let :math:`{i'}` be :math:`{|{b^\ast}|} / 64 \, {\mathrm{Ki}} + n`.

#. If :math:`{i'}` is less than or equal to :math:`j`, then:

  a. Let :math:`{\mathit{mi}'}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({i'}, j),\; \mathsf{bytes}~{b^\ast}~{0^{n \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

  #. Return :math:`{\mathit{mi}'}`.


:math:`{\mathrm{funcs}}({{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
..............................................................................................


1. If :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~{\mathit{fa}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{fa}}~{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
................................................................................................


1. If :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~{\mathit{ga}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ga}}~{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
...............................................................................................


1. If :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~{\mathit{ta}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ta}}~{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
.............................................................................................


1. If :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~{\mathit{ma}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ma}}~{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{allocfunc}}({\mathit{moduleinst}}, {\mathit{func}})`
....................................................................


1. Assert: Due to validation, :math:`{\mathit{func}}` is of the case :math:`\mathsf{func}`.

#. Let :math:`(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}})` be :math:`{\mathit{func}}`.

#. Let :math:`{\mathit{fi}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{moduleinst}}{.}\mathsf{types}{}[x],\; \mathsf{module}~{\mathit{moduleinst}},\; \mathsf{code}~{\mathit{func}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{funcs}|}`.

#. Append :math:`{\mathit{fi}}` to the :math:`s{.}\mathsf{funcs}`.

#. Return :math:`a`.


:math:`{\mathrm{allocfuncs}}({\mathit{moduleinst}}, {{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
....................................................................................................................


1. If :math:`{{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{func}}~{{\mathit{func}'}^\ast}` be :math:`{{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Let :math:`{\mathit{fa}}` be :math:`{\mathrm{allocfunc}}({\mathit{moduleinst}}, {\mathit{func}})`.

#. Let :math:`{{\mathit{fa}'}^\ast}` be :math:`{\mathrm{allocfuncs}}({\mathit{moduleinst}}, {{\mathit{func}'}^\ast})`.

#. Return :math:`{\mathit{fa}}~{{\mathit{fa}'}^\ast}`.


:math:`{\mathrm{allocglobal}}({\mathit{globaltype}}, {\mathit{val}})`
.....................................................................


1. Let :math:`{\mathit{gi}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{globaltype}},\; \mathsf{value}~{\mathit{val}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{globals}|}`.

#. Append :math:`{\mathit{gi}}` to the :math:`s{.}\mathsf{globals}`.

#. Return :math:`a`.


:math:`{\mathrm{allocglobals}}({{\mathit{globaltype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}, {{\mathit{val}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
....................................................................................................................................................................


1. If :math:`{{\mathit{globaltype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Assert: Due to validation, :math:`{{\mathit{val}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\epsilon`.

  #. Return :math:`\epsilon`.

#. Else:

  a. Let :math:`{\mathit{globaltype}}~{{\mathit{globaltype}'}^\ast}` be :math:`{{\mathit{globaltype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

  #. Assert: Due to validation, :math:`{|{{\mathit{val}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|}` is greater than or equal to :math:`1`.

  #. Let :math:`{\mathit{val}}~{{\mathit{val}'}^\ast}` be :math:`{{\mathit{val}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

  #. Let :math:`{\mathit{ga}}` be :math:`{\mathrm{allocglobal}}({\mathit{globaltype}}, {\mathit{val}})`.

  #. Let :math:`{{\mathit{ga}'}^\ast}` be :math:`{\mathrm{allocglobals}}({{\mathit{globaltype}'}^\ast}, {{\mathit{val}'}^\ast})`.

  #. Return :math:`{\mathit{ga}}~{{\mathit{ga}'}^\ast}`.


:math:`{\mathrm{alloctable}}((i, j))`
.....................................


1. Let :math:`{\mathit{ti}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~(i, j),\; \mathsf{refs}~{\epsilon^{i}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{tables}|}`.

#. Append :math:`{\mathit{ti}}` to the :math:`s{.}\mathsf{tables}`.

#. Return :math:`a`.


:math:`{\mathrm{alloctables}}({{\mathit{tabletype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
...................................................................................................


1. If :math:`{{\mathit{tabletype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{tabletype}}~{{\mathit{tabletype}'}^\ast}` be :math:`{{\mathit{tabletype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Let :math:`{\mathit{ta}}` be :math:`{\mathrm{alloctable}}({\mathit{tabletype}})`.

#. Let :math:`{{\mathit{ta}'}^\ast}` be :math:`{\mathrm{alloctables}}({{\mathit{tabletype}'}^\ast})`.

#. Return :math:`{\mathit{ta}}~{{\mathit{ta}'}^\ast}`.


:math:`{\mathrm{allocmem}}((i, j))`
...................................


1. Let :math:`{\mathit{mi}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~(i, j),\; \mathsf{bytes}~{0^{i \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{mems}|}`.

#. Append :math:`{\mathit{mi}}` to the :math:`s{.}\mathsf{mems}`.

#. Return :math:`a`.


:math:`{\mathrm{allocmems}}({{\mathit{memtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
...............................................................................................


1. If :math:`{{\mathit{memtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{memtype}}~{{\mathit{memtype}'}^\ast}` be :math:`{{\mathit{memtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Let :math:`{\mathit{ma}}` be :math:`{\mathrm{allocmem}}({\mathit{memtype}})`.

#. Let :math:`{{\mathit{ma}'}^\ast}` be :math:`{\mathrm{allocmems}}({{\mathit{memtype}'}^\ast})`.

#. Return :math:`{\mathit{ma}}~{{\mathit{ma}'}^\ast}`.


:math:`{\mathrm{instexport}}({{\mathit{fa}}^\ast}, {{\mathit{ga}}^\ast}, {{\mathit{ta}}^\ast}, {{\mathit{ma}}^\ast}, (\mathsf{export}~{\mathit{name}}~{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}))`
.....................................................................................................................................................................................................................


1. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{func}~{{\mathit{fa}}^\ast}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{global}~{{\mathit{ga}}^\ast}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{table}~{{\mathit{ta}}^\ast}{}[x]) \}\end{array}`.

#. Assert: Due to validation, :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{mem}`.

#. Let :math:`(\mathsf{mem}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{mem}~{{\mathit{ma}}^\ast}{}[x]) \}\end{array}`.


:math:`{\mathrm{allocmodule}}({\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}^\ast})`
......................................................................................................


1. Let :math:`{{\mathit{fa}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ga}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{globals}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ma}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{mems}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ta}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{tables}}({{\mathit{externaddr}}^\ast})`.

#. Assert: Due to validation, :math:`{\mathit{module}}` is of the case :math:`\mathsf{module}`.

#. Let :math:`(\mathsf{module}~{{\mathit{type}}_0^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^{n_{\mathit{func}}}}~{{\mathit{global}}_1^{n_{\mathit{global}}}}~{{\mathit{table}}_2^{n_{\mathit{table}}}}~{{\mathit{mem}}_3^{n_{\mathit{mem}}}}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be :math:`{\mathit{module}}`.

#. Assert: Due to validation, for all :math:`{({\mathit{mem}}_3)^{n_{\mathit{mem}}}}`, :math:`{\mathit{mem}}_3` is of the case :math:`\mathsf{memory}`.

#. Let :math:`{(\mathsf{memory}~{\mathit{memtype}})^{n_{\mathit{mem}}}}` be :math:`{{\mathit{mem}}_3^{n_{\mathit{mem}}}}`.

#. Assert: Due to validation, for all :math:`{({\mathit{table}}_2)^{n_{\mathit{table}}}}`, :math:`{\mathit{table}}_2` is of the case :math:`\mathsf{table}`.

#. Let :math:`{(\mathsf{table}~{\mathit{tabletype}})^{n_{\mathit{table}}}}` be :math:`{{\mathit{table}}_2^{n_{\mathit{table}}}}`.

#. Assert: Due to validation, for all :math:`{({\mathit{global}}_1)^{n_{\mathit{global}}}}`, :math:`{\mathit{global}}_1` is of the case :math:`\mathsf{global}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_1)^{n_{\mathit{global}}}}` be :math:`{{\mathit{global}}_1^{n_{\mathit{global}}}}`.

#. Assert: Due to validation, for all :math:`{({\mathit{type}}_0)^\ast}`, :math:`{\mathit{type}}_0` is of the case :math:`\mathsf{type}`.

#. Let :math:`{(\mathsf{type}~{\mathit{ft}})^\ast}` be :math:`{{\mathit{type}}_0^\ast}`.

#. Let :math:`{{\mathit{fa}}^\ast}` be :math:`{{|s{.}\mathsf{funcs}|} + i_{\mathit{func}}^{i_{\mathit{func}}<n_{\mathit{func}}}}`.

#. Let :math:`{{\mathit{ga}}^\ast}` be :math:`{{|s{.}\mathsf{globals}|} + i_{\mathit{global}}^{i_{\mathit{global}}<n_{\mathit{global}}}}`.

#. Let :math:`{{\mathit{ta}}^\ast}` be :math:`{{|s{.}\mathsf{tables}|} + i_{\mathit{table}}^{i_{\mathit{table}}<n_{\mathit{table}}}}`.

#. Let :math:`{{\mathit{ma}}^\ast}` be :math:`{{|s{.}\mathsf{mems}|} + i_{\mathit{mem}}^{i_{\mathit{mem}}<n_{\mathit{mem}}}}`.

#. Let :math:`{{\mathit{xi}}^\ast}` be :math:`{{\mathrm{instexport}}({{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast}, {{\mathit{ga}}_{\mathit{ex}}^\ast}~{{\mathit{ga}}^\ast}, {{\mathit{ta}}_{\mathit{ex}}^\ast}~{{\mathit{ta}}^\ast}, {{\mathit{ma}}_{\mathit{ex}}^\ast}~{{\mathit{ma}}^\ast}, {\mathit{export}})^\ast}`.

#. Let :math:`{\mathit{moduleinst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}}^\ast},\; \mathsf{funcs}~{{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast},\; \mathsf{globals}~{{\mathit{ga}}_{\mathit{ex}}^\ast}~{{\mathit{ga}}^\ast},\; \mathsf{tables}~{{\mathit{ta}}_{\mathit{ex}}^\ast}~{{\mathit{ta}}^\ast},\; \mathsf{mems}~{{\mathit{ma}}_{\mathit{ex}}^\ast}~{{\mathit{ma}}^\ast},\; \mathsf{exports}~{{\mathit{xi}}^\ast} \}\end{array}`.

#. Let :math:`{\mathit{funcaddr}}_0` be :math:`{\mathrm{allocfuncs}}({\mathit{moduleinst}}, {{\mathit{func}}^{n_{\mathit{func}}}})`.

#. Assert: Due to validation, :math:`{\mathit{funcaddr}}_0` is :math:`{{\mathit{fa}}^\ast}`.

#. Let :math:`{\mathit{globaladdr}}_0` be :math:`{\mathrm{allocglobals}}({{\mathit{globaltype}}^{n_{\mathit{global}}}}, {{\mathit{val}}^\ast})`.

#. Assert: Due to validation, :math:`{\mathit{globaladdr}}_0` is :math:`{{\mathit{ga}}^\ast}`.

#. Let :math:`{\mathit{tableaddr}}_0` be :math:`{\mathrm{alloctables}}({{\mathit{tabletype}}^{n_{\mathit{table}}}})`.

#. Assert: Due to validation, :math:`{\mathit{tableaddr}}_0` is :math:`{{\mathit{ta}}^\ast}`.

#. Let :math:`{\mathit{memaddr}}_0` be :math:`{\mathrm{allocmems}}({{\mathit{memtype}}^{n_{\mathit{mem}}}})`.

#. Assert: Due to validation, :math:`{\mathit{memaddr}}_0` is :math:`{{\mathit{ma}}^\ast}`.

#. Return :math:`{\mathit{moduleinst}}`.


:math:`{\mathrm{initelem}}({\mathit{moduleinst}}, {{\mathit{u{\kern-0.1em\scriptstyle 32}}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}, {{\mathit{funcaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
...............................................................................................................................................................................................................


1. If :math:`{{\mathit{u{\kern-0.1em\scriptstyle 32}}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon` and :math:`{{\mathit{funcaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\epsilon`, then:

  a. Return.

#. Assert: Due to validation, :math:`{|{{\mathit{funcaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|}` is greater than or equal to :math:`1`.

#. Let :math:`{a^\ast}~{{{a'}^\ast}^\ast}` be :math:`{{\mathit{funcaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{u{\kern-0.1em\scriptstyle 32}}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}|}` is greater than or equal to :math:`1`.

#. Let :math:`i~{{i'}^\ast}` be :math:`{{\mathit{u{\kern-0.1em\scriptstyle 32}}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Replace :math:`s{.}\mathsf{tables}{}[{\mathit{moduleinst}}{.}\mathsf{tables}{}[0]]{.}\mathsf{refs}{}[i : {|{a^\ast}|}]` with :math:`{a^\ast}`.

#. Perform :math:`{\mathrm{initelem}}({\mathit{moduleinst}}, {{i'}^\ast}, {{{a'}^\ast}^\ast})`.

#. Return.


:math:`{\mathrm{initdata}}({\mathit{moduleinst}}, {{\mathit{u{\kern-0.1em\scriptstyle 32}}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}, {{\mathit{byte}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
...........................................................................................................................................................................................................


1. If :math:`{{\mathit{u{\kern-0.1em\scriptstyle 32}}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon` and :math:`{{\mathit{byte}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\epsilon`, then:

  a. Return.

#. Assert: Due to validation, :math:`{|{{\mathit{byte}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|}` is greater than or equal to :math:`1`.

#. Let :math:`{b^\ast}~{{{b'}^\ast}^\ast}` be :math:`{{\mathit{byte}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{u{\kern-0.1em\scriptstyle 32}}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}|}` is greater than or equal to :math:`1`.

#. Let :math:`i~{{i'}^\ast}` be :math:`{{\mathit{u{\kern-0.1em\scriptstyle 32}}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Replace :math:`s{.}\mathsf{mems}{}[{\mathit{moduleinst}}{.}\mathsf{mems}{}[0]]{.}\mathsf{bytes}{}[i : {|{b^\ast}|}]` with :math:`{b^\ast}`.

#. Perform :math:`{\mathrm{initdata}}({\mathit{moduleinst}}, {{i'}^\ast}, {{{b'}^\ast}^\ast})`.

#. Return.


:math:`{\mathrm{instantiate}}(z, {\mathit{module}}, {{\mathit{externaddr}}^\ast})`
..................................................................................


1. Assert: Due to validation, :math:`{\mathit{module}}` is of the case :math:`\mathsf{module}`.

#. Let :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be :math:`{\mathit{module}}`.

#. Assert: Due to validation, for all :math:`{({\mathit{type}})^\ast}`, :math:`{\mathit{type}}` is of the case :math:`\mathsf{type}`.

#. Let :math:`{(\mathsf{type}~{\mathit{functype}})^\ast}` be :math:`{{\mathit{type}}^\ast}`.

#. Let :math:`n_{\mathsf{f}}` be :math:`{|{{\mathit{func}}^\ast}|}`.

#. Assert: Due to validation, for all :math:`{({\mathit{start}})^?}`, :math:`{\mathit{start}}` is of the case :math:`\mathsf{start}`.

#. Let :math:`{(\mathsf{start}~{x'})^?}` be :math:`{{\mathit{start}}^?}`.

#. Assert: Due to validation, for all :math:`{({\mathit{data}})^\ast}`, :math:`{\mathit{data}}` is of the case :math:`\mathsf{data}`.

#. Let :math:`{(\mathsf{data}~{\mathit{expr}}_{\mathsf{d}}~{b^\ast})^\ast}` be :math:`{{\mathit{data}}^\ast}`.

#. Assert: Due to validation, for all :math:`{({\mathit{elem}})^\ast}`, :math:`{\mathit{elem}}` is of the case :math:`\mathsf{elem}`.

#. Let :math:`{(\mathsf{elem}~{\mathit{expr}}_{\mathsf{e}}~{x^\ast})^\ast}` be :math:`{{\mathit{elem}}^\ast}`.

#. Assert: Due to validation, for all :math:`{({\mathit{global}})^\ast}`, :math:`{\mathit{global}}` is of the case :math:`\mathsf{global}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_{\mathsf{g}})^\ast}` be :math:`{{\mathit{global}}^\ast}`.

#. Let :math:`{\mathit{moduleinst}}_{\mathit{init}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{functype}}^\ast},\; \mathsf{funcs}~{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})~{{|s{.}\mathsf{funcs}|} + i_{\mathsf{f}}^{i_{\mathsf{f}}<n_{\mathsf{f}}}},\; \mathsf{globals}~{\mathrm{globals}}({{\mathit{externaddr}}^\ast}),\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{exports}~\epsilon \}\end{array}`.

#. Let :math:`f_{\mathit{init}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~\epsilon,\; \mathsf{module}~{\mathit{moduleinst}}_{\mathit{init}} \}\end{array}`.

#. Let :math:`z` be :math:`f_{\mathit{init}}`.

#. Push the activation of :math:`z` to the stack.

#. Let :math:`{(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_{\mathsf{d}})^\ast}` be :math:`{{\mathrm{eval}}_{\mathit{expr}}({\mathit{expr}}_{\mathsf{d}})^\ast}`.

#. Pop the activation of :math:`f` from the stack.

#. Push the activation of :math:`z` to the stack.

#. Let :math:`{(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_{\mathsf{e}})^\ast}` be :math:`{{\mathrm{eval}}_{\mathit{expr}}({\mathit{expr}}_{\mathsf{e}})^\ast}`.

#. Pop the activation of :math:`f` from the stack.

#. Push the activation of :math:`z` to the stack.

#. Let :math:`{{\mathit{val}}^\ast}` be :math:`{{\mathrm{eval}}_{\mathit{expr}}({\mathit{expr}}_{\mathsf{g}})^\ast}`.

#. Pop the activation of :math:`f` from the stack.

#. Let :math:`{\mathit{moduleinst}}` be :math:`{\mathrm{allocmodule}}({\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}^\ast})`.

#. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~\epsilon,\; \mathsf{module}~{\mathit{moduleinst}} \}\end{array}`.

#. Perform :math:`{\mathrm{initelem}}({\mathit{moduleinst}}, {i_{\mathsf{e}}^\ast}, {{{\mathit{moduleinst}}{.}\mathsf{funcs}{}[x]^\ast}^\ast})`.

#. Perform :math:`{\mathrm{initdata}}({\mathit{moduleinst}}, {i_{\mathsf{d}}^\ast}, {{b^\ast}^\ast})`.

#. Push the activation of :math:`f` with arity :math:`0` to the stack.

#. If :math:`{(\mathsf{call}~{x'})^?}` is defined, then:

  a. Execute the instruction :math:`(\mathsf{call}~{x'})`.

#. Pop the activation of :math:`f` with arity :math:`0` from the stack.

#. Return :math:`f{.}\mathsf{module}`.


:math:`{\mathrm{invoke}}(z, {\mathit{fa}}, {{\mathit{val}}^{n}})`
.................................................................


1. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~\epsilon,\; \mathsf{module}~\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{exports}~\epsilon \}\end{array} \}\end{array}`.

#. Push the activation of :math:`f` to the stack.

#. Let :math:`{t_1^{n}}~\rightarrow~{t_2^\ast}` be :math:`z{.}\mathsf{funcs}{}[{\mathit{fa}}]{.}\mathsf{type}`.

#. Pop the activation of :math:`f` from the stack.

#. Let :math:`k` be :math:`{|{t_2^\ast}|}`.

#. Push the activation of :math:`f` with arity :math:`k` to the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{call}~{\mathit{fa}})`.

#. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Pop the activation of :math:`f` with arity :math:`k` from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Return :math:`{{\mathit{val}}^{k}}`.


:math:`{\mathrm{eval}}_{\mathit{expr}}({{\mathit{instr}}^\ast})`
................................................................


1. Execute the instruction :math:`{{\mathit{instr}}^\ast}`.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Return :math:`{\mathit{val}}`.


== Complete.
watsup 0.4 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...
Limits_ok
- the limits (n, m) is valid with the nat k if:
  - n is less than or equal to m.
  - m is less than or equal to k.

Functype_ok
- the function type t_1* -> t_2? is valid.

Globaltype_ok
- the global type ((MUT ()? ?) t) is valid.

Tabletype_ok
- the table type limits is valid if:
  - the limits limits is valid with the nat ((2 ^ 32) - 1).

Memtype_ok
- the memory type limits is valid if:
  - the limits limits is valid with the nat (2 ^ 16).

Externtype_ok
- the external type externtype_u0 is valid if:
  - Either:
    - externtype_u0 is (FUNC functype).
    - the function type functype is valid.
  - Or:
    - externtype_u0 is (GLOBAL globaltype).
    - the global type globaltype is valid.
  - Or:
    - externtype_u0 is (TABLE tabletype).
    - the table type tabletype is valid.
  - Or:
    - externtype_u0 is (MEM memtype).
    - the memory type memtype is valid.

Limits_sub
- the limits (n_11, n_12) matches the limits (n_21, n_22) if:
  - n_11 is greater than or equal to n_21.
  - n_12 is less than or equal to n_22.

Functype_sub
- the function type ft matches the function type ft.

Globaltype_sub
- the global type gt matches the global type gt.

Tabletype_sub
- the table type lim_1 matches the table type lim_2 if:
  - the limits lim_1 matches the limits lim_2.

Memtype_sub
- the memory type lim_1 matches the memory type lim_2 if:
  - the limits lim_1 matches the limits lim_2.

Externtype_sub
- the external type externtype_u0 matches the external type externtype_u1 if:
  - Either:
    - externtype_u0 is (FUNC ft_1).
    - externtype_u1 is (FUNC ft_2).
    - the function type ft_1 matches the function type ft_2.
  - Or:
    - externtype_u0 is (GLOBAL gt_1).
    - externtype_u1 is (GLOBAL gt_2).
    - the global type gt_1 matches the global type gt_2.
  - Or:
    - externtype_u0 is (TABLE tt_1).
    - externtype_u1 is (TABLE tt_2).
    - the table type tt_1 matches the table type tt_2.
  - Or:
    - externtype_u0 is (MEM mt_1).
    - externtype_u1 is (MEM mt_2).
    - the memory type mt_1 matches the memory type mt_2.

Instr_ok/nop
- the instruction NOP is valid with the function type [] -> [].

Instr_ok/unreachable
- the instruction UNREACHABLE is valid with the function type t_1* -> t_2*.

Instr_ok/drop
- the instruction DROP is valid with the function type [t] -> [].

Instr_ok/select
- the instruction SELECT is valid with the function type [t, t, I32] -> [t].

Instr_ok/block
- the instruction (BLOCK t? instr*) is valid with the function type [] -> t? if:
  - Under the context C with .LABELS prepended by [t?], the instruction sequence instr* is valid with the function type [] -> t?.

Instr_ok/loop
- the instruction (LOOP t? instr*) is valid with the function type [] -> t? if:
  - Under the context C with .LABELS prepended by [?()], the instruction sequence instr* is valid with the function type [] -> [].

Instr_ok/if
- the instruction (IF t? instr_1* ELSE instr_2*) is valid with the function type [I32] -> t? if:
  - Under the context C with .LABELS prepended by [t?], the instruction sequence instr_1* is valid with the function type [] -> t?.
  - Under the context C with .LABELS prepended by [t?], the instruction sequence instr_2* is valid with the function type [] -> t?.

Instr_ok/br
- the instruction (BR l) is valid with the function type t_1* :: t? -> t_2* if:
  - |C.LABELS| is greater than l.
  - C.LABELS[l] is t?.

Instr_ok/br_if
- the instruction (BR_IF l) is valid with the function type t? :: [I32] -> t? if:
  - |C.LABELS| is greater than l.
  - C.LABELS[l] is t?.

Instr_ok/br_table
- the instruction (BR_TABLE l* l') is valid with the function type t_1* :: t? -> t_2* if:
  - |C.LABELS| is greater than l'.
  - t? is C.LABELS[l'].
  - For all l in l*, |C.LABELS| is greater than l.
  - For all l in l*, t? is C.LABELS[l].

Instr_ok/call
- the instruction (CALL x) is valid with the function type t_1* -> t_2? if:
  - |C.FUNCS| is greater than x.
  - C.FUNCS[x] is t_1* -> t_2?.

Instr_ok/call_indirect
- the instruction (CALL_INDIRECT x) is valid with the function type t_1* :: [I32] -> t_2? if:
  - |C.TYPES| is greater than x.
  - C.TYPES[x] is t_1* -> t_2?.

Instr_ok/return
- the instruction RETURN is valid with the function type t_1* :: t? -> t_2* if:
  - C.RETURN is ?(t?).

Instr_ok/const
- the instruction (t.CONST c_t) is valid with the function type [] -> [t].

Instr_ok/unop
- the instruction (UNOP t unop_t) is valid with the function type [t] -> [t].

Instr_ok/binop
- the instruction (BINOP t binop_t) is valid with the function type [t, t] -> [t].

Instr_ok/testop
- the instruction (TESTOP t testop_t) is valid with the function type [t] -> [I32].

Instr_ok/relop
- the instruction (RELOP t relop_t) is valid with the function type [t, t] -> [I32].

Instr_ok/cvtop
- the instruction (CVTOP nt_1 nt_2 cvtop_u0) is valid with the function type [nt_2] -> [nt_1] if:
  - Either:
    - cvtop_u0 is REINTERPRET.
    - $size(nt_1) is $size(nt_2).
  - Or: cvtop_u0 is cvtop.

Instr_ok/local.get
- the instruction (LOCAL.GET x) is valid with the function type [] -> [t] if:
  - |C.LOCALS| is greater than x.
  - C.LOCALS[x] is t.

Instr_ok/local.set
- the instruction (LOCAL.SET x) is valid with the function type [t] -> [] if:
  - |C.LOCALS| is greater than x.
  - C.LOCALS[x] is t.

Instr_ok/local.tee
- the instruction (LOCAL.TEE x) is valid with the function type [t] -> [t] if:
  - |C.LOCALS| is greater than x.
  - C.LOCALS[x] is t.

Instr_ok/global.get
- the instruction (GLOBAL.GET x) is valid with the function type [] -> [t] if:
  - |C.GLOBALS| is greater than x.
  - C.GLOBALS[x] is (mut t).

Instr_ok/global.set
- the instruction (GLOBAL.SET x) is valid with the function type [t] -> [] if:
  - |C.GLOBALS| is greater than x.
  - C.GLOBALS[x] is (MUT t).

Instr_ok/memory.size
- the instruction MEMORY.SIZE is valid with the function type [] -> [I32] if:
  - |C.MEMS| is greater than 0.
  - C.MEMS[0] is mt.

Instr_ok/memory.grow
- the instruction MEMORY.GROW is valid with the function type [I32] -> [I32] if:
  - |C.MEMS| is greater than 0.
  - C.MEMS[0] is mt.

Instr_ok/load
- the instruction (LOAD nt (_) (n, sx)? ? memarg) is valid with the function type [I32] -> [nt] if:
  - |C.MEMS| is greater than 0.
  - C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - If n is defined,
    - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).
    - (n / 8) is less than ($size(nt) / 8).
  - If n is defined, nt is Inn.

Instr_ok/store
- the instruction (STORE nt n? memarg) is valid with the function type [I32, nt] -> [] if:
  - |C.MEMS| is greater than 0.
  - C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - If n is defined,
    - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).
    - (n / 8) is less than ($size(nt) / 8).
  - If n is defined, nt is Inn.

Instrs_ok
- the instruction sequence instr_u0* is valid with the function type valtype_u1* -> valtype_u2* if:
  - Either:
    - instr_u0* is [].
    - valtype_u1* is [].
    - valtype_u2* is [].
  - Or:
    - instr_u0* is [instr_1] :: instr_2*.
    - valtype_u1* is t_1*.
    - valtype_u2* is t_3*.
    - the instruction instr_1 is valid with the function type t_1* -> t_2*.
    - the instruction sequence instr_2* is valid with the function type t_2* -> t_3*.
  - Or:
    - instr_u0* is instr*.
    - valtype_u1* is t* :: t_1*.
    - valtype_u2* is t* :: t_2*.
    - the instruction sequence instr* is valid with the function type t_1* -> t_2*.

Expr_ok
- the expression instr* is valid with the result type t? if:
  - the instruction sequence instr* is valid with the function type [] -> t?.

Instr_const
- the instruction instr_u0 is constant if:
  - Either: instr_u0 is (t.CONST c).
  - Or:
    - instr_u0 is (GLOBAL.GET x).
    - |C.GLOBALS| is greater than x.
    - C.GLOBALS[x] is (t).

Expr_const
- the expression instr* is constant if:
  - For all instr in instr*, the instruction instr is constant.

Type_ok
- the type (TYPE ft) is valid with the function type ft if:
  - the function type ft is valid.

Func_ok
- the function (FUNC x (LOCAL t)* expr) is valid with the function type t_1* -> t_2? if:
  - |C.TYPES| is greater than x.
  - C.TYPES[x] is t_1* -> t_2?.
  - Under the context C with .LOCALS appended by t_1* :: t* with .LABELS appended by [t_2?] with .RETURN appended by ?(t_2?), the expression expr is valid with the result type t_2?.

Global_ok
- the global (GLOBAL gt expr) is valid with the global type gt if:
  - the global type gt is valid.
  - gt is (mut t).
  - the expression expr is valid with the number type sequence ?(t).
  - the expression expr is constant.

Table_ok
- the table (TABLE tt) is valid with the table type tt if:
  - the table type tt is valid.

Mem_ok
- the memory (MEMORY mt) is valid with the memory type mt if:
  - the memory type mt is valid.

Elem_ok
- the table segment (ELEM expr x*) is valid if:
  - |C.TABLES| is greater than 0.
  - C.TABLES[0] is lim.
  - the expression expr is valid with the number type sequence ?(I32).
  - the expression expr is constant.
  - |x*| is |ft*|.
  - For all x in x*, |C.FUNCS| is greater than x.
  - For all ft in ft* and x in x*, C.FUNCS[x] is ft.

Data_ok
- the memory segment (DATA expr b*) is valid if:
  - |C.MEMS| is greater than 0.
  - C.MEMS[0] is lim.
  - the expression expr is valid with the number type sequence ?(I32).
  - the expression expr is constant.

Start_ok
- the start function (START x) is valid if:
  - |C.FUNCS| is greater than x.
  - C.FUNCS[x] is [] -> [].

Import_ok
- the import (IMPORT name_1 name_2 xt) is valid with the external type xt if:
  - the external type xt is valid.

Externidx_ok
- the external index externidx_u0 is valid with the external type externtype_u1 if:
  - Either:
    - externidx_u0 is (FUNC x).
    - externtype_u1 is (FUNC ft).
    - |C.FUNCS| is greater than x.
    - C.FUNCS[x] is ft.
  - Or:
    - externidx_u0 is (GLOBAL x).
    - externtype_u1 is (GLOBAL gt).
    - |C.GLOBALS| is greater than x.
    - C.GLOBALS[x] is gt.
  - Or:
    - externidx_u0 is (TABLE x).
    - externtype_u1 is (TABLE tt).
    - |C.TABLES| is greater than x.
    - C.TABLES[x] is tt.
  - Or:
    - externidx_u0 is (MEM x).
    - externtype_u1 is (MEM mt).
    - |C.MEMS| is greater than x.
    - C.MEMS[x] is mt.

Export_ok
- the export (EXPORT name externidx) is valid with the external type xt if:
  - the external index externidx is valid with the external type xt.

Module_ok
- the module (MODULE type* import* func* global* table* mem* elem* data* start? export*) is valid if:
  - |type*| is |ft'*|.
  - For all ft' in ft'* and type in type*, the type type is valid with the function type ft'.
  - |ixt*| is |import*|.
  - For all import in import* and ixt in ixt*, Under the context { TYPES: ft'*; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; LOCALS: []; LABELS: []; RETURN: ?(); }, the import import is valid with the external type ixt.
  - |gt*| is |global*|.
  - For all global in global* and gt in gt*, Under the context C', the global global is valid with the global type gt.
  - |func*| is |ft*|.
  - For all ft in ft* and func in func*, the function func is valid with the function type ft.
  - |tt*| is |table*|.
  - For all table in table* and tt in tt*, the table table is valid with the table type tt.
  - |mt*| is |mem*|.
  - For all mem in mem* and mt in mt*, the memory mem is valid with the memory type mt.
  - For all elem in elem*, the table segment elem is valid.
  - For all data in data*, the memory segment data is valid.
  - If start is defined, the start function start is valid.
  - |xt*| is |export*|.
  - For all export in export* and xt in xt*, the export export is valid with the external type xt.
  - |tt*| is less than or equal to 1.
  - |mt*| is less than or equal to 1.
  - C is { TYPES: ft'*; FUNCS: ift* :: ft*; GLOBALS: igt* :: gt*; TABLES: itt* :: tt*; MEMS: imt* :: mt*; LOCALS: []; LABELS: []; RETURN: ?(); }.
  - C' is { TYPES: ft'*; FUNCS: ift* :: ft*; GLOBALS: igt*; TABLES: []; MEMS: []; LOCALS: []; LABELS: []; RETURN: ?(); }.
  - ift* is $funcsxt(ixt*).
  - igt* is $globalsxt(ixt*).
  - itt* is $tablesxt(ixt*).
  - imt* is $memsxt(ixt*).

Step_pure/unreachable
1. Trap.

Step_pure/nop
1. Do nothing.

Step_pure/drop
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Do nothing.

Step_pure/select
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. Assert: Due to validation, a value is on the top of the stack.
4. Pop the value val_2 from the stack.
5. Assert: Due to validation, a value is on the top of the stack.
6. Pop the value val_1 from the stack.
7. If (c is not 0), then:
  a. Push the value val_1 to the stack.
8. Else:
  a. Push the value val_2 to the stack.

Step_pure/if t? instr_1* instr_2*
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c is not 0), then:
  a. Execute the instruction (BLOCK t? instr_1*).
4. Else:
  a. Execute the instruction (BLOCK t? instr_2*).

Step_pure/label
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, a label is now on the top of the stack.
3. Pop the current label from the stack.
4. Push the values val* to the stack.

Step_pure/br n_u0
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, the top of the stack is a LABEL_.
3. Push the values val* to the stack.
4. Let L be the current label.
5. Let n be the arity of L.
6. Let instr'* be the continuation of L.
7. If (n_u0 is 0), then:
  a. Assert: Due to validation, there are at least n values on the top of the stack.
  b. Pop the values val^n from the stack.
  c. Pop all values val'* from the top of the stack.
  d. Pop the current label from the stack.
  e. Push the values val^n to the stack.
  f. Execute the instruction instr'*.
8. Else:
  a. Pop all values val* from the top of the stack.
  b. If (n_u0 ≥ 1), then:
    1) Let l be (n_u0 - 1).
    2) Pop the current label from the stack.
    3) Push the values val* to the stack.
    4) Execute the instruction (BR l).

Step_pure/br_if l
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c is not 0), then:
  a. Execute the instruction (BR l).
4. Else:
  a. Do nothing.

Step_pure/br_table l* l'
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. If (i < |l*|), then:
  a. Execute the instruction (BR l*[i]).
4. Else:
  a. Execute the instruction (BR l').

Step_pure/frame
1. Let F be the current frame.
2. Let n be the arity of F.
3. Assert: Due to validation, there are at least n values on the top of the stack.
4. Assert: Due to validation, there are at least n values on the top of the stack.
5. Pop the values val^n from the stack.
6. Assert: Due to validation, a frame is now on the top of the stack.
7. Pop the current frame from the stack.
8. Push the values val^n to the stack.

Step_pure/return
1. Pop all values val* from the top of the stack.
2. If the top of the stack is a FRAME_, then:
  a. Push the values val* to the stack.
  b. Let F be the current frame.
  c. Let n be the arity of F.
  d. Assert: Due to validation, there are at least n values on the top of the stack.
  e. Pop the values val^n from the stack.
  f. Pop all values val'* from the top of the stack.
  g. Pop the current frame from the stack.
  h. Push the values val^n to the stack.
3. Else if the top of the stack is a LABEL_, then:
  a. Push the values val* to the stack.
  b. Pop all values val* from the top of the stack.
  c. Pop the current label from the stack.
  d. Push the values val* to the stack.
  e. Execute the instruction RETURN.

Step_pure/unop t unop
1. Assert: Due to validation, a value of value type t is on the top of the stack.
2. Pop the value (t.CONST c_1) from the stack.
3. If (|$unop_(t, unop, c_1)| ≤ 0), then:
  a. Trap.
4. Let c be an element of $unop_(t, unop, c_1).
5. Push the value (t.CONST c) to the stack.

Step_pure/binop t binop
1. Assert: Due to validation, a value of value type t is on the top of the stack.
2. Pop the value (t.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type valtype_0 is on the top of the stack.
4. Pop the value (valtype_0.CONST c_1) from the stack.
5. If (|$binop_(t, binop, c_1, c_2)| ≤ 0), then:
  a. Trap.
6. Let c be an element of $binop_(t, binop, c_1, c_2).
7. Push the value (t.CONST c) to the stack.

Step_pure/testop t testop
1. Assert: Due to validation, a value of value type t is on the top of the stack.
2. Pop the value (t.CONST c_1) from the stack.
3. Let c be $testop_(t, testop, c_1).
4. Push the value (I32.CONST c) to the stack.

Step_pure/relop t relop
1. Assert: Due to validation, a value of value type t is on the top of the stack.
2. Pop the value (t.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type valtype_0 is on the top of the stack.
4. Pop the value (valtype_0.CONST c_1) from the stack.
5. Let c be $relop_(t, relop, c_1, c_2).
6. Push the value (I32.CONST c) to the stack.

Step_pure/cvtop t_2 t_1 cvtop
1. Assert: Due to validation, a value of value type t_1 is on the top of the stack.
2. Pop the value (t_1.CONST c_1) from the stack.
3. If (|$cvtop__(t_1, t_2, cvtop, c_1)| ≤ 0), then:
  a. Trap.
4. Let c be an element of $cvtop__(t_1, t_2, cvtop, c_1).
5. Push the value (t_2.CONST c) to the stack.

Step_pure/local.tee x
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Push the value val to the stack.
4. Push the value val to the stack.
5. Execute the instruction (LOCAL.SET x).

Step_read/block t? instr*
1. Let n be 0.
2. If t? is not defined, then:
  a. Let L be the label_n{[]}.
  b. Enter instr* with label L.
3. Let n be 1.
4. If (t? is not ?()), then:
  a. Let L be the label_n{[]}.
  b. Enter instr* with label L.

Step_read/loop t? instr*
1. Let L be the label_0{[(LOOP t? instr*)]}.
2. Enter instr* with label L.

Step_read/call x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$funcaddr(z)|).
3. Execute the instruction (CALL_ADDR $funcaddr(z)[x]).

Step_read/call_indirect x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (i ≥ |$table(z, 0).REFS|), then:
  a. Trap.
5. If $table(z, 0).REFS[i] is not defined, then:
  a. Trap.
6. Let ?(a) be $table(z, 0).REFS[i].
7. If (a ≥ |$funcinst(z)|), then:
  a. Trap.
8. If ($type(z, x) is not $funcinst(z)[a].TYPE), then:
  a. Trap.
9. Execute the instruction (CALL_ADDR a).

Step_read/call_addr a
1. Let z be the current state.
2. Assert: Due to validation, (a < |$funcinst(z)|).
3. Let { TYPE: t_1^k -> t_2^n; MODULE: mm; CODE: func; } be $funcinst(z)[a].
4. Assert: Due to validation, there are at least k values on the top of the stack.
5. Pop the values val^k from the stack.
6. Assert: Due to validation, func is of the case FUNC.
7. Let (FUNC x local_0* instr*) be func.
8. Assert: Due to validation, local_0 is of the case LOCAL*.
9. Let (LOCAL t)* be local_0*.
10. Let f be { LOCALS: val^k :: $default_(t)*; MODULE: mm; }.
11. Let F be the activation of f with arity n.
12. Push F to the stack.
13. Let L be the label_n{[]}.
14. Enter instr* with label L.

Step_read/local.get x
1. Let z be the current state.
2. Push the value $local(z, x) to the stack.

Step_read/global.get x
1. Let z be the current state.
2. Push the value $global(z, x).VALUE to the stack.

Step_read/load valtype_u0 sz_sx_u1? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If sz_sx_u1? is not defined, then:
  a. Let t be valtype_u0.
  b. If (((i + ao.OFFSET) + ($size(t) / 8)) > |$mem(z, 0).BYTES|), then:
    1) Trap.
  c. Let c be $bytes__1^-1(t, $mem(z, 0).BYTES[(i + ao.OFFSET) : ($size(t) / 8)]).
  d. Push the value (t.CONST c) to the stack.
5. If the type of valtype_u0 is Inn, then:
  a. If sz_sx_u1? is defined, then:
    1) Let ?(sz_sx_0) be sz_sx_u1?.
    2) Let (n, sx) be sz_sx_0.
    3) If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
  b. Let Inn be valtype_u0.
  c. If sz_sx_u1? is defined, then:
    1) Let ?(sz_sx_0) be sz_sx_u1?.
    2) Let (n, sx) be sz_sx_0.
    3) Let c be $ibytes__1^-1(n, $mem(z, 0).BYTES[(i + ao.OFFSET) : (n / 8)]).
    4) Push the value (Inn.CONST $extend__(n, $size(Inn), sx, c)) to the stack.

Step_read/memory.size
1. Let z be the current state.
2. Let ((n · 64) · $Ki()) be |$mem(z, 0).BYTES|.
3. Push the value (I32.CONST n) to the stack.

Step/local.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_local(z, x, val).

Step/global.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_global(z, x, val).

Step/store valtype_u0 sz_u1? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type valtype_u2 is on the top of the stack.
3. Pop the value (valtype_u2.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Let t be valtype_u2.
7. If ((((i + ao.OFFSET) + ($size(t) / 8)) > |$mem(z, 0).BYTES|) and ((valtype_u0 is t) and sz_u1? is not defined)), then:
  a. Trap.
8. If ((valtype_u0 is t) and sz_u1? is not defined), then:
  a. Let b* be $bytes_(t, c).
  b. Perform $with_mem(z, 0, (i + ao.OFFSET), ($size(t) / 8), b*).
9. If the type of valtype_u2 is Inn, then:
  a. Let Inn be valtype_u2.
  b. If ((valtype_u0 is Inn) and sz_u1? is defined), then:
    1) Let ?(n) be sz_u1?.
    2) If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
    3) Let b* be $ibytes_(n, $wrap__($size(Inn), n, c)).
    4) Perform $with_mem(z, 0, (i + ao.OFFSET), (n / 8), b*).

Step/memory.grow
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Either:
  a. Let mi be $growmemory($mem(z, 0), n).
  b. Push the value (I32.CONST (|$mem(z, 0).BYTES| / (64 · $Ki()))) to the stack.
  c. Perform $with_meminst(z, 0, mi).
5. Or:
  a. Push the value (I32.CONST $invsigned_(32, (- 1))) to the stack.

Ki
1. Return 1024.

min n_u0 n_u1
1. If (n_u0 is 0), then:
  a. Return 0.
2. If (n_u1 is 0), then:
  a. Return 0.
3. Assert: Due to validation, (n_u0 ≥ 1).
4. Let i be (n_u0 - 1).
5. Assert: Due to validation, (n_u1 ≥ 1).
6. Let j be (n_u1 - 1).
7. Return $min(i, j).

sum n_u0*
1. If (n_u0* is []), then:
  a. Return 0.
2. Let [n] :: n'* be n_u0*.
3. Return (n + $sum(n'*)).

opt_ X X_u0*
1. If (X_u0* is []), then:
  a. Return ?().
2. Assert: Due to validation, (|X_u0*| is 1).
3. Let [w] be X_u0*.
4. Return ?(w).

list_ X X_u0?
1. If X_u0? is not defined, then:
  a. Return [].
2. Let ?(w) be X_u0?.
3. Return [w].

concat_ X X_u0*
1. If (X_u0* is []), then:
  a. Return [].
2. Let [w*] :: w'** be X_u0*.
3. Return w* :: $concat_(X, w'**).

signif N_u0
1. If (N_u0 is 32), then:
  a. Return 23.
2. Assert: Due to validation, (N_u0 is 64).
3. Return 52.

expon N_u0
1. If (N_u0 is 32), then:
  a. Return 8.
2. Assert: Due to validation, (N_u0 is 64).
3. Return 11.

M N
1. Return $signif(N).

E N
1. Return $expon(N).

fzero N
1. Return (POS (SUBNORM 0)).

fone N
1. Return (POS (NORM 1 0)).

canon_ N
1. Return (2 ^ ($signif(N) - 1)).

size valtype_u0
1. If (valtype_u0 is I32), then:
  a. Return 32.
2. If (valtype_u0 is I64), then:
  a. Return 64.
3. If (valtype_u0 is F32), then:
  a. Return 32.
4. If (valtype_u0 is F64), then:
  a. Return 64.

funcsxt externtype_u0*
1. If (externtype_u0* is []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype_u0*.
3. If externtype_0 is of the case FUNC, then:
  a. Let (FUNC ft) be externtype_0.
  b. Return [ft] :: $funcsxt(xt*).
4. Let [externtype] :: xt* be externtype_u0*.
5. Return $funcsxt(xt*).

globalsxt externtype_u0*
1. If (externtype_u0* is []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype_u0*.
3. If externtype_0 is of the case GLOBAL, then:
  a. Let (GLOBAL gt) be externtype_0.
  b. Return [gt] :: $globalsxt(xt*).
4. Let [externtype] :: xt* be externtype_u0*.
5. Return $globalsxt(xt*).

tablesxt externtype_u0*
1. If (externtype_u0* is []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype_u0*.
3. If externtype_0 is of the case TABLE, then:
  a. Let (TABLE tt) be externtype_0.
  b. Return [tt] :: $tablesxt(xt*).
4. Let [externtype] :: xt* be externtype_u0*.
5. Return $tablesxt(xt*).

memsxt externtype_u0*
1. If (externtype_u0* is []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype_u0*.
3. If externtype_0 is of the case MEM, then:
  a. Let (MEM mt) be externtype_0.
  b. Return [mt] :: $memsxt(xt*).
4. Let [externtype] :: xt* be externtype_u0*.
5. Return $memsxt(xt*).

memarg0
1. Return { ALIGN: 0; OFFSET: 0; }.

signed_ N i
1. If (0 ≤ (2 ^ (N - 1))), then:
  a. Return i.
2. Assert: Due to validation, ((2 ^ (N - 1)) ≤ i).
3. Assert: Due to validation, (i < (2 ^ N)).
4. Return (i - (2 ^ N)).

invsigned_ N ii
1. Let j be $signed__1^-1(N, ii).
2. Return j.

unop_ valtype_u1 unop__u0 val__u3
1. If ((unop__u0 is CLZ) and the type of valtype_u1 is Inn), then:
  a. Let Inn be valtype_u1.
  b. Let iN be val__u3.
  c. Return [$iclz_($size(Inn), iN)].
2. If ((unop__u0 is CTZ) and the type of valtype_u1 is Inn), then:
  a. Let Inn be valtype_u1.
  b. Let iN be val__u3.
  c. Return [$ictz_($size(Inn), iN)].
3. If ((unop__u0 is POPCNT) and the type of valtype_u1 is Inn), then:
  a. Let Inn be valtype_u1.
  b. Let iN be val__u3.
  c. Return [$ipopcnt_($size(Inn), iN)].
4. If ((unop__u0 is ABS) and the type of valtype_u1 is Fnn), then:
  a. Let Fnn be valtype_u1.
  b. Let fN be val__u3.
  c. Return $fabs_($size(Fnn), fN).
5. If ((unop__u0 is NEG) and the type of valtype_u1 is Fnn), then:
  a. Let Fnn be valtype_u1.
  b. Let fN be val__u3.
  c. Return $fneg_($size(Fnn), fN).
6. If ((unop__u0 is SQRT) and the type of valtype_u1 is Fnn), then:
  a. Let Fnn be valtype_u1.
  b. Let fN be val__u3.
  c. Return $fsqrt_($size(Fnn), fN).
7. If ((unop__u0 is CEIL) and the type of valtype_u1 is Fnn), then:
  a. Let Fnn be valtype_u1.
  b. Let fN be val__u3.
  c. Return $fceil_($size(Fnn), fN).
8. If ((unop__u0 is FLOOR) and the type of valtype_u1 is Fnn), then:
  a. Let Fnn be valtype_u1.
  b. Let fN be val__u3.
  c. Return $ffloor_($size(Fnn), fN).
9. If ((unop__u0 is TRUNC) and the type of valtype_u1 is Fnn), then:
  a. Let Fnn be valtype_u1.
  b. Let fN be val__u3.
  c. Return $ftrunc_($size(Fnn), fN).
10. Assert: Due to validation, (unop__u0 is NEAREST).
11. Assert: Due to validation, the type of valtype_u1 is Fnn.
12. Let Fnn be valtype_u1.
13. Let fN be val__u3.
14. Return $fnearest_($size(Fnn), fN).

binop_ valtype_u1 binop__u0 val__u3 val__u5
1. If ((binop__u0 is ADD) and the type of valtype_u1 is Inn), then:
  a. Let Inn be valtype_u1.
  b. Let iN_1 be val__u3.
  c. Let iN_2 be val__u5.
  d. Return [$iadd_($size(Inn), iN_1, iN_2)].
2. If ((binop__u0 is SUB) and the type of valtype_u1 is Inn), then:
  a. Let Inn be valtype_u1.
  b. Let iN_1 be val__u3.
  c. Let iN_2 be val__u5.
  d. Return [$isub_($size(Inn), iN_1, iN_2)].
3. If ((binop__u0 is MUL) and the type of valtype_u1 is Inn), then:
  a. Let Inn be valtype_u1.
  b. Let iN_1 be val__u3.
  c. Let iN_2 be val__u5.
  d. Return [$imul_($size(Inn), iN_1, iN_2)].
4. If the type of valtype_u1 is Inn, then:
  a. Let Inn be valtype_u1.
  b. Let iN_1 be val__u3.
  c. Let iN_2 be val__u5.
  d. If binop__u0 is of the case DIV, then:
    1) Let (DIV sx) be binop__u0.
    2) Return $list_(val_((Inn : Inn <: valtype)), $idiv_($size(Inn), sx, iN_1, iN_2)).
  e. If binop__u0 is of the case REM, then:
    1) Let (REM sx) be binop__u0.
    2) Return $list_(val_((Inn : Inn <: valtype)), $irem_($size(Inn), sx, iN_1, iN_2)).
5. If ((binop__u0 is AND) and the type of valtype_u1 is Inn), then:
  a. Let Inn be valtype_u1.
  b. Let iN_1 be val__u3.
  c. Let iN_2 be val__u5.
  d. Return [$iand_($size(Inn), iN_1, iN_2)].
6. If ((binop__u0 is OR) and the type of valtype_u1 is Inn), then:
  a. Let Inn be valtype_u1.
  b. Let iN_1 be val__u3.
  c. Let iN_2 be val__u5.
  d. Return [$ior_($size(Inn), iN_1, iN_2)].
7. If ((binop__u0 is XOR) and the type of valtype_u1 is Inn), then:
  a. Let Inn be valtype_u1.
  b. Let iN_1 be val__u3.
  c. Let iN_2 be val__u5.
  d. Return [$ixor_($size(Inn), iN_1, iN_2)].
8. If ((binop__u0 is SHL) and the type of valtype_u1 is Inn), then:
  a. Let Inn be valtype_u1.
  b. Let iN_1 be val__u3.
  c. Let iN_2 be val__u5.
  d. Return [$ishl_($size(Inn), iN_1, iN_2)].
9. If the type of valtype_u1 is Inn, then:
  a. Let Inn be valtype_u1.
  b. Let iN_1 be val__u3.
  c. Let iN_2 be val__u5.
  d. If binop__u0 is of the case SHR, then:
    1) Let (SHR sx) be binop__u0.
    2) Return [$ishr_($size(Inn), sx, iN_1, iN_2)].
10. If ((binop__u0 is ROTL) and the type of valtype_u1 is Inn), then:
  a. Let Inn be valtype_u1.
  b. Let iN_1 be val__u3.
  c. Let iN_2 be val__u5.
  d. Return [$irotl_($size(Inn), iN_1, iN_2)].
11. If ((binop__u0 is ROTR) and the type of valtype_u1 is Inn), then:
  a. Let Inn be valtype_u1.
  b. Let iN_1 be val__u3.
  c. Let iN_2 be val__u5.
  d. Return [$irotr_($size(Inn), iN_1, iN_2)].
12. If ((binop__u0 is ADD) and the type of valtype_u1 is Fnn), then:
  a. Let Fnn be valtype_u1.
  b. Let fN_1 be val__u3.
  c. Let fN_2 be val__u5.
  d. Return $fadd_($size(Fnn), fN_1, fN_2).
13. If ((binop__u0 is SUB) and the type of valtype_u1 is Fnn), then:
  a. Let Fnn be valtype_u1.
  b. Let fN_1 be val__u3.
  c. Let fN_2 be val__u5.
  d. Return $fsub_($size(Fnn), fN_1, fN_2).
14. If ((binop__u0 is MUL) and the type of valtype_u1 is Fnn), then:
  a. Let Fnn be valtype_u1.
  b. Let fN_1 be val__u3.
  c. Let fN_2 be val__u5.
  d. Return $fmul_($size(Fnn), fN_1, fN_2).
15. If ((binop__u0 is DIV) and the type of valtype_u1 is Fnn), then:
  a. Let Fnn be valtype_u1.
  b. Let fN_1 be val__u3.
  c. Let fN_2 be val__u5.
  d. Return $fdiv_($size(Fnn), fN_1, fN_2).
16. If ((binop__u0 is MIN) and the type of valtype_u1 is Fnn), then:
  a. Let Fnn be valtype_u1.
  b. Let fN_1 be val__u3.
  c. Let fN_2 be val__u5.
  d. Return $fmin_($size(Fnn), fN_1, fN_2).
17. If ((binop__u0 is MAX) and the type of valtype_u1 is Fnn), then:
  a. Let Fnn be valtype_u1.
  b. Let fN_1 be val__u3.
  c. Let fN_2 be val__u5.
  d. Return $fmax_($size(Fnn), fN_1, fN_2).
18. Assert: Due to validation, (binop__u0 is COPYSIGN).
19. Assert: Due to validation, the type of valtype_u1 is Fnn.
20. Let Fnn be valtype_u1.
21. Let fN_1 be val__u3.
22. Let fN_2 be val__u5.
23. Return $fcopysign_($size(Fnn), fN_1, fN_2).

testop_ Inn EQZ iN
1. Return $ieqz_($size(Inn), iN).

relop_ valtype_u1 relop__u0 val__u3 val__u5
1. If ((relop__u0 is EQ) and the type of valtype_u1 is Inn), then:
  a. Let Inn be valtype_u1.
  b. Let iN_1 be val__u3.
  c. Let iN_2 be val__u5.
  d. Return $ieq_($size(Inn), iN_1, iN_2).
2. If ((relop__u0 is NE) and the type of valtype_u1 is Inn), then:
  a. Let Inn be valtype_u1.
  b. Let iN_1 be val__u3.
  c. Let iN_2 be val__u5.
  d. Return $ine_($size(Inn), iN_1, iN_2).
3. If the type of valtype_u1 is Inn, then:
  a. Let Inn be valtype_u1.
  b. Let iN_1 be val__u3.
  c. Let iN_2 be val__u5.
  d. If relop__u0 is of the case LT, then:
    1) Let (LT sx) be relop__u0.
    2) Return $ilt_($size(Inn), sx, iN_1, iN_2).
  e. If relop__u0 is of the case GT, then:
    1) Let (GT sx) be relop__u0.
    2) Return $igt_($size(Inn), sx, iN_1, iN_2).
  f. If relop__u0 is of the case LE, then:
    1) Let (LE sx) be relop__u0.
    2) Return $ile_($size(Inn), sx, iN_1, iN_2).
  g. If relop__u0 is of the case GE, then:
    1) Let (GE sx) be relop__u0.
    2) Return $ige_($size(Inn), sx, iN_1, iN_2).
4. If ((relop__u0 is EQ) and the type of valtype_u1 is Fnn), then:
  a. Let Fnn be valtype_u1.
  b. Let fN_1 be val__u3.
  c. Let fN_2 be val__u5.
  d. Return $feq_($size(Fnn), fN_1, fN_2).
5. If ((relop__u0 is NE) and the type of valtype_u1 is Fnn), then:
  a. Let Fnn be valtype_u1.
  b. Let fN_1 be val__u3.
  c. Let fN_2 be val__u5.
  d. Return $fne_($size(Fnn), fN_1, fN_2).
6. If ((relop__u0 is LT) and the type of valtype_u1 is Fnn), then:
  a. Let Fnn be valtype_u1.
  b. Let fN_1 be val__u3.
  c. Let fN_2 be val__u5.
  d. Return $flt_($size(Fnn), fN_1, fN_2).
7. If ((relop__u0 is GT) and the type of valtype_u1 is Fnn), then:
  a. Let Fnn be valtype_u1.
  b. Let fN_1 be val__u3.
  c. Let fN_2 be val__u5.
  d. Return $fgt_($size(Fnn), fN_1, fN_2).
8. If ((relop__u0 is LE) and the type of valtype_u1 is Fnn), then:
  a. Let Fnn be valtype_u1.
  b. Let fN_1 be val__u3.
  c. Let fN_2 be val__u5.
  d. Return $fle_($size(Fnn), fN_1, fN_2).
9. Assert: Due to validation, (relop__u0 is GE).
10. Assert: Due to validation, the type of valtype_u1 is Fnn.
11. Let Fnn be valtype_u1.
12. Let fN_1 be val__u3.
13. Let fN_2 be val__u5.
14. Return $fge_($size(Fnn), fN_1, fN_2).

cvtop__ valtype_u0 valtype_u1 cvtop_u2 val__u4
1. If ((valtype_u0 is I32) and (valtype_u1 is I64)), then:
  a. Let iN be val__u4.
  b. If cvtop_u2 is of the case EXTEND, then:
    1) Let (EXTEND sx) be cvtop_u2.
    2) Return [$extend__(32, 64, sx, iN)].
2. If ((valtype_u0 is I64) and ((valtype_u1 is I32) and (cvtop_u2 is WRAP))), then:
  a. Let iN be val__u4.
  b. Return [$wrap__(64, 32, iN)].
3. If the type of valtype_u0 is Fnn, then:
  a. Let Fnn be valtype_u0.
  b. If the type of valtype_u1 is Inn, then:
    1) Let Inn be valtype_u1.
    2) Let fN be val__u4.
    3) If cvtop_u2 is of the case TRUNC, then:
      a) Let (TRUNC sx) be cvtop_u2.
      b) Return $list_(val_((Inn : Inn <: valtype)), $trunc__($size(Fnn), $size(Inn), sx, fN)).
4. If ((valtype_u0 is F32) and ((valtype_u1 is F64) and (cvtop_u2 is PROMOTE))), then:
  a. Let fN be val__u4.
  b. Return $promote__(32, 64, fN).
5. If ((valtype_u0 is F64) and ((valtype_u1 is F32) and (cvtop_u2 is DEMOTE))), then:
  a. Let fN be val__u4.
  b. Return $demote__(64, 32, fN).
6. If the type of valtype_u1 is Fnn, then:
  a. Let Fnn be valtype_u1.
  b. If the type of valtype_u0 is Inn, then:
    1) Let Inn be valtype_u0.
    2) Let iN be val__u4.
    3) If cvtop_u2 is of the case CONVERT, then:
      a) Let (CONVERT sx) be cvtop_u2.
      b) Return [$convert__($size(Inn), $size(Fnn), sx, iN)].
7. Assert: Due to validation, (cvtop_u2 is REINTERPRET).
8. If the type of valtype_u1 is Fnn, then:
  a. Let Fnn be valtype_u1.
  b. If the type of valtype_u0 is Inn, then:
    1) Let Inn be valtype_u0.
    2) Let iN be val__u4.
    3) If ($size(Inn) is $size(Fnn)), then:
      a) Return [$reinterpret__(Inn, Fnn, iN)].
9. Assert: Due to validation, the type of valtype_u0 is Fnn.
10. Let Fnn be valtype_u0.
11. Assert: Due to validation, the type of valtype_u1 is Inn.
12. Let Inn be valtype_u1.
13. Let fN be val__u4.
14. Assert: Due to validation, ($size(Inn) is $size(Fnn)).
15. Return [$reinterpret__(Fnn, Inn, fN)].

invibytes_ N b*
1. Let n be $ibytes__1^-1(N, b*).
2. Return n.

invfbytes_ N b*
1. Let p be $fbytes__1^-1(N, b*).
2. Return p.

default_ valtype_u0
1. If (valtype_u0 is I32), then:
  a. Return (I32.CONST 0).
2. If (valtype_u0 is I64), then:
  a. Return (I64.CONST 0).
3. If (valtype_u0 is F32), then:
  a. Return (F32.CONST $fzero(32)).
4. Assert: Due to validation, (valtype_u0 is F64).
5. Return (F64.CONST $fzero(64)).

funcsxa externaddr_u0*
1. If (externaddr_u0* is []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr_u0*.
3. If externaddr_0 is of the case FUNC, then:
  a. Let (FUNC fa) be externaddr_0.
  b. Return [fa] :: $funcsxa(xv*).
4. Let [externaddr] :: xv* be externaddr_u0*.
5. Return $funcsxa(xv*).

globalsxa externaddr_u0*
1. If (externaddr_u0* is []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr_u0*.
3. If externaddr_0 is of the case GLOBAL, then:
  a. Let (GLOBAL ga) be externaddr_0.
  b. Return [ga] :: $globalsxa(xv*).
4. Let [externaddr] :: xv* be externaddr_u0*.
5. Return $globalsxa(xv*).

tablesxa externaddr_u0*
1. If (externaddr_u0* is []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr_u0*.
3. If externaddr_0 is of the case TABLE, then:
  a. Let (TABLE ta) be externaddr_0.
  b. Return [ta] :: $tablesxa(xv*).
4. Let [externaddr] :: xv* be externaddr_u0*.
5. Return $tablesxa(xv*).

memsxa externaddr_u0*
1. If (externaddr_u0* is []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr_u0*.
3. If externaddr_0 is of the case MEM, then:
  a. Let (MEM ma) be externaddr_0.
  b. Return [ma] :: $memsxa(xv*).
4. Let [externaddr] :: xv* be externaddr_u0*.
5. Return $memsxa(xv*).

store
1. Return.

frame
1. Let f be the current frame.
2. Return f.

funcaddr
1. Let f be the current frame.
2. Return f.MODULE.FUNCS.

funcinst
1. Return s.FUNCS.

globalinst
1. Return s.GLOBALS.

tableinst
1. Return s.TABLES.

meminst
1. Return s.MEMS.

moduleinst
1. Let f be the current frame.
2. Return f.MODULE.

type x
1. Let f be the current frame.
2. Return f.MODULE.TYPES[x].

func x
1. Let f be the current frame.
2. Return s.FUNCS[f.MODULE.FUNCS[x]].

global x
1. Let f be the current frame.
2. Return s.GLOBALS[f.MODULE.GLOBALS[x]].

table x
1. Let f be the current frame.
2. Return s.TABLES[f.MODULE.TABLES[x]].

mem x
1. Let f be the current frame.
2. Return s.MEMS[f.MODULE.MEMS[x]].

local x
1. Let f be the current frame.
2. Return f.LOCALS[x].

with_local x v
1. Let f be the current frame.
2. Replace f.LOCALS[x] with v.

with_global x v
1. Let f be the current frame.
2. Replace s.GLOBALS[f.MODULE.GLOBALS[x]].VALUE with v.

with_table x i a
1. Let f be the current frame.
2. Replace s.TABLES[f.MODULE.TABLES[x]].REFS[i] with ?(a).

with_tableinst x ti
1. Let f be the current frame.
2. Replace s.TABLES[f.MODULE.TABLES[x]] with ti.

with_mem x i j b*
1. Let f be the current frame.
2. Replace s.MEMS[f.MODULE.MEMS[x]].BYTES[i : j] with b*.

with_meminst x mi
1. Let f be the current frame.
2. Replace s.MEMS[f.MODULE.MEMS[x]] with mi.

growtable ti n
1. Let { TYPE: (i, j); REFS: ?(a)*; } be ti.
2. Let i' be (|a*| + n).
3. If (i' ≤ j), then:
  a. Let ti' be { TYPE: (i', j); REFS: ?(a)* :: ?()^n; }.
  b. Return ti'.

growmemory mi n
1. Let { TYPE: (i, j); BYTES: b*; } be mi.
2. Let i' be ((|b*| / (64 · $Ki())) + n).
3. If (i' ≤ j), then:
  a. Let mi' be { TYPE: (i', j); BYTES: b* :: 0^(n · (64 · $Ki())); }.
  b. Return mi'.

funcs externaddr_u0*
1. If (externaddr_u0* is []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr_u0*.
3. If externaddr_0 is of the case FUNC, then:
  a. Let (FUNC fa) be externaddr_0.
  b. Return [fa] :: $funcs(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr_u0*.
5. Return $funcs(externaddr'*).

globals externaddr_u0*
1. If (externaddr_u0* is []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr_u0*.
3. If externaddr_0 is of the case GLOBAL, then:
  a. Let (GLOBAL ga) be externaddr_0.
  b. Return [ga] :: $globals(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr_u0*.
5. Return $globals(externaddr'*).

tables externaddr_u0*
1. If (externaddr_u0* is []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr_u0*.
3. If externaddr_0 is of the case TABLE, then:
  a. Let (TABLE ta) be externaddr_0.
  b. Return [ta] :: $tables(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr_u0*.
5. Return $tables(externaddr'*).

mems externaddr_u0*
1. If (externaddr_u0* is []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr_u0*.
3. If externaddr_0 is of the case MEM, then:
  a. Let (MEM ma) be externaddr_0.
  b. Return [ma] :: $mems(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr_u0*.
5. Return $mems(externaddr'*).

allocfunc moduleinst func
1. Assert: Due to validation, func is of the case FUNC.
2. Let (FUNC x local* expr) be func.
3. Let fi be { TYPE: moduleinst.TYPES[x]; MODULE: moduleinst; CODE: func; }.
4. Let a be |s.FUNCS|.
5. Append fi to the s.FUNCS.
6. Return a.

allocfuncs moduleinst func_u0*
1. If (func_u0* is []), then:
  a. Return [].
2. Let [func] :: func'* be func_u0*.
3. Let fa be $allocfunc(moduleinst, func).
4. Let fa'* be $allocfuncs(moduleinst, func'*).
5. Return [fa] :: fa'*.

allocglobal globaltype val
1. Let gi be { TYPE: globaltype; VALUE: val; }.
2. Let a be |s.GLOBALS|.
3. Append gi to the s.GLOBALS.
4. Return a.

allocglobals globaltype_u0* val_u1*
1. If (globaltype_u0* is []), then:
  a. Assert: Due to validation, (val_u1* is []).
  b. Return [].
2. Else:
  a. Let [globaltype] :: globaltype'* be globaltype_u0*.
  b. Assert: Due to validation, (|val_u1*| ≥ 1).
  c. Let [val] :: val'* be val_u1*.
  d. Let ga be $allocglobal(globaltype, val).
  e. Let ga'* be $allocglobals(globaltype'*, val'*).
  f. Return [ga] :: ga'*.

alloctable (i, j)
1. Let ti be { TYPE: (i, j); REFS: ?()^i; }.
2. Let a be |s.TABLES|.
3. Append ti to the s.TABLES.
4. Return a.

alloctables tabletype_u0*
1. If (tabletype_u0* is []), then:
  a. Return [].
2. Let [tabletype] :: tabletype'* be tabletype_u0*.
3. Let ta be $alloctable(tabletype).
4. Let ta'* be $alloctables(tabletype'*).
5. Return [ta] :: ta'*.

allocmem (i, j)
1. Let mi be { TYPE: (i, j); BYTES: 0^(i · (64 · $Ki())); }.
2. Let a be |s.MEMS|.
3. Append mi to the s.MEMS.
4. Return a.

allocmems memtype_u0*
1. If (memtype_u0* is []), then:
  a. Return [].
2. Let [memtype] :: memtype'* be memtype_u0*.
3. Let ma be $allocmem(memtype).
4. Let ma'* be $allocmems(memtype'*).
5. Return [ma] :: ma'*.

instexport fa* ga* ta* ma* (EXPORT name externidx_u0)
1. If externidx_u0 is of the case FUNC, then:
  a. Let (FUNC x) be externidx_u0.
  b. Return { NAME: name; ADDR: (FUNC fa*[x]); }.
2. If externidx_u0 is of the case GLOBAL, then:
  a. Let (GLOBAL x) be externidx_u0.
  b. Return { NAME: name; ADDR: (GLOBAL ga*[x]); }.
3. If externidx_u0 is of the case TABLE, then:
  a. Let (TABLE x) be externidx_u0.
  b. Return { NAME: name; ADDR: (TABLE ta*[x]); }.
4. Assert: Due to validation, externidx_u0 is of the case MEM.
5. Let (MEM x) be externidx_u0.
6. Return { NAME: name; ADDR: (MEM ma*[x]); }.

allocmodule module externaddr* val*
1. Let fa_ex* be $funcs(externaddr*).
2. Let ga_ex* be $globals(externaddr*).
3. Let ma_ex* be $mems(externaddr*).
4. Let ta_ex* be $tables(externaddr*).
5. Assert: Due to validation, module is of the case MODULE.
6. Let (MODULE type_0* import* func^n_func global_1^n_global table_2^n_table mem_3^n_mem elem* data* start? export*) be module.
7. Assert: Due to validation, mem_3 is of the case MEMORY^n_mem.
8. Let (MEMORY memtype)^n_mem be mem_3^n_mem.
9. Assert: Due to validation, table_2 is of the case TABLE^n_table.
10. Let (TABLE tabletype)^n_table be table_2^n_table.
11. Assert: Due to validation, global_1 is of the case GLOBAL^n_global.
12. Let (GLOBAL globaltype expr_1)^n_global be global_1^n_global.
13. Assert: Due to validation, type_0 is of the case TYPE*.
14. Let (TYPE ft)* be type_0*.
15. Let fa* be (|s.FUNCS| + i_func)^(i_func<n_func).
16. Let ga* be (|s.GLOBALS| + i_global)^(i_global<n_global).
17. Let ta* be (|s.TABLES| + i_table)^(i_table<n_table).
18. Let ma* be (|s.MEMS| + i_mem)^(i_mem<n_mem).
19. Let xi* be $instexport(fa_ex* :: fa*, ga_ex* :: ga*, ta_ex* :: ta*, ma_ex* :: ma*, export)*.
20. Let moduleinst be { TYPES: ft*; FUNCS: fa_ex* :: fa*; GLOBALS: ga_ex* :: ga*; TABLES: ta_ex* :: ta*; MEMS: ma_ex* :: ma*; EXPORTS: xi*; }.
21. Let funcaddr_0 be $allocfuncs(moduleinst, func^n_func).
22. Assert: Due to validation, (funcaddr_0 is fa*).
23. Let globaladdr_0 be $allocglobals(globaltype^n_global, val*).
24. Assert: Due to validation, (globaladdr_0 is ga*).
25. Let tableaddr_0 be $alloctables(tabletype^n_table).
26. Assert: Due to validation, (tableaddr_0 is ta*).
27. Let memaddr_0 be $allocmems(memtype^n_mem).
28. Assert: Due to validation, (memaddr_0 is ma*).
29. Return moduleinst.

initelem moduleinst u32_u0* funcaddr_u1*
1. If ((u32_u0* is []) and (funcaddr_u1* is [])), then:
  a. Return.
2. Assert: Due to validation, (|funcaddr_u1*| ≥ 1).
3. Let [a*] :: a'** be funcaddr_u1*.
4. Assert: Due to validation, (|u32_u0*| ≥ 1).
5. Let [i] :: i'* be u32_u0*.
6. Replace s.TABLES[moduleinst.TABLES[0]].REFS[i : |a*|] with ?(a)*.
7. Perform $initelem(moduleinst, i'*, a'**).
8. Return.

initdata moduleinst u32_u0* byte_u1*
1. If ((u32_u0* is []) and (byte_u1* is [])), then:
  a. Return.
2. Assert: Due to validation, (|byte_u1*| ≥ 1).
3. Let [b*] :: b'** be byte_u1*.
4. Assert: Due to validation, (|u32_u0*| ≥ 1).
5. Let [i] :: i'* be u32_u0*.
6. Replace s.MEMS[moduleinst.MEMS[0]].BYTES[i : |b*|] with b*.
7. Perform $initdata(moduleinst, i'*, b'**).
8. Return.

instantiate z module externaddr*
1. Assert: Due to validation, module is of the case MODULE.
2. Let (MODULE type* import* func* global* table* mem* elem* data* start? export*) be module.
3. Assert: Due to validation, type is of the case TYPE*.
4. Let (TYPE functype)* be type*.
5. Let n_F be |func*|.
6. Assert: Due to validation, start is of the case START?.
7. Let (START x')? be start?.
8. Assert: Due to validation, data is of the case DATA*.
9. Let (DATA expr_D b*)* be data*.
10. Assert: Due to validation, elem is of the case ELEM*.
11. Let (ELEM expr_E x*)* be elem*.
12. Assert: Due to validation, global is of the case GLOBAL*.
13. Let (GLOBAL globaltype expr_G)* be global*.
14. Let moduleinst_init be { TYPES: functype*; FUNCS: $funcs(externaddr*) :: (|s.FUNCS| + i_F)^(i_F<n_F); GLOBALS: $globals(externaddr*); TABLES: []; MEMS: []; EXPORTS: []; }.
15. Let f_init be { LOCALS: []; MODULE: moduleinst_init; }.
16. Let z be f_init.
17. Push the activation of z to the stack.
18. Let [(I32.CONST i_D)]* be $eval_expr(expr_D)*.
19. Pop the activation of _f from the stack.
20. Push the activation of z to the stack.
21. Let [(I32.CONST i_E)]* be $eval_expr(expr_E)*.
22. Pop the activation of _f from the stack.
23. Push the activation of z to the stack.
24. Let [val]* be $eval_expr(expr_G)*.
25. Pop the activation of _f from the stack.
26. Let moduleinst be $allocmodule(module, externaddr*, val*).
27. Let f be { LOCALS: []; MODULE: moduleinst; }.
28. Perform $initelem(moduleinst, i_E*, moduleinst.FUNCS[x]**).
29. Perform $initdata(moduleinst, i_D*, b**).
30. Push the activation of f with arity 0 to the stack.
31. If (CALL x')? is defined, then:
  a. Execute the instruction (CALL x').
32. Pop the activation of f with arity 0 from the stack.
33. Return f.MODULE.

invoke z fa val^n
1. Let f be { LOCALS: []; MODULE: { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; EXPORTS: []; }; }.
2. Push the activation of f to the stack.
3. Let t_1^n -> t_2* be $funcinst(z)[fa].TYPE.
4. Pop the activation of _f from the stack.
5. Let k be |t_2*|.
6. Push the activation of f with arity k to the stack.
7. Push the values val^n to the stack.
8. Execute the instruction (CALL_ADDR fa).
9. Pop all values val* from the top of the stack.
10. Pop the activation of f with arity k from the stack.
11. Push the values val* to the stack.
12. Pop the values val^k from the stack.
13. Return val^k.

eval_expr instr*
1. Execute the instruction instr*.
2. Pop the value val from the stack.
3. Return [val].

== Complete.
Generating prose for Wasm 2.0...
watsup 0.4 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...

* The limits :math:`(n, m)` is valid with the nat :math:`k` if:


  * :math:`n` is less than or equal to :math:`m`.

  * :math:`m` is less than or equal to :math:`k`.


* The function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid.


* The global type :math:`((\mathsf{mut}~{()^?}~{}^?)~t)` is valid.


* The table type :math:`({\mathit{limits}}~{\mathit{reftype}})` is valid if:


  * The limits :math:`{\mathit{limits}}` is valid with the nat :math:`{2^{32}} - 1`.


* The memory type :math:`{\mathit{limits}}~\mathsf{page}` is valid if:


  * The limits :math:`{\mathit{limits}}` is valid with the nat :math:`{2^{16}}`.


* The external type :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valid if:


  * Either:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{func}~{\mathit{functype}})`.

    * The function type :math:`{\mathit{functype}}` is valid.

  * Or:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{global}~{\mathit{globaltype}})`.

    * The global type :math:`{\mathit{globaltype}}` is valid.
  * Or:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{table}~{\mathit{tabletype}})`.

    * The table type :math:`{\mathit{tabletype}}` is valid.
  * Or:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{mem}~{\mathit{memtype}})`.

    * The memory type :math:`{\mathit{memtype}}` is valid.


* The value type :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` matches the value type :math:`t` if:


  * Either: :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`t`.

  * Or: :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{bot}`.


* The value type sequence :math:`{t_1^\ast}` matches the value type sequence :math:`{t_2^\ast}` if:


  * :math:`{|t_{\mathit{{\scriptstyle 2}*}}|}` is :math:`{|t_{\mathit{{\scriptstyle 1}*}}|}`.

  * For all :math:`t_1` in :math:`{t_1^\ast}` and :math:`t_2` in :math:`{t_2^\ast}`, the value type :math:`t_1` matches the value type :math:`t_2`.


* The limits :math:`(n_{11}, n_{12})` matches the limits :math:`(n_{21}, n_{22})` if:


  * :math:`n_{11}` is greater than or equal to :math:`n_{21}`.

  * :math:`n_{12}` is less than or equal to :math:`n_{22}`.


* The function type :math:`{\mathit{ft}}` matches the function type :math:`{\mathit{ft}}`.


* The global type :math:`{\mathit{gt}}` matches the global type :math:`{\mathit{gt}}`.


* The table type :math:`({\mathit{lim}}_1~{\mathit{rt}})` matches the table type :math:`({\mathit{lim}}_2~{\mathit{rt}})` if:


  * The limits :math:`{\mathit{lim}}_1` matches the limits :math:`{\mathit{lim}}_2`.


* The memory type :math:`{\mathit{lim}}_1~\mathsf{page}` matches the memory type :math:`{\mathit{lim}}_2~\mathsf{page}` if:


  * The limits :math:`{\mathit{lim}}_1` matches the limits :math:`{\mathit{lim}}_2`.


* The external type :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` matches the external type :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


  * Either:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{func}~{\mathit{ft}}_1)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{func}~{\mathit{ft}}_2)`.

    * The function type :math:`{\mathit{ft}}_1` matches the function type :math:`{\mathit{ft}}_2`.

  * Or:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{global}~{\mathit{gt}}_1)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{global}~{\mathit{gt}}_2)`.

    * The global type :math:`{\mathit{gt}}_1` matches the global type :math:`{\mathit{gt}}_2`.
  * Or:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{table}~{\mathit{tt}}_1)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{table}~{\mathit{tt}}_2)`.

    * The table type :math:`{\mathit{tt}}_1` matches the table type :math:`{\mathit{tt}}_2`.
  * Or:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{mem}~{\mathit{mt}}_1)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{mem}~{\mathit{mt}}_2)`.

    * The memory type :math:`{\mathit{mt}}_1` matches the memory type :math:`{\mathit{mt}}_2`.


* The block type :math:`{\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valid with the function type :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}~\rightarrow~{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` if:


  * Either:

    * :math:`{\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{{\mathit{valtype}}^?}`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\epsilon`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is :math:`{{\mathit{valtype}}^?}`.

  * Or:

    * :math:`{\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{typeidx}}`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`{t_1^\ast}`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is :math:`{t_2^\ast}`.

    * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`{\mathit{typeidx}}`.

    * :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.


* The instruction :math:`\mathsf{nop}` is valid with the function type :math:`\epsilon~\rightarrow~\epsilon`.


* The instruction :math:`\mathsf{unreachable}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.


* The instruction :math:`\mathsf{drop}` is valid with the function type :math:`t~\rightarrow~\epsilon`.


* The instruction :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}~{}^?` is valid with the function type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


  * Either: :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is :math:`t`.

  * Or:

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is :math:`\epsilon`.

    * The value type :math:`t` matches the value type :math:`{t'}`.

    * :math:`{t'}` is contained in :math:`{\mathit{numtype}}~{\mathit{vectype}}`.


* The instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}^\ast})` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


  * The block type :math:`{\mathit{bt}}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * Under the context :math:`C{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_2^\ast}]`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.


* The instruction :math:`(\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast})` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


  * The block type :math:`{\mathit{bt}}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * Under the context :math:`C{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_1^\ast}]`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.


* The instruction :math:`(\mathsf{if}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast})` is valid with the function type :math:`{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


  * The block type :math:`{\mathit{bt}}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * Under the context :math:`C{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_2^\ast}]`, the instruction sequence :math:`{{\mathit{instr}}_1^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * Under the context :math:`C{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_2^\ast}]`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.


* The instruction :math:`(\mathsf{br}~l)` is valid with the function type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


  * :math:`{|C{.}\mathsf{labels}|}` is greater than :math:`l`.

  * :math:`C{.}\mathsf{labels}{}[l]` is :math:`{t^\ast}`.


* The instruction :math:`(\mathsf{br\_if}~l)` is valid with the function type :math:`{t^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t^\ast}` if:


  * :math:`{|C{.}\mathsf{labels}|}` is greater than :math:`l`.

  * :math:`C{.}\mathsf{labels}{}[l]` is :math:`{t^\ast}`.


* The instruction :math:`(\mathsf{br\_table}~{l^\ast}~{l'})` is valid with the function type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


  * For all :math:`l` in :math:`{l^\ast}`, :math:`{|C{.}\mathsf{labels}|}` is greater than :math:`l`.

  * For all :math:`l` in :math:`{l^\ast}`, the value type sequence :math:`{t^\ast}` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.

  * :math:`{|C{.}\mathsf{labels}|}` is greater than :math:`{l'}`.

  * The value type sequence :math:`{t^\ast}` matches the result type :math:`C{.}\mathsf{labels}{}[{l'}]`.


* The instruction :math:`(\mathsf{call}~x)` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


  * :math:`{|C{.}\mathsf{funcs}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{funcs}{}[x]` is :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.


* The instruction :math:`(\mathsf{call\_indirect}~x~y)` is valid with the function type :math:`{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


  * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{tables}{}[x]` is :math:`({\mathit{lim}}~\mathsf{funcref})`.

  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`y`.

  * :math:`C{.}\mathsf{types}{}[y]` is :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.


* The instruction :math:`\mathsf{return}` is valid with the function type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


  * :math:`C{.}\mathsf{return}` is :math:`{t^\ast}`.


* The instruction :math:`({\mathit{nt}}{.}\mathsf{const}~c_{\mathit{nt}})` is valid with the function type :math:`\epsilon~\rightarrow~{\mathit{nt}}`.


* The instruction :math:`({\mathit{nt}} {.} {\mathit{unop}}_{\mathit{nt}})` is valid with the function type :math:`{\mathit{nt}}~\rightarrow~{\mathit{nt}}`.


* The instruction :math:`({\mathit{nt}} {.} {\mathit{binop}}_{\mathit{nt}})` is valid with the function type :math:`{\mathit{nt}}~{\mathit{nt}}~\rightarrow~{\mathit{nt}}`.


* The instruction :math:`({\mathit{nt}} {.} {\mathit{testop}}_{\mathit{nt}})` is valid with the function type :math:`{\mathit{nt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.


* The instruction :math:`({\mathit{nt}} {.} {\mathit{relop}}_{\mathit{nt}})` is valid with the function type :math:`{\mathit{nt}}~{\mathit{nt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.


* The instruction :math:`({\mathit{nt}}_1 {.} {{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}{\mathsf{\_}}{{\mathit{nt}}_2})` is valid with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1` if:


  * Either:

    * :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{reinterpret}`.

    * :math:`{|{\mathit{nt}}_1|}` is :math:`{|{\mathit{nt}}_2|}`.

  * Or: :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{cvtop}}`.


* The instruction :math:`(\mathsf{ref{.}null}~{\mathit{rt}})` is valid with the function type :math:`\epsilon~\rightarrow~{\mathit{rt}}`.


* The instruction :math:`(\mathsf{ref{.}func}~x)` is valid with the function type :math:`\epsilon~\rightarrow~\mathsf{funcref}` if:


  * :math:`{|C{.}\mathsf{funcs}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{funcs}{}[x]` is :math:`{\mathit{ft}}`.


* The instruction :math:`\mathsf{ref{.}is\_null}` is valid with the function type :math:`{\mathit{rt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.


* The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` is valid with the function type :math:`\epsilon~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvunop}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvbinop}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvternop}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvtestop}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.


* The instruction :math:`({\mathit{sh}} {.} {\mathit{vunop}}_{\mathit{sh}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`({\mathit{sh}} {.} {\mathit{vbinop}}_{\mathit{sh}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`({\mathit{sh}} {.} {\mathit{vtestop}}_{\mathit{sh}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.


* The instruction :math:`({\mathit{sh}} {.} {\mathit{vrelop}}_{\mathit{sh}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`({\mathit{sh}} {.} {\mathit{vshiftop}}_{\mathit{sh}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`({\mathit{sh}}{.}\mathsf{bitmask})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.


* The instruction :math:`({\mathit{sh}}{.}\mathsf{swizzle})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`({\mathit{sh}}{.}\mathsf{shuffle}~{i^\ast})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * For all :math:`i` in :math:`{i^\ast}`, :math:`i` is less than :math:`2 \cdot {\mathrm{dim}}({\mathit{sh}})`.


* The instruction :math:`({\mathit{sh}}{.}\mathsf{splat})` is valid with the function type :math:`{\mathrm{unpack}}({\mathit{sh}})~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`({{\mathit{sh}}{.}\mathsf{extract\_lane}}{{{\mathit{sx}}^?}}~i)` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~{\mathrm{unpack}}({\mathit{sh}})` if:


  * :math:`i` is less than :math:`{\mathrm{dim}}({\mathit{sh}})`.


* The instruction :math:`({\mathit{sh}}{.}\mathsf{replace\_lane}~i)` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~{\mathrm{unpack}}({\mathit{sh}})~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * :math:`i` is less than :math:`{\mathrm{dim}}({\mathit{sh}})`.


* The instruction :math:`(\mathsf{vextunop}~{\mathit{sh}}_1~{\mathit{sh}}_2~{\mathit{vextunop}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`(\mathsf{vextbinop}~{\mathit{sh}}_1~{\mathit{sh}}_2~{\mathit{vextbinop}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`({{\mathit{sh}}_1{.}\mathsf{narrow}}{\mathsf{\_}}{{\mathit{sh}}_2}{\mathsf{\_}}{{\mathit{sx}}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`({\mathit{sh}}_1 {.} {{\mathit{sh}}_2}{\mathsf{\_}}{{\mathit{vcvtop}}}{\mathsf{\_}}{{{\mathit{hf}}^?}}{\mathsf{\_}}{{{\mathit{zero}}^?}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`(\mathsf{local{.}get}~x)` is valid with the function type :math:`\epsilon~\rightarrow~t` if:


  * :math:`{|C{.}\mathsf{locals}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{locals}{}[x]` is :math:`t`.


* The instruction :math:`(\mathsf{local{.}set}~x)` is valid with the function type :math:`t~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{locals}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{locals}{}[x]` is :math:`t`.


* The instruction :math:`(\mathsf{local{.}tee}~x)` is valid with the function type :math:`t~\rightarrow~t` if:


  * :math:`{|C{.}\mathsf{locals}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{locals}{}[x]` is :math:`t`.


* The instruction :math:`(\mathsf{global{.}get}~x)` is valid with the function type :math:`\epsilon~\rightarrow~t` if:


  * :math:`{|C{.}\mathsf{globals}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{globals}{}[x]` is :math:`({\mathit{mut}}~t)`.


* The instruction :math:`(\mathsf{global{.}set}~x)` is valid with the function type :math:`t~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{globals}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{globals}{}[x]` is :math:`(\mathsf{mut}~t)`.


* The instruction :math:`(\mathsf{table{.}get}~x)` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathit{rt}}` if:


  * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{tables}{}[x]` is :math:`({\mathit{lim}}~{\mathit{rt}})`.


* The instruction :math:`(\mathsf{table{.}set}~x)` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathit{rt}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{tables}{}[x]` is :math:`({\mathit{lim}}~{\mathit{rt}})`.


* The instruction :math:`(\mathsf{table{.}size}~x)` is valid with the function type :math:`\epsilon~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


  * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{tables}{}[x]` is :math:`({\mathit{lim}}~{\mathit{rt}})`.


* The instruction :math:`(\mathsf{table{.}grow}~x)` is valid with the function type :math:`{\mathit{rt}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


  * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{tables}{}[x]` is :math:`({\mathit{lim}}~{\mathit{rt}})`.


* The instruction :math:`(\mathsf{table{.}fill}~x)` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathit{rt}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{tables}{}[x]` is :math:`({\mathit{lim}}~{\mathit{rt}})`.


* The instruction :math:`(\mathsf{table{.}copy}~x_1~x_2)` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x_1`.

  * :math:`C{.}\mathsf{tables}{}[x_1]` is :math:`({\mathit{lim}}_1~{\mathit{rt}})`.

  * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x_2`.

  * :math:`C{.}\mathsf{tables}{}[x_2]` is :math:`({\mathit{lim}}_2~{\mathit{rt}})`.


* The instruction :math:`(\mathsf{table{.}init}~x_1~x_2)` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x_1`.

  * :math:`C{.}\mathsf{tables}{}[x_1]` is :math:`({\mathit{lim}}~{\mathit{rt}})`.

  * :math:`{|C{.}\mathsf{elems}|}` is greater than :math:`x_2`.

  * :math:`C{.}\mathsf{elems}{}[x_2]` is :math:`{\mathit{rt}}`.


* The instruction :math:`(\mathsf{elem{.}drop}~x)` is valid with the function type :math:`\epsilon~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{elems}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{elems}{}[x]` is :math:`{\mathit{rt}}`.


* The instruction :math:`\mathsf{memory{.}size}` is valid with the function type :math:`\epsilon~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`0`.

  * :math:`C{.}\mathsf{mems}{}[0]` is :math:`{\mathit{mt}}`.


* The instruction :math:`\mathsf{memory{.}grow}` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`0`.

  * :math:`C{.}\mathsf{mems}{}[0]` is :math:`{\mathit{mt}}`.


* The instruction :math:`\mathsf{memory{.}fill}` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`0`.

  * :math:`C{.}\mathsf{mems}{}[0]` is :math:`{\mathit{mt}}`.


* The instruction :math:`\mathsf{memory{.}copy}` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`0`.

  * :math:`C{.}\mathsf{mems}{}[0]` is :math:`{\mathit{mt}}`.


* The instruction :math:`(\mathsf{memory{.}init}~x)` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`0`.

  * :math:`C{.}\mathsf{mems}{}[0]` is :math:`{\mathit{mt}}`.

  * :math:`{|C{.}\mathsf{datas}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{datas}{}[x]` is :math:`\mathsf{ok}`.


* The instruction :math:`(\mathsf{data{.}drop}~x)` is valid with the function type :math:`\epsilon~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{datas}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{datas}{}[x]` is :math:`\mathsf{ok}`.


* The instruction :math:`({{\mathit{nt}}{.}\mathsf{load}}{{(n, {\mathit{sx}})^?}}~{}^?~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathit{nt}}` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`0`.

  * :math:`C{.}\mathsf{mems}{}[0]` is :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

  * If :math:`n` is defined,

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.

    * :math:`n / 8` is less than :math:`{|{\mathit{nt}}|} / 8`.

  * If :math:`n` is defined, :math:`{\mathit{nt}}` is :math:`{\mathsf{i}}{n}`.


* The instruction :math:`({\mathit{nt}}{.}\mathsf{store}~{n^?}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathit{nt}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`0`.

  * :math:`C{.}\mathsf{mems}{}[0]` is :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

  * If :math:`n` is defined,

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.

    * :math:`n / 8` is less than :math:`{|{\mathit{nt}}|} / 8`.

  * If :math:`n` is defined, :math:`{\mathit{nt}}` is :math:`{\mathsf{i}}{n}`.


* The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`0`.

  * :math:`C{.}\mathsf{mems}{}[0]` is :math:`{\mathit{mt}}`.

  * Either:

    * :math:`{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`({M}{\mathsf{x}}{\mathsf{x}}{\mathsf{\_}}{N})`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8 \cdot N`.

  * Or:

    * :math:`{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`({n}{\mathsf{\_}}{\mathsf{splat}})`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.
  * Or:

    * :math:`{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`({n}{\mathsf{\_}}{\mathsf{zero}})`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.


* The instruction :math:`(\mathsf{vload\_lane}~\mathsf{v{\scriptstyle 128}}~n~{\mathit{memarg}}~{\mathit{laneidx}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`0`.

  * :math:`C{.}\mathsf{mems}{}[0]` is :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.

  * :math:`{\mathit{laneidx}}` is less than :math:`128 / n`.


* The instruction :math:`(\mathsf{vstore}~\mathsf{v{\scriptstyle 128}}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`0`.

  * :math:`C{.}\mathsf{mems}{}[0]` is :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|\mathsf{v{\scriptstyle 128}}|} / 8`.


* The instruction :math:`(\mathsf{vstore\_lane}~\mathsf{v{\scriptstyle 128}}~n~{\mathit{memarg}}~{\mathit{laneidx}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`0`.

  * :math:`C{.}\mathsf{mems}{}[0]` is :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.

  * :math:`{\mathit{laneidx}}` is less than :math:`128 / n`.


* The instruction sequence :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is valid with the function type :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}~\rightarrow~{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` if:


  * Either:

    * :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\epsilon`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is :math:`\epsilon`.

  * Or:

    * :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`{t_1^\ast}`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is :math:`{t_3^\ast}`.

    * The instruction :math:`{\mathit{instr}}_1` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

    * The instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the function type :math:`{t_2^\ast}~\rightarrow~{t_3^\ast}`.
  * Or:

    * :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`{{\mathit{instr}}^\ast}`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`{{t'}_1^\ast}`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is :math:`{{t'}_2^\ast}`.

    * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

    * The value type sequence :math:`{{t'}_1^\ast}` matches the value type sequence :math:`{t_1^\ast}`.

    * The value type sequence :math:`{t_2^\ast}` matches the value type sequence :math:`{{t'}_2^\ast}`.
  * Or:

    * :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`{{\mathit{instr}}^\ast}`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`{t^\ast}~{t_1^\ast}`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is :math:`{t^\ast}~{t_2^\ast}`.

    * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.


* The expression :math:`{{\mathit{instr}}^\ast}` is valid with the value type sequence :math:`{t^\ast}` if:


  * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`\epsilon~\rightarrow~{t^\ast}`.


* :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is const if:


  * Either: :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`({\mathit{nt}}{.}\mathsf{const}~c)`.

  * Or: :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`({\mathit{vt}}{.}\mathsf{const}~{\mathit{vc}})`.
  * Or: :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{ref{.}null}~{\mathit{rt}})`.
  * Or: :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{ref{.}func}~x)`.
  * Or:

    * :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{global{.}get}~x)`.

    * :math:`{|C{.}\mathsf{globals}|}` is greater than :math:`x`.

    * :math:`C{.}\mathsf{globals}{}[x]` is :math:`(t)`.


* :math:`{{\mathit{instr}}^\ast}` is const if:


  * For all :math:`{\mathit{instr}}` in :math:`{{\mathit{instr}}^\ast}`, :math:`{\mathit{instr}}` is const.


* The type :math:`(\mathsf{type}~{\mathit{ft}})` is valid with the function type :math:`{\mathit{ft}}` if:


  * The function type :math:`{\mathit{ft}}` is valid.


* The function :math:`(\mathsf{func}~x~{(\mathsf{local}~t)^\ast}~{\mathit{expr}})` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{types}{}[x]` is :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * Under the context :math:`C{}[{.}\mathsf{locals} \mathrel{{=}{\oplus}} {t_1^\ast}~{t^\ast}]{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_2^\ast}]{}[{.}\mathsf{return} \mathrel{{=}{\oplus}} {t_2^\ast}]`, the expression :math:`{\mathit{expr}}` is valid with the value type sequence :math:`{t_2^\ast}`.


* The global :math:`(\mathsf{global}~{\mathit{gt}}~{\mathit{expr}})` is valid with the global type :math:`{\mathit{gt}}` if:


  * The global type :math:`{\mathit{gt}}` is valid.

  * :math:`{\mathit{gt}}` is :math:`({\mathit{mut}}~t)`.

  * The expression :math:`{\mathit{expr}}` is valid with the value type :math:`t`.

  * :math:`{\mathit{expr}}` is const.


* The table :math:`(\mathsf{table}~{\mathit{tt}})` is valid with the table type :math:`{\mathit{tt}}` if:


  * The table type :math:`{\mathit{tt}}` is valid.


* The memory :math:`(\mathsf{memory}~{\mathit{mt}})` is valid with the memory type :math:`{\mathit{mt}}` if:


  * The memory type :math:`{\mathit{mt}}` is valid.


* The elemmode :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valid with the reference type :math:`{\mathit{rt}}` if:


  * Either:

    * :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{active}~x~{\mathit{expr}})`.

    * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x`.

    * :math:`C{.}\mathsf{tables}{}[x]` is :math:`({\mathit{lim}}~{\mathit{rt}})`.

    * The expression :math:`{\mathit{expr}}` is valid with the value type :math:`\mathsf{i{\scriptstyle 32}}`.

    * :math:`{\mathit{expr}}` is const.

  * Or: :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{passive}`.
  * Or: :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{declare}`.


* The table segment :math:`(\mathsf{elem}~{\mathit{rt}}~{{\mathit{expr}}^\ast}~{\mathit{elemmode}})` is valid with the reference type :math:`{\mathit{rt}}` if:


  * For all :math:`{\mathit{expr}}` in :math:`{{\mathit{expr}}^\ast}`,

    * The expression :math:`{\mathit{expr}}` is valid with the value type :math:`{\mathit{rt}}`.

    * :math:`{\mathit{expr}}` is const.

  * The elemmode :math:`{\mathit{elemmode}}` is valid with the reference type :math:`{\mathit{rt}}`.


* The datamode :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valid if:


  * Either:

    * :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{active}~0~{\mathit{expr}})`.

    * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`0`.

    * :math:`C{.}\mathsf{mems}{}[0]` is :math:`{\mathit{mt}}`.

    * The expression :math:`{\mathit{expr}}` is valid with the value type :math:`\mathsf{i{\scriptstyle 32}}`.

    * :math:`{\mathit{expr}}` is const.

  * Or: :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{passive}`.


* The memory segment :math:`(\mathsf{data}~{b^\ast}~{\mathit{datamode}})` is valid if:


  * The datamode :math:`{\mathit{datamode}}` is valid.


* The start function :math:`(\mathsf{start}~x)` is valid if:


  * :math:`{|C{.}\mathsf{funcs}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{funcs}{}[x]` is :math:`\epsilon~\rightarrow~\epsilon`.


* The import :math:`(\mathsf{import}~{\mathit{name}}_1~{\mathit{name}}_2~{\mathit{xt}})` is valid with the external type :math:`{\mathit{xt}}` if:


  * The external type :math:`{\mathit{xt}}` is valid.


* The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valid with the external type :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


  * Either:

    * :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{func}~x)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{func}~{\mathit{ft}})`.

    * :math:`{|C{.}\mathsf{funcs}|}` is greater than :math:`x`.

    * :math:`C{.}\mathsf{funcs}{}[x]` is :math:`{\mathit{ft}}`.

  * Or:

    * :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{global}~x)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{global}~{\mathit{gt}})`.

    * :math:`{|C{.}\mathsf{globals}|}` is greater than :math:`x`.

    * :math:`C{.}\mathsf{globals}{}[x]` is :math:`{\mathit{gt}}`.
  * Or:

    * :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{table}~x)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{table}~{\mathit{tt}})`.

    * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x`.

    * :math:`C{.}\mathsf{tables}{}[x]` is :math:`{\mathit{tt}}`.
  * Or:

    * :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{mem}~x)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{mem}~{\mathit{mt}})`.

    * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`x`.

    * :math:`C{.}\mathsf{mems}{}[x]` is :math:`{\mathit{mt}}`.


* The export :math:`(\mathsf{export}~{\mathit{name}}~{\mathit{externidx}})` is valid with the external type :math:`{\mathit{xt}}` if:


  * The external index :math:`{\mathit{externidx}}` is valid with the external type :math:`{\mathit{xt}}`.


* The module :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^{n}}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` is valid if:


  * :math:`{|{\mathit{type*}}|}` is :math:`{|{\mathit{ft'*}}|}`.

  * For all :math:`{\mathit{ft}'}` in :math:`{{\mathit{ft}'}^\ast}` and :math:`{\mathit{type}}` in :math:`{{\mathit{type}}^\ast}`, the type :math:`{\mathit{type}}` is valid with the function type :math:`{\mathit{ft}'}`.

  * :math:`{|{\mathit{ixt*}}|}` is :math:`{|{\mathit{import*}}|}`.

  * For all :math:`{\mathit{import}}` in :math:`{{\mathit{import}}^\ast}` and :math:`{\mathit{ixt}}` in :math:`{{\mathit{ixt}}^\ast}`, under the context :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon,\; \mathsf{return}~\epsilon \}\end{array}`, the import :math:`{\mathit{import}}` is valid with the external type :math:`{\mathit{ixt}}`.

  * :math:`{|{\mathit{gt*}}|}` is :math:`{|{\mathit{global*}}|}`.

  * For all :math:`{\mathit{global}}` in :math:`{{\mathit{global}}^\ast}` and :math:`{\mathit{gt}}` in :math:`{{\mathit{gt}}^\ast}`, under the context :math:`{C'}`, the global :math:`{\mathit{global}}` is valid with the global type :math:`{\mathit{gt}}`.

  * :math:`{|{\mathit{tt*}}|}` is :math:`{|{\mathit{table*}}|}`.

  * For all :math:`{\mathit{table}}` in :math:`{{\mathit{table}}^\ast}` and :math:`{\mathit{tt}}` in :math:`{{\mathit{tt}}^\ast}`, under the context :math:`{C'}`, the table :math:`{\mathit{table}}` is valid with the table type :math:`{\mathit{tt}}`.

  * :math:`{|{\mathit{mt*}}|}` is :math:`{|{\mathit{mem*}}|}`.

  * For all :math:`{\mathit{mem}}` in :math:`{{\mathit{mem}}^\ast}` and :math:`{\mathit{mt}}` in :math:`{{\mathit{mt}}^\ast}`, under the context :math:`{C'}`, the memory :math:`{\mathit{mem}}` is valid with the memory type :math:`{\mathit{mt}}`.

  * :math:`{|{\mathit{rt*}}|}` is :math:`{|{\mathit{elem*}}|}`.

  * For all :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}` and :math:`{\mathit{rt}}` in :math:`{{\mathit{rt}}^\ast}`, under the context :math:`{C'}`, the table segment :math:`{\mathit{elem}}` is valid with the reference type :math:`{\mathit{rt}}`.

  * For all :math:`{\mathit{data}}` in :math:`{{\mathit{data}}^\ast}`, under the context :math:`{C'}`, the memory segment :math:`{\mathit{data}}` is valid.

  * :math:`{|{\mathit{func*}}|}` is :math:`{|{\mathit{ft*}}|}`.

  * For all :math:`{\mathit{ft}}` in :math:`{{\mathit{ft}}^\ast}` and :math:`{\mathit{func}}` in :math:`{{\mathit{func}}^\ast}`, the function :math:`{\mathit{func}}` is valid with the function type :math:`{\mathit{ft}}`.

  * If :math:`{\mathit{start}}` is defined, the start function :math:`{\mathit{start}}` is valid.

  * :math:`{|{\mathit{xt*}}|}` is :math:`{|{\mathit{export*}}|}`.

  * For all :math:`{\mathit{export}}` in :math:`{{\mathit{export}}^\ast}` and :math:`{\mathit{xt}}` in :math:`{{\mathit{xt}}^\ast}`, the export :math:`{\mathit{export}}` is valid with the external type :math:`{\mathit{xt}}`.

  * :math:`{|{{\mathit{mt}}^\ast}|}` is less than or equal to :math:`1`.

  * :math:`C` is :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{funcs}~{{\mathit{ift}}^\ast}~{{\mathit{ft}}^\ast},\; \mathsf{globals}~{{\mathit{igt}}^\ast}~{{\mathit{gt}}^\ast},\; \mathsf{tables}~{{\mathit{itt}}^\ast}~{{\mathit{tt}}^\ast},\; \mathsf{mems}~{{\mathit{imt}}^\ast}~{{\mathit{mt}}^\ast},\; \mathsf{elems}~{{\mathit{rt}}^\ast},\; \mathsf{datas}~{\mathsf{ok}^{n}},\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon,\; \mathsf{return}~\epsilon \}\end{array}`.

  * :math:`{C'}` is :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{funcs}~{{\mathit{ift}}^\ast}~{{\mathit{ft}}^\ast},\; \mathsf{globals}~{{\mathit{igt}}^\ast},\; \mathsf{tables}~{{\mathit{itt}}^\ast}~{{\mathit{tt}}^\ast},\; \mathsf{mems}~{{\mathit{imt}}^\ast}~{{\mathit{mt}}^\ast},\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon,\; \mathsf{return}~\epsilon \}\end{array}`.

  * :math:`{{\mathit{ift}}^\ast}` is :math:`{\mathrm{funcs}}({{\mathit{ixt}}^\ast})`.

  * :math:`{{\mathit{igt}}^\ast}` is :math:`{\mathrm{globals}}({{\mathit{ixt}}^\ast})`.

  * :math:`{{\mathit{itt}}^\ast}` is :math:`{\mathrm{tables}}({{\mathit{ixt}}^\ast})`.

  * :math:`{{\mathit{imt}}^\ast}` is :math:`{\mathrm{mems}}({{\mathit{ixt}}^\ast})`.


:math:`\mathsf{unreachable}`
............................


1. Trap.


:math:`\mathsf{nop}`
....................


1. Do nothing.


:math:`\mathsf{drop}`
.....................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Do nothing.


:math:`\mathsf{select}~{({t^\ast})^?}`
......................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_2` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_1` from the stack.

#. If :math:`c` is not :math:`0`, then:

  a. Push the value :math:`{\mathit{val}}_1` to the stack.

#. Else:

  a. Push the value :math:`{\mathit{val}}_2` to the stack.


:math:`\mathsf{if}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast}~{{\mathit{instr}}_2^\ast}`
.....................................................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c` is not :math:`0`, then:

  a. Execute the instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast})`.

#. Else:

  a. Execute the instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}_2^\ast})`.


:math:`\mathsf{label}`
......................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, a label is now on the top of the stack.

#. Pop the current label from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.


:math:`\mathsf{br}~n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`
.............................................................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, the top of the stack is a :math:`\mathsf{label}`.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

#. Let :math:`L` be the current label.

#. Let :math:`n` be the arity of :math:`L`.

#. Let :math:`{{\mathit{instr}'}^\ast}` be the continuation of :math:`L`.

#. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`0`, then:

  a. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

  #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

  #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

  #. Pop the current label from the stack.

  #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

  #. Execute the instruction :math:`{{\mathit{instr}'}^\ast}`.

#. Else:

  a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

  #. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is greater than or equal to :math:`1`, then:

    1) Let :math:`l` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 0}}} - 1`.

    #) Pop the current label from the stack.

    #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

    #) Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{br\_if}~l`
.........................


1. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c` is not :math:`0`, then:

  a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

  a. Do nothing.


:math:`\mathsf{br\_table}~{l^\ast}~{l'}`
........................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i` is less than :math:`{|{l^\ast}|}`, then:

  a. Execute the instruction :math:`(\mathsf{br}~{l^\ast}{}[i])`.

#. Else:

  a. Execute the instruction :math:`(\mathsf{br}~{l'})`.


:math:`\mathsf{frame}`
......................


1. Let :math:`F` be the current frame.

#. Let :math:`n` be the arity of :math:`F`.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Assert: Due to validation, a frame is now on the top of the stack.

#. Pop the current frame from the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.


:math:`\mathsf{return}`
.......................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. If the top of the stack is a :math:`\mathsf{frame}`, then:

  a. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Let :math:`F` be the current frame.

  #. Let :math:`n` be the arity of :math:`F`.

  #. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

  #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

  #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

  #. Pop the current frame from the stack.

  #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Else if the top of the stack is a :math:`\mathsf{label}`, then:

  a. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

  #. Pop the current label from the stack.

  #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Execute the instruction :math:`\mathsf{return}`.


:math:`{\mathit{nt}} {.} {\mathit{unop}}`
.........................................


1. Assert: Due to validation, a value of value type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{nt}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{unop}}}{{}_{{\mathit{nt}}}}{(c_1)}|}` is less than or equal to :math:`0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{unop}}}{{}_{{\mathit{nt}}}}{(c_1)}`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{binop}}`
..........................................


1. Assert: Due to validation, a value of value type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{nt}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`{\mathit{numtype}}_0` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{binop}}}{{}_{{\mathit{nt}}}}{(c_1, c_2)}|}` is less than or equal to :math:`0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{binop}}}{{}_{{\mathit{nt}}}}{(c_1, c_2)}`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{testop}}`
...........................................


1. Assert: Due to validation, a value of value type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{nt}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{testop}}}{{}_{{\mathit{nt}}}}{(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{relop}}`
..........................................


1. Assert: Due to validation, a value of value type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{nt}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`{\mathit{numtype}}_0` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{relop}}}{{}_{{\mathit{nt}}}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}}_2 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_1}`
............................................................................


1. Assert: Due to validation, a value of value type :math:`{\mathit{nt}}_1` is on the top of the stack.

#. Pop the value :math:`({\mathit{nt}}_1{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{cvtop}}}{{}_{{\mathit{nt}}_1, {\mathit{nt}}_2}}{(c_1)}|}` is less than or equal to :math:`0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{cvtop}}}{{}_{{\mathit{nt}}_1, {\mathit{nt}}_2}}{(c_1)}`.

#. Push the value :math:`({\mathit{nt}}_2{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{ref{.}is\_null}`
...............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. If :math:`{\mathit{ref}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvunop}}`
..........................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vvunop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvbinop}}`
...........................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vvbinop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvternop}}`
............................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_3)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vvternop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2, c_3)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} \mathsf{any\_true}`
...........................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{ine}}}_{{|\mathsf{v{\scriptstyle 128}}|}}(c_1, 0)`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vunop}}`
..........................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{vunop}}}{{}_{{\mathit{sh}}}}{(c_1)}|}` is less than or equal to :math:`0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vunop}}}{{}_{{\mathit{sh}}}}{(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vbinop}}`
...........................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{vbinop}}}{{}_{{\mathit{sh}}}}{(c_1, c_2)}|}` is less than or equal to :math:`0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vbinop}}}{{}_{{\mathit{sh}}}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N} {.} \mathsf{all\_true}`
...............................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c)`.

#. If for all :math:`{({\mathit{ci}}_1)^\ast}`, :math:`{\mathit{ci}}_1` is not :math:`0`, then:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vrelop}}`
...........................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vrelop}}}{{}_{{\mathit{sh}}}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N} {.} {\mathit{vshiftop}}`
................................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`{{c'}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c_1)`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{{{\mathit{vshiftop}}}{\mathsf{\_}}~{{\mathsf{i}}{n}}{\mathsf{x}}{N}}{({c'}, n)}^\ast})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}{.}\mathsf{bitmask}`
...........................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c)`.

#. Let :math:`{\mathit{ci}}` be the result for which :math:`{{\mathrm{bits}}}_{{\mathsf{i}}{32}}({\mathit{ci}})` :math:`=` :math:`{{{{{\mathrm{ilt}}}_{{|{\mathsf{i}}{n}|}}^{\mathsf{s}}}}{({\mathit{ci}}_1, 0)}^\ast}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{\mathit{ci}})` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{M}{.}\mathsf{swizzle}`
...........................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`{{c'}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c_1)~{0^{256 - M}}`.

#. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c_2)`.

#. Assert: Due to validation, for all :math:`{(k)^{k<M}}`, :math:`{{\mathit{ci}}^\ast}{}[k]` is less than :math:`{|{{c'}^\ast}|}`.

#. Assert: Due to validation, for all :math:`{(k)^{k<M}}`, :math:`k` is less than :math:`{|{{\mathit{ci}}^\ast}|}`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{c'}^\ast}{}[{{\mathit{ci}}^\ast}{}[k]]^{k<M}})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}{.}\mathsf{shuffle}~{i^\ast}`
....................................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, for all :math:`{(k)^{k<N}}`, :math:`k` is less than :math:`{|{i^\ast}|}`.

#. Let :math:`{{c'}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c_1)~{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c_2)`.

#. Assert: Due to validation, for all :math:`{(k)^{k<N}}`, :math:`{i^\ast}{}[k]` is less than :math:`{|{{c'}^\ast}|}`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{{c'}^\ast}{}[{i^\ast}{}[k]]^{k<N}})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}{.}\mathsf{splat}`
.........................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0` is :math:`{\mathrm{unpack}}({\mathsf{i}}{n})`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{{\mathrm{pack}}}_{{\mathsf{i}}{n}}(c_1)^{N}})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}{\mathsf{x}}{N}{.}\mathsf{extract\_lane}}{{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~i`
............................................................................................................................................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is numtype, then:

  a. Let :math:`{\mathit{nt}}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If :math:`i` is less than :math:`{|{{\mathrm{lanes}}}_{{{\mathit{nt}}}{\mathsf{x}}{N}}(c_1)|}`, then:

    1) Let :math:`c_2` be :math:`{{\mathrm{lanes}}}_{{{\mathit{nt}}}{\mathsf{x}}{N}}(c_1){}[i]`.

    #) Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c_2)` to the stack.

#. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is packtype, then:

  a. Let :math:`{\mathit{pt}}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

    1) Let :math:`{\mathit{sx}}` be :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

    #) If :math:`i` is less than :math:`{|{{\mathrm{lanes}}}_{{{\mathit{pt}}}{\mathsf{x}}{N}}(c_1)|}`, then:

      a) Let :math:`c_2` be :math:`{{{{\mathrm{extend}}}_{{|{\mathit{pt}}|}, 32}^{{\mathit{sx}}}}}{({{\mathrm{lanes}}}_{{{\mathit{pt}}}{\mathsf{x}}{N}}(c_1){}[i])}`.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c_2)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}{.}\mathsf{replace\_lane}~i`
...................................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0` is :math:`{\mathrm{unpack}}({\mathsf{i}}{n})`.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c_1){}[{}[i] = {{\mathrm{pack}}}_{{\mathsf{i}}{n}}(c_2)])`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{vextunop}~{\mathit{sh}}_1~{\mathit{sh}}_2~{\mathit{vextunop}}`
.............................................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{vextunop}}}_{{\mathit{sh}}_1, {\mathit{sh}}_2}({\mathit{vextunop}}, c_1)`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{vextbinop}~{\mathit{sh}}_1~{\mathit{sh}}_2~{\mathit{vextbinop}}`
...............................................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{vextbinop}}}_{{\mathit{sh}}_1, {\mathit{sh}}_2}({\mathit{vextbinop}}, c_1, c_2)`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{N_2}{.}\mathsf{narrow}}{\mathsf{\_}}{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{N_1}}{\mathsf{\_}}{{\mathit{sx}}}`
...................................................................................................................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{N_1}}(c_1)`.

#. Let :math:`{{\mathit{ci}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{N_1}}(c_2)`.

#. Let :math:`{{\mathit{cj}}_1^\ast}` be :math:`{{{{{\mathrm{narrow}}}_{{|{{\mathsf{i}}{n}}_1|}, {|{{\mathsf{i}}{n}}_2|}}^{{\mathit{sx}}}}}{{\mathit{ci}}_1}^\ast}`.

#. Let :math:`{{\mathit{cj}}_2^\ast}` be :math:`{{{{{\mathrm{narrow}}}_{{|{{\mathsf{i}}{n}}_1|}, {|{{\mathsf{i}}{n}}_2|}}^{{\mathit{sx}}}}}{{\mathit{ci}}_2}^\ast}`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{N_2}}({{\mathit{cj}}_1^\ast}~{{\mathit{cj}}_2^\ast})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}}{\mathsf{x}}{n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}} {.} {{{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}}{\mathsf{x}}{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}{\mathsf{\_}}{{\mathit{vcvtop}}}{\mathsf{\_}}{{{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^?}}{\mathsf{\_}}{{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 5}}}^?}}`
...........................................................................................................................................................................................................................................................................................................................................................................................................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^?}` is not defined and :math:`{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 5}}}^?}` is not defined, then:

  a. Let :math:`{{\mathsf{i}}{n}}_1` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}`.

  #. Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`M` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`M`, then:

    1) Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M}}(c_1)`.

    #) Let :math:`{{{\mathit{cj}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{vcvtop}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M}, {{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M}}({\mathit{vcvtop}}, {\mathit{ci}})^\ast}`.

    #) If :math:`{|{{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M}}({{\mathit{cj}}^\ast})^\ast}|}` is greater than :math:`0`, then:

      a) Let :math:`c` be an element of :math:`{{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M}}({{\mathit{cj}}^\ast})^\ast}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. If :math:`{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 5}}}^?}` is not defined, then:

  a. Let :math:`{{\mathsf{i}}{n}}_1` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}`.

  #. Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`M_1` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`M_2` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If :math:`{{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^?}` is defined, then:

    1) Let :math:`{\mathit{half}}` be :math:`{{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^?}`.

    #) Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}}(c_1){}[{\mathrm{half}}({\mathit{half}}, 0, M_2) : M_2]`.

    #) Let :math:`{{{\mathit{cj}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{vcvtop}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}, {\mathit{ci}})^\ast}`.

    #) If :math:`{|{{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}({{\mathit{cj}}^\ast})^\ast}|}` is greater than :math:`0`, then:

      a) Let :math:`c` be an element of :math:`{{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}({{\mathit{cj}}^\ast})^\ast}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. If :math:`{{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^?}` is not defined, then:

  a. Let :math:`M_1` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`M_2` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` is numtype, then:

    1) Let :math:`{\mathit{nt}}_1` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}`.

    #) If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is numtype, then:

      a) Let :math:`{\mathit{nt}}_2` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

      #) If :math:`{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 5}}}^?}` is defined, then:

        1. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{nt}}_1}{\mathsf{x}}{M_1}}(c_1)`.

        #. Let :math:`{{{\mathit{cj}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{vcvtop}}}_{{{\mathit{nt}}_1}{\mathsf{x}}{M_1}, {{\mathit{nt}}_2}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}, {\mathit{ci}})^\ast}~{{\mathrm{zero}}({\mathit{nt}}_2)^{M_1}}`.

        #. If :math:`{|{{{\mathrm{invlanes}}}_{{{\mathit{nt}}_2}{\mathsf{x}}{M_2}}({{\mathit{cj}}^\ast})^\ast}|}` is greater than :math:`0`, then:

          a. Let :math:`c` be an element of :math:`{{{\mathrm{invlanes}}}_{{{\mathit{nt}}_2}{\mathsf{x}}{M_2}}({{\mathit{cj}}^\ast})^\ast}`.

          #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{local{.}tee}~x`
..............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Execute the instruction :math:`(\mathsf{local{.}set}~x)`.


:math:`\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}^\ast}`
............................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{k}}~\rightarrow~{t_2^{n}}` be :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`k` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Let :math:`L` be the label whose arity is :math:`n` and whose continuation is :math:`\epsilon`.

#. Enter :math:`{{\mathit{val}}^{k}}~{{\mathit{instr}}^\ast}` with label :math:`L`.


:math:`\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast}`
...........................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{k}}~\rightarrow~{t_2^{n}}` be :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`k` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Let :math:`L` be the label whose arity is :math:`k` and whose continuation is :math:`(\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast})`.

#. Enter :math:`{{\mathit{val}}^{k}}~{{\mathit{instr}}^\ast}` with label :math:`L`.


:math:`\mathsf{call}~x`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x` is less than :math:`{|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Execute the instruction :math:`(\mathsf{call}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x])`.


:math:`\mathsf{call\_indirect}~x~y`
...................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i` is greater than or equal to :math:`{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i]` is not of the case :math:`\mathsf{ref{.}func\_addr}`, then:

  a. Trap.

#. Let :math:`(\mathsf{ref{.}func\_addr}~a)` be :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i]`.

#. If :math:`a` is greater than or equal to :math:`{|z{.}\mathsf{funcs}|}`, then:

  a. Trap.

#. If :math:`z{.}\mathsf{types}{}[y]` is not :math:`z{.}\mathsf{funcs}{}[a]{.}\mathsf{type}`, then:

  a. Trap.

#. Execute the instruction :math:`(\mathsf{call}~a)`.


:math:`\mathsf{call}~a`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`a` is less than :math:`{|z{.}\mathsf{funcs}|}`.

#. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{t_1^{k}}~\rightarrow~{t_2^{n}},\; \mathsf{module}~{\mathit{mm}},\; \mathsf{code}~{\mathit{func}} \}\end{array}` be :math:`z{.}\mathsf{funcs}{}[a]`.

#. Assert: Due to validation, there are at least :math:`k` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Assert: Due to validation, :math:`{\mathit{func}}` is of the case :math:`\mathsf{func}`.

#. Let :math:`(\mathsf{func}~x~{{\mathit{local}}_0^\ast}~{{\mathit{instr}}^\ast})` be :math:`{\mathit{func}}`.

#. Assert: Due to validation, for all :math:`{({\mathit{local}}_0)^\ast}`, :math:`{\mathit{local}}_0` is of the case :math:`\mathsf{local}`.

#. Let :math:`{(\mathsf{local}~t)^\ast}` be :math:`{{\mathit{local}}_0^\ast}`.

#. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~{{\mathit{val}}^{k}}~{{{\mathrm{default}}}_{t}^\ast},\; \mathsf{module}~{\mathit{mm}} \}\end{array}`.

#. Let :math:`F` be the activation of :math:`f` with arity :math:`n`.

#. Push :math:`F` to the stack.

#. Let :math:`L` be the label whose arity is :math:`n` and whose continuation is :math:`\epsilon`.

#. Enter :math:`{{\mathit{instr}}^\ast}` with label :math:`L`.


:math:`\mathsf{ref{.}func}~x`
.............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x` is less than :math:`{|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Push the value :math:`(\mathsf{ref{.}func}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x])` to the stack.


:math:`\mathsf{local{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Push the value :math:`z{.}\mathsf{locals}{}[x]` to the stack.


:math:`\mathsf{global{.}get}~x`
...............................


1. Let :math:`z` be the current state.

#. Push the value :math:`z{.}\mathsf{globals}{}[x]{.}\mathsf{value}` to the stack.


:math:`\mathsf{table{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i` is greater than or equal to :math:`{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. Push the value :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i]` to the stack.


:math:`\mathsf{table{.}size}~x`
...............................


1. Let :math:`z` be the current state.

#. Let :math:`n` be :math:`{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{table{.}fill}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n` is greater than :math:`{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`n` is :math:`0`, then:

  a. Do nothing.

#. Else:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

  #. Push the value :math:`{\mathit{val}}` to the stack.

  #. Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

  #. Push the value :math:`{\mathit{val}}` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`(\mathsf{table{.}fill}~x)`.


:math:`\mathsf{table{.}copy}~x~y`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n` is greater than :math:`{|z{.}\mathsf{tables}{}[y]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`j + n` is greater than :math:`{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`n` is :math:`0`, then:

  a. Do nothing.

#. Else:

  a. If :math:`j` is less than or equal to :math:`i`, then:

    1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

    #) Execute the instruction :math:`(\mathsf{table{.}get}~y)`.

    #) Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

  #. Else:

    1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + n - 1)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + n - 1)` to the stack.

    #) Execute the instruction :math:`(\mathsf{table{.}get}~y)`.

    #) Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`(\mathsf{table{.}copy}~x~y)`.


:math:`\mathsf{table{.}init}~x~y`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n` is greater than :math:`{|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`j + n` is greater than :math:`{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`n` is :math:`0`, then:

  a. Do nothing.

#. Else if :math:`i` is less than :math:`{|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

  #. Push the value :math:`z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[i]` to the stack.

  #. Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`(\mathsf{table{.}init}~x~y)`.


:math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}{.}\mathsf{load}~{{\mathit{sz}}_{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}^?}~{\mathit{ao}}`
..........................................................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`{{\mathit{sz}}_{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}^?}` is not defined, then:

  a. Let :math:`{\mathit{nt}}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}}|} / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

    1) Trap.

  #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathit{nt}}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}}|} / 8]`.

  #. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.

#. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Inn, then:

  a. If :math:`{{\mathit{sz}}_{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}^?}` is defined, then:

    1) Let :math:`{\mathit{sz}}_{{\mathit{sx}}_0}` be :math:`{{\mathit{sz}}_{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}^?}`.

    #) Let :math:`(n, {\mathit{sx}})` be :math:`{\mathit{sz}}_{{\mathit{sx}}_0}`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      a) Trap.

  #. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If :math:`{{\mathit{sz}}_{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}^?}` is defined, then:

    1) Let :math:`{\mathit{sz}}_{{\mathit{sx}}_0}` be :math:`{{\mathit{sz}}_{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}^?}`.

    #) Let :math:`(n, {\mathit{sx}})` be :math:`{\mathit{sz}}_{{\mathit{sx}}_0}`.

    #) Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8]`.

    #) Push the value :math:`({\mathsf{i}}{n}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{n, {|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{(c)})` to the stack.


:math:`\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}~{\mathit{ao}}`
.................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|\mathsf{v{\scriptstyle 128}}|} / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}` and :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is not defined, then:

  a. Trap.

#. If :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is not defined, then:

  a. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{\mathsf{v{\scriptstyle 128}}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|\mathsf{v{\scriptstyle 128}}|} / 8]`.

  #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. Else:

  a. Let :math:`{\mathit{vloadop}}_0` be :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}`.

  #. If :math:`{\mathit{vloadop}}_0` is of the case :math:`\mathsf{shape}`, then:

    1) Let :math:`({M}{\mathsf{x}}{\mathsf{x}}{\mathsf{\_}}{N})` be :math:`{\mathit{vloadop}}_0`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + M \cdot N / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      a) Trap.

    #) Let :math:`{j^{N}}` be the result for which for all :math:`{(k)^{k<N}}`, :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{M}}({j^{N}})` is :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} + k \cdot M / 8 : M / 8]`.

    #) If the type of :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`M \cdot 2` is Jnn, then:

      a) Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`M \cdot 2`.

      #) Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{{{{\mathrm{extend}}}_{M, {|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{(j)}^{N}})`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

  #. If :math:`{\mathit{vloadop}}_0` is of the case :math:`\mathsf{splat}`, then:

    1) Let :math:`({N}{\mathsf{\_}}{\mathsf{splat}})` be :math:`{\mathit{vloadop}}_0`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      a) Trap.

    #) Let :math:`M` be :math:`128 / N`.

    #) If the type of :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`N` is Jnn, then:

      a) Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`N`.

      #) Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

      #) Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({j^{M}})`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

  #. If :math:`{\mathit{vloadop}}_0` is of the case :math:`\mathsf{zero}`, then:

    1) Let :math:`({N}{\mathsf{\_}}{\mathsf{zero}})` be :math:`{\mathit{vloadop}}_0`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      a) Trap.

    #) Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

    #) Let :math:`c` be :math:`{{{{\mathrm{extend}}}_{N, 128}^{\mathsf{u}}}}{(j)}`.

    #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{vload\_lane}~\mathsf{v{\scriptstyle 128}}~N~{\mathit{ao}}~j`
...........................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. Let :math:`M` be :math:`128 / N`.

#. If the type of :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`N` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`N`.

  #. Let :math:`k` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(k)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

  #. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c_1){}[{}[j] = k])`.

  #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{memory{.}size}`
..............................


1. Let :math:`z` be the current state.

#. Let :math:`n \cdot 64 \cdot {\mathrm{Ki}}` be :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{memory{.}fill}`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n` is greater than :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. If :math:`n` is :math:`0`, then:

  a. Do nothing.

#. Else:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

  #. Push the value :math:`{\mathit{val}}` to the stack.

  #. Execute the instruction :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}~8)`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

  #. Push the value :math:`{\mathit{val}}` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`\mathsf{memory{.}fill}`.


:math:`\mathsf{memory{.}copy}`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n` is greater than :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. If :math:`j + n` is greater than :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. If :math:`n` is :math:`0`, then:

  a. Do nothing.

#. Else:

  a. If :math:`j` is less than or equal to :math:`i`, then:

    1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

    #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{load}}{(8, \mathsf{u})}~{}^?)`.

    #) Execute the instruction :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}~8)`.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

  #. Else:

    1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + n - 1)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + n - 1)` to the stack.

    #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{load}}{(8, \mathsf{u})}~{}^?)`.

    #) Execute the instruction :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}~8)`.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`\mathsf{memory{.}copy}`.


:math:`\mathsf{memory{.}init}~x`
................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n` is greater than :math:`{|z{.}\mathsf{datas}{}[x]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. If :math:`j + n` is greater than :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. If :math:`n` is :math:`0`, then:

  a. Do nothing.

#. Else if :math:`i` is less than :math:`{|z{.}\mathsf{datas}{}[x]{.}\mathsf{bytes}|}`, then:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~z{.}\mathsf{datas}{}[x]{.}\mathsf{bytes}{}[i])` to the stack.

  #. Execute the instruction :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}~8)`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`(\mathsf{memory{.}init}~x)`.


:math:`\mathsf{local{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{locals}{}[x] = {\mathit{val}}]`.


:math:`\mathsf{global{.}set}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = {\mathit{val}}]`.


:math:`\mathsf{table{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i` is greater than or equal to :math:`{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. Perform :math:`z{}[{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i] = {\mathit{ref}}]`.


:math:`\mathsf{table{.}grow}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Either:

  a. Let :math:`{\mathit{ti}}` be :math:`{\mathrm{growtable}}(z{.}\mathsf{tables}{}[x], n, {\mathit{ref}})`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|})` to the stack.

  #. Perform :math:`z{}[{.}\mathsf{tables}{}[x] = {\mathit{ti}}]`.

#. Or:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{32}^{{-1}}}}{({-1})})` to the stack.


:math:`\mathsf{elem{.}drop}~x`
..............................


1. Let :math:`z` be the current state.

#. Perform :math:`z{}[{.}\mathsf{elems}{}[x]{.}\mathsf{refs} = \epsilon]`.


:math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}{.}\mathsf{store}~{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}~{\mathit{ao}}`
...........................................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Let :math:`{\mathit{nt}}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}}|} / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}` and :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{nt}}` and :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Trap.

#. If :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{nt}}` and :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathit{nt}}}(c)`.

  #. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}}|} / 8] = {b^\ast}]`.

#. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. If :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathsf{i}}{n}` and :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

    1) Let :math:`n` be :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      a) Trap.

    #) Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}({{\mathrm{wrap}}}_{{|{\mathsf{i}}{n}|}, n}(c))`.

    #) Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8] = {b^\ast}]`.


:math:`\mathsf{vstore}~\mathsf{v{\scriptstyle 128}}~{\mathit{ao}}`
..................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|\mathsf{v{\scriptstyle 128}}|} / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{\mathsf{v{\scriptstyle 128}}}(c)`.

#. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|\mathsf{v{\scriptstyle 128}}|} / 8] = {b^\ast}]`.


:math:`\mathsf{vstore\_lane}~\mathsf{v{\scriptstyle 128}}~N~{\mathit{ao}}~j`
............................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N` is greater than :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. Let :math:`M` be :math:`128 / N`.

#. If the type of :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`N` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`N`.

  #. If :math:`j` is less than :math:`{|{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c)|}`, then:

    1) Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}({{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c){}[j])`.

    #) Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8] = {b^\ast}]`.


:math:`\mathsf{memory{.}grow}`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Either:

  a. Let :math:`{\mathit{mi}}` be :math:`{\mathrm{growmemory}}(z{.}\mathsf{mems}{}[0], n)`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|} / 64 \, {\mathrm{Ki}})` to the stack.

  #. Perform :math:`z{}[{.}\mathsf{mems}{}[0] = {\mathit{mi}}]`.

#. Or:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{32}^{{-1}}}}{({-1})})` to the stack.


:math:`\mathsf{data{.}drop}~x`
..............................


1. Let :math:`z` be the current state.

#. Perform :math:`z{}[{.}\mathsf{datas}{}[x]{.}\mathsf{bytes} = \epsilon]`.


:math:`{\mathrm{Ki}}`
.....................


1. Return :math:`1024`.


:math:`{\mathrm{min}}(n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}, n_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
............................................................................................................


1. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`0`, then:

  a. Return :math:`0`.

#. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`0`, then:

  a. Return :math:`0`.

#. Assert: Due to validation, :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is greater than or equal to :math:`1`.

#. Let :math:`i` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 0}}} - 1`.

#. Assert: Due to validation, :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is greater than or equal to :math:`1`.

#. Let :math:`j` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}} - 1`.

#. Return :math:`{\mathrm{min}}(i, j)`.


:math:`{\mathrm{sum}}({n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
........................................................................


1. If :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`0`.

#. Let :math:`n~{{n'}^\ast}` be :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`n + {\mathrm{sum}}({{n'}^\ast})`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`
........................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}|}` is :math:`1`.

#. Let :math:`w` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`w`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}`
.....................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is not defined, then:

  a. Return :math:`\epsilon`.

#. Let :math:`w` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}`.

#. Return :math:`w`.


:math:`{\mathrm{concat}}({X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
...........................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{w^\ast}~{{{w'}^\ast}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{w^\ast}~{\mathrm{concat}}({{{w'}^\ast}^\ast})`.


:math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{{\mathit{TODO}}}(w_1, {X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
...................................................................................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{{w'}^\ast}~{{w^\ast}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`w_1~{{w'}^\ast}~{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{{\mathit{TODO}}}(w_1, {{w^\ast}^\ast})`.


:math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{{\mathit{TODO}}}({X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}, {{w^\ast}^\ast})`
...............................................................................................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`w_1~{{w'}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{{\mathit{TODO}}}(w_1, {{w^\ast}^\ast})~{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{{\mathit{TODO}}}({{w'}^\ast}, {{w^\ast}^\ast})`.


:math:`\Large\times~{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`
.....................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{w_1^\ast}~{{w^\ast}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{{\mathit{TODO}}}({w_1^\ast}, \Large\times~{{w^\ast}^\ast})`.


:math:`{\mathrm{signif}}(N_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
....................................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`32`, then:

  a. Return :math:`23`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`64`.

#. Return :math:`52`.


:math:`{\mathrm{expon}}(N_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
...................................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`32`, then:

  a. Return :math:`8`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`64`.

#. Return :math:`11`.


:math:`M`
.........


1. Return :math:`{\mathrm{signif}}(N)`.


:math:`E`
.........


1. Return :math:`{\mathrm{expon}}(N)`.


:math:`{+0}`
............


1. Return :math:`({+((0 + 0 \cdot {2^{{-M}}}) \cdot {2^{n}})})`.


:math:`{+1}`
............


1. Return :math:`({+((1 + 1 \cdot {2^{{-M}}}) \cdot {2^{0}})})`.


:math:`{{\mathrm{canon}}}_{N}`
..............................


1. Return :math:`{2^{{\mathrm{signif}}(N) - 1}}`.


:math:`{|{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}|}`
......................................................................


1. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{i{\scriptstyle 32}}`, then:

  a. Return :math:`32`.

#. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{i{\scriptstyle 64}}`, then:

  a. Return :math:`64`.

#. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{f{\scriptstyle 32}}`, then:

  a. Return :math:`32`.

#. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{f{\scriptstyle 64}}`, then:

  a. Return :math:`64`.

#. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{v{\scriptstyle 128}}`, then:

  a. Return :math:`128`.


:math:`{|{\mathsf{i}}{n}|}`
...........................


1. Return :math:`{|{\mathsf{i}}{n}|}`.


:math:`{|{\mathit{packtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}|}`
.......................................................................


1. If :math:`{\mathit{packtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{i{\scriptstyle 8}}`, then:

  a. Return :math:`8`.

#. Assert: Due to validation, :math:`{\mathit{packtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{i{\scriptstyle 16}}`.

#. Return :math:`16`.


:math:`{|{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}|}`
.......................................................................


1. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is numtype, then:

  a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{|{\mathit{numtype}}|}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is packtype.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{|{\mathit{packtype}}|}`.


:math:`{\mathrm{lanetype}}({{\mathsf{i}}{n}}{\mathsf{x}}{N})`
.............................................................


1. Return :math:`{\mathsf{i}}{n}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N_1`
...........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N_2`
...........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`N_1`
...........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`N_2`
...........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`{\mathrm{zero}}({\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
...................................................................................


1. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Inn, then:

  a. Return :math:`0`.

#. Assert: Due to validation, the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{+0}`.


:math:`{\mathrm{dim}}({{\mathsf{i}}{n}}{\mathsf{x}}{N})`
........................................................


1. Return :math:`N`.


:math:`{|{{\mathsf{i}}{n}}{\mathsf{x}}{N}|}`
............................................


1. Return :math:`{|{\mathsf{i}}{n}|} \cdot N`.


:math:`{\mathrm{concat}}({{\mathit{byte}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
.........................................................................................


1. If :math:`{{\mathit{byte}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{b^\ast}~{{{b'}^\ast}^\ast}` be :math:`{{\mathit{byte}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{b^\ast}~{\mathrm{concat}}({{{b'}^\ast}^\ast})`.


:math:`{\mathrm{unpack}}({\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
......................................................................................


1. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is numtype, then:

  a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathit{numtype}}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is packtype.

#. Return :math:`\mathsf{i{\scriptstyle 32}}`.


:math:`{\mathrm{unpack}}({{\mathsf{i}}{n}}{\mathsf{x}}{N})`
...........................................................


1. Return :math:`{\mathrm{unpack}}({\mathsf{i}}{n})`.


:math:`{\mathrm{funcs}}({{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
..............................................................................................


1. If :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~{\mathit{ft}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{ft}}~{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
................................................................................................


1. If :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~{\mathit{gt}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{gt}}~{\mathrm{globals}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
...............................................................................................


1. If :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~{\mathit{tt}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{tt}}~{\mathrm{tables}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
.............................................................................................


1. If :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~{\mathit{mt}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{mt}}~{\mathrm{mems}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{dataidx}}({\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
....................................................................................


1. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{memory{.}init}`, then:

  a. Let :math:`(\mathsf{memory{.}init}~x)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`x`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{data{.}drop}`, then:

  a. Let :math:`(\mathsf{data{.}drop}~x)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`x`.

#. Return :math:`\epsilon`.


:math:`{\mathrm{dataidx}}({{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
...........................................................................................


1. If :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{instr}}~{{\mathit{instr}'}^\ast}` be :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{dataidx}}({\mathit{instr}})~{\mathrm{dataidx}}({{\mathit{instr}'}^\ast})`.


:math:`{\mathrm{dataidx}}({{\mathit{in}}^\ast})`
................................................


1. Return :math:`{\mathrm{dataidx}}({{\mathit{in}}^\ast})`.


:math:`{\mathrm{dataidx}}((\mathsf{func}~x~{{\mathit{loc}}^\ast}~e))`
.....................................................................


1. Return :math:`{\mathrm{dataidx}}(e)`.


:math:`{\mathrm{dataidx}}({{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
..........................................................................................


1. If :math:`{{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{func}}~{{\mathit{func}'}^\ast}` be :math:`{{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{dataidx}}({\mathit{func}})~{\mathrm{dataidx}}({{\mathit{func}'}^\ast})`.






1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{align}~0,\; \mathsf{offset}~0 \}\end{array}`.


:math:`{{\mathrm{signed}}}_{N}(i)`
..................................


1. If :math:`0` is less than or equal to :math:`{2^{N - 1}}`, then:

  a. Return :math:`i`.

#. Assert: Due to validation, :math:`{2^{N - 1}}` is less than or equal to :math:`i`.

#. Assert: Due to validation, :math:`i` is less than :math:`{2^{N}}`.

#. Return :math:`i - {2^{N}}`.


:math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{(i)}`
...............................................


1. Let :math:`j` be the result for which :math:`{{\mathrm{signed}}}_{N}(j)` :math:`=` :math:`i`.

#. Return :math:`j`.


:math:`{{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}}{{}_{{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}{({\mathit{num\_u{\kern-0.1em\scriptstyle 3}}})}`
........................................................................................................................................................................


1. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{clz}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{iclz}}}_{N}({\mathit{iN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ctz}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{ictz}}}_{N}({\mathit{iN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{popcnt}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{ipopcnt}}}_{N}({\mathit{iN}})`.

#. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Assert: Due to validation, :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{extend}`.

  #. Let :math:`(\mathsf{extend}~M)` be :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}`.

  #. Let :math:`{\mathit{iN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{{{\mathrm{extend}}}_{M, N}^{\mathsf{s}}}}{({{\mathrm{wrap}}}_{N, M}({\mathit{iN}}))}`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{abs}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{fabs}}}_{N}({\mathit{fN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{neg}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{fneg}}}_{N}({\mathit{fN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{sqrt}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{fsqrt}}}_{N}({\mathit{fN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ceil}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{fceil}}}_{N}({\mathit{fN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{floor}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{ffloor}}}_{N}({\mathit{fN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{trunc}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{ftrunc}}}_{N}({\mathit{fN}})`.

#. Assert: Due to validation, :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{nearest}`.

#. Assert: Due to validation, the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

#. Return :math:`{{\mathrm{fnearest}}}_{N}({\mathit{fN}})`.


:math:`{{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}}{{}_{{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}{({\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}, {\mathit{num\_u{\kern-0.1em\scriptstyle 5}}})}`
.......................................................................................................................................................................................................................


1. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{add}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{iadd}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{sub}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{isub}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{mul}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{imul}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{div}`, then:

    1) Let :math:`({\mathsf{div}}{{\mathit{sx}}})` be :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{{{\mathrm{idiv}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{rem}`, then:

    1) Let :math:`({\mathsf{rem}}{{\mathit{sx}}})` be :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{{{\mathrm{irem}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{and}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{iand}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{or}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{ior}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{xor}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{ixor}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{shl}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{ishl}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{shr}`, then:

    1) Let :math:`({\mathsf{shr}}{{\mathit{sx}}})` be :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{{{\mathrm{ishr}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{rotl}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{irotl}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{rotr}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{irotr}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{add}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fadd}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{sub}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fsub}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{mul}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fmul}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{div}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fdiv}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{min}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fmin}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{max}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fmax}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{copysign}`.

#. Assert: Due to validation, the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

#. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

#. Return :math:`{{\mathrm{fcopysign}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.


:math:`{\mathsf{eqz}}{{}_{{\mathsf{i}}{n}}}{({\mathit{iN}})}`
.............................................................


1. Return :math:`{{\mathrm{ieqz}}}_{N}({\mathit{iN}})`.


:math:`{{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}}{{}_{{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}{({\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}, {\mathit{num\_u{\kern-0.1em\scriptstyle 5}}})}`
.......................................................................................................................................................................................................................


1. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{eq}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{ieq}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ne}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{ine}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{lt}`, then:

    1) Let :math:`({\mathsf{lt}}{{\mathit{sx}}})` be :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{{{\mathrm{ilt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{gt}`, then:

    1) Let :math:`({\mathsf{gt}}{{\mathit{sx}}})` be :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{{{\mathrm{igt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{le}`, then:

    1) Let :math:`({\mathsf{le}}{{\mathit{sx}}})` be :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{{{\mathrm{ile}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ge}`, then:

    1) Let :math:`({\mathsf{ge}}{{\mathit{sx}}})` be :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{{{\mathrm{ige}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

#. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{eq}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{feq}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ne}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fne}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{lt}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{flt}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{gt}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fgt}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{le}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fle}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ge}`.

#. Assert: Due to validation, the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

#. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

#. Return :math:`{{\mathrm{fge}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.


:math:`{{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}{{}_{{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, {\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}}}{({\mathit{num\_u{\kern-0.1em\scriptstyle 3}}})}`
...............................................................................................................................................................................................................................................


1. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{{\mathsf{i}}{n}}_1` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` is Inn, then:

    1) Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}`.

    #) Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{extend}`, then:

      a) Let :math:`(\mathsf{extend}~{\mathit{sx}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

      #) Return :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

#. If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{wrap}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{{\mathsf{i}}{n}}_1` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` is Inn, then:

    1) Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}`.

    #) Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

    #) Return :math:`{{\mathrm{wrap}}}_{N_1, N_2}({\mathit{iN}}_1)`.

#. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{{\mathsf{f}}{n}}_1` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` is Inn, then:

    1) Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}`.

    #) Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{trunc}`, then:

      a) Let :math:`(\mathsf{trunc}~{\mathit{sx}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

      #) Return :math:`{{{{\mathrm{trunc}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{fN}}_1)}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{trunc\_sat}`, then:

      a) Let :math:`(\mathsf{trunc\_sat}~{\mathit{sx}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

      #) Return :math:`{{{{\mathrm{trunc\_sat}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{fN}}_1)}`.

#. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` is Fnn, then:

  a. Let :math:`{{\mathsf{f}}{n}}_2` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}`.

  #. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

    1) Let :math:`{{\mathsf{i}}{n}}_1` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{convert}`, then:

      a) Let :math:`(\mathsf{convert}~{\mathit{sx}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

      #) Return :math:`{{{{\mathrm{convert}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

#. If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{promote}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{{\mathsf{f}}{n}}_1` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` is Fnn, then:

    1) Let :math:`{{\mathsf{f}}{n}}_2` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}`.

    #) Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

    #) Return :math:`{{\mathrm{promote}}}_{N_1, N_2}({\mathit{fN}}_1)`.

#. If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{demote}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{{\mathsf{f}}{n}}_1` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` is Fnn, then:

    1) Let :math:`{{\mathsf{f}}{n}}_2` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}`.

    #) Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

    #) Return :math:`{{\mathrm{demote}}}_{N_1, N_2}({\mathit{fN}}_1)`.

#. Assert: Due to validation, :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{reinterpret}`.

#. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` is Fnn, then:

  a. Let :math:`{{\mathsf{f}}{n}}_2` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}`.

  #. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

    1) Let :math:`{{\mathsf{i}}{n}}_1` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

    #) If :math:`{|{{\mathsf{i}}{n}}_1|}` is :math:`{|{{\mathsf{f}}{n}}_2|}`, then:

      a) Return :math:`{{\mathrm{reinterpret}}}_{{{\mathsf{i}}{n}}_1, {{\mathsf{f}}{n}}_2}({\mathit{iN}}_1)`.

#. Assert: Due to validation, the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{{\mathsf{f}}{n}}_1` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Assert: Due to validation, the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` is Inn.

#. Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

#. Assert: Due to validation, :math:`{|{{\mathsf{f}}{n}}_1|}` is :math:`{|{{\mathsf{i}}{n}}_2|}`.

#. Return :math:`{{\mathrm{reinterpret}}}_{{{\mathsf{f}}{n}}_1, {{\mathsf{i}}{n}}_2}({\mathit{fN}}_1)`.


:math:`{{\mathrm{invibytes}}}_{N}({b^\ast})`
............................................


1. Let :math:`n` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(n)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`n`.


:math:`{{\mathrm{invfbytes}}}_{N}({b^\ast})`
............................................


1. Let :math:`p` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{f}}{N}}(p)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`p`.


:math:`{{\mathrm{pack}}}_{{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}(c)`
..........................................................................................


1. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is numtype, then:

  a. Return :math:`c`.

#. Assert: Due to validation, the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is packtype.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{{\mathrm{wrap}}}_{{|{\mathrm{unpack}}({\mathit{packtype}})|}, {|{\mathit{packtype}}|}}(c)`.


:math:`{{\mathrm{unpack}}}_{{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}(c)`
............................................................................................


1. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is numtype, then:

  a. Return :math:`c`.

#. Assert: Due to validation, the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is packtype.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{{{{\mathrm{extend}}}_{{|{\mathit{packtype}}|}, {|{\mathrm{unpack}}({\mathit{packtype}})|}}^{\mathsf{u}}}}{(c)}`.


:math:`{{\mathrm{invlanes}}}_{{\mathit{sh}}}({c^\ast})`
.......................................................


1. Let :math:`{\mathit{vc}}` be the result for which :math:`{{\mathrm{lanes}}}_{{\mathit{sh}}}({\mathit{vc}})` :math:`=` :math:`{c^\ast}`.

#. Return :math:`{\mathit{vc}}`.


:math:`{\mathrm{half}}({\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}, i, j)`
......................................................................................


1. If :math:`{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{low}`, then:

  a. Return :math:`i`.

#. Assert: Due to validation, :math:`{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{high}`.

#. Return :math:`j`.


:math:`{\mathsf{not}}{{}_{\mathsf{v{\scriptstyle 128}}}({\mathit{v{\kern-0.1em\scriptstyle 128}}})}`
....................................................................................................


1. Return :math:`{{\mathrm{inot}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}})`.


:math:`{{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}{{}_{\mathsf{v{\scriptstyle 128}}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)}`
.................................................................................................................................................................................................


1. If :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{and}`, then:

  a. Return :math:`{{\mathrm{iand}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. If :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{andnot}`, then:

  a. Return :math:`{{\mathrm{iandnot}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. If :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{or}`, then:

  a. Return :math:`{{\mathrm{ior}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{xor}`.

#. Return :math:`{{\mathrm{ixor}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.


:math:`{\mathsf{bitselect}}{{}_{\mathsf{v{\scriptstyle 128}}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_3)}`
......................................................................................................................................................................................................


1. Return :math:`{{\mathrm{ibitselect}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_3)`.


:math:`{{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}}{{}_{{{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}}}{({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)}`
..........................................................................................................................................................................................


1. If :math:`{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{abs}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{iabs}}}_{N}({\mathit{lane}}_1)^\ast})`.

  #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{neg}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{ineg}}}_{N}({\mathit{lane}}_1)^\ast})`.

  #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{popcnt}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{ipopcnt}}}_{N}({\mathit{lane}}_1)^\ast})`.

  #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{abs}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fabs}}}_{N}({\mathit{lane}}_1)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{neg}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fneg}}}_{N}({\mathit{lane}}_1)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{sqrt}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fsqrt}}}_{N}({\mathit{lane}}_1)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ceil}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fceil}}}_{N}({\mathit{lane}}_1)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{floor}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{ffloor}}}_{N}({\mathit{lane}}_1)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{trunc}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{ftrunc}}}_{N}({\mathit{lane}}_1)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{nearest}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

#. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fnearest}}}_{N}({\mathit{lane}}_1)^\ast}`.

#. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

#. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.


:math:`{{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}}{{}_{{{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}}}{({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)}`
........................................................................................................................................................................................................................................


1. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{add}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{iadd}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

  #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{sub}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{isub}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

  #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{min}`, then:

    1) Let :math:`({\mathsf{min}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{imin}}}_{N}({\mathit{sx}}, {\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

  #. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{max}`, then:

    1) Let :math:`({\mathsf{max}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{imax}}}_{N}({\mathit{sx}}, {\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

  #. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{add\_sat}`, then:

    1) Let :math:`({\mathsf{add\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{{{\mathrm{iadd\_sat}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)}^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

  #. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{sub\_sat}`, then:

    1) Let :math:`({\mathsf{sub\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{{{\mathrm{isub\_sat}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)}^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{mul}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{imul}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

  #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is  and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{{{\mathrm{iavgr}}}_{N}^{\mathsf{u}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)}^\ast})`.

  #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is  and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{{{\mathrm{iq{\kern-0.1em\scriptstyle 15\kern-0.1em}mulr\_sat}}}_{N}^{\mathsf{s}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)}^\ast})`.

  #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{add}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fadd}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{sub}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fsub}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{mul}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fmul}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{div}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fdiv}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{min}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fmin}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{max}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fmax}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{pmin}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fpmin}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{pmax}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

#. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fpmax}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

#. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

#. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.


:math:`{{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}}{{}_{{{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}}}{({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)}`
........................................................................................................................................................................................................................................


1. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{eq}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{ieq}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

  #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

  #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ne}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{ine}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

  #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

  #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{lt}`, then:

    1) Let :math:`(\mathsf{lt}~{\mathit{sx}})` be :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{{{\mathrm{ilt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)})}^\ast}`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

  #. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{gt}`, then:

    1) Let :math:`(\mathsf{gt}~{\mathit{sx}})` be :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{{{\mathrm{igt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)})}^\ast}`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

  #. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{le}`, then:

    1) Let :math:`(\mathsf{le}~{\mathit{sx}})` be :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{{{\mathrm{ile}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)})}^\ast}`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

  #. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ge}`, then:

    1) Let :math:`(\mathsf{ge}~{\mathit{sx}})` be :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{{{\mathrm{ige}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)})}^\ast}`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{eq}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathsf{f}}{n}|}`.

  #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{feq}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

  #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

  #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ne}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathsf{f}}{n}|}`.

  #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{fne}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

  #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

  #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{lt}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathsf{f}}{n}|}`.

  #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{flt}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

  #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

  #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{gt}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathsf{f}}{n}|}`.

  #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{fgt}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

  #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

  #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{le}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathsf{f}}{n}|}`.

  #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{fle}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

  #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

  #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. Assert: Due to validation, :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ge}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

#. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathsf{f}}{n}|}`.

#. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{fge}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

#. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

#. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.


:math:`{{\mathrm{vcvtop}}}_{{{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}}{\mathsf{x}}{M_1}, {{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, {\mathit{lane\_u{\kern-0.1em\scriptstyle 4}}})`
......................................................................................................................................................................................................................................................................................................


1. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is Jnn, then:

  a. Let :math:`{{\mathsf{i}}{n}}_1` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Jnn, then:

    1) Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

    #) Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{lane\_u{\kern-0.1em\scriptstyle 4}}}`.

    #) If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{extend}`, then:

      a) Let :math:`(\mathsf{extend}~{\mathit{sx}})` be :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{\mathit{iN}}_2` be :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

      #) Return :math:`{\mathit{iN}}_2`.

#. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Fnn, then:

  a. Let :math:`{{\mathsf{f}}{n}}_2` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is Jnn, then:

    1) Let :math:`{{\mathsf{i}}{n}}_1` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

    #) Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{lane\_u{\kern-0.1em\scriptstyle 4}}}`.

    #) If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{convert}`, then:

      a) Let :math:`(\mathsf{convert}~{\mathit{sx}})` be :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{\mathit{fN}}_2` be :math:`{{{{\mathrm{convert}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

      #) Return :math:`{\mathit{fN}}_2`.

#. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is Fnn, then:

  a. Let :math:`{{\mathsf{f}}{n}}_1` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Inn, then:

    1) Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

    #) Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{lane\_u{\kern-0.1em\scriptstyle 4}}}`.

    #) If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{trunc\_sat}`, then:

      a) Let :math:`(\mathsf{trunc\_sat}~{\mathit{sx}})` be :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{{\mathit{iN}}_2^?}` be :math:`{{{{\mathrm{trunc\_sat}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{fN}}_1)}`.

      #) Return :math:`{{\mathit{iN}}_2^?}`.

#. If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{demote}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is Fnn, then:

  a. Let :math:`{{\mathsf{f}}{n}}_1` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Fnn, then:

    1) Let :math:`{{\mathsf{f}}{n}}_2` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

    #) Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{lane\_u{\kern-0.1em\scriptstyle 4}}}`.

    #) Let :math:`{{\mathit{fN}}_2^\ast}` be :math:`{{\mathrm{demote}}}_{N_1, N_2}({\mathit{fN}}_1)`.

    #) Return :math:`{{\mathit{fN}}_2^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{promote}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is Fnn.

#. Let :math:`{{\mathsf{f}}{n}}_1` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Fnn.

#. Let :math:`{{\mathsf{f}}{n}}_2` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{lane\_u{\kern-0.1em\scriptstyle 4}}}`.

#. Let :math:`{{\mathit{fN}}_2^\ast}` be :math:`{{\mathrm{promote}}}_{N_1, N_2}({\mathit{fN}}_1)`.

#. Return :math:`{{\mathit{fN}}_2^\ast}`.


:math:`{{\mathrm{vextunop}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}((\mathsf{extadd\_pairwise}~{\mathit{sx}}), c_1)`
..............................................................................................................................................................


1. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_1)`.

#. Let :math:`{{\mathit{cj}}_1~{\mathit{cj}}_2^\ast}` be the result for which :math:`{\mathrm{concat}}({{\mathit{cj}}_1~{\mathit{cj}}_2^\ast})` :math:`=` :math:`{{{{{\mathrm{extend}}}_{N_2, N_1}^{{\mathit{sx}}}}}{({\mathit{ci}})}^\ast}`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}}({{{\mathrm{iadd}}}_{N_1}({\mathit{cj}}_1, {\mathit{cj}}_2)^\ast})`.

#. Return :math:`c`.


:math:`{{\mathrm{vextbinop}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}({\mathit{vextbinop\_u{\kern-0.1em\scriptstyle 0}}}, c_1, c_2)`
.............................................................................................................................................................................


1. If :math:`{\mathit{vextbinop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{extmul}`, then:

  a. Let :math:`({\mathsf{extmul}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vextbinop\_u{\kern-0.1em\scriptstyle 0}}}`.

  #. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_1){}[{\mathrm{half}}({\mathit{hf}}, 0, M_1) : M_1]`.

  #. Let :math:`{{\mathit{ci}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_2){}[{\mathrm{half}}({\mathit{hf}}, 0, M_1) : M_1]`.

  #. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}}({{{\mathrm{imul}}}_{N_1}({{{{\mathrm{extend}}}_{N_2, N_1}^{{\mathit{sx}}}}}{({\mathit{ci}}_1)}, {{{{\mathrm{extend}}}_{N_2, N_1}^{{\mathit{sx}}}}}{({\mathit{ci}}_2)})^\ast})`.

  #. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{vextbinop\_u{\kern-0.1em\scriptstyle 0}}}` is .

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_1)`.

#. Let :math:`{{\mathit{ci}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_2)`.

#. Let :math:`{{\mathit{cj}}_1~{\mathit{cj}}_2^\ast}` be the result for which :math:`{\mathrm{concat}}({{\mathit{cj}}_1~{\mathit{cj}}_2^\ast})` :math:`=` :math:`{{{\mathrm{imul}}}_{N_1}({{{{\mathrm{extend}}}_{N_2, N_1}^{\mathsf{s}}}}{({\mathit{ci}}_1)}, {{{{\mathrm{extend}}}_{N_2, N_1}^{\mathsf{s}}}}{({\mathit{ci}}_2)})^\ast}`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}}({{{\mathrm{iadd}}}_{N_1}({\mathit{cj}}_1, {\mathit{cj}}_2)^\ast})`.

#. Return :math:`c`.


:math:`{{{\mathit{vshiftop\_u{\kern-0.1em\scriptstyle 0}}}}{\mathsf{\_}}~{{\mathsf{i}}{n}}{\mathsf{x}}{M}}{({\mathit{lane}}, n)}`
.................................................................................................................................


1. If :math:`{\mathit{vshiftop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{shl}`, then:

  a. Return :math:`{{\mathrm{ishl}}}_{N}({\mathit{lane}}, n)`.

#. Assert: Due to validation, :math:`{\mathit{vshiftop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{shr}`.

#. Let :math:`(\mathsf{shr}~{\mathit{sx}})` be :math:`{\mathit{vshiftop\_u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{{{{\mathrm{ishr}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}, n)}`.


:math:`{{\mathrm{default}}}_{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}`
.........................................................................................


1. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{i{\scriptstyle 32}}`, then:

  a. Return :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)`.

#. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{i{\scriptstyle 64}}`, then:

  a. Return :math:`(\mathsf{i{\scriptstyle 64}}{.}\mathsf{const}~0)`.

#. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{f{\scriptstyle 32}}`, then:

  a. Return :math:`(\mathsf{f{\scriptstyle 32}}{.}\mathsf{const}~{+0})`.

#. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{f{\scriptstyle 64}}`, then:

  a. Return :math:`(\mathsf{f{\scriptstyle 64}}{.}\mathsf{const}~{+0})`.

#. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{v{\scriptstyle 128}}`, then:

  a. Return :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~0)`.

#. If :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{funcref}`, then:

  a. Return :math:`(\mathsf{ref{.}null}~\mathsf{funcref})`.

#. Assert: Due to validation, :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{externref}`.

#. Return :math:`(\mathsf{ref{.}null}~\mathsf{externref})`.


:math:`{\mathrm{funcs}}({{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
..............................................................................................


1. If :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~{\mathit{fa}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{fa}}~{\mathrm{funcs}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
................................................................................................


1. If :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~{\mathit{ga}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ga}}~{\mathrm{globals}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
...............................................................................................


1. If :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~{\mathit{ta}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ta}}~{\mathrm{tables}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
.............................................................................................


1. If :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~{\mathit{ma}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ma}}~{\mathrm{mems}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{store}}`
........................


1. Return.


:math:`{\mathrm{frame}}`
........................


1. Let :math:`f` be the current frame.

#. Return :math:`f`.


:math:`{\mathrm{funcaddr}}`
...........................


1. Let :math:`f` be the current frame.

#. Return :math:`f{.}\mathsf{module}{.}\mathsf{funcs}`.


:math:`{\mathrm{funcinst}}`
...........................


1. Return :math:`s{.}\mathsf{funcs}`.


:math:`{\mathrm{globalinst}}`
.............................


1. Return :math:`s{.}\mathsf{globals}`.


:math:`{\mathrm{tableinst}}`
............................


1. Return :math:`s{.}\mathsf{tables}`.


:math:`{\mathrm{meminst}}`
..........................


1. Return :math:`s{.}\mathsf{mems}`.


:math:`{\mathrm{eleminst}}`
...........................


1. Return :math:`s{.}\mathsf{elems}`.


:math:`{\mathrm{datainst}}`
...........................


1. Return :math:`s{.}\mathsf{datas}`.


:math:`{\mathrm{moduleinst}}`
.............................


1. Let :math:`f` be the current frame.

#. Return :math:`f{.}\mathsf{module}`.


:math:`{\mathrm{type}}(x)`
..........................


1. Let :math:`f` be the current frame.

#. Return :math:`f{.}\mathsf{module}{.}\mathsf{types}{}[x]`.


:math:`{\mathrm{func}}(x)`
..........................


1. Let :math:`f` be the current frame.

#. Return :math:`s{.}\mathsf{funcs}{}[f{.}\mathsf{module}{.}\mathsf{funcs}{}[x]]`.


:math:`{\mathrm{global}}(x)`
............................


1. Let :math:`f` be the current frame.

#. Return :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]`.


:math:`{\mathrm{table}}(x)`
...........................


1. Let :math:`f` be the current frame.

#. Return :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]`.


:math:`{\mathrm{mem}}(x)`
.........................


1. Let :math:`f` be the current frame.

#. Return :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]`.


:math:`{\mathrm{elem}}(x)`
..........................


1. Let :math:`f` be the current frame.

#. Return :math:`s{.}\mathsf{elems}{}[f{.}\mathsf{module}{.}\mathsf{elems}{}[x]]`.


:math:`{\mathrm{data}}(x)`
..........................


1. Let :math:`f` be the current frame.

#. Return :math:`s{.}\mathsf{datas}{}[f{.}\mathsf{module}{.}\mathsf{datas}{}[x]]`.


:math:`{\mathrm{local}}(x)`
...........................


1. Let :math:`f` be the current frame.

#. Return :math:`f{.}\mathsf{locals}{}[x]`.


:math:`{\mathrm{with}}_{\mathit{local}}(x, v)`
..............................................


1. Let :math:`f` be the current frame.

#. Replace :math:`f{.}\mathsf{locals}{}[x]` with :math:`v`.


:math:`{\mathrm{with}}_{\mathit{global}}(x, v)`
...............................................


1. Let :math:`f` be the current frame.

#. Replace :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]{.}\mathsf{value}` with :math:`v`.


:math:`{\mathrm{with}}_{\mathit{table}}(x, i, r)`
.................................................


1. Let :math:`f` be the current frame.

#. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]{.}\mathsf{refs}{}[i]` with :math:`r`.


:math:`{\mathrm{with}}_{\mathit{tableinst}}(x, {\mathit{ti}})`
..............................................................


1. Let :math:`f` be the current frame.

#. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]` with :math:`{\mathit{ti}}`.


:math:`{\mathrm{with}}_{\mathit{mem}}(x, i, j, {b^\ast})`
.........................................................


1. Let :math:`f` be the current frame.

#. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]{.}\mathsf{bytes}{}[i : j]` with :math:`{b^\ast}`.


:math:`{\mathrm{with}}_{\mathit{meminst}}(x, {\mathit{mi}})`
............................................................


1. Let :math:`f` be the current frame.

#. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]` with :math:`{\mathit{mi}}`.


:math:`{\mathrm{with}}_{\mathit{elem}}(x, {r^\ast})`
....................................................


1. Let :math:`f` be the current frame.

#. Replace :math:`s{.}\mathsf{elems}{}[f{.}\mathsf{module}{.}\mathsf{elems}{}[x]]{.}\mathsf{refs}` with :math:`{r^\ast}`.


:math:`{\mathrm{with}}_{\mathit{data}}(x, {b^\ast})`
....................................................


1. Let :math:`f` be the current frame.

#. Replace :math:`s{.}\mathsf{datas}{}[f{.}\mathsf{module}{.}\mathsf{datas}{}[x]]{.}\mathsf{bytes}` with :math:`{b^\ast}`.


:math:`{\mathrm{growtable}}({\mathit{ti}}, n, r)`
.................................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~((i, j)~{\mathit{rt}}),\; \mathsf{refs}~{{r'}^\ast} \}\end{array}` be :math:`{\mathit{ti}}`.

#. Let :math:`{i'}` be :math:`{|{{r'}^\ast}|} + n`.

#. If :math:`{i'}` is less than or equal to :math:`j`, then:

  a. Let :math:`{\mathit{ti}'}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~(({i'}, j)~{\mathit{rt}}),\; \mathsf{refs}~{{r'}^\ast}~{r^{n}} \}\end{array}`.

  #. Return :math:`{\mathit{ti}'}`.


:math:`{\mathrm{growmemory}}({\mathit{mi}}, n)`
...............................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~(i, j)~\mathsf{page},\; \mathsf{bytes}~{b^\ast} \}\end{array}` be :math:`{\mathit{mi}}`.

#. Let :math:`{i'}` be :math:`{|{b^\ast}|} / 64 \, {\mathrm{Ki}} + n`.

#. If :math:`{i'}` is less than or equal to :math:`j`, then:

  a. Let :math:`{\mathit{mi}'}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({i'}, j)~\mathsf{page},\; \mathsf{bytes}~{b^\ast}~{0^{n \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

  #. Return :math:`{\mathit{mi}'}`.


:math:`{{\mathrm{blocktype}}}_{z}({\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
................................................................................................


1. If :math:`{\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon~\rightarrow~\epsilon`.

#. If :math:`{\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case , then:

  a. Let :math:`{\mathit{valtype}}_0` be :math:`{\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{\mathit{valtype}}_0` is defined, then:

    1) Let :math:`t` be :math:`{\mathit{valtype}}_0`.

    #) Return :math:`\epsilon~\rightarrow~t`.

#. Assert: Due to validation, :math:`{\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case .

#. Let :math:`x` be :math:`{\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`z{.}\mathsf{types}{}[x]`.


:math:`{\mathrm{funcs}}({{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
..............................................................................................


1. If :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~{\mathit{fa}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{fa}}~{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
................................................................................................


1. If :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~{\mathit{ga}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ga}}~{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
...............................................................................................


1. If :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~{\mathit{ta}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ta}}~{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
.............................................................................................


1. If :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~{\mathit{ma}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ma}}~{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{allocfunc}}({\mathit{moduleinst}}, {\mathit{func}})`
....................................................................


1. Assert: Due to validation, :math:`{\mathit{func}}` is of the case :math:`\mathsf{func}`.

#. Let :math:`(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}})` be :math:`{\mathit{func}}`.

#. Let :math:`{\mathit{fi}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{moduleinst}}{.}\mathsf{types}{}[x],\; \mathsf{module}~{\mathit{moduleinst}},\; \mathsf{code}~{\mathit{func}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{funcs}|}`.

#. Append :math:`{\mathit{fi}}` to the :math:`s{.}\mathsf{funcs}`.

#. Return :math:`a`.


:math:`{\mathrm{allocfuncs}}({\mathit{moduleinst}}, {{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
....................................................................................................................


1. If :math:`{{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{func}}~{{\mathit{func}'}^\ast}` be :math:`{{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Let :math:`{\mathit{fa}}` be :math:`{\mathrm{allocfunc}}({\mathit{moduleinst}}, {\mathit{func}})`.

#. Let :math:`{{\mathit{fa}'}^\ast}` be :math:`{\mathrm{allocfuncs}}({\mathit{moduleinst}}, {{\mathit{func}'}^\ast})`.

#. Return :math:`{\mathit{fa}}~{{\mathit{fa}'}^\ast}`.


:math:`{\mathrm{allocglobal}}({\mathit{globaltype}}, {\mathit{val}})`
.....................................................................


1. Let :math:`{\mathit{gi}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{globaltype}},\; \mathsf{value}~{\mathit{val}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{globals}|}`.

#. Append :math:`{\mathit{gi}}` to the :math:`s{.}\mathsf{globals}`.

#. Return :math:`a`.


:math:`{\mathrm{allocglobals}}({{\mathit{globaltype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}, {{\mathit{val}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
....................................................................................................................................................................


1. If :math:`{{\mathit{globaltype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Assert: Due to validation, :math:`{{\mathit{val}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\epsilon`.

  #. Return :math:`\epsilon`.

#. Else:

  a. Let :math:`{\mathit{globaltype}}~{{\mathit{globaltype}'}^\ast}` be :math:`{{\mathit{globaltype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

  #. Assert: Due to validation, :math:`{|{{\mathit{val}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|}` is greater than or equal to :math:`1`.

  #. Let :math:`{\mathit{val}}~{{\mathit{val}'}^\ast}` be :math:`{{\mathit{val}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

  #. Let :math:`{\mathit{ga}}` be :math:`{\mathrm{allocglobal}}({\mathit{globaltype}}, {\mathit{val}})`.

  #. Let :math:`{{\mathit{ga}'}^\ast}` be :math:`{\mathrm{allocglobals}}({{\mathit{globaltype}'}^\ast}, {{\mathit{val}'}^\ast})`.

  #. Return :math:`{\mathit{ga}}~{{\mathit{ga}'}^\ast}`.


:math:`{\mathrm{alloctable}}(((i, j)~{\mathit{rt}}))`
.....................................................


1. Let :math:`{\mathit{ti}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~((i, j)~{\mathit{rt}}),\; \mathsf{refs}~{(\mathsf{ref{.}null}~{\mathit{rt}})^{i}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{tables}|}`.

#. Append :math:`{\mathit{ti}}` to the :math:`s{.}\mathsf{tables}`.

#. Return :math:`a`.


:math:`{\mathrm{alloctables}}({{\mathit{tabletype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
...................................................................................................


1. If :math:`{{\mathit{tabletype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{tabletype}}~{{\mathit{tabletype}'}^\ast}` be :math:`{{\mathit{tabletype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Let :math:`{\mathit{ta}}` be :math:`{\mathrm{alloctable}}({\mathit{tabletype}})`.

#. Let :math:`{{\mathit{ta}'}^\ast}` be :math:`{\mathrm{alloctables}}({{\mathit{tabletype}'}^\ast})`.

#. Return :math:`{\mathit{ta}}~{{\mathit{ta}'}^\ast}`.


:math:`{\mathrm{allocmem}}((i, j)~\mathsf{page})`
.................................................


1. Let :math:`{\mathit{mi}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~(i, j)~\mathsf{page},\; \mathsf{bytes}~{0^{i \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{mems}|}`.

#. Append :math:`{\mathit{mi}}` to the :math:`s{.}\mathsf{mems}`.

#. Return :math:`a`.


:math:`{\mathrm{allocmems}}({{\mathit{memtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
...............................................................................................


1. If :math:`{{\mathit{memtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{memtype}}~{{\mathit{memtype}'}^\ast}` be :math:`{{\mathit{memtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Let :math:`{\mathit{ma}}` be :math:`{\mathrm{allocmem}}({\mathit{memtype}})`.

#. Let :math:`{{\mathit{ma}'}^\ast}` be :math:`{\mathrm{allocmems}}({{\mathit{memtype}'}^\ast})`.

#. Return :math:`{\mathit{ma}}~{{\mathit{ma}'}^\ast}`.


:math:`{\mathrm{allocelem}}({\mathit{rt}}, {{\mathit{ref}}^\ast})`
..................................................................


1. Let :math:`{\mathit{ei}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{rt}},\; \mathsf{refs}~{{\mathit{ref}}^\ast} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{elems}|}`.

#. Append :math:`{\mathit{ei}}` to the :math:`s{.}\mathsf{elems}`.

#. Return :math:`a`.


:math:`{\mathrm{allocelems}}({{\mathit{reftype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}, {{\mathit{ref}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
...............................................................................................................................................................


1. If :math:`{{\mathit{reftype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon` and :math:`{{\mathit{ref}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{{\mathit{ref}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|}` is greater than or equal to :math:`1`.

#. Let :math:`{{\mathit{ref}}^\ast}~{{{\mathit{ref}'}^\ast}^\ast}` be :math:`{{\mathit{ref}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{reftype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}|}` is greater than or equal to :math:`1`.

#. Let :math:`{\mathit{rt}}~{{\mathit{rt}'}^\ast}` be :math:`{{\mathit{reftype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Let :math:`{\mathit{ea}}` be :math:`{\mathrm{allocelem}}({\mathit{rt}}, {{\mathit{ref}}^\ast})`.

#. Let :math:`{{\mathit{ea}'}^\ast}` be :math:`{\mathrm{allocelems}}({{\mathit{rt}'}^\ast}, {{{\mathit{ref}'}^\ast}^\ast})`.

#. Return :math:`{\mathit{ea}}~{{\mathit{ea}'}^\ast}`.


:math:`{\mathrm{allocdata}}({{\mathit{byte}}^\ast})`
....................................................


1. Let :math:`{\mathit{di}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{bytes}~{{\mathit{byte}}^\ast} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{datas}|}`.

#. Append :math:`{\mathit{di}}` to the :math:`s{.}\mathsf{datas}`.

#. Return :math:`a`.


:math:`{\mathrm{allocdatas}}({{\mathit{byte}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
.............................................................................................


1. If :math:`{{\mathit{byte}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{{\mathit{byte}}^\ast}~{{{\mathit{byte}'}^\ast}^\ast}` be :math:`{{\mathit{byte}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Let :math:`{\mathit{da}}` be :math:`{\mathrm{allocdata}}({{\mathit{byte}}^\ast})`.

#. Let :math:`{{\mathit{da}'}^\ast}` be :math:`{\mathrm{allocdatas}}({{{\mathit{byte}'}^\ast}^\ast})`.

#. Return :math:`{\mathit{da}}~{{\mathit{da}'}^\ast}`.


:math:`{\mathrm{instexport}}({{\mathit{fa}}^\ast}, {{\mathit{ga}}^\ast}, {{\mathit{ta}}^\ast}, {{\mathit{ma}}^\ast}, (\mathsf{export}~{\mathit{name}}~{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}))`
.....................................................................................................................................................................................................................


1. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{func}~{{\mathit{fa}}^\ast}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{global}~{{\mathit{ga}}^\ast}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{table}~{{\mathit{ta}}^\ast}{}[x]) \}\end{array}`.

#. Assert: Due to validation, :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{mem}`.

#. Let :math:`(\mathsf{mem}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{mem}~{{\mathit{ma}}^\ast}{}[x]) \}\end{array}`.


:math:`{\mathrm{allocmodule}}({\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}^\ast}, {{{\mathit{ref}}^\ast}^\ast})`
....................................................................................................................................


1. Let :math:`{{\mathit{fa}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ga}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{globals}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ma}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{mems}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ta}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{tables}}({{\mathit{externaddr}}^\ast})`.

#. Assert: Due to validation, :math:`{\mathit{module}}` is of the case :math:`\mathsf{module}`.

#. Let :math:`(\mathsf{module}~{{\mathit{type}}_0^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^{n_{\mathit{func}}}}~{{\mathit{global}}_1^{n_{\mathit{global}}}}~{{\mathit{table}}_2^{n_{\mathit{table}}}}~{{\mathit{mem}}_3^{n_{\mathit{mem}}}}~{{\mathit{elem}}_4^{n_{\mathit{elem}}}}~{{\mathit{data}}_5^{n_{\mathit{data}}}}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be :math:`{\mathit{module}}`.

#. Assert: Due to validation, for all :math:`{({\mathit{data}}_5)^{n_{\mathit{data}}}}`, :math:`{\mathit{data}}_5` is of the case :math:`\mathsf{data}`.

#. Let :math:`{(\mathsf{data}~{{\mathit{byte}}^\ast}~{\mathit{datamode}})^{n_{\mathit{data}}}}` be :math:`{{\mathit{data}}_5^{n_{\mathit{data}}}}`.

#. Assert: Due to validation, for all :math:`{({\mathit{elem}}_4)^{n_{\mathit{elem}}}}`, :math:`{\mathit{elem}}_4` is of the case :math:`\mathsf{elem}`.

#. Let :math:`{(\mathsf{elem}~{\mathit{rt}}~{{\mathit{expr}}_2^\ast}~{\mathit{elemmode}})^{n_{\mathit{elem}}}}` be :math:`{{\mathit{elem}}_4^{n_{\mathit{elem}}}}`.

#. Assert: Due to validation, for all :math:`{({\mathit{mem}}_3)^{n_{\mathit{mem}}}}`, :math:`{\mathit{mem}}_3` is of the case :math:`\mathsf{memory}`.

#. Let :math:`{(\mathsf{memory}~{\mathit{memtype}})^{n_{\mathit{mem}}}}` be :math:`{{\mathit{mem}}_3^{n_{\mathit{mem}}}}`.

#. Assert: Due to validation, for all :math:`{({\mathit{table}}_2)^{n_{\mathit{table}}}}`, :math:`{\mathit{table}}_2` is of the case :math:`\mathsf{table}`.

#. Let :math:`{(\mathsf{table}~{\mathit{tabletype}})^{n_{\mathit{table}}}}` be :math:`{{\mathit{table}}_2^{n_{\mathit{table}}}}`.

#. Assert: Due to validation, for all :math:`{({\mathit{global}}_1)^{n_{\mathit{global}}}}`, :math:`{\mathit{global}}_1` is of the case :math:`\mathsf{global}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_1)^{n_{\mathit{global}}}}` be :math:`{{\mathit{global}}_1^{n_{\mathit{global}}}}`.

#. Assert: Due to validation, for all :math:`{({\mathit{type}}_0)^\ast}`, :math:`{\mathit{type}}_0` is of the case :math:`\mathsf{type}`.

#. Let :math:`{(\mathsf{type}~{\mathit{ft}})^\ast}` be :math:`{{\mathit{type}}_0^\ast}`.

#. Let :math:`{{\mathit{fa}}^\ast}` be :math:`{{|s{.}\mathsf{funcs}|} + i_{\mathit{func}}^{i_{\mathit{func}}<n_{\mathit{func}}}}`.

#. Let :math:`{{\mathit{ga}}^\ast}` be :math:`{{|s{.}\mathsf{globals}|} + i_{\mathit{global}}^{i_{\mathit{global}}<n_{\mathit{global}}}}`.

#. Let :math:`{{\mathit{ta}}^\ast}` be :math:`{{|s{.}\mathsf{tables}|} + i_{\mathit{table}}^{i_{\mathit{table}}<n_{\mathit{table}}}}`.

#. Let :math:`{{\mathit{ma}}^\ast}` be :math:`{{|s{.}\mathsf{mems}|} + i_{\mathit{mem}}^{i_{\mathit{mem}}<n_{\mathit{mem}}}}`.

#. Let :math:`{{\mathit{ea}}^\ast}` be :math:`{{|s{.}\mathsf{elems}|} + i_{\mathit{elem}}^{i_{\mathit{elem}}<n_{\mathit{elem}}}}`.

#. Let :math:`{{\mathit{da}}^\ast}` be :math:`{{|s{.}\mathsf{datas}|} + i_{\mathit{data}}^{i_{\mathit{data}}<n_{\mathit{data}}}}`.

#. Let :math:`{{\mathit{xi}}^\ast}` be :math:`{{\mathrm{instexport}}({{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast}, {{\mathit{ga}}_{\mathit{ex}}^\ast}~{{\mathit{ga}}^\ast}, {{\mathit{ta}}_{\mathit{ex}}^\ast}~{{\mathit{ta}}^\ast}, {{\mathit{ma}}_{\mathit{ex}}^\ast}~{{\mathit{ma}}^\ast}, {\mathit{export}})^\ast}`.

#. Let :math:`{\mathit{moduleinst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}}^\ast},\; \mathsf{funcs}~{{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast},\; \mathsf{globals}~{{\mathit{ga}}_{\mathit{ex}}^\ast}~{{\mathit{ga}}^\ast},\; \mathsf{tables}~{{\mathit{ta}}_{\mathit{ex}}^\ast}~{{\mathit{ta}}^\ast},\; \mathsf{mems}~{{\mathit{ma}}_{\mathit{ex}}^\ast}~{{\mathit{ma}}^\ast},\; \mathsf{elems}~{{\mathit{ea}}^\ast},\; \mathsf{datas}~{{\mathit{da}}^\ast},\; \mathsf{exports}~{{\mathit{xi}}^\ast} \}\end{array}`.

#. Let :math:`{\mathit{funcaddr}}_0` be :math:`{\mathrm{allocfuncs}}({\mathit{moduleinst}}, {{\mathit{func}}^{n_{\mathit{func}}}})`.

#. Assert: Due to validation, :math:`{\mathit{funcaddr}}_0` is :math:`{{\mathit{fa}}^\ast}`.

#. Let :math:`{\mathit{globaladdr}}_0` be :math:`{\mathrm{allocglobals}}({{\mathit{globaltype}}^{n_{\mathit{global}}}}, {{\mathit{val}}^\ast})`.

#. Assert: Due to validation, :math:`{\mathit{globaladdr}}_0` is :math:`{{\mathit{ga}}^\ast}`.

#. Let :math:`{\mathit{tableaddr}}_0` be :math:`{\mathrm{alloctables}}({{\mathit{tabletype}}^{n_{\mathit{table}}}})`.

#. Assert: Due to validation, :math:`{\mathit{tableaddr}}_0` is :math:`{{\mathit{ta}}^\ast}`.

#. Let :math:`{\mathit{memaddr}}_0` be :math:`{\mathrm{allocmems}}({{\mathit{memtype}}^{n_{\mathit{mem}}}})`.

#. Assert: Due to validation, :math:`{\mathit{memaddr}}_0` is :math:`{{\mathit{ma}}^\ast}`.

#. Let :math:`{\mathit{elemaddr}}_0` be :math:`{\mathrm{allocelems}}({{\mathit{rt}}^{n_{\mathit{elem}}}}, {{{\mathit{ref}}^\ast}^\ast})`.

#. Assert: Due to validation, :math:`{\mathit{elemaddr}}_0` is :math:`{{\mathit{ea}}^\ast}`.

#. Let :math:`{\mathit{dataaddr}}_0` be :math:`{\mathrm{allocdatas}}({({{\mathit{byte}}^\ast})^{n_{\mathit{data}}}})`.

#. Assert: Due to validation, :math:`{\mathit{dataaddr}}_0` is :math:`{{\mathit{da}}^\ast}`.

#. Return :math:`{\mathit{moduleinst}}`.


:math:`{\mathrm{runelem}}((\mathsf{elem}~{\mathit{reftype}}~{{\mathit{expr}}^\ast}~{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}), i)`
....................................................................................................................................................


1. If :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{passive}`, then:

  a. Return :math:`\epsilon`.

#. If :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{declare}`, then:

  a. Return :math:`(\mathsf{elem{.}drop}~i)`.

#. Assert: Due to validation, :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{active}`.

#. Let :math:`(\mathsf{active}~x~{{\mathit{instr}}^\ast})` be :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Let :math:`n` be :math:`{|{{\mathit{expr}}^\ast}|}`.

#. Return :math:`{{\mathit{instr}}^\ast}~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)~(\mathsf{table{.}init}~x~i)~(\mathsf{elem{.}drop}~i)`.


:math:`{\mathrm{rundata}}((\mathsf{data}~{{\mathit{byte}}^\ast}~{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}), i)`
.................................................................................................................................


1. If :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{passive}`, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{active}`.

#. Let :math:`(\mathsf{active}~n_0~{{\mathit{instr}}^\ast})` be :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Assert: Due to validation, :math:`n_0` is :math:`0`.

#. Let :math:`n` be :math:`{|{{\mathit{byte}}^\ast}|}`.

#. Return :math:`{{\mathit{instr}}^\ast}~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)~(\mathsf{memory{.}init}~i)~(\mathsf{data{.}drop}~i)`.


:math:`{\mathrm{instantiate}}(z, {\mathit{module}}, {{\mathit{externaddr}}^\ast})`
..................................................................................


1. Assert: Due to validation, :math:`{\mathit{module}}` is of the case :math:`\mathsf{module}`.

#. Let :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be :math:`{\mathit{module}}`.

#. Assert: Due to validation, for all :math:`{({\mathit{type}})^\ast}`, :math:`{\mathit{type}}` is of the case :math:`\mathsf{type}`.

#. Let :math:`{(\mathsf{type}~{\mathit{functype}})^\ast}` be :math:`{{\mathit{type}}^\ast}`.

#. Let :math:`n_{\mathsf{d}}` be :math:`{|{{\mathit{data}}^\ast}|}`.

#. Let :math:`n_{\mathsf{e}}` be :math:`{|{{\mathit{elem}}^\ast}|}`.

#. Let :math:`n_{\mathsf{f}}` be :math:`{|{{\mathit{func}}^\ast}|}`.

#. Assert: Due to validation, for all :math:`{({\mathit{start}})^?}`, :math:`{\mathit{start}}` is of the case :math:`\mathsf{start}`.

#. Let :math:`{(\mathsf{start}~x)^?}` be :math:`{{\mathit{start}}^?}`.

#. Assert: Due to validation, for all :math:`{({\mathit{global}})^\ast}`, :math:`{\mathit{global}}` is of the case :math:`\mathsf{global}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_{\mathsf{g}})^\ast}` be :math:`{{\mathit{global}}^\ast}`.

#. Assert: Due to validation, for all :math:`{({\mathit{elem}})^\ast}`, :math:`{\mathit{elem}}` is of the case :math:`\mathsf{elem}`.

#. Let :math:`{(\mathsf{elem}~{\mathit{reftype}}~{{\mathit{expr}}_{\mathsf{e}}^\ast}~{\mathit{elemmode}})^\ast}` be :math:`{{\mathit{elem}}^\ast}`.

#. Let :math:`{{\mathit{instr}}_{\mathsf{d}}^\ast}` be :math:`{\mathrm{concat}}({{\mathrm{rundata}}({{\mathit{data}}^\ast}{}[j], j)^{j<n_{\mathsf{d}}}})`.

#. Let :math:`{{\mathit{instr}}_{\mathsf{e}}^\ast}` be :math:`{\mathrm{concat}}({{\mathrm{runelem}}({{\mathit{elem}}^\ast}{}[i], i)^{i<n_{\mathsf{e}}}})`.

#. Let :math:`{\mathit{moduleinst}}_{\mathit{init}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{functype}}^\ast},\; \mathsf{funcs}~{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})~{{|s{.}\mathsf{funcs}|} + i_{\mathsf{f}}^{i_{\mathsf{f}}<n_{\mathsf{f}}}},\; \mathsf{globals}~{\mathrm{globals}}({{\mathit{externaddr}}^\ast}),\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{exports}~\epsilon \}\end{array}`.

#. Let :math:`f_{\mathit{init}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~\epsilon,\; \mathsf{module}~{\mathit{moduleinst}}_{\mathit{init}} \}\end{array}`.

#. Let :math:`z` be :math:`f_{\mathit{init}}`.

#. Push the activation of :math:`z` to the stack.

#. Let :math:`{{\mathit{val}}^\ast}` be :math:`{{\mathrm{eval}}_{\mathit{expr}}({\mathit{expr}}_{\mathsf{g}})^\ast}`.

#. Pop the activation of :math:`f` from the stack.

#. Push the activation of :math:`z` to the stack.

#. Let :math:`{{{\mathit{ref}}^\ast}^\ast}` be :math:`{{{\mathrm{eval}}_{\mathit{expr}}({\mathit{expr}}_{\mathsf{e}})^\ast}^\ast}`.

#. Pop the activation of :math:`f` from the stack.

#. Let :math:`{\mathit{moduleinst}}` be :math:`{\mathrm{allocmodule}}({\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}^\ast}, {{{\mathit{ref}}^\ast}^\ast})`.

#. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~\epsilon,\; \mathsf{module}~{\mathit{moduleinst}} \}\end{array}`.

#. Push the activation of :math:`f` with arity :math:`0` to the stack.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{e}}^\ast}`.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{d}}^\ast}`.

#. If :math:`{(\mathsf{call}~x)^?}` is defined, then:

  a. Execute the instruction :math:`(\mathsf{call}~x)`.

#. Pop the activation of :math:`f` with arity :math:`0` from the stack.

#. Return :math:`f{.}\mathsf{module}`.


:math:`{\mathrm{invoke}}(z, {\mathit{fa}}, {{\mathit{val}}^{n}})`
.................................................................


1. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~\epsilon,\; \mathsf{module}~\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{exports}~\epsilon \}\end{array} \}\end{array}`.

#. Push the activation of :math:`f` to the stack.

#. Let :math:`{t_1^{n}}~\rightarrow~{t_2^\ast}` be :math:`z{.}\mathsf{funcs}{}[{\mathit{fa}}]{.}\mathsf{type}`.

#. Pop the activation of :math:`f` from the stack.

#. Let :math:`k` be :math:`{|{t_2^\ast}|}`.

#. Push the activation of :math:`f` with arity :math:`k` to the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{call}~{\mathit{fa}})`.

#. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Pop the activation of :math:`f` with arity :math:`k` from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Return :math:`{{\mathit{val}}^{k}}`.


:math:`{\mathrm{eval}}_{\mathit{expr}}({{\mathit{instr}}^\ast})`
................................................................


1. Execute the instruction :math:`{{\mathit{instr}}^\ast}`.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Return :math:`{\mathit{val}}`.


== Complete.
watsup 0.4 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...
Limits_ok
- the limits (n, m) is valid with the nat k if:
  - n is less than or equal to m.
  - m is less than or equal to k.

Functype_ok
- the function type t_1* -> t_2* is valid.

Globaltype_ok
- the global type ((MUT ()? ?) t) is valid.

Tabletype_ok
- the table type (limits reftype) is valid if:
  - the limits limits is valid with the nat ((2 ^ 32) - 1).

Memtype_ok
- the memory type limits PAGE is valid if:
  - the limits limits is valid with the nat (2 ^ 16).

Externtype_ok
- the external type externtype_u0 is valid if:
  - Either:
    - externtype_u0 is (FUNC functype).
    - the function type functype is valid.
  - Or:
    - externtype_u0 is (GLOBAL globaltype).
    - the global type globaltype is valid.
  - Or:
    - externtype_u0 is (TABLE tabletype).
    - the table type tabletype is valid.
  - Or:
    - externtype_u0 is (MEM memtype).
    - the memory type memtype is valid.

Valtype_sub
- the value type valtype_u0 matches the value type t if:
  - Either: valtype_u0 is t.
  - Or: valtype_u0 is BOT.

Resulttype_sub
- the value type sequence t_1* matches the value type sequence t_2* if:
  - |t_2*| is |t_1*|.
  - For all t_1 in t_1* and t_2 in t_2*, the value type t_1 matches the value type t_2.

Limits_sub
- the limits (n_11, n_12) matches the limits (n_21, n_22) if:
  - n_11 is greater than or equal to n_21.
  - n_12 is less than or equal to n_22.

Functype_sub
- the function type ft matches the function type ft.

Globaltype_sub
- the global type gt matches the global type gt.

Tabletype_sub
- the table type (lim_1 rt) matches the table type (lim_2 rt) if:
  - the limits lim_1 matches the limits lim_2.

Memtype_sub
- the memory type lim_1 PAGE matches the memory type lim_2 PAGE if:
  - the limits lim_1 matches the limits lim_2.

Externtype_sub
- the external type externtype_u0 matches the external type externtype_u1 if:
  - Either:
    - externtype_u0 is (FUNC ft_1).
    - externtype_u1 is (FUNC ft_2).
    - the function type ft_1 matches the function type ft_2.
  - Or:
    - externtype_u0 is (GLOBAL gt_1).
    - externtype_u1 is (GLOBAL gt_2).
    - the global type gt_1 matches the global type gt_2.
  - Or:
    - externtype_u0 is (TABLE tt_1).
    - externtype_u1 is (TABLE tt_2).
    - the table type tt_1 matches the table type tt_2.
  - Or:
    - externtype_u0 is (MEM mt_1).
    - externtype_u1 is (MEM mt_2).
    - the memory type mt_1 matches the memory type mt_2.

Blocktype_ok
- the block type blocktype_u0 is valid with the function type valtype_u1* -> valtype_u2* if:
  - Either:
    - blocktype_u0 is (_RESULT valtype?).
    - valtype_u1* is [].
    - valtype_u2* is valtype?.
  - Or:
    - blocktype_u0 is (_IDX typeidx).
    - valtype_u1* is t_1*.
    - valtype_u2* is t_2*.
    - |C.TYPES| is greater than typeidx.
    - C.TYPES[typeidx] is t_1* -> t_2*.

Instr_ok/nop
- the instruction NOP is valid with the function type [] -> [].

Instr_ok/unreachable
- the instruction UNREACHABLE is valid with the function type t_1* -> t_2*.

Instr_ok/drop
- the instruction DROP is valid with the function type [t] -> [].

Instr_ok/select
- the instruction (SELECT() valtype_u0? ?) is valid with the function type [t, t, I32] -> [t] if:
  - Either: valtype_u0? is ?([t]).
  - Or:
    - valtype_u0? is ?().
    - the value type t matches the value type t'.
    - t' is contained in [numtype, vectype].

Instr_ok/block
- the instruction (BLOCK bt instr*) is valid with the function type t_1* -> t_2* if:
  - the block type bt is valid with the function type t_1* -> t_2*.
  - Under the context C with .LABELS prepended by [t_2*], the instruction sequence instr* is valid with the function type t_1* -> t_2*.

Instr_ok/loop
- the instruction (LOOP bt instr*) is valid with the function type t_1* -> t_2* if:
  - the block type bt is valid with the function type t_1* -> t_2*.
  - Under the context C with .LABELS prepended by [t_1*], the instruction sequence instr* is valid with the function type t_1* -> t_2*.

Instr_ok/if
- the instruction (IF bt instr_1* ELSE instr_2*) is valid with the function type t_1* :: [I32] -> t_2* if:
  - the block type bt is valid with the function type t_1* -> t_2*.
  - Under the context C with .LABELS prepended by [t_2*], the instruction sequence instr_1* is valid with the function type t_1* -> t_2*.
  - Under the context C with .LABELS prepended by [t_2*], the instruction sequence instr_2* is valid with the function type t_1* -> t_2*.

Instr_ok/br
- the instruction (BR l) is valid with the function type t_1* :: t* -> t_2* if:
  - |C.LABELS| is greater than l.
  - C.LABELS[l] is t*.

Instr_ok/br_if
- the instruction (BR_IF l) is valid with the function type t* :: [I32] -> t* if:
  - |C.LABELS| is greater than l.
  - C.LABELS[l] is t*.

Instr_ok/br_table
- the instruction (BR_TABLE l* l') is valid with the function type t_1* :: t* -> t_2* if:
  - For all l in l*, |C.LABELS| is greater than l.
  - For all l in l*, the value type sequence t* matches the result type C.LABELS[l].
  - |C.LABELS| is greater than l'.
  - the value type sequence t* matches the result type C.LABELS[l'].

Instr_ok/call
- the instruction (CALL x) is valid with the function type t_1* -> t_2* if:
  - |C.FUNCS| is greater than x.
  - C.FUNCS[x] is t_1* -> t_2*.

Instr_ok/call_indirect
- the instruction (CALL_INDIRECT x y) is valid with the function type t_1* :: [I32] -> t_2* if:
  - |C.TABLES| is greater than x.
  - C.TABLES[x] is (lim FUNCREF).
  - |C.TYPES| is greater than y.
  - C.TYPES[y] is t_1* -> t_2*.

Instr_ok/return
- the instruction RETURN is valid with the function type t_1* :: t* -> t_2* if:
  - C.RETURN is ?(t*).

Instr_ok/const
- the instruction (nt.CONST c_nt) is valid with the function type [] -> [nt].

Instr_ok/unop
- the instruction (UNOP nt unop_nt) is valid with the function type [nt] -> [nt].

Instr_ok/binop
- the instruction (BINOP nt binop_nt) is valid with the function type [nt, nt] -> [nt].

Instr_ok/testop
- the instruction (TESTOP nt testop_nt) is valid with the function type [nt] -> [I32].

Instr_ok/relop
- the instruction (RELOP nt relop_nt) is valid with the function type [nt, nt] -> [I32].

Instr_ok/cvtop
- the instruction (CVTOP nt_1 nt_2 cvtop_u0) is valid with the function type [nt_2] -> [nt_1] if:
  - Either:
    - cvtop_u0 is REINTERPRET.
    - $size(nt_1) is $size(nt_2).
  - Or: cvtop_u0 is cvtop.

Instr_ok/ref.null
- the instruction (REF.NULL rt) is valid with the function type [] -> [rt].

Instr_ok/ref.func
- the instruction (REF.FUNC x) is valid with the function type [] -> [FUNCREF] if:
  - |C.FUNCS| is greater than x.
  - C.FUNCS[x] is ft.

Instr_ok/ref.is_null
- the instruction REF.IS_NULL is valid with the function type [rt] -> [I32].

Instr_ok/vconst
- the instruction (V128.CONST c) is valid with the function type [] -> [V128].

Instr_ok/vvunop
- the instruction (VVUNOP V128 vvunop) is valid with the function type [V128] -> [V128].

Instr_ok/vvbinop
- the instruction (VVBINOP V128 vvbinop) is valid with the function type [V128, V128] -> [V128].

Instr_ok/vvternop
- the instruction (VVTERNOP V128 vvternop) is valid with the function type [V128, V128, V128] -> [V128].

Instr_ok/vvtestop
- the instruction (VVTESTOP V128 vvtestop) is valid with the function type [V128] -> [I32].

Instr_ok/vunop
- the instruction (VUNOP sh vunop_sh) is valid with the function type [V128] -> [V128].

Instr_ok/vbinop
- the instruction (VBINOP sh vbinop_sh) is valid with the function type [V128, V128] -> [V128].

Instr_ok/vtestop
- the instruction (VTESTOP sh vtestop_sh) is valid with the function type [V128] -> [I32].

Instr_ok/vrelop
- the instruction (VRELOP sh vrelop_sh) is valid with the function type [V128, V128] -> [V128].

Instr_ok/vshiftop
- the instruction (VSHIFTOP sh vshiftop_sh) is valid with the function type [V128, I32] -> [V128].

Instr_ok/vbitmask
- the instruction (VBITMASK sh) is valid with the function type [V128] -> [I32].

Instr_ok/vswizzle
- the instruction (VSWIZZLE sh) is valid with the function type [V128, V128] -> [V128].

Instr_ok/vshuffle
- the instruction (VSHUFFLE sh i*) is valid with the function type [V128, V128] -> [V128] if:
  - For all i in i*, i is less than (2 · $dim(sh)).

Instr_ok/vsplat
- the instruction (VSPLAT sh) is valid with the function type [$shunpack(sh)] -> [V128].

Instr_ok/vextract_lane
- the instruction (VEXTRACT_LANE sh sx? i) is valid with the function type [V128] -> [$shunpack(sh)] if:
  - i is less than $dim(sh).

Instr_ok/vreplace_lane
- the instruction (VREPLACE_LANE sh i) is valid with the function type [V128, $shunpack(sh)] -> [V128] if:
  - i is less than $dim(sh).

Instr_ok/vextunop
- the instruction (VEXTUNOP sh_1 sh_2 vextunop) is valid with the function type [V128] -> [V128].

Instr_ok/vextbinop
- the instruction (VEXTBINOP sh_1 sh_2 vextbinop) is valid with the function type [V128, V128] -> [V128].

Instr_ok/vnarrow
- the instruction (VNARROW sh_1 sh_2 sx) is valid with the function type [V128, V128] -> [V128].

Instr_ok/vcvtop
- the instruction (VCVTOP sh_1 sh_2 vcvtop hf? zero?) is valid with the function type [V128] -> [V128].

Instr_ok/local.get
- the instruction (LOCAL.GET x) is valid with the function type [] -> [t] if:
  - |C.LOCALS| is greater than x.
  - C.LOCALS[x] is t.

Instr_ok/local.set
- the instruction (LOCAL.SET x) is valid with the function type [t] -> [] if:
  - |C.LOCALS| is greater than x.
  - C.LOCALS[x] is t.

Instr_ok/local.tee
- the instruction (LOCAL.TEE x) is valid with the function type [t] -> [t] if:
  - |C.LOCALS| is greater than x.
  - C.LOCALS[x] is t.

Instr_ok/global.get
- the instruction (GLOBAL.GET x) is valid with the function type [] -> [t] if:
  - |C.GLOBALS| is greater than x.
  - C.GLOBALS[x] is (mut t).

Instr_ok/global.set
- the instruction (GLOBAL.SET x) is valid with the function type [t] -> [] if:
  - |C.GLOBALS| is greater than x.
  - C.GLOBALS[x] is (MUT t).

Instr_ok/table.get
- the instruction (TABLE.GET x) is valid with the function type [I32] -> [rt] if:
  - |C.TABLES| is greater than x.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.set
- the instruction (TABLE.SET x) is valid with the function type [I32, rt] -> [] if:
  - |C.TABLES| is greater than x.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.size
- the instruction (TABLE.SIZE x) is valid with the function type [] -> [I32] if:
  - |C.TABLES| is greater than x.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.grow
- the instruction (TABLE.GROW x) is valid with the function type [rt, I32] -> [I32] if:
  - |C.TABLES| is greater than x.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.fill
- the instruction (TABLE.FILL x) is valid with the function type [I32, rt, I32] -> [] if:
  - |C.TABLES| is greater than x.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.copy
- the instruction (TABLE.COPY x_1 x_2) is valid with the function type [I32, I32, I32] -> [] if:
  - |C.TABLES| is greater than x_1.
  - C.TABLES[x_1] is (lim_1 rt).
  - |C.TABLES| is greater than x_2.
  - C.TABLES[x_2] is (lim_2 rt).

Instr_ok/table.init
- the instruction (TABLE.INIT x_1 x_2) is valid with the function type [I32, I32, I32] -> [] if:
  - |C.TABLES| is greater than x_1.
  - C.TABLES[x_1] is (lim rt).
  - |C.ELEMS| is greater than x_2.
  - C.ELEMS[x_2] is rt.

Instr_ok/elem.drop
- the instruction (ELEM.DROP x) is valid with the function type [] -> [] if:
  - |C.ELEMS| is greater than x.
  - C.ELEMS[x] is rt.

Instr_ok/memory.size
- the instruction MEMORY.SIZE is valid with the function type [] -> [I32] if:
  - |C.MEMS| is greater than 0.
  - C.MEMS[0] is mt.

Instr_ok/memory.grow
- the instruction MEMORY.GROW is valid with the function type [I32] -> [I32] if:
  - |C.MEMS| is greater than 0.
  - C.MEMS[0] is mt.

Instr_ok/memory.fill
- the instruction MEMORY.FILL is valid with the function type [I32, I32, I32] -> [] if:
  - |C.MEMS| is greater than 0.
  - C.MEMS[0] is mt.

Instr_ok/memory.copy
- the instruction MEMORY.COPY is valid with the function type [I32, I32, I32] -> [] if:
  - |C.MEMS| is greater than 0.
  - C.MEMS[0] is mt.

Instr_ok/memory.init
- the instruction (MEMORY.INIT x) is valid with the function type [I32, I32, I32] -> [] if:
  - |C.MEMS| is greater than 0.
  - C.MEMS[0] is mt.
  - |C.DATAS| is greater than x.
  - C.DATAS[x] is OK.

Instr_ok/data.drop
- the instruction (DATA.DROP x) is valid with the function type [] -> [] if:
  - |C.DATAS| is greater than x.
  - C.DATAS[x] is OK.

Instr_ok/load
- the instruction (LOAD nt (_) (n, sx)? ? memarg) is valid with the function type [I32] -> [nt] if:
  - |C.MEMS| is greater than 0.
  - C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - If n is defined,
    - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).
    - (n / 8) is less than ($size(nt) / 8).
  - If n is defined, nt is Inn.

Instr_ok/store
- the instruction (STORE nt n? memarg) is valid with the function type [I32, nt] -> [] if:
  - |C.MEMS| is greater than 0.
  - C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - If n is defined,
    - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).
    - (n / 8) is less than ($size(nt) / 8).
  - If n is defined, nt is Inn.

Instr_ok/vload
- the instruction (VLOAD V128 ?(vloadop_u0) memarg) is valid with the function type [I32] -> [V128] if:
  - |C.MEMS| is greater than 0.
  - C.MEMS[0] is mt.
  - Either:
    - vloadop_u0 is (SHAPE M X N sx).
    - (2 ^ memarg.ALIGN) is less than or equal to ((M / 8) · N).
  - Or:
    - vloadop_u0 is (SPLAT n).
    - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).
  - Or:
    - vloadop_u0 is (ZERO n).
    - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).

Instr_ok/vload_lane
- the instruction (VLOAD_LANE V128 n memarg laneidx) is valid with the function type [I32, V128] -> [V128] if:
  - |C.MEMS| is greater than 0.
  - C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).
  - laneidx is less than (128 / n).

Instr_ok/vstore
- the instruction (VSTORE V128 memarg) is valid with the function type [I32, V128] -> [] if:
  - |C.MEMS| is greater than 0.
  - C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(V128) / 8).

Instr_ok/vstore_lane
- the instruction (VSTORE_LANE V128 n memarg laneidx) is valid with the function type [I32, V128] -> [] if:
  - |C.MEMS| is greater than 0.
  - C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).
  - laneidx is less than (128 / n).

Instrs_ok
- the instruction sequence instr_u0* is valid with the function type valtype_u1* -> valtype_u2* if:
  - Either:
    - instr_u0* is [].
    - valtype_u1* is [].
    - valtype_u2* is [].
  - Or:
    - instr_u0* is [instr_1] :: instr_2*.
    - valtype_u1* is t_1*.
    - valtype_u2* is t_3*.
    - the instruction instr_1 is valid with the function type t_1* -> t_2*.
    - the instruction sequence instr_2* is valid with the function type t_2* -> t_3*.
  - Or:
    - instr_u0* is instr*.
    - valtype_u1* is t'_1*.
    - valtype_u2* is t'_2*.
    - the instruction sequence instr* is valid with the function type t_1* -> t_2*.
    - the value type sequence t'_1* matches the value type sequence t_1*.
    - the value type sequence t_2* matches the value type sequence t'_2*.
  - Or:
    - instr_u0* is instr*.
    - valtype_u1* is t* :: t_1*.
    - valtype_u2* is t* :: t_2*.
    - the instruction sequence instr* is valid with the function type t_1* -> t_2*.

Expr_ok
- the expression instr* is valid with the value type sequence t* if:
  - the instruction sequence instr* is valid with the function type [] -> t*.

Instr_const
- the instruction instr_u0 is constant if:
  - Either: instr_u0 is (nt.CONST c).
  - Or: instr_u0 is (vt.CONST vc).
  - Or: instr_u0 is (REF.NULL rt).
  - Or: instr_u0 is (REF.FUNC x).
  - Or:
    - instr_u0 is (GLOBAL.GET x).
    - |C.GLOBALS| is greater than x.
    - C.GLOBALS[x] is (t).

Expr_const
- the expression instr* is constant if:
  - For all instr in instr*, the instruction instr is constant.

Type_ok
- the type (TYPE ft) is valid with the function type ft if:
  - the function type ft is valid.

Func_ok
- the function (FUNC x (LOCAL t)* expr) is valid with the function type t_1* -> t_2* if:
  - |C.TYPES| is greater than x.
  - C.TYPES[x] is t_1* -> t_2*.
  - Under the context C with .LOCALS appended by t_1* :: t* with .LABELS appended by [t_2*] with .RETURN appended by ?(t_2*), the expression expr is valid with the value type sequence t_2*.

Global_ok
- the global (GLOBAL gt expr) is valid with the global type gt if:
  - the global type gt is valid.
  - gt is (mut t).
  - the expression expr is valid with the value type t.
  - the expression expr is constant.

Table_ok
- the table (TABLE tt) is valid with the table type tt if:
  - the table type tt is valid.

Mem_ok
- the memory (MEMORY mt) is valid with the memory type mt if:
  - the memory type mt is valid.

Elemmode_ok
- the elemmode elemmode_u0 is valid with the reference type rt if:
  - Either:
    - elemmode_u0 is (ACTIVE x expr).
    - |C.TABLES| is greater than x.
    - C.TABLES[x] is (lim rt).
    - the expression expr is valid with the value type I32.
    - the expression expr is constant.
  - Or: elemmode_u0 is PASSIVE.
  - Or: elemmode_u0 is DECLARE.

Elem_ok
- the table segment (ELEM rt expr* elemmode) is valid with the reference type rt if:
  - For all expr in expr*,
    - the expression expr is valid with the value type rt.
    - the expression expr is constant.
  - the elemmode elemmode is valid with the reference type rt.

Datamode_ok
- the datamode datamode_u0 is valid if:
  - Either:
    - datamode_u0 is (ACTIVE 0 expr).
    - |C.MEMS| is greater than 0.
    - C.MEMS[0] is mt.
    - the expression expr is valid with the value type I32.
    - the expression expr is constant.
  - Or: datamode_u0 is PASSIVE.

Data_ok
- the memory segment (DATA b* datamode) is valid if:
  - the datamode datamode is valid.

Start_ok
- the start function (START x) is valid if:
  - |C.FUNCS| is greater than x.
  - C.FUNCS[x] is [] -> [].

Import_ok
- the import (IMPORT name_1 name_2 xt) is valid with the external type xt if:
  - the external type xt is valid.

Externidx_ok
- the external index externidx_u0 is valid with the external type externtype_u1 if:
  - Either:
    - externidx_u0 is (FUNC x).
    - externtype_u1 is (FUNC ft).
    - |C.FUNCS| is greater than x.
    - C.FUNCS[x] is ft.
  - Or:
    - externidx_u0 is (GLOBAL x).
    - externtype_u1 is (GLOBAL gt).
    - |C.GLOBALS| is greater than x.
    - C.GLOBALS[x] is gt.
  - Or:
    - externidx_u0 is (TABLE x).
    - externtype_u1 is (TABLE tt).
    - |C.TABLES| is greater than x.
    - C.TABLES[x] is tt.
  - Or:
    - externidx_u0 is (MEM x).
    - externtype_u1 is (MEM mt).
    - |C.MEMS| is greater than x.
    - C.MEMS[x] is mt.

Export_ok
- the export (EXPORT name externidx) is valid with the external type xt if:
  - the external index externidx is valid with the external type xt.

Module_ok
- the module (MODULE type* import* func* global* table* mem* elem* data^n start? export*) is valid if:
  - |type*| is |ft'*|.
  - For all ft' in ft'* and type in type*, the type type is valid with the function type ft'.
  - |ixt*| is |import*|.
  - For all import in import* and ixt in ixt*, Under the context { TYPES: ft'*; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; RETURN: ?(); }, the import import is valid with the external type ixt.
  - |gt*| is |global*|.
  - For all global in global* and gt in gt*, Under the context C', the global global is valid with the global type gt.
  - |tt*| is |table*|.
  - For all table in table* and tt in tt*, Under the context C', the table table is valid with the table type tt.
  - |mt*| is |mem*|.
  - For all mem in mem* and mt in mt*, Under the context C', the memory mem is valid with the memory type mt.
  - |rt*| is |elem*|.
  - For all elem in elem* and rt in rt*, Under the context C', the table segment elem is valid with the reference type rt.
  - For all data in data*, Under the context C', the memory segment data is valid.
  - |func*| is |ft*|.
  - For all ft in ft* and func in func*, the function func is valid with the function type ft.
  - If start is defined, the start function start is valid.
  - |xt*| is |export*|.
  - For all export in export* and xt in xt*, the export export is valid with the external type xt.
  - |mt*| is less than or equal to 1.
  - C is { TYPES: ft'*; FUNCS: ift* :: ft*; GLOBALS: igt* :: gt*; TABLES: itt* :: tt*; MEMS: imt* :: mt*; ELEMS: rt*; DATAS: OK^n; LOCALS: []; LABELS: []; RETURN: ?(); }.
  - C' is { TYPES: ft'*; FUNCS: ift* :: ft*; GLOBALS: igt*; TABLES: itt* :: tt*; MEMS: imt* :: mt*; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; RETURN: ?(); }.
  - ift* is $funcsxt(ixt*).
  - igt* is $globalsxt(ixt*).
  - itt* is $tablesxt(ixt*).
  - imt* is $memsxt(ixt*).

Step_pure/unreachable
1. Trap.

Step_pure/nop
1. Do nothing.

Step_pure/drop
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Do nothing.

Step_pure/select t*?
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. Assert: Due to validation, a value is on the top of the stack.
4. Pop the value val_2 from the stack.
5. Assert: Due to validation, a value is on the top of the stack.
6. Pop the value val_1 from the stack.
7. If (c is not 0), then:
  a. Push the value val_1 to the stack.
8. Else:
  a. Push the value val_2 to the stack.

Step_pure/if bt instr_1* instr_2*
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c is not 0), then:
  a. Execute the instruction (BLOCK bt instr_1*).
4. Else:
  a. Execute the instruction (BLOCK bt instr_2*).

Step_pure/label
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, a label is now on the top of the stack.
3. Pop the current label from the stack.
4. Push the values val* to the stack.

Step_pure/br n_u0
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, the top of the stack is a LABEL_.
3. Push the values val* to the stack.
4. Let L be the current label.
5. Let n be the arity of L.
6. Let instr'* be the continuation of L.
7. If (n_u0 is 0), then:
  a. Assert: Due to validation, there are at least n values on the top of the stack.
  b. Pop the values val^n from the stack.
  c. Pop all values val'* from the top of the stack.
  d. Pop the current label from the stack.
  e. Push the values val^n to the stack.
  f. Execute the instruction instr'*.
8. Else:
  a. Pop all values val* from the top of the stack.
  b. If (n_u0 ≥ 1), then:
    1) Let l be (n_u0 - 1).
    2) Pop the current label from the stack.
    3) Push the values val* to the stack.
    4) Execute the instruction (BR l).

Step_pure/br_if l
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c is not 0), then:
  a. Execute the instruction (BR l).
4. Else:
  a. Do nothing.

Step_pure/br_table l* l'
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. If (i < |l*|), then:
  a. Execute the instruction (BR l*[i]).
4. Else:
  a. Execute the instruction (BR l').

Step_pure/frame
1. Let F be the current frame.
2. Let n be the arity of F.
3. Assert: Due to validation, there are at least n values on the top of the stack.
4. Assert: Due to validation, there are at least n values on the top of the stack.
5. Pop the values val^n from the stack.
6. Assert: Due to validation, a frame is now on the top of the stack.
7. Pop the current frame from the stack.
8. Push the values val^n to the stack.

Step_pure/return
1. Pop all values val* from the top of the stack.
2. If the top of the stack is a FRAME_, then:
  a. Push the values val* to the stack.
  b. Let F be the current frame.
  c. Let n be the arity of F.
  d. Assert: Due to validation, there are at least n values on the top of the stack.
  e. Pop the values val^n from the stack.
  f. Pop all values val'* from the top of the stack.
  g. Pop the current frame from the stack.
  h. Push the values val^n to the stack.
3. Else if the top of the stack is a LABEL_, then:
  a. Push the values val* to the stack.
  b. Pop all values val* from the top of the stack.
  c. Pop the current label from the stack.
  d. Push the values val* to the stack.
  e. Execute the instruction RETURN.

Step_pure/unop nt unop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (nt.CONST c_1) from the stack.
3. If (|$unop_(nt, unop, c_1)| ≤ 0), then:
  a. Trap.
4. Let c be an element of $unop_(nt, unop, c_1).
5. Push the value (nt.CONST c) to the stack.

Step_pure/binop nt binop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (nt.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type numtype_0 is on the top of the stack.
4. Pop the value (numtype_0.CONST c_1) from the stack.
5. If (|$binop_(nt, binop, c_1, c_2)| ≤ 0), then:
  a. Trap.
6. Let c be an element of $binop_(nt, binop, c_1, c_2).
7. Push the value (nt.CONST c) to the stack.

Step_pure/testop nt testop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (nt.CONST c_1) from the stack.
3. Let c be $testop_(nt, testop, c_1).
4. Push the value (I32.CONST c) to the stack.

Step_pure/relop nt relop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (nt.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type numtype_0 is on the top of the stack.
4. Pop the value (numtype_0.CONST c_1) from the stack.
5. Let c be $relop_(nt, relop, c_1, c_2).
6. Push the value (I32.CONST c) to the stack.

Step_pure/cvtop nt_2 nt_1 cvtop
1. Assert: Due to validation, a value of value type nt_1 is on the top of the stack.
2. Pop the value (nt_1.CONST c_1) from the stack.
3. If (|$cvtop__(nt_1, nt_2, cvtop, c_1)| ≤ 0), then:
  a. Trap.
4. Let c be an element of $cvtop__(nt_1, nt_2, cvtop, c_1).
5. Push the value (nt_2.CONST c) to the stack.

Step_pure/ref.is_null
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is of the case REF.NULL, then:
  a. Push the value (I32.CONST 1) to the stack.
4. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_pure/vvunop V128 vvunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vvunop_(V128, vvunop, c_1).
4. Push the value (V128.CONST c) to the stack.

Step_pure/vvbinop V128 vvbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vvbinop_(V128, vvbinop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vvternop V128 vvternop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_3) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_2) from the stack.
5. Assert: Due to validation, a value of value type V128 is on the top of the stack.
6. Pop the value (V128.CONST c_1) from the stack.
7. Let c be $vvternop_(V128, vvternop, c_1, c_2, c_3).
8. Push the value (V128.CONST c) to the stack.

Step_pure/vvtestop V128 ANY_TRUE
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $ine_($size(V128), c_1, 0).
4. Push the value (I32.CONST c) to the stack.

Step_pure/vunop sh vunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (|$vunop_(sh, vunop, c_1)| ≤ 0), then:
  a. Trap.
4. Let c be an element of $vunop_(sh, vunop, c_1).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vbinop sh vbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. If (|$vbinop_(sh, vbinop, c_1, c_2)| ≤ 0), then:
  a. Trap.
6. Let c be an element of $vbinop_(sh, vbinop, c_1, c_2).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vtestop Jnn X N ALL_TRUE
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c) from the stack.
3. Let ci_1* be $lanes_(Jnn X N, c).
4. If (ci_1 is not 0)*, then:
  a. Push the value (I32.CONST 1) to the stack.
5. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_pure/vrelop sh vrelop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vrelop_(sh, vrelop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vshiftop Jnn X N vshiftop
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST n) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c'* be $lanes_(Jnn X N, c_1).
6. Let c be $invlanes_(Jnn X N, $vshiftop_(Jnn X N, vshiftop, c', n)*).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vbitmask Jnn X N
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c) from the stack.
3. Let ci_1* be $lanes_(Jnn X N, c).
4. Let ci be $ibits__1^-1(32, $ilt_($lsize(Jnn), S, ci_1, 0)*).
5. Push the value (I32.CONST ci) to the stack.

Step_pure/vswizzle Pnn X M
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c'* be $lanes_(Pnn X M, c_1) :: 0^(256 - M).
6. Let ci* be $lanes_(Pnn X M, c_2).
7. Assert: Due to validation, (ci*[k] < |c'*|)^(k<M).
8. Assert: Due to validation, (k < |ci*|)^(k<M).
9. Let c be $invlanes_(Pnn X M, c'*[ci*[k]]^(k<M)).
10. Push the value (V128.CONST c) to the stack.

Step_pure/vshuffle Pnn X N i*
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Assert: Due to validation, (k < |i*|)^(k<N).
6. Let c'* be $lanes_(Pnn X N, c_1) :: $lanes_(Pnn X N, c_2).
7. Assert: Due to validation, (i*[k] < |c'*|)^(k<N).
8. Let c be $invlanes_(Pnn X N, c'*[i*[k]]^(k<N)).
9. Push the value (V128.CONST c) to the stack.

Step_pure/vsplat Lnn X N
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. Assert: Due to validation, (numtype_0 is $unpack(Lnn)).
4. Let c be $invlanes_(Lnn X N, $packnum_(Lnn, c_1)^N).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vextract_lane lanetype_u0 X N sx_u1? i
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (sx_u1? is not defined and the type of lanetype_u0 is numtype), then:
  a. Let nt be lanetype_u0.
  b. If (i < |$lanes_(nt X N, c_1)|), then:
    1) Let c_2 be $lanes_(nt X N, c_1)[i].
    2) Push the value (nt.CONST c_2) to the stack.
4. If the type of lanetype_u0 is packtype, then:
  a. Let pt be lanetype_u0.
  b. If sx_u1? is defined, then:
    1) Let ?(sx) be sx_u1?.
    2) If (i < |$lanes_(pt X N, c_1)|), then:
      a) Let c_2 be $extend__($psize(pt), 32, sx, $lanes_(pt X N, c_1)[i]).
      b) Push the value (I32.CONST c_2) to the stack.

Step_pure/vreplace_lane Lnn X N i
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, (numtype_0 is $unpack(Lnn)).
4. Assert: Due to validation, a value of value type V128 is on the top of the stack.
5. Pop the value (V128.CONST c_1) from the stack.
6. Let c be $invlanes_(Lnn X N, $lanes_(Lnn X N, c_1) with [i] replaced by $packnum_(Lnn, c_2)).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vextunop sh_1 sh_2 vextunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vextunop__(sh_1, sh_2, vextunop, c_1).
4. Push the value (V128.CONST c) to the stack.

Step_pure/vextbinop sh_1 sh_2 vextbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vextbinop__(sh_1, sh_2, vextbinop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vnarrow Jnn_2 X N_2 Jnn_1 X N_1 sx
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let ci_1* be $lanes_(Jnn_1 X N_1, c_1).
6. Let ci_2* be $lanes_(Jnn_1 X N_1, c_2).
7. Let cj_1* be $narrow__($lsize(Jnn_1), $lsize(Jnn_2), sx, ci_1)*.
8. Let cj_2* be $narrow__($lsize(Jnn_1), $lsize(Jnn_2), sx, ci_2)*.
9. Let c be $invlanes_(Jnn_2 X N_2, cj_1* :: cj_2*).
10. Push the value (V128.CONST c) to the stack.

Step_pure/vcvtop lanetype_u3 X n_u0 lanetype_u4 X n_u1 vcvtop half_u2? zero_u5?
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (half_u2? is not defined and zero_u5? is not defined), then:
  a. Let Lnn_1 be lanetype_u4.
  b. Let Lnn_2 be lanetype_u3.
  c. Let M be n_u1.
  d. If (n_u0 is M), then:
    1) Let ci* be $lanes_(Lnn_1 X M, c_1).
    2) Let cj** be $setproduct_(lane_(Lnn_2), $vcvtop__(Lnn_1 X M, Lnn_2 X M, vcvtop, ci)*).
    3) If (|$invlanes_(Lnn_2 X M, cj*)*| > 0), then:
      a) Let c be an element of $invlanes_(Lnn_2 X M, cj*)*.
      b) Push the value (V128.CONST c) to the stack.
4. If zero_u5? is not defined, then:
  a. Let Lnn_1 be lanetype_u4.
  b. Let Lnn_2 be lanetype_u3.
  c. Let M_1 be n_u1.
  d. Let M_2 be n_u0.
  e. If half_u2? is defined, then:
    1) Let ?(half) be half_u2?.
    2) Let ci* be $lanes_(Lnn_1 X M_1, c_1)[$half(half, 0, M_2) : M_2].
    3) Let cj** be $setproduct_(lane_(Lnn_2), $vcvtop__(Lnn_1 X M_1, Lnn_2 X M_2, vcvtop, ci)*).
    4) If (|$invlanes_(Lnn_2 X M_2, cj*)*| > 0), then:
      a) Let c be an element of $invlanes_(Lnn_2 X M_2, cj*)*.
      b) Push the value (V128.CONST c) to the stack.
5. If half_u2? is not defined, then:
  a. Let M_1 be n_u1.
  b. Let M_2 be n_u0.
  c. If the type of lanetype_u4 is numtype, then:
    1) Let nt_1 be lanetype_u4.
    2) If the type of lanetype_u3 is numtype, then:
      a) Let nt_2 be lanetype_u3.
      b) If zero_u5? is defined, then:
        1. Let ci* be $lanes_(nt_1 X M_1, c_1).
        2. Let cj** be $setproduct_(lane_((nt_2 : numtype <: lanetype)), $vcvtop__(nt_1 X M_1, nt_2 X M_2, vcvtop, ci)* :: [$zero(nt_2)]^M_1).
        3. If (|$invlanes_(nt_2 X M_2, cj*)*| > 0), then:
          a. Let c be an element of $invlanes_(nt_2 X M_2, cj*)*.
          b. Push the value (V128.CONST c) to the stack.

Step_pure/local.tee x
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Push the value val to the stack.
4. Push the value val to the stack.
5. Execute the instruction (LOCAL.SET x).

Step_read/block bt instr*
1. Let z be the current state.
2. Let t_1^k -> t_2^n be $blocktype(z, bt).
3. Assert: Due to validation, there are at least k values on the top of the stack.
4. Pop the values val^k from the stack.
5. Let L be the label_n{[]}.
6. Enter val^k :: instr* with label L.

Step_read/loop bt instr*
1. Let z be the current state.
2. Let t_1^k -> t_2^n be $blocktype(z, bt).
3. Assert: Due to validation, there are at least k values on the top of the stack.
4. Pop the values val^k from the stack.
5. Let L be the label_k{[(LOOP bt instr*)]}.
6. Enter val^k :: instr* with label L.

Step_read/call x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$funcaddr(z)|).
3. Execute the instruction (CALL_ADDR $funcaddr(z)[x]).

Step_read/call_indirect x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (i ≥ |$table(z, x).REFS|), then:
  a. Trap.
5. If $table(z, x).REFS[i] is not of the case REF.FUNC_ADDR, then:
  a. Trap.
6. Let (REF.FUNC_ADDR a) be $table(z, x).REFS[i].
7. If (a ≥ |$funcinst(z)|), then:
  a. Trap.
8. If ($type(z, y) is not $funcinst(z)[a].TYPE), then:
  a. Trap.
9. Execute the instruction (CALL_ADDR a).

Step_read/call_addr a
1. Let z be the current state.
2. Assert: Due to validation, (a < |$funcinst(z)|).
3. Let { TYPE: t_1^k -> t_2^n; MODULE: mm; CODE: func; } be $funcinst(z)[a].
4. Assert: Due to validation, there are at least k values on the top of the stack.
5. Pop the values val^k from the stack.
6. Assert: Due to validation, func is of the case FUNC.
7. Let (FUNC x local_0* instr*) be func.
8. Assert: Due to validation, local_0 is of the case LOCAL*.
9. Let (LOCAL t)* be local_0*.
10. Let f be { LOCALS: val^k :: $default_(t)*; MODULE: mm; }.
11. Let F be the activation of f with arity n.
12. Push F to the stack.
13. Let L be the label_n{[]}.
14. Enter instr* with label L.

Step_read/ref.func x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$funcaddr(z)|).
3. Push the value (REF.FUNC_ADDR $funcaddr(z)[x]) to the stack.

Step_read/local.get x
1. Let z be the current state.
2. Push the value $local(z, x) to the stack.

Step_read/global.get x
1. Let z be the current state.
2. Push the value $global(z, x).VALUE to the stack.

Step_read/table.get x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (i ≥ |$table(z, x).REFS|), then:
  a. Trap.
5. Push the value $table(z, x).REFS[i] to the stack.

Step_read/table.size x
1. Let z be the current state.
2. Let n be |$table(z, x).REFS|.
3. Push the value (I32.CONST n) to the stack.

Step_read/table.fill x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. If ((i + n) > |$table(z, x).REFS|), then:
  a. Trap.
9. If (n is 0), then:
  a. Do nothing.
10. Else:
  a. Push the value (I32.CONST i) to the stack.
  b. Push the value val to the stack.
  c. Execute the instruction (TABLE.SET x).
  d. Push the value (I32.CONST (i + 1)) to the stack.
  e. Push the value val to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (TABLE.FILL x).

Step_read/table.copy x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$table(z, y).REFS|), then:
  a. Trap.
9. If ((j + n) > |$table(z, x).REFS|), then:
  a. Trap.
10. If (n is 0), then:
  a. Do nothing.
11. Else:
  a. If (j ≤ i), then:
    1) Push the value (I32.CONST j) to the stack.
    2) Push the value (I32.CONST i) to the stack.
    3) Execute the instruction (TABLE.GET y).
    4) Execute the instruction (TABLE.SET x).
    5) Push the value (I32.CONST (j + 1)) to the stack.
    6) Push the value (I32.CONST (i + 1)) to the stack.
  b. Else:
    1) Push the value (I32.CONST ((j + n) - 1)) to the stack.
    2) Push the value (I32.CONST ((i + n) - 1)) to the stack.
    3) Execute the instruction (TABLE.GET y).
    4) Execute the instruction (TABLE.SET x).
    5) Push the value (I32.CONST j) to the stack.
    6) Push the value (I32.CONST i) to the stack.
  c. Push the value (I32.CONST (n - 1)) to the stack.
  d. Execute the instruction (TABLE.COPY x y).

Step_read/table.init x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$elem(z, y).REFS|), then:
  a. Trap.
9. If ((j + n) > |$table(z, x).REFS|), then:
  a. Trap.
10. If (n is 0), then:
  a. Do nothing.
11. Else if (i < |$elem(z, y).REFS|), then:
  a. Push the value (I32.CONST j) to the stack.
  b. Push the value $elem(z, y).REFS[i] to the stack.
  c. Execute the instruction (TABLE.SET x).
  d. Push the value (I32.CONST (j + 1)) to the stack.
  e. Push the value (I32.CONST (i + 1)) to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (TABLE.INIT x y).

Step_read/load numtype_u0 sz_sx_u1? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If sz_sx_u1? is not defined, then:
  a. Let nt be numtype_u0.
  b. If (((i + ao.OFFSET) + ($size(nt) / 8)) > |$mem(z, 0).BYTES|), then:
    1) Trap.
  c. Let c be $nbytes__1^-1(nt, $mem(z, 0).BYTES[(i + ao.OFFSET) : ($size(nt) / 8)]).
  d. Push the value (nt.CONST c) to the stack.
5. If the type of numtype_u0 is Inn, then:
  a. If sz_sx_u1? is defined, then:
    1) Let ?(sz_sx_0) be sz_sx_u1?.
    2) Let (n, sx) be sz_sx_0.
    3) If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
  b. Let Inn be numtype_u0.
  c. If sz_sx_u1? is defined, then:
    1) Let ?(sz_sx_0) be sz_sx_u1?.
    2) Let (n, sx) be sz_sx_0.
    3) Let c be $ibytes__1^-1(n, $mem(z, 0).BYTES[(i + ao.OFFSET) : (n / 8)]).
    4) Push the value (Inn.CONST $extend__(n, $size(Inn), sx, c)) to the stack.

Step_read/vload V128 vloadop_u0? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If ((((i + ao.OFFSET) + ($size(V128) / 8)) > |$mem(z, 0).BYTES|) and vloadop_u0? is not defined), then:
  a. Trap.
5. If vloadop_u0? is not defined, then:
  a. Let c be $vbytes__1^-1(V128, $mem(z, 0).BYTES[(i + ao.OFFSET) : ($size(V128) / 8)]).
  b. Push the value (V128.CONST c) to the stack.
6. Else:
  a. Let ?(vloadop_0) be vloadop_u0?.
  b. If vloadop_0 is of the case SHAPE, then:
    1) Let (SHAPE M X N sx) be vloadop_0.
    2) If (((i + ao.OFFSET) + ((M · N) / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
    3) Let j^N be $ibytes__1^-1(M, $mem(z, 0).BYTES[((i + ao.OFFSET) + ((k · M) / 8)) : (M / 8)])^(k<N).
    4) If the type of $lsize^-1((M · 2)) is Jnn, then:
      a) Let Jnn be $lsize^-1((M · 2)).
      b) Let c be $invlanes_(Jnn X N, $extend__(M, $lsize(Jnn), sx, j)^N).
      c) Push the value (V128.CONST c) to the stack.
  c. If vloadop_0 is of the case SPLAT, then:
    1) Let (SPLAT N) be vloadop_0.
    2) If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
    3) Let M be (128 / N).
    4) If the type of $lsize^-1(N) is Jnn, then:
      a) Let Jnn be $lsize^-1(N).
      b) Let j be $ibytes__1^-1(N, $mem(z, 0).BYTES[(i + ao.OFFSET) : (N / 8)]).
      c) Let c be $invlanes_(Jnn X M, j^M).
      d) Push the value (V128.CONST c) to the stack.
  d. If vloadop_0 is of the case ZERO, then:
    1) Let (ZERO N) be vloadop_0.
    2) If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
    3) Let j be $ibytes__1^-1(N, $mem(z, 0).BYTES[(i + ao.OFFSET) : (N / 8)]).
    4) Let c be $extend__(N, 128, U, j).
    5) Push the value (V128.CONST c) to the stack.

Step_read/vload_lane V128 N ao j
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c_1) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, 0).BYTES|), then:
  a. Trap.
7. Let M be (128 / N).
8. If the type of $lsize^-1(N) is Jnn, then:
  a. Let Jnn be $lsize^-1(N).
  b. Let k be $ibytes__1^-1(N, $mem(z, 0).BYTES[(i + ao.OFFSET) : (N / 8)]).
  c. Let c be $invlanes_(Jnn X M, $lanes_(Jnn X M, c_1) with [j] replaced by k).
  d. Push the value (V128.CONST c) to the stack.

Step_read/memory.size
1. Let z be the current state.
2. Let ((n · 64) · $Ki()) be |$mem(z, 0).BYTES|.
3. Push the value (I32.CONST n) to the stack.

Step_read/memory.fill
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. If ((i + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.
9. If (n is 0), then:
  a. Do nothing.
10. Else:
  a. Push the value (I32.CONST i) to the stack.
  b. Push the value val to the stack.
  c. Execute the instruction (STORE I32 ?(8) $memarg0()).
  d. Push the value (I32.CONST (i + 1)) to the stack.
  e. Push the value val to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction MEMORY.FILL.

Step_read/memory.copy
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.
9. If ((j + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.
10. If (n is 0), then:
  a. Do nothing.
11. Else:
  a. If (j ≤ i), then:
    1) Push the value (I32.CONST j) to the stack.
    2) Push the value (I32.CONST i) to the stack.
    3) Execute the instruction (LOAD I32 (_) ?((8, U)) ? $memarg0()).
    4) Execute the instruction (STORE I32 ?(8) $memarg0()).
    5) Push the value (I32.CONST (j + 1)) to the stack.
    6) Push the value (I32.CONST (i + 1)) to the stack.
  b. Else:
    1) Push the value (I32.CONST ((j + n) - 1)) to the stack.
    2) Push the value (I32.CONST ((i + n) - 1)) to the stack.
    3) Execute the instruction (LOAD I32 (_) ?((8, U)) ? $memarg0()).
    4) Execute the instruction (STORE I32 ?(8) $memarg0()).
    5) Push the value (I32.CONST j) to the stack.
    6) Push the value (I32.CONST i) to the stack.
  c. Push the value (I32.CONST (n - 1)) to the stack.
  d. Execute the instruction MEMORY.COPY.

Step_read/memory.init x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$data(z, x).BYTES|), then:
  a. Trap.
9. If ((j + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.
10. If (n is 0), then:
  a. Do nothing.
11. Else if (i < |$data(z, x).BYTES|), then:
  a. Push the value (I32.CONST j) to the stack.
  b. Push the value (I32.CONST $data(z, x).BYTES[i]) to the stack.
  c. Execute the instruction (STORE I32 ?(8) $memarg0()).
  d. Push the value (I32.CONST (j + 1)) to the stack.
  e. Push the value (I32.CONST (i + 1)) to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (MEMORY.INIT x).

Step/local.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_local(z, x, val).

Step/global.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_global(z, x, val).

Step/table.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value ref from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (i ≥ |$table(z, x).REFS|), then:
  a. Trap.
7. Perform $with_table(z, x, i, ref).

Step/table.grow x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value ref from the stack.
6. Either:
  a. Let ti be $growtable($table(z, x), n, ref).
  b. Push the value (I32.CONST |$table(z, x).REFS|) to the stack.
  c. Perform $with_tableinst(z, x, ti).
7. Or:
  a. Push the value (I32.CONST $invsigned_(32, (- 1))) to the stack.

Step/elem.drop x
1. Let z be the current state.
2. Perform $with_elem(z, x, []).

Step/store numtype_u0 sz_u1? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type numtype_u2 is on the top of the stack.
3. Pop the value (numtype_u2.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Let nt be numtype_u2.
7. If ((((i + ao.OFFSET) + ($size(nt) / 8)) > |$mem(z, 0).BYTES|) and ((numtype_u0 is nt) and sz_u1? is not defined)), then:
  a. Trap.
8. If ((numtype_u0 is nt) and sz_u1? is not defined), then:
  a. Let b* be $nbytes_(nt, c).
  b. Perform $with_mem(z, 0, (i + ao.OFFSET), ($size(nt) / 8), b*).
9. If the type of numtype_u2 is Inn, then:
  a. Let Inn be numtype_u2.
  b. If ((numtype_u0 is Inn) and sz_u1? is defined), then:
    1) Let ?(n) be sz_u1?.
    2) If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
    3) Let b* be $ibytes_(n, $wrap__($size(Inn), n, c)).
    4) Perform $with_mem(z, 0, (i + ao.OFFSET), (n / 8), b*).

Step/vstore V128 ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + ($size(V128) / 8)) > |$mem(z, 0).BYTES|), then:
  a. Trap.
7. Let b* be $vbytes_(V128, c).
8. Perform $with_mem(z, 0, (i + ao.OFFSET), ($size(V128) / 8), b*).

Step/vstore_lane V128 N ao j
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + N) > |$mem(z, 0).BYTES|), then:
  a. Trap.
7. Let M be (128 / N).
8. If the type of $lsize^-1(N) is Jnn, then:
  a. Let Jnn be $lsize^-1(N).
  b. If (j < |$lanes_(Jnn X M, c)|), then:
    1) Let b* be $ibytes_(N, $lanes_(Jnn X M, c)[j]).
    2) Perform $with_mem(z, 0, (i + ao.OFFSET), (N / 8), b*).

Step/memory.grow
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Either:
  a. Let mi be $growmemory($mem(z, 0), n).
  b. Push the value (I32.CONST (|$mem(z, 0).BYTES| / (64 · $Ki()))) to the stack.
  c. Perform $with_meminst(z, 0, mi).
5. Or:
  a. Push the value (I32.CONST $invsigned_(32, (- 1))) to the stack.

Step/data.drop x
1. Let z be the current state.
2. Perform $with_data(z, x, []).

Ki
1. Return 1024.

min n_u0 n_u1
1. If (n_u0 is 0), then:
  a. Return 0.
2. If (n_u1 is 0), then:
  a. Return 0.
3. Assert: Due to validation, (n_u0 ≥ 1).
4. Let i be (n_u0 - 1).
5. Assert: Due to validation, (n_u1 ≥ 1).
6. Let j be (n_u1 - 1).
7. Return $min(i, j).

sum n_u0*
1. If (n_u0* is []), then:
  a. Return 0.
2. Let [n] :: n'* be n_u0*.
3. Return (n + $sum(n'*)).

opt_ X X_u0*
1. If (X_u0* is []), then:
  a. Return ?().
2. Assert: Due to validation, (|X_u0*| is 1).
3. Let [w] be X_u0*.
4. Return ?(w).

list_ X X_u0?
1. If X_u0? is not defined, then:
  a. Return [].
2. Let ?(w) be X_u0?.
3. Return [w].

concat_ X X_u0*
1. If (X_u0* is []), then:
  a. Return [].
2. Let [w*] :: w'** be X_u0*.
3. Return w* :: $concat_(X, w'**).

setproduct2_ X w_1 X_u0*
1. If (X_u0* is []), then:
  a. Return [].
2. Let [w'*] :: w** be X_u0*.
3. Return [[w_1] :: w'*] :: $setproduct2_(X, w_1, w**).

setproduct1_ X X_u0* w**
1. If (X_u0* is []), then:
  a. Return [].
2. Let [w_1] :: w'* be X_u0*.
3. Return $setproduct2_(X, w_1, w**) :: $setproduct1_(X, w'*, w**).

setproduct_ X X_u0*
1. If (X_u0* is []), then:
  a. Return [[]].
2. Let [w_1*] :: w** be X_u0*.
3. Return $setproduct1_(X, w_1*, $setproduct_(X, w**)).

signif N_u0
1. If (N_u0 is 32), then:
  a. Return 23.
2. Assert: Due to validation, (N_u0 is 64).
3. Return 52.

expon N_u0
1. If (N_u0 is 32), then:
  a. Return 8.
2. Assert: Due to validation, (N_u0 is 64).
3. Return 11.

M N
1. Return $signif(N).

E N
1. Return $expon(N).

fzero N
1. Return (POS (SUBNORM 0)).

fone N
1. Return (POS (NORM 1 0)).

canon_ N
1. Return (2 ^ ($signif(N) - 1)).

size valtype_u0
1. If (valtype_u0 is I32), then:
  a. Return 32.
2. If (valtype_u0 is I64), then:
  a. Return 64.
3. If (valtype_u0 is F32), then:
  a. Return 32.
4. If (valtype_u0 is F64), then:
  a. Return 64.
5. If (valtype_u0 is V128), then:
  a. Return 128.

isize Inn
1. Return $size(Inn).

psize packtype_u0
1. If (packtype_u0 is I8), then:
  a. Return 8.
2. Assert: Due to validation, (packtype_u0 is I16).
3. Return 16.

lsize lanetype_u0
1. If the type of lanetype_u0 is numtype, then:
  a. Let numtype be lanetype_u0.
  b. Return $size(numtype).
2. Assert: Due to validation, the type of lanetype_u0 is packtype.
3. Let packtype be lanetype_u0.
4. Return $psize(packtype).

lanetype Lnn X N
1. Return Lnn.

sizenn nt
1. Return $size(nt).

sizenn1 nt
1. Return $size(nt).

sizenn2 nt
1. Return $size(nt).

lsizenn lt
1. Return $lsize(lt).

lsizenn1 lt
1. Return $lsize(lt).

lsizenn2 lt
1. Return $lsize(lt).

zero numtype_u0
1. If the type of numtype_u0 is Inn, then:
  a. Return 0.
2. Assert: Due to validation, the type of numtype_u0 is Fnn.
3. Let Fnn be numtype_u0.
4. Return $fzero($size(Fnn)).

dim Lnn X N
1. Return N.

shsize Lnn X N
1. Return ($lsize(Lnn) · N).

concat_bytes byte_u0*
1. If (byte_u0* is []), then:
  a. Return [].
2. Let [b*] :: b'** be byte_u0*.
3. Return b* :: $concat_bytes(b'**).

unpack lanetype_u0
1. If the type of lanetype_u0 is numtype, then:
  a. Let numtype be lanetype_u0.
  b. Return numtype.
2. Assert: Due to validation, the type of lanetype_u0 is packtype.
3. Return I32.

shunpack Lnn X N
1. Return $unpack(Lnn).

funcsxt externtype_u0*
1. If (externtype_u0* is []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype_u0*.
3. If externtype_0 is of the case FUNC, then:
  a. Let (FUNC ft) be externtype_0.
  b. Return [ft] :: $funcsxt(xt*).
4. Let [externtype] :: xt* be externtype_u0*.
5. Return $funcsxt(xt*).

globalsxt externtype_u0*
1. If (externtype_u0* is []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype_u0*.
3. If externtype_0 is of the case GLOBAL, then:
  a. Let (GLOBAL gt) be externtype_0.
  b. Return [gt] :: $globalsxt(xt*).
4. Let [externtype] :: xt* be externtype_u0*.
5. Return $globalsxt(xt*).

tablesxt externtype_u0*
1. If (externtype_u0* is []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype_u0*.
3. If externtype_0 is of the case TABLE, then:
  a. Let (TABLE tt) be externtype_0.
  b. Return [tt] :: $tablesxt(xt*).
4. Let [externtype] :: xt* be externtype_u0*.
5. Return $tablesxt(xt*).

memsxt externtype_u0*
1. If (externtype_u0* is []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype_u0*.
3. If externtype_0 is of the case MEM, then:
  a. Let (MEM mt) be externtype_0.
  b. Return [mt] :: $memsxt(xt*).
4. Let [externtype] :: xt* be externtype_u0*.
5. Return $memsxt(xt*).

dataidx_instr instr_u0
1. If instr_u0 is of the case MEMORY.INIT, then:
  a. Let (MEMORY.INIT x) be instr_u0.
  b. Return [x].
2. If instr_u0 is of the case DATA.DROP, then:
  a. Let (DATA.DROP x) be instr_u0.
  b. Return [x].
3. Return [].

dataidx_instrs instr_u0*
1. If (instr_u0* is []), then:
  a. Return [].
2. Let [instr] :: instr'* be instr_u0*.
3. Return $dataidx_instr(instr) :: $dataidx_instrs(instr'*).

dataidx_expr in*
1. Return $dataidx_instrs(in*).

dataidx_func (FUNC x loc* e)
1. Return $dataidx_expr(e).

dataidx_funcs func_u0*
1. If (func_u0* is []), then:
  a. Return [].
2. Let [func] :: func'* be func_u0*.
3. Return $dataidx_func(func) :: $dataidx_funcs(func'*).

memarg0
1. Return { ALIGN: 0; OFFSET: 0; }.

signed_ N i
1. If (0 ≤ (2 ^ (N - 1))), then:
  a. Return i.
2. Assert: Due to validation, ((2 ^ (N - 1)) ≤ i).
3. Assert: Due to validation, (i < (2 ^ N)).
4. Return (i - (2 ^ N)).

invsigned_ N i
1. Let j be $signed__1^-1(N, i).
2. Return j.

unop_ numtype_u1 unop__u0 num__u3
1. If ((unop__u0 is CLZ) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN be num__u3.
  c. Return [$iclz_($sizenn(Inn), iN)].
2. If ((unop__u0 is CTZ) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN be num__u3.
  c. Return [$ictz_($sizenn(Inn), iN)].
3. If ((unop__u0 is POPCNT) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN be num__u3.
  c. Return [$ipopcnt_($sizenn(Inn), iN)].
4. If the type of numtype_u1 is Inn, then:
  a. Let Inn be numtype_u1.
  b. Assert: Due to validation, unop__u0 is of the case EXTEND.
  c. Let (EXTEND M) be unop__u0.
  d. Let iN be num__u3.
  e. Return [$extend__(M, $sizenn(Inn), S, $wrap__($sizenn(Inn), M, iN))].
5. If ((unop__u0 is ABS) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN be num__u3.
  c. Return $fabs_($sizenn(Fnn), fN).
6. If ((unop__u0 is NEG) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN be num__u3.
  c. Return $fneg_($sizenn(Fnn), fN).
7. If ((unop__u0 is SQRT) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN be num__u3.
  c. Return $fsqrt_($sizenn(Fnn), fN).
8. If ((unop__u0 is CEIL) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN be num__u3.
  c. Return $fceil_($sizenn(Fnn), fN).
9. If ((unop__u0 is FLOOR) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN be num__u3.
  c. Return $ffloor_($sizenn(Fnn), fN).
10. If ((unop__u0 is TRUNC) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN be num__u3.
  c. Return $ftrunc_($sizenn(Fnn), fN).
11. Assert: Due to validation, (unop__u0 is NEAREST).
12. Assert: Due to validation, the type of numtype_u1 is Fnn.
13. Let Fnn be numtype_u1.
14. Let fN be num__u3.
15. Return $fnearest_($sizenn(Fnn), fN).

binop_ numtype_u1 binop__u0 num__u3 num__u5
1. If ((binop__u0 is ADD) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return [$iadd_($sizenn(Inn), iN_1, iN_2)].
2. If ((binop__u0 is SUB) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return [$isub_($sizenn(Inn), iN_1, iN_2)].
3. If ((binop__u0 is MUL) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return [$imul_($sizenn(Inn), iN_1, iN_2)].
4. If the type of numtype_u1 is Inn, then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. If binop__u0 is of the case DIV, then:
    1) Let (DIV sx) be binop__u0.
    2) Return $list_(num_((Inn : Inn <: numtype)), $idiv_($sizenn(Inn), sx, iN_1, iN_2)).
  e. If binop__u0 is of the case REM, then:
    1) Let (REM sx) be binop__u0.
    2) Return $list_(num_((Inn : Inn <: numtype)), $irem_($sizenn(Inn), sx, iN_1, iN_2)).
5. If ((binop__u0 is AND) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return [$iand_($sizenn(Inn), iN_1, iN_2)].
6. If ((binop__u0 is OR) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return [$ior_($sizenn(Inn), iN_1, iN_2)].
7. If ((binop__u0 is XOR) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return [$ixor_($sizenn(Inn), iN_1, iN_2)].
8. If ((binop__u0 is SHL) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return [$ishl_($sizenn(Inn), iN_1, iN_2)].
9. If the type of numtype_u1 is Inn, then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. If binop__u0 is of the case SHR, then:
    1) Let (SHR sx) be binop__u0.
    2) Return [$ishr_($sizenn(Inn), sx, iN_1, iN_2)].
10. If ((binop__u0 is ROTL) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return [$irotl_($sizenn(Inn), iN_1, iN_2)].
11. If ((binop__u0 is ROTR) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return [$irotr_($sizenn(Inn), iN_1, iN_2)].
12. If ((binop__u0 is ADD) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $fadd_($sizenn(Fnn), fN_1, fN_2).
13. If ((binop__u0 is SUB) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $fsub_($sizenn(Fnn), fN_1, fN_2).
14. If ((binop__u0 is MUL) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $fmul_($sizenn(Fnn), fN_1, fN_2).
15. If ((binop__u0 is DIV) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $fdiv_($sizenn(Fnn), fN_1, fN_2).
16. If ((binop__u0 is MIN) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $fmin_($sizenn(Fnn), fN_1, fN_2).
17. If ((binop__u0 is MAX) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $fmax_($sizenn(Fnn), fN_1, fN_2).
18. Assert: Due to validation, (binop__u0 is COPYSIGN).
19. Assert: Due to validation, the type of numtype_u1 is Fnn.
20. Let Fnn be numtype_u1.
21. Let fN_1 be num__u3.
22. Let fN_2 be num__u5.
23. Return $fcopysign_($sizenn(Fnn), fN_1, fN_2).

testop_ Inn EQZ iN
1. Return $ieqz_($sizenn(Inn), iN).

relop_ numtype_u1 relop__u0 num__u3 num__u5
1. If ((relop__u0 is EQ) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return $ieq_($sizenn(Inn), iN_1, iN_2).
2. If ((relop__u0 is NE) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return $ine_($sizenn(Inn), iN_1, iN_2).
3. If the type of numtype_u1 is Inn, then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. If relop__u0 is of the case LT, then:
    1) Let (LT sx) be relop__u0.
    2) Return $ilt_($sizenn(Inn), sx, iN_1, iN_2).
  e. If relop__u0 is of the case GT, then:
    1) Let (GT sx) be relop__u0.
    2) Return $igt_($sizenn(Inn), sx, iN_1, iN_2).
  f. If relop__u0 is of the case LE, then:
    1) Let (LE sx) be relop__u0.
    2) Return $ile_($sizenn(Inn), sx, iN_1, iN_2).
  g. If relop__u0 is of the case GE, then:
    1) Let (GE sx) be relop__u0.
    2) Return $ige_($sizenn(Inn), sx, iN_1, iN_2).
4. If ((relop__u0 is EQ) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $feq_($sizenn(Fnn), fN_1, fN_2).
5. If ((relop__u0 is NE) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $fne_($sizenn(Fnn), fN_1, fN_2).
6. If ((relop__u0 is LT) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $flt_($sizenn(Fnn), fN_1, fN_2).
7. If ((relop__u0 is GT) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $fgt_($sizenn(Fnn), fN_1, fN_2).
8. If ((relop__u0 is LE) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $fle_($sizenn(Fnn), fN_1, fN_2).
9. Assert: Due to validation, (relop__u0 is GE).
10. Assert: Due to validation, the type of numtype_u1 is Fnn.
11. Let Fnn be numtype_u1.
12. Let fN_1 be num__u3.
13. Let fN_2 be num__u5.
14. Return $fge_($sizenn(Fnn), fN_1, fN_2).

cvtop__ numtype_u1 numtype_u4 cvtop_u0 num__u3
1. If the type of numtype_u1 is Inn, then:
  a. Let Inn_1 be numtype_u1.
  b. If the type of numtype_u4 is Inn, then:
    1) Let Inn_2 be numtype_u4.
    2) Let iN_1 be num__u3.
    3) If cvtop_u0 is of the case EXTEND, then:
      a) Let (EXTEND sx) be cvtop_u0.
      b) Return [$extend__($sizenn1(Inn_1), $sizenn2(Inn_2), sx, iN_1)].
2. If ((cvtop_u0 is WRAP) and the type of numtype_u1 is Inn), then:
  a. Let Inn_1 be numtype_u1.
  b. If the type of numtype_u4 is Inn, then:
    1) Let Inn_2 be numtype_u4.
    2) Let iN_1 be num__u3.
    3) Return [$wrap__($sizenn1(Inn_1), $sizenn2(Inn_2), iN_1)].
3. If the type of numtype_u1 is Fnn, then:
  a. Let Fnn_1 be numtype_u1.
  b. If the type of numtype_u4 is Inn, then:
    1) Let Inn_2 be numtype_u4.
    2) Let fN_1 be num__u3.
    3) If cvtop_u0 is of the case TRUNC, then:
      a) Let (TRUNC sx) be cvtop_u0.
      b) Return $list_(num_((Inn_2 : Inn <: numtype)), $trunc__($sizenn1(Fnn_1), $sizenn2(Inn_2), sx, fN_1)).
    4) If cvtop_u0 is of the case TRUNC_SAT, then:
      a) Let (TRUNC_SAT sx) be cvtop_u0.
      b) Return $list_(num_((Inn_2 : Inn <: numtype)), $trunc_sat__($sizenn1(Fnn_1), $sizenn2(Inn_2), sx, fN_1)).
4. If the type of numtype_u4 is Fnn, then:
  a. Let Fnn_2 be numtype_u4.
  b. If the type of numtype_u1 is Inn, then:
    1) Let Inn_1 be numtype_u1.
    2) Let iN_1 be num__u3.
    3) If cvtop_u0 is of the case CONVERT, then:
      a) Let (CONVERT sx) be cvtop_u0.
      b) Return [$convert__($sizenn1(Inn_1), $sizenn2(Fnn_2), sx, iN_1)].
5. If ((cvtop_u0 is PROMOTE) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn_1 be numtype_u1.
  b. If the type of numtype_u4 is Fnn, then:
    1) Let Fnn_2 be numtype_u4.
    2) Let fN_1 be num__u3.
    3) Return $promote__($sizenn1(Fnn_1), $sizenn2(Fnn_2), fN_1).
6. If ((cvtop_u0 is DEMOTE) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn_1 be numtype_u1.
  b. If the type of numtype_u4 is Fnn, then:
    1) Let Fnn_2 be numtype_u4.
    2) Let fN_1 be num__u3.
    3) Return $demote__($sizenn1(Fnn_1), $sizenn2(Fnn_2), fN_1).
7. Assert: Due to validation, (cvtop_u0 is REINTERPRET).
8. If the type of numtype_u4 is Fnn, then:
  a. Let Fnn_2 be numtype_u4.
  b. If the type of numtype_u1 is Inn, then:
    1) Let Inn_1 be numtype_u1.
    2) Let iN_1 be num__u3.
    3) If ($size(Inn_1) is $size(Fnn_2)), then:
      a) Return [$reinterpret__(Inn_1, Fnn_2, iN_1)].
9. Assert: Due to validation, the type of numtype_u1 is Fnn.
10. Let Fnn_1 be numtype_u1.
11. Assert: Due to validation, the type of numtype_u4 is Inn.
12. Let Inn_2 be numtype_u4.
13. Let fN_1 be num__u3.
14. Assert: Due to validation, ($size(Fnn_1) is $size(Inn_2)).
15. Return [$reinterpret__(Fnn_1, Inn_2, fN_1)].

invibytes_ N b*
1. Let n be $ibytes__1^-1(N, b*).
2. Return n.

invfbytes_ N b*
1. Let p be $fbytes__1^-1(N, b*).
2. Return p.

packnum_ lanetype_u0 c
1. If the type of lanetype_u0 is numtype, then:
  a. Return c.
2. Assert: Due to validation, the type of lanetype_u0 is packtype.
3. Let packtype be lanetype_u0.
4. Return $wrap__($size($unpack(packtype)), $psize(packtype), c).

unpacknum_ lanetype_u0 c
1. If the type of lanetype_u0 is numtype, then:
  a. Return c.
2. Assert: Due to validation, the type of lanetype_u0 is packtype.
3. Let packtype be lanetype_u0.
4. Return $extend__($psize(packtype), $size($unpack(packtype)), U, c).

invlanes_ sh c*
1. Let vc be $lanes__1^-1(sh, c*).
2. Return vc.

half half_u0 i j
1. If (half_u0 is LOW), then:
  a. Return i.
2. Assert: Due to validation, (half_u0 is HIGH).
3. Return j.

vvunop_ V128 NOT v128
1. Return $inot_($size(V128), v128).

vvbinop_ V128 vvbinop_u0 v128_1 v128_2
1. If (vvbinop_u0 is AND), then:
  a. Return $iand_($size(V128), v128_1, v128_2).
2. If (vvbinop_u0 is ANDNOT), then:
  a. Return $iandnot_($size(V128), v128_1, v128_2).
3. If (vvbinop_u0 is OR), then:
  a. Return $ior_($size(V128), v128_1, v128_2).
4. Assert: Due to validation, (vvbinop_u0 is XOR).
5. Return $ixor_($size(V128), v128_1, v128_2).

vvternop_ V128 BITSELECT v128_1 v128_2 v128_3
1. Return $ibitselect_($size(V128), v128_1, v128_2, v128_3).

vunop_ lanetype_u1 X M vunop__u0 v128_1
1. If ((vunop__u0 is ABS) and the type of lanetype_u1 is Jnn), then:
  a. Let Jnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Jnn X M, v128_1).
  c. Let v128 be $invlanes_(Jnn X M, $iabs_($lsizenn(Jnn), lane_1)*).
  d. Return [v128].
2. If ((vunop__u0 is NEG) and the type of lanetype_u1 is Jnn), then:
  a. Let Jnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Jnn X M, v128_1).
  c. Let v128 be $invlanes_(Jnn X M, $ineg_($lsizenn(Jnn), lane_1)*).
  d. Return [v128].
3. If ((vunop__u0 is POPCNT) and the type of lanetype_u1 is Jnn), then:
  a. Let Jnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Jnn X M, v128_1).
  c. Let v128 be $invlanes_(Jnn X M, $ipopcnt_($lsizenn(Jnn), lane_1)*).
  d. Return [v128].
4. If ((vunop__u0 is ABS) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Fnn X M, v128_1).
  c. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fabs_($sizenn(Fnn), lane_1)*).
  d. Let v128* be $invlanes_(Fnn X M, lane*)*.
  e. Return v128*.
5. If ((vunop__u0 is NEG) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Fnn X M, v128_1).
  c. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fneg_($sizenn(Fnn), lane_1)*).
  d. Let v128* be $invlanes_(Fnn X M, lane*)*.
  e. Return v128*.
6. If ((vunop__u0 is SQRT) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Fnn X M, v128_1).
  c. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fsqrt_($sizenn(Fnn), lane_1)*).
  d. Let v128* be $invlanes_(Fnn X M, lane*)*.
  e. Return v128*.
7. If ((vunop__u0 is CEIL) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Fnn X M, v128_1).
  c. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fceil_($sizenn(Fnn), lane_1)*).
  d. Let v128* be $invlanes_(Fnn X M, lane*)*.
  e. Return v128*.
8. If ((vunop__u0 is FLOOR) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Fnn X M, v128_1).
  c. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $ffloor_($sizenn(Fnn), lane_1)*).
  d. Let v128* be $invlanes_(Fnn X M, lane*)*.
  e. Return v128*.
9. If ((vunop__u0 is TRUNC) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Fnn X M, v128_1).
  c. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $ftrunc_($sizenn(Fnn), lane_1)*).
  d. Let v128* be $invlanes_(Fnn X M, lane*)*.
  e. Return v128*.
10. Assert: Due to validation, (vunop__u0 is NEAREST).
11. Assert: Due to validation, the type of lanetype_u1 is Fnn.
12. Let Fnn be lanetype_u1.
13. Let lane_1* be $lanes_(Fnn X M, v128_1).
14. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fnearest_($sizenn(Fnn), lane_1)*).
15. Let v128* be $invlanes_(Fnn X M, lane*)*.
16. Return v128*.

vbinop_ lanetype_u1 X M vbinop__u0 v128_1 v128_2
1. If ((vbinop__u0 is ADD) and the type of lanetype_u1 is Jnn), then:
  a. Let Jnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Jnn X M, v128_1).
  c. Let lane_2* be $lanes_(Jnn X M, v128_2).
  d. Let v128 be $invlanes_(Jnn X M, $iadd_($lsizenn(Jnn), lane_1, lane_2)*).
  e. Return [v128].
2. If ((vbinop__u0 is SUB) and the type of lanetype_u1 is Jnn), then:
  a. Let Jnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Jnn X M, v128_1).
  c. Let lane_2* be $lanes_(Jnn X M, v128_2).
  d. Let v128 be $invlanes_(Jnn X M, $isub_($lsizenn(Jnn), lane_1, lane_2)*).
  e. Return [v128].
3. If the type of lanetype_u1 is Jnn, then:
  a. Let Jnn be lanetype_u1.
  b. If vbinop__u0 is of the case MIN, then:
    1) Let (MIN sx) be vbinop__u0.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let v128 be $invlanes_(Jnn X M, $imin_($lsizenn(Jnn), sx, lane_1, lane_2)*).
    5) Return [v128].
  c. If vbinop__u0 is of the case MAX, then:
    1) Let (MAX sx) be vbinop__u0.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let v128 be $invlanes_(Jnn X M, $imax_($lsizenn(Jnn), sx, lane_1, lane_2)*).
    5) Return [v128].
  d. If vbinop__u0 is of the case ADD_SAT, then:
    1) Let (ADD_SAT sx) be vbinop__u0.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let v128 be $invlanes_(Jnn X M, $iadd_sat_($lsizenn(Jnn), sx, lane_1, lane_2)*).
    5) Return [v128].
  e. If vbinop__u0 is of the case SUB_SAT, then:
    1) Let (SUB_SAT sx) be vbinop__u0.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let v128 be $invlanes_(Jnn X M, $isub_sat_($lsizenn(Jnn), sx, lane_1, lane_2)*).
    5) Return [v128].
4. If ((vbinop__u0 is MUL) and the type of lanetype_u1 is Jnn), then:
  a. Let Jnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Jnn X M, v128_1).
  c. Let lane_2* be $lanes_(Jnn X M, v128_2).
  d. Let v128 be $invlanes_(Jnn X M, $imul_($lsizenn(Jnn), lane_1, lane_2)*).
  e. Return [v128].
5. If ((vbinop__u0 is AVGRU) and the type of lanetype_u1 is Jnn), then:
  a. Let Jnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Jnn X M, v128_1).
  c. Let lane_2* be $lanes_(Jnn X M, v128_2).
  d. Let v128 be $invlanes_(Jnn X M, $iavgr_($lsizenn(Jnn), U, lane_1, lane_2)*).
  e. Return [v128].
6. If ((vbinop__u0 is Q15MULR_SATS) and the type of lanetype_u1 is Jnn), then:
  a. Let Jnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Jnn X M, v128_1).
  c. Let lane_2* be $lanes_(Jnn X M, v128_2).
  d. Let v128 be $invlanes_(Jnn X M, $iq15mulr_sat_($lsizenn(Jnn), S, lane_1, lane_2)*).
  e. Return [v128].
7. If ((vbinop__u0 is ADD) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Fnn X M, v128_1).
  c. Let lane_2* be $lanes_(Fnn X M, v128_2).
  d. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fadd_($sizenn(Fnn), lane_1, lane_2)*).
  e. Let v128* be $invlanes_(Fnn X M, lane*)*.
  f. Return v128*.
8. If ((vbinop__u0 is SUB) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Fnn X M, v128_1).
  c. Let lane_2* be $lanes_(Fnn X M, v128_2).
  d. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fsub_($sizenn(Fnn), lane_1, lane_2)*).
  e. Let v128* be $invlanes_(Fnn X M, lane*)*.
  f. Return v128*.
9. If ((vbinop__u0 is MUL) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Fnn X M, v128_1).
  c. Let lane_2* be $lanes_(Fnn X M, v128_2).
  d. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fmul_($sizenn(Fnn), lane_1, lane_2)*).
  e. Let v128* be $invlanes_(Fnn X M, lane*)*.
  f. Return v128*.
10. If ((vbinop__u0 is DIV) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Fnn X M, v128_1).
  c. Let lane_2* be $lanes_(Fnn X M, v128_2).
  d. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fdiv_($sizenn(Fnn), lane_1, lane_2)*).
  e. Let v128* be $invlanes_(Fnn X M, lane*)*.
  f. Return v128*.
11. If ((vbinop__u0 is MIN) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Fnn X M, v128_1).
  c. Let lane_2* be $lanes_(Fnn X M, v128_2).
  d. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fmin_($sizenn(Fnn), lane_1, lane_2)*).
  e. Let v128* be $invlanes_(Fnn X M, lane*)*.
  f. Return v128*.
12. If ((vbinop__u0 is MAX) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Fnn X M, v128_1).
  c. Let lane_2* be $lanes_(Fnn X M, v128_2).
  d. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fmax_($sizenn(Fnn), lane_1, lane_2)*).
  e. Let v128* be $invlanes_(Fnn X M, lane*)*.
  f. Return v128*.
13. If ((vbinop__u0 is PMIN) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Fnn X M, v128_1).
  c. Let lane_2* be $lanes_(Fnn X M, v128_2).
  d. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fpmin_($sizenn(Fnn), lane_1, lane_2)*).
  e. Let v128* be $invlanes_(Fnn X M, lane*)*.
  f. Return v128*.
14. Assert: Due to validation, (vbinop__u0 is PMAX).
15. Assert: Due to validation, the type of lanetype_u1 is Fnn.
16. Let Fnn be lanetype_u1.
17. Let lane_1* be $lanes_(Fnn X M, v128_1).
18. Let lane_2* be $lanes_(Fnn X M, v128_2).
19. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fpmax_($sizenn(Fnn), lane_1, lane_2)*).
20. Let v128* be $invlanes_(Fnn X M, lane*)*.
21. Return v128*.

vrelop_ lanetype_u1 X M vrelop__u0 v128_1 v128_2
1. If ((vrelop__u0 is EQ) and the type of lanetype_u1 is Jnn), then:
  a. Let Jnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Jnn X M, v128_1).
  c. Let lane_2* be $lanes_(Jnn X M, v128_2).
  d. Let lane_3* be $extend__(1, $lsizenn(Jnn), S, $ieq_($lsizenn(Jnn), lane_1, lane_2))*.
  e. Let v128 be $invlanes_(Jnn X M, lane_3*).
  f. Return v128.
2. If ((vrelop__u0 is NE) and the type of lanetype_u1 is Jnn), then:
  a. Let Jnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Jnn X M, v128_1).
  c. Let lane_2* be $lanes_(Jnn X M, v128_2).
  d. Let lane_3* be $extend__(1, $lsizenn(Jnn), S, $ine_($lsizenn(Jnn), lane_1, lane_2))*.
  e. Let v128 be $invlanes_(Jnn X M, lane_3*).
  f. Return v128.
3. If the type of lanetype_u1 is Jnn, then:
  a. Let Jnn be lanetype_u1.
  b. If vrelop__u0 is of the case LT, then:
    1) Let (LT sx) be vrelop__u0.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let lane_3* be $extend__(1, $lsizenn(Jnn), S, $ilt_($lsizenn(Jnn), sx, lane_1, lane_2))*.
    5) Let v128 be $invlanes_(Jnn X M, lane_3*).
    6) Return v128.
  c. If vrelop__u0 is of the case GT, then:
    1) Let (GT sx) be vrelop__u0.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let lane_3* be $extend__(1, $lsizenn(Jnn), S, $igt_($lsizenn(Jnn), sx, lane_1, lane_2))*.
    5) Let v128 be $invlanes_(Jnn X M, lane_3*).
    6) Return v128.
  d. If vrelop__u0 is of the case LE, then:
    1) Let (LE sx) be vrelop__u0.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let lane_3* be $extend__(1, $lsizenn(Jnn), S, $ile_($lsizenn(Jnn), sx, lane_1, lane_2))*.
    5) Let v128 be $invlanes_(Jnn X M, lane_3*).
    6) Return v128.
  e. If vrelop__u0 is of the case GE, then:
    1) Let (GE sx) be vrelop__u0.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let lane_3* be $extend__(1, $lsizenn(Jnn), S, $ige_($lsizenn(Jnn), sx, lane_1, lane_2))*.
    5) Let v128 be $invlanes_(Jnn X M, lane_3*).
    6) Return v128.
4. If ((vrelop__u0 is EQ) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Fnn X M, v128_1).
  c. Let lane_2* be $lanes_(Fnn X M, v128_2).
  d. Let Inn be $isize^-1($size(Fnn)).
  e. Let lane_3* be $extend__(1, $sizenn(Fnn), S, $feq_($sizenn(Fnn), lane_1, lane_2))*.
  f. Let v128 be $invlanes_(Inn X M, lane_3*).
  g. Return v128.
5. If ((vrelop__u0 is NE) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Fnn X M, v128_1).
  c. Let lane_2* be $lanes_(Fnn X M, v128_2).
  d. Let Inn be $isize^-1($size(Fnn)).
  e. Let lane_3* be $extend__(1, $sizenn(Fnn), S, $fne_($sizenn(Fnn), lane_1, lane_2))*.
  f. Let v128 be $invlanes_(Inn X M, lane_3*).
  g. Return v128.
6. If ((vrelop__u0 is LT) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Fnn X M, v128_1).
  c. Let lane_2* be $lanes_(Fnn X M, v128_2).
  d. Let Inn be $isize^-1($size(Fnn)).
  e. Let lane_3* be $extend__(1, $sizenn(Fnn), S, $flt_($sizenn(Fnn), lane_1, lane_2))*.
  f. Let v128 be $invlanes_(Inn X M, lane_3*).
  g. Return v128.
7. If ((vrelop__u0 is GT) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Fnn X M, v128_1).
  c. Let lane_2* be $lanes_(Fnn X M, v128_2).
  d. Let Inn be $isize^-1($size(Fnn)).
  e. Let lane_3* be $extend__(1, $sizenn(Fnn), S, $fgt_($sizenn(Fnn), lane_1, lane_2))*.
  f. Let v128 be $invlanes_(Inn X M, lane_3*).
  g. Return v128.
8. If ((vrelop__u0 is LE) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Let lane_1* be $lanes_(Fnn X M, v128_1).
  c. Let lane_2* be $lanes_(Fnn X M, v128_2).
  d. Let Inn be $isize^-1($size(Fnn)).
  e. Let lane_3* be $extend__(1, $sizenn(Fnn), S, $fle_($sizenn(Fnn), lane_1, lane_2))*.
  f. Let v128 be $invlanes_(Inn X M, lane_3*).
  g. Return v128.
9. Assert: Due to validation, (vrelop__u0 is GE).
10. Assert: Due to validation, the type of lanetype_u1 is Fnn.
11. Let Fnn be lanetype_u1.
12. Let lane_1* be $lanes_(Fnn X M, v128_1).
13. Let lane_2* be $lanes_(Fnn X M, v128_2).
14. Let Inn be $isize^-1($size(Fnn)).
15. Let lane_3* be $extend__(1, $sizenn(Fnn), S, $fge_($sizenn(Fnn), lane_1, lane_2))*.
16. Let v128 be $invlanes_(Inn X M, lane_3*).
17. Return v128.

vcvtop__ lanetype_u2 X M_1 lanetype_u0 X M_2 vcvtop_u1 lane__u4
1. If the type of lanetype_u2 is Jnn, then:
  a. Let Jnn_1 be lanetype_u2.
  b. If the type of lanetype_u0 is Jnn, then:
    1) Let Jnn_2 be lanetype_u0.
    2) Let iN_1 be lane__u4.
    3) If vcvtop_u1 is of the case EXTEND, then:
      a) Let (EXTEND sx) be vcvtop_u1.
      b) Let iN_2 be $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), sx, iN_1).
      c) Return [iN_2].
2. If the type of lanetype_u0 is Fnn, then:
  a. Let Fnn_2 be lanetype_u0.
  b. If the type of lanetype_u2 is Jnn, then:
    1) Let Jnn_1 be lanetype_u2.
    2) Let iN_1 be lane__u4.
    3) If vcvtop_u1 is of the case CONVERT, then:
      a) Let (CONVERT sx) be vcvtop_u1.
      b) Let fN_2 be $convert__($lsizenn1(Jnn_1), $lsizenn2(Fnn_2), sx, iN_1).
      c) Return [fN_2].
3. If the type of lanetype_u2 is Fnn, then:
  a. Let Fnn_1 be lanetype_u2.
  b. If the type of lanetype_u0 is Inn, then:
    1) Let Inn_2 be lanetype_u0.
    2) Let fN_1 be lane__u4.
    3) If vcvtop_u1 is of the case TRUNC_SAT, then:
      a) Let (TRUNC_SAT sx) be vcvtop_u1.
      b) Let iN_2? be $trunc_sat__($lsizenn1(Fnn_1), $lsizenn2(Inn_2), sx, fN_1).
      c) Return $list_(lane_((Inn_2 : Inn <: lanetype)), iN_2?).
4. If ((vcvtop_u1 is DEMOTE) and the type of lanetype_u2 is Fnn), then:
  a. Let Fnn_1 be lanetype_u2.
  b. If the type of lanetype_u0 is Fnn, then:
    1) Let Fnn_2 be lanetype_u0.
    2) Let fN_1 be lane__u4.
    3) Let fN_2* be $demote__($lsizenn1(Fnn_1), $lsizenn2(Fnn_2), fN_1).
    4) Return fN_2*.
5. Assert: Due to validation, (vcvtop_u1 is PROMOTE).
6. Assert: Due to validation, the type of lanetype_u2 is Fnn.
7. Let Fnn_1 be lanetype_u2.
8. Assert: Due to validation, the type of lanetype_u0 is Fnn.
9. Let Fnn_2 be lanetype_u0.
10. Let fN_1 be lane__u4.
11. Let fN_2* be $promote__($lsizenn1(Fnn_1), $lsizenn2(Fnn_2), fN_1).
12. Return fN_2*.

vextunop__ Inn_1 X M_1 Inn_2 X M_2 (EXTADD_PAIRWISE sx) c_1
1. Let ci* be $lanes_(Inn_2 X M_2, c_1).
2. Let [cj_1, cj_2]* be $concat__1^-1(iN($lsizenn1((Inn_1 : Inn <: lanetype))), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), sx, ci)*).
3. Let c be $invlanes_(Inn_1 X M_1, $iadd_($lsizenn1(Inn_1), cj_1, cj_2)*).
4. Return c.

vextbinop__ Inn_1 X M_1 Inn_2 X M_2 vextbinop__u0 c_1 c_2
1. If vextbinop__u0 is of the case EXTMUL, then:
  a. Let (EXTMUL sx hf) be vextbinop__u0.
  b. Let ci_1* be $lanes_(Inn_2 X M_2, c_1)[$half(hf, 0, M_1) : M_1].
  c. Let ci_2* be $lanes_(Inn_2 X M_2, c_2)[$half(hf, 0, M_1) : M_1].
  d. Let c be $invlanes_(Inn_1 X M_1, $imul_($lsizenn1(Inn_1), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), sx, ci_1), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), sx, ci_2))*).
  e. Return c.
2. Assert: Due to validation, (vextbinop__u0 is DOTS).
3. Let ci_1* be $lanes_(Inn_2 X M_2, c_1).
4. Let ci_2* be $lanes_(Inn_2 X M_2, c_2).
5. Let [cj_1, cj_2]* be $concat__1^-1(iN($lsizenn1((Inn_1 : Inn <: lanetype))), $imul_($lsizenn1(Inn_1), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), S, ci_1), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), S, ci_2))*).
6. Let c be $invlanes_(Inn_1 X M_1, $iadd_($lsizenn1(Inn_1), cj_1, cj_2)*).
7. Return c.

vshiftop_ Jnn X M vshiftop__u0 lane n
1. If (vshiftop__u0 is SHL), then:
  a. Return $ishl_($lsizenn(Jnn), lane, n).
2. Assert: Due to validation, vshiftop__u0 is of the case SHR.
3. Let (SHR sx) be vshiftop__u0.
4. Return $ishr_($lsizenn(Jnn), sx, lane, n).

default_ valtype_u0
1. If (valtype_u0 is I32), then:
  a. Return (I32.CONST 0).
2. If (valtype_u0 is I64), then:
  a. Return (I64.CONST 0).
3. If (valtype_u0 is F32), then:
  a. Return (F32.CONST $fzero(32)).
4. If (valtype_u0 is F64), then:
  a. Return (F64.CONST $fzero(64)).
5. If (valtype_u0 is V128), then:
  a. Return (V128.CONST 0).
6. If (valtype_u0 is FUNCREF), then:
  a. Return (REF.NULL FUNCREF).
7. Assert: Due to validation, (valtype_u0 is EXTERNREF).
8. Return (REF.NULL EXTERNREF).

funcsxa externaddr_u0*
1. If (externaddr_u0* is []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr_u0*.
3. If externaddr_0 is of the case FUNC, then:
  a. Let (FUNC fa) be externaddr_0.
  b. Return [fa] :: $funcsxa(xv*).
4. Let [externaddr] :: xv* be externaddr_u0*.
5. Return $funcsxa(xv*).

globalsxa externaddr_u0*
1. If (externaddr_u0* is []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr_u0*.
3. If externaddr_0 is of the case GLOBAL, then:
  a. Let (GLOBAL ga) be externaddr_0.
  b. Return [ga] :: $globalsxa(xv*).
4. Let [externaddr] :: xv* be externaddr_u0*.
5. Return $globalsxa(xv*).

tablesxa externaddr_u0*
1. If (externaddr_u0* is []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr_u0*.
3. If externaddr_0 is of the case TABLE, then:
  a. Let (TABLE ta) be externaddr_0.
  b. Return [ta] :: $tablesxa(xv*).
4. Let [externaddr] :: xv* be externaddr_u0*.
5. Return $tablesxa(xv*).

memsxa externaddr_u0*
1. If (externaddr_u0* is []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be externaddr_u0*.
3. If externaddr_0 is of the case MEM, then:
  a. Let (MEM ma) be externaddr_0.
  b. Return [ma] :: $memsxa(xv*).
4. Let [externaddr] :: xv* be externaddr_u0*.
5. Return $memsxa(xv*).

store
1. Return.

frame
1. Let f be the current frame.
2. Return f.

funcaddr
1. Let f be the current frame.
2. Return f.MODULE.FUNCS.

funcinst
1. Return s.FUNCS.

globalinst
1. Return s.GLOBALS.

tableinst
1. Return s.TABLES.

meminst
1. Return s.MEMS.

eleminst
1. Return s.ELEMS.

datainst
1. Return s.DATAS.

moduleinst
1. Let f be the current frame.
2. Return f.MODULE.

type x
1. Let f be the current frame.
2. Return f.MODULE.TYPES[x].

func x
1. Let f be the current frame.
2. Return s.FUNCS[f.MODULE.FUNCS[x]].

global x
1. Let f be the current frame.
2. Return s.GLOBALS[f.MODULE.GLOBALS[x]].

table x
1. Let f be the current frame.
2. Return s.TABLES[f.MODULE.TABLES[x]].

mem x
1. Let f be the current frame.
2. Return s.MEMS[f.MODULE.MEMS[x]].

elem x
1. Let f be the current frame.
2. Return s.ELEMS[f.MODULE.ELEMS[x]].

data x
1. Let f be the current frame.
2. Return s.DATAS[f.MODULE.DATAS[x]].

local x
1. Let f be the current frame.
2. Return f.LOCALS[x].

with_local x v
1. Let f be the current frame.
2. Replace f.LOCALS[x] with v.

with_global x v
1. Let f be the current frame.
2. Replace s.GLOBALS[f.MODULE.GLOBALS[x]].VALUE with v.

with_table x i r
1. Let f be the current frame.
2. Replace s.TABLES[f.MODULE.TABLES[x]].REFS[i] with r.

with_tableinst x ti
1. Let f be the current frame.
2. Replace s.TABLES[f.MODULE.TABLES[x]] with ti.

with_mem x i j b*
1. Let f be the current frame.
2. Replace s.MEMS[f.MODULE.MEMS[x]].BYTES[i : j] with b*.

with_meminst x mi
1. Let f be the current frame.
2. Replace s.MEMS[f.MODULE.MEMS[x]] with mi.

with_elem x r*
1. Let f be the current frame.
2. Replace s.ELEMS[f.MODULE.ELEMS[x]].REFS with r*.

with_data x b*
1. Let f be the current frame.
2. Replace s.DATAS[f.MODULE.DATAS[x]].BYTES with b*.

growtable ti n r
1. Let { TYPE: ((i, j) rt); REFS: r'*; } be ti.
2. Let i' be (|r'*| + n).
3. If (i' ≤ j), then:
  a. Let ti' be { TYPE: ((i', j) rt); REFS: r'* :: r^n; }.
  b. Return ti'.

growmemory mi n
1. Let { TYPE: (i, j) PAGE; BYTES: b*; } be mi.
2. Let i' be ((|b*| / (64 · $Ki())) + n).
3. If (i' ≤ j), then:
  a. Let mi' be { TYPE: (i', j) PAGE; BYTES: b* :: 0^(n · (64 · $Ki())); }.
  b. Return mi'.

blocktype z blocktype_u1
1. If (blocktype_u1 is (_RESULT ?())), then:
  a. Return [] -> [].
2. If blocktype_u1 is of the case _RESULT, then:
  a. Let (_RESULT valtype_0) be blocktype_u1.
  b. If valtype_0 is defined, then:
    1) Let ?(t) be valtype_0.
    2) Return [] -> [t].
3. Assert: Due to validation, blocktype_u1 is of the case _IDX.
4. Let (_IDX x) be blocktype_u1.
5. Return $type(z, x).

funcs externaddr_u0*
1. If (externaddr_u0* is []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr_u0*.
3. If externaddr_0 is of the case FUNC, then:
  a. Let (FUNC fa) be externaddr_0.
  b. Return [fa] :: $funcs(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr_u0*.
5. Return $funcs(externaddr'*).

globals externaddr_u0*
1. If (externaddr_u0* is []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr_u0*.
3. If externaddr_0 is of the case GLOBAL, then:
  a. Let (GLOBAL ga) be externaddr_0.
  b. Return [ga] :: $globals(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr_u0*.
5. Return $globals(externaddr'*).

tables externaddr_u0*
1. If (externaddr_u0* is []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr_u0*.
3. If externaddr_0 is of the case TABLE, then:
  a. Let (TABLE ta) be externaddr_0.
  b. Return [ta] :: $tables(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr_u0*.
5. Return $tables(externaddr'*).

mems externaddr_u0*
1. If (externaddr_u0* is []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be externaddr_u0*.
3. If externaddr_0 is of the case MEM, then:
  a. Let (MEM ma) be externaddr_0.
  b. Return [ma] :: $mems(externaddr'*).
4. Let [externaddr] :: externaddr'* be externaddr_u0*.
5. Return $mems(externaddr'*).

allocfunc moduleinst func
1. Assert: Due to validation, func is of the case FUNC.
2. Let (FUNC x local* expr) be func.
3. Let fi be { TYPE: moduleinst.TYPES[x]; MODULE: moduleinst; CODE: func; }.
4. Let a be |s.FUNCS|.
5. Append fi to the s.FUNCS.
6. Return a.

allocfuncs moduleinst func_u0*
1. If (func_u0* is []), then:
  a. Return [].
2. Let [func] :: func'* be func_u0*.
3. Let fa be $allocfunc(moduleinst, func).
4. Let fa'* be $allocfuncs(moduleinst, func'*).
5. Return [fa] :: fa'*.

allocglobal globaltype val
1. Let gi be { TYPE: globaltype; VALUE: val; }.
2. Let a be |s.GLOBALS|.
3. Append gi to the s.GLOBALS.
4. Return a.

allocglobals globaltype_u0* val_u1*
1. If (globaltype_u0* is []), then:
  a. Assert: Due to validation, (val_u1* is []).
  b. Return [].
2. Else:
  a. Let [globaltype] :: globaltype'* be globaltype_u0*.
  b. Assert: Due to validation, (|val_u1*| ≥ 1).
  c. Let [val] :: val'* be val_u1*.
  d. Let ga be $allocglobal(globaltype, val).
  e. Let ga'* be $allocglobals(globaltype'*, val'*).
  f. Return [ga] :: ga'*.

alloctable ((i, j) rt)
1. Let ti be { TYPE: ((i, j) rt); REFS: (REF.NULL rt)^i; }.
2. Let a be |s.TABLES|.
3. Append ti to the s.TABLES.
4. Return a.

alloctables tabletype_u0*
1. If (tabletype_u0* is []), then:
  a. Return [].
2. Let [tabletype] :: tabletype'* be tabletype_u0*.
3. Let ta be $alloctable(tabletype).
4. Let ta'* be $alloctables(tabletype'*).
5. Return [ta] :: ta'*.

allocmem (i, j) PAGE
1. Let mi be { TYPE: (i, j) PAGE; BYTES: 0^(i · (64 · $Ki())); }.
2. Let a be |s.MEMS|.
3. Append mi to the s.MEMS.
4. Return a.

allocmems memtype_u0*
1. If (memtype_u0* is []), then:
  a. Return [].
2. Let [memtype] :: memtype'* be memtype_u0*.
3. Let ma be $allocmem(memtype).
4. Let ma'* be $allocmems(memtype'*).
5. Return [ma] :: ma'*.

allocelem rt ref*
1. Let ei be { TYPE: rt; REFS: ref*; }.
2. Let a be |s.ELEMS|.
3. Append ei to the s.ELEMS.
4. Return a.

allocelems reftype_u0* ref_u1*
1. If ((reftype_u0* is []) and (ref_u1* is [])), then:
  a. Return [].
2. Assert: Due to validation, (|ref_u1*| ≥ 1).
3. Let [ref*] :: ref'** be ref_u1*.
4. Assert: Due to validation, (|reftype_u0*| ≥ 1).
5. Let [rt] :: rt'* be reftype_u0*.
6. Let ea be $allocelem(rt, ref*).
7. Let ea'* be $allocelems(rt'*, ref'**).
8. Return [ea] :: ea'*.

allocdata byte*
1. Let di be { BYTES: byte*; }.
2. Let a be |s.DATAS|.
3. Append di to the s.DATAS.
4. Return a.

allocdatas byte_u0*
1. If (byte_u0* is []), then:
  a. Return [].
2. Let [byte*] :: byte'** be byte_u0*.
3. Let da be $allocdata(byte*).
4. Let da'* be $allocdatas(byte'**).
5. Return [da] :: da'*.

instexport fa* ga* ta* ma* (EXPORT name externidx_u0)
1. If externidx_u0 is of the case FUNC, then:
  a. Let (FUNC x) be externidx_u0.
  b. Return { NAME: name; ADDR: (FUNC fa*[x]); }.
2. If externidx_u0 is of the case GLOBAL, then:
  a. Let (GLOBAL x) be externidx_u0.
  b. Return { NAME: name; ADDR: (GLOBAL ga*[x]); }.
3. If externidx_u0 is of the case TABLE, then:
  a. Let (TABLE x) be externidx_u0.
  b. Return { NAME: name; ADDR: (TABLE ta*[x]); }.
4. Assert: Due to validation, externidx_u0 is of the case MEM.
5. Let (MEM x) be externidx_u0.
6. Return { NAME: name; ADDR: (MEM ma*[x]); }.

allocmodule module externaddr* val* ref**
1. Let fa_ex* be $funcs(externaddr*).
2. Let ga_ex* be $globals(externaddr*).
3. Let ma_ex* be $mems(externaddr*).
4. Let ta_ex* be $tables(externaddr*).
5. Assert: Due to validation, module is of the case MODULE.
6. Let (MODULE type_0* import* func^n_func global_1^n_global table_2^n_table mem_3^n_mem elem_4^n_elem data_5^n_data start? export*) be module.
7. Assert: Due to validation, data_5 is of the case DATA^n_data.
8. Let (DATA byte* datamode)^n_data be data_5^n_data.
9. Assert: Due to validation, elem_4 is of the case ELEM^n_elem.
10. Let (ELEM rt expr_2* elemmode)^n_elem be elem_4^n_elem.
11. Assert: Due to validation, mem_3 is of the case MEMORY^n_mem.
12. Let (MEMORY memtype)^n_mem be mem_3^n_mem.
13. Assert: Due to validation, table_2 is of the case TABLE^n_table.
14. Let (TABLE tabletype)^n_table be table_2^n_table.
15. Assert: Due to validation, global_1 is of the case GLOBAL^n_global.
16. Let (GLOBAL globaltype expr_1)^n_global be global_1^n_global.
17. Assert: Due to validation, type_0 is of the case TYPE*.
18. Let (TYPE ft)* be type_0*.
19. Let fa* be (|s.FUNCS| + i_func)^(i_func<n_func).
20. Let ga* be (|s.GLOBALS| + i_global)^(i_global<n_global).
21. Let ta* be (|s.TABLES| + i_table)^(i_table<n_table).
22. Let ma* be (|s.MEMS| + i_mem)^(i_mem<n_mem).
23. Let ea* be (|s.ELEMS| + i_elem)^(i_elem<n_elem).
24. Let da* be (|s.DATAS| + i_data)^(i_data<n_data).
25. Let xi* be $instexport(fa_ex* :: fa*, ga_ex* :: ga*, ta_ex* :: ta*, ma_ex* :: ma*, export)*.
26. Let moduleinst be { TYPES: ft*; FUNCS: fa_ex* :: fa*; GLOBALS: ga_ex* :: ga*; TABLES: ta_ex* :: ta*; MEMS: ma_ex* :: ma*; ELEMS: ea*; DATAS: da*; EXPORTS: xi*; }.
27. Let funcaddr_0 be $allocfuncs(moduleinst, func^n_func).
28. Assert: Due to validation, (funcaddr_0 is fa*).
29. Let globaladdr_0 be $allocglobals(globaltype^n_global, val*).
30. Assert: Due to validation, (globaladdr_0 is ga*).
31. Let tableaddr_0 be $alloctables(tabletype^n_table).
32. Assert: Due to validation, (tableaddr_0 is ta*).
33. Let memaddr_0 be $allocmems(memtype^n_mem).
34. Assert: Due to validation, (memaddr_0 is ma*).
35. Let elemaddr_0 be $allocelems(rt^n_elem, ref**).
36. Assert: Due to validation, (elemaddr_0 is ea*).
37. Let dataaddr_0 be $allocdatas(byte*^n_data).
38. Assert: Due to validation, (dataaddr_0 is da*).
39. Return moduleinst.

runelem (ELEM reftype expr* elemmode_u0) i
1. If (elemmode_u0 is PASSIVE), then:
  a. Return [].
2. If (elemmode_u0 is DECLARE), then:
  a. Return [(ELEM.DROP i)].
3. Assert: Due to validation, elemmode_u0 is of the case ACTIVE.
4. Let (ACTIVE x instr*) be elemmode_u0.
5. Let n be |expr*|.
6. Return instr* :: [(I32.CONST 0), (I32.CONST n), (TABLE.INIT x i), (ELEM.DROP i)].

rundata (DATA byte* datamode_u0) i
1. If (datamode_u0 is PASSIVE), then:
  a. Return [].
2. Assert: Due to validation, datamode_u0 is of the case ACTIVE.
3. Let (ACTIVE n_0 instr*) be datamode_u0.
4. Assert: Due to validation, (n_0 is 0).
5. Let n be |byte*|.
6. Return instr* :: [(I32.CONST 0), (I32.CONST n), (MEMORY.INIT i), (DATA.DROP i)].

instantiate z module externaddr*
1. Assert: Due to validation, module is of the case MODULE.
2. Let (MODULE type* import* func* global* table* mem* elem* data* start? export*) be module.
3. Assert: Due to validation, type is of the case TYPE*.
4. Let (TYPE functype)* be type*.
5. Let n_D be |data*|.
6. Let n_E be |elem*|.
7. Let n_F be |func*|.
8. Assert: Due to validation, start is of the case START?.
9. Let (START x)? be start?.
10. Assert: Due to validation, global is of the case GLOBAL*.
11. Let (GLOBAL globaltype expr_G)* be global*.
12. Assert: Due to validation, elem is of the case ELEM*.
13. Let (ELEM reftype expr_E* elemmode)* be elem*.
14. Let instr_D* be $concat_(instr, $rundata(data*[j], j)^(j<n_D)).
15. Let instr_E* be $concat_(instr, $runelem(elem*[i], i)^(i<n_E)).
16. Let moduleinst_init be { TYPES: functype*; FUNCS: $funcs(externaddr*) :: (|s.FUNCS| + i_F)^(i_F<n_F); GLOBALS: $globals(externaddr*); TABLES: []; MEMS: []; ELEMS: []; DATAS: []; EXPORTS: []; }.
17. Let f_init be { LOCALS: []; MODULE: moduleinst_init; }.
18. Let z be f_init.
19. Push the activation of z to the stack.
20. Let [val]* be $eval_expr(expr_G)*.
21. Pop the activation of _f from the stack.
22. Push the activation of z to the stack.
23. Let [ref]** be $eval_expr(expr_E)**.
24. Pop the activation of _f from the stack.
25. Let moduleinst be $allocmodule(module, externaddr*, val*, ref**).
26. Let f be { LOCALS: []; MODULE: moduleinst; }.
27. Push the activation of f with arity 0 to the stack.
28. Execute the sequence (instr_E*).
29. Execute the sequence (instr_D*).
30. If (CALL x)? is defined, then:
  a. Execute the instruction (CALL x).
31. Pop the activation of f with arity 0 from the stack.
32. Return f.MODULE.

invoke z fa val^n
1. Let f be { LOCALS: []; MODULE: { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; EXPORTS: []; }; }.
2. Push the activation of f to the stack.
3. Let t_1^n -> t_2* be $funcinst(z)[fa].TYPE.
4. Pop the activation of _f from the stack.
5. Let k be |t_2*|.
6. Push the activation of f with arity k to the stack.
7. Push the values val^n to the stack.
8. Execute the instruction (CALL_ADDR fa).
9. Pop all values val* from the top of the stack.
10. Pop the activation of f with arity k from the stack.
11. Push the values val* to the stack.
12. Pop the values val^k from the stack.
13. Return val^k.

eval_expr instr*
1. Execute the instruction instr*.
2. Pop the value val from the stack.
3. Return [val].

== Complete.
Generating prose for Wasm 3.0...
watsup 0.4 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...

* The number type :math:`{\mathit{numtype}}` is valid.


* The vector type :math:`{\mathit{vectype}}` is valid.


* The heap type :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valid if:


  * Either: :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{absheaptype}}`.

  * Or:

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{typeidx}}`.

    * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`{\mathit{typeidx}}`.

    * :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is :math:`{\mathit{dt}}`.
  * Or:

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{rec}~i)`.

    * :math:`{|C{.}\mathsf{recs}|}` is greater than :math:`i`.

    * :math:`C{.}\mathsf{recs}{}[i]` is :math:`{\mathit{st}}`.


* The reference type :math:`(\mathsf{ref}~(\mathsf{null}~{()^?}~{}^?)~{\mathit{heaptype}})` is valid if:


  * The heap type :math:`{\mathit{heaptype}}` is valid.


* The value type :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valid if:


  * Either:

    * :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{numtype}}`.

    * The number type :math:`{\mathit{numtype}}` is valid.

  * Or:

    * :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{vectype}}`.

    * The vector type :math:`{\mathit{vectype}}` is valid.
  * Or:

    * :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{reftype}}`.

    * The reference type :math:`{\mathit{reftype}}` is valid.
  * Or: :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{bot}`.


* The value type sequence :math:`{t^\ast}` is valid if:


  * For all :math:`t` in :math:`{t^\ast}`, the value type :math:`t` is valid.


* The instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}` is valid if:


  * The value type sequence :math:`{t_1^\ast}` is valid.

  * The value type sequence :math:`{t_2^\ast}` is valid.

  * :math:`{|{\mathit{x*}}|}` is :math:`{|{\mathit{lct*}}|}`.

  * For all :math:`x` in :math:`{x^\ast}`, :math:`{|C{.}\mathsf{locals}|}` is greater than :math:`x`.

  * For all :math:`{{\mathit{lt}}}` in :math:`{{{\mathit{lt}}}^\ast}` and :math:`x` in :math:`{x^\ast}`, :math:`C{.}\mathsf{locals}{}[x]` is :math:`{{\mathit{lt}}}`.


* The packed type :math:`{\mathit{packtype}}` is valid.


* The storage type :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valid if:


  * Either:

    * :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{valtype}}`.

    * The value type :math:`{\mathit{valtype}}` is valid.

  * Or:

    * :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{packtype}}`.

    * The packed type :math:`{\mathit{packtype}}` is valid.


* The field type :math:`((\mathsf{mut}~{()^?}~{}^?)~{\mathit{storagetype}})` is valid if:


  * The storage type :math:`{\mathit{storagetype}}` is valid.


* The function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid if:


  * The value type sequence :math:`{t_1^\ast}` is valid.

  * The value type sequence :math:`{t_2^\ast}` is valid.


* The composite type :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valid if:


  * Either:

    * :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{struct}~{{\mathit{fieldtype}}^\ast})`.

    * For all :math:`{\mathit{fieldtype}}` in :math:`{{\mathit{fieldtype}}^\ast}`, the field type :math:`{\mathit{fieldtype}}` is valid.

  * Or:

    * :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{array}~{\mathit{fieldtype}})`.

    * The field type :math:`{\mathit{fieldtype}}` is valid.
  * Or:

    * :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{func}~{\mathit{functype}})`.

    * The function type :math:`{\mathit{functype}}` is valid.


* The packed type :math:`{\mathit{packtype}}` matches the packed type :math:`{\mathit{packtype}}`.


* The number type :math:`{\mathit{numtype}}` matches the number type :math:`{\mathit{numtype}}`.


* The defined type :math:`{\mathit{deftype}}_1` matches the defined type :math:`{\mathit{deftype}}_2` if:


  * Either: :math:`{{\mathrm{clos}}}_{C}({\mathit{deftype}}_1)` is :math:`{{\mathrm{clos}}}_{C}({\mathit{deftype}}_2)`.

  * Or:

    * :math:`{\mathrm{unroll}}({\mathit{deftype}}_1)` is :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{ct}})`.

    * :math:`{|{{\mathit{typeuse}}^\ast}|}` is greater than :math:`i`.

    * The type use :math:`{{\mathit{typeuse}}^\ast}{}[i]` matches the heap type :math:`{\mathit{deftype}}_2`.


* The heap type :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` matches the heap type :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


  * Either:

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{heaptype}}`.

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathit{heaptype}}`.

  * Or:

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{heaptype}}_1`.

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathit{heaptype}}_2`.

    * The heap type :math:`{\mathit{heaptype}'}` is valid.

    * The heap type :math:`{\mathit{heaptype}}_1` matches the heap type :math:`{\mathit{heaptype}'}`.

    * The heap type :math:`{\mathit{heaptype}'}` matches the heap type :math:`{\mathit{heaptype}}_2`.
  * Or:

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{eq}`.

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{any}`.
  * Or:

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{i{\scriptstyle 31}}`.

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{eq}`.
  * Or:

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{struct}`.

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{eq}`.
  * Or:

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{array}`.

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{eq}`.
  * Or:

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{deftype}}`.

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{struct}`.

    * The :ref:`expansion <aux-expand-deftype>` of :math:`{\mathit{deftype}}` is :math:`(\mathsf{struct}~{{\mathit{fieldtype}}^\ast})`
  * Or:

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{deftype}}`.

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{array}`.

    * The :ref:`expansion <aux-expand-deftype>` of :math:`{\mathit{deftype}}` is :math:`(\mathsf{array}~{\mathit{fieldtype}})`
  * Or:

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{deftype}}`.

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`\mathsf{func}`.

    * The :ref:`expansion <aux-expand-deftype>` of :math:`{\mathit{deftype}}` is :math:`(\mathsf{func}~{\mathit{functype}})`
  * Or:

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{deftype}}_1`.

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathit{deftype}}_2`.

    * The defined type :math:`{\mathit{deftype}}_1` matches the defined type :math:`{\mathit{deftype}}_2`.
  * Or:

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{typeidx}}`.

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathit{heaptype}}`.

    * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`{\mathit{typeidx}}`.

    * The defined type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` matches the heap type :math:`{\mathit{heaptype}}`.
  * Or:

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{heaptype}}`.

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathit{typeidx}}`.

    * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`{\mathit{typeidx}}`.

    * The heap type :math:`{\mathit{heaptype}}` matches the defined type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]`.
  * Or:

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{rec}~i)`.

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{{\mathit{typeuse}}^\ast}{}[j]`.

    * :math:`{|{{\mathit{typeuse}}^\ast}|}` is greater than :math:`j`.

    * :math:`{|C{.}\mathsf{recs}|}` is greater than :math:`i`.

    * :math:`C{.}\mathsf{recs}{}[i]` is :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{ct}})`.
  * Or:

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{none}`.

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathit{heaptype}}`.

    * The heap type :math:`{\mathit{heaptype}}` matches the heap type :math:`\mathsf{any}`.
  * Or:

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{nofunc}`.

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathit{heaptype}}`.

    * The heap type :math:`{\mathit{heaptype}}` matches the heap type :math:`\mathsf{func}`.
  * Or:

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{noextern}`.

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathit{heaptype}}`.

    * The heap type :math:`{\mathit{heaptype}}` matches the heap type :math:`\mathsf{extern}`.
  * Or:

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{bot}`.

    * :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathit{heaptype}}`.


* The reference type :math:`(\mathsf{ref}~(\mathsf{null}~{{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}~{}^?)~{\mathit{ht}}_1)` matches the reference type :math:`(\mathsf{ref}~(\mathsf{null}~{{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}~{}^?)~{\mathit{ht}}_2)` if:


  * The heap type :math:`{\mathit{ht}}_1` matches the heap type :math:`{\mathit{ht}}_2`.

  * Either:

    * :math:`{{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is :math:`\epsilon`.

    * :math:`{{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is :math:`\epsilon`.

  * Or:

    * :math:`{{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is :math:`{()^?}`.

    * :math:`{{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is :math:`()`.


* The vector type :math:`{\mathit{vectype}}` matches the vector type :math:`{\mathit{vectype}}`.


* The value type :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` matches the value type :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


  * Either:

    * :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{numtype}}_1`.

    * :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathit{numtype}}_2`.

    * The number type :math:`{\mathit{numtype}}_1` matches the number type :math:`{\mathit{numtype}}_2`.

  * Or:

    * :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{vectype}}_1`.

    * :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathit{vectype}}_2`.

    * The vector type :math:`{\mathit{vectype}}_1` matches the vector type :math:`{\mathit{vectype}}_2`.
  * Or:

    * :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{reftype}}_1`.

    * :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathit{reftype}}_2`.

    * The reference type :math:`{\mathit{reftype}}_1` matches the reference type :math:`{\mathit{reftype}}_2`.
  * Or:

    * :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{bot}`.

    * :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathit{valtype}}`.


* The storage type :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` matches the storage type :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


  * Either:

    * :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{valtype}}_1`.

    * :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathit{valtype}}_2`.

    * The value type :math:`{\mathit{valtype}}_1` matches the value type :math:`{\mathit{valtype}}_2`.

  * Or:

    * :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{packtype}}_1`.

    * :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathit{packtype}}_2`.

    * The packed type :math:`{\mathit{packtype}}_1` matches the packed type :math:`{\mathit{packtype}}_2`.


* The field type :math:`((\mathsf{mut}~{{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}~{}^?)~{\mathit{zt}}_1)` matches the field type :math:`((\mathsf{mut}~{{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}~{}^?)~{\mathit{zt}}_2)` if:


  * The storage type :math:`{\mathit{zt}}_1` matches the storage type :math:`{\mathit{zt}}_2`.

  * Either:

    * :math:`{{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is :math:`\epsilon`.

    * :math:`{{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is :math:`\epsilon`.

  * Or:

    * :math:`{{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is :math:`()`.

    * :math:`{{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is :math:`()`.

    * The storage type :math:`{\mathit{zt}}_2` matches the storage type :math:`{\mathit{zt}}_1`.


* The value type sequence :math:`{t_1^\ast}` matches the value type sequence :math:`{t_2^\ast}` if:


  * :math:`{|t_{\mathit{{\scriptstyle 2}*}}|}` is :math:`{|t_{\mathit{{\scriptstyle 1}*}}|}`.

  * For all :math:`t_1` in :math:`{t_1^\ast}` and :math:`t_2` in :math:`{t_2^\ast}`, the value type :math:`t_1` matches the value type :math:`t_2`.


* The function type :math:`{t_{11}^\ast}~\rightarrow~{t_{12}^\ast}` matches the function type :math:`{t_{21}^\ast}~\rightarrow~{t_{22}^\ast}` if:


  * The value type sequence :math:`{t_{21}^\ast}` matches the value type sequence :math:`{t_{11}^\ast}`.

  * The value type sequence :math:`{t_{12}^\ast}` matches the value type sequence :math:`{t_{22}^\ast}`.


* The composite type :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` matches the composite type :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


  * Either:

    * :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{struct}~{{\mathit{yt}}_1^\ast}~{\mathit{yt}'}_1)`.

    * :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{struct}~{{\mathit{yt}}_2^\ast})`.

    * :math:`{|{\mathit{yt}}_{\mathit{{\scriptstyle 2}*}}|}` is :math:`{|{\mathit{yt}}_{\mathit{{\scriptstyle 1}*}}|}`.

    * For all :math:`{\mathit{yt}}_1` in :math:`{{\mathit{yt}}_1^\ast}` and :math:`{\mathit{yt}}_2` in :math:`{{\mathit{yt}}_2^\ast}`, the field type :math:`{\mathit{yt}}_1` matches the field type :math:`{\mathit{yt}}_2`.

  * Or:

    * :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{array}~{\mathit{yt}}_1)`.

    * :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{array}~{\mathit{yt}}_2)`.

    * The field type :math:`{\mathit{yt}}_1` matches the field type :math:`{\mathit{yt}}_2`.
  * Or:

    * :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{func}~{\mathit{ft}}_1)`.

    * :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{func}~{\mathit{ft}}_2)`.

    * The function type :math:`{\mathit{ft}}_1` matches the function type :math:`{\mathit{ft}}_2`.


* The sub type :math:`(\mathsf{sub}~(\mathsf{final}~{()^?}~{}^?)~{x^\ast}~{\mathit{comptype}})` is valid with the oktypeidx :math:`({\mathsf{ok}}{x_0})` if:


  * :math:`{|{x^\ast}|}` is less than or equal to :math:`1`.

  * For all :math:`x` in :math:`{x^\ast}`, :math:`x` is less than :math:`x_0`.

  * :math:`{|{\mathit{x*}}|}` is :math:`{|{\mathit{comptype'*}}|}`.

  * :math:`{|{\mathit{x'**}}|}` is :math:`{|{\mathit{comptype'*}}|}`.

  * For all :math:`x` in :math:`{x^\ast}`, :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * For all :math:`{\mathit{comptype}'}` in :math:`{{\mathit{comptype}'}^\ast}` and :math:`x` in :math:`{x^\ast}` and :math:`{\mathit{x'*}}` in :math:`{{\mathit{x'*}}^\ast}`, :math:`{\mathrm{unroll}}(C{.}\mathsf{types}{}[x])` is :math:`(\mathsf{sub}~{{x'}^\ast}~{\mathit{comptype}'})`.

  * The composite type :math:`{\mathit{comptype}}` is valid.

  * For all :math:`{\mathit{comptype}'}` in :math:`{{\mathit{comptype}'}^\ast}`, the composite type :math:`{\mathit{comptype}}` matches the composite type :math:`{\mathit{comptype}'}`.


* The sub type :math:`(\mathsf{sub}~(\mathsf{final}~{()^?}~{}^?)~{{\mathit{typeuse}}^\ast}~{\mathit{compttype}})` is valid with the oktypeidxnat :math:`({\mathsf{ok}}{(x, i)})` if:


  * :math:`{|{{\mathit{typeuse}}^\ast}|}` is less than or equal to :math:`1`.

  * For all :math:`{\mathit{typeuse}}` in :math:`{{\mathit{typeuse}}^\ast}`, :math:`{\mathit{typeuse}} \prec x, i` is true.

  * :math:`{|{\mathit{typeuse*}}|}` is :math:`{|{\mathit{comptype'*}}|}`.

  * :math:`{|{\mathit{typeuse'**}}|}` is :math:`{|{\mathit{comptype'*}}|}`.

  * For all :math:`{\mathit{comptype}'}` in :math:`{{\mathit{comptype}'}^\ast}` and :math:`{\mathit{typeuse}}` in :math:`{{\mathit{typeuse}}^\ast}` and :math:`{\mathit{typeuse'*}}` in :math:`{{\mathit{typeuse'*}}^\ast}`, :math:`{{\mathrm{unroll}}}_{C}({\mathit{typeuse}})` is :math:`(\mathsf{sub}~{{\mathit{typeuse}'}^\ast}~{\mathit{comptype}'})`.

  * The composite type :math:`{\mathit{comptype}}` is valid.

  * For all :math:`{\mathit{comptype}'}` in :math:`{{\mathit{comptype}'}^\ast}`, the composite type :math:`{\mathit{comptype}}` matches the composite type :math:`{\mathit{comptype}'}`.


* The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})` is valid with the oktypeidxnat :math:`({\mathsf{ok}}{(x, i)})` if:


  * Either: :math:`{{\mathit{subtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`.

  * Or:

    * :math:`{{\mathit{subtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`{\mathit{subtype}}_1~{{\mathit{subtype}}^\ast}`.

    * The sub type :math:`{\mathit{subtype}}_1` is valid with the oktypeidxnat :math:`({\mathsf{ok}}{(x, i)})`.

    * The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is valid with the oktypeidxnat :math:`({\mathsf{ok}}{(x + 1, i + 1)})`.


* The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})` is valid with the oktypeidx :math:`({\mathsf{ok}}{x})` if:


  * Either: :math:`{{\mathit{subtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`.

  * Or:

    * :math:`{{\mathit{subtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`{\mathit{subtype}}_1~{{\mathit{subtype}}^\ast}`.

    * The sub type :math:`{\mathit{subtype}}_1` is valid with the oktypeidx :math:`({\mathsf{ok}}{x})`.

    * The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is valid with the oktypeidx :math:`({\mathsf{ok}}{x + 1})`.
  * Or:

    * :math:`{{\mathit{subtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`{{\mathit{subtype}}^\ast}`.

    * Under the context :math:`C{}[{.}\mathsf{recs} \mathrel{{=}{\oplus}} {{\mathit{subtype}}^\ast}]`, the recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is valid with the oktypeidxnat :math:`({\mathsf{ok}}{(x, 0)})`.


* The defined type :math:`({\mathit{rectype}} {.} i)` is valid if:


  * The recursive type :math:`{\mathit{rectype}}` is valid with the oktypeidx :math:`({\mathsf{ok}}{x})`.

  * :math:`{\mathit{rectype}}` is :math:`(\mathsf{rec}~{{\mathit{subtype}}^{n}})`.

  * :math:`i` is less than :math:`n`.


* The limits :math:`(n, m)` is valid with the nat :math:`k` if:


  * :math:`n` is less than or equal to :math:`m`.

  * :math:`m` is less than or equal to :math:`k`.


* The global type :math:`((\mathsf{mut}~{()^?}~{}^?)~t)` is valid if:


  * The value type :math:`t` is valid.


* The table type :math:`({\mathit{limits}}~{\mathit{reftype}})` is valid if:


  * The limits :math:`{\mathit{limits}}` is valid with the nat :math:`{2^{32}} - 1`.

  * The reference type :math:`{\mathit{reftype}}` is valid.


* The memory type :math:`{\mathit{limits}}~\mathsf{page}` is valid if:


  * The limits :math:`{\mathit{limits}}` is valid with the nat :math:`{2^{16}}`.


* The memory type :math:`{\mathit{deftype}}` is valid if:


  * The defined type :math:`{\mathit{deftype}}` is valid.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`{\mathit{deftype}}` is :math:`(\mathsf{func}~{\mathit{functype}})`


* The external type :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valid if:


  * Either:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{func}~{\mathit{deftype}})`.

    * The defined type :math:`{\mathit{deftype}}` is valid.

    * The :ref:`expansion <aux-expand-deftype>` of :math:`{\mathit{deftype}}` is :math:`(\mathsf{func}~{\mathit{functype}})`

  * Or:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{global}~{\mathit{globaltype}})`.

    * The global type :math:`{\mathit{globaltype}}` is valid.
  * Or:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{table}~{\mathit{tabletype}})`.

    * The table type :math:`{\mathit{tabletype}}` is valid.
  * Or:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{mem}~{\mathit{memtype}})`.

    * The memory type :math:`{\mathit{memtype}}` is valid.
  * Or:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{tag}~{\mathit{tagtype}})`.

    * The memory type :math:`{\mathit{tagtype}}` is valid.


* The instruction type :math:`{t_{11}^\ast}~{\rightarrow}_{{x_1^\ast}}\,{t_{12}^\ast}` matches the instruction type :math:`{t_{21}^\ast}~{\rightarrow}_{{x_2^\ast}}\,{t_{22}^\ast}` if:


  * The value type sequence :math:`{t_{21}^\ast}` matches the value type sequence :math:`{t_{11}^\ast}`.

  * The value type sequence :math:`{t_{12}^\ast}` matches the value type sequence :math:`{t_{22}^\ast}`.

  * :math:`{x^\ast}` is :math:`{x_2^\ast} \setminus {x_1^\ast}`.

  * :math:`{|{\mathit{x*}}|}` is :math:`{|{\mathit{t*}}|}`.

  * For all :math:`x` in :math:`{x^\ast}`, :math:`{|C{.}\mathsf{locals}|}` is greater than :math:`x`.

  * For all :math:`t` in :math:`{t^\ast}` and :math:`x` in :math:`{x^\ast}`, :math:`C{.}\mathsf{locals}{}[x]` is :math:`(\mathsf{set}~t)`.


* The limits :math:`(n_1, m_1)` matches the limits :math:`(n_2, m_2)` if:


  * :math:`n_1` is greater than or equal to :math:`n_2`.

  * :math:`m_1` is less than or equal to :math:`m_2`.


* The global type :math:`((\mathsf{mut}~{{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}~{}^?)~{\mathit{valtype}}_1)` matches the global type :math:`((\mathsf{mut}~{{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}~{}^?)~{\mathit{valtype}}_2)` if:


  * The value type :math:`{\mathit{valtype}}_1` matches the value type :math:`{\mathit{valtype}}_2`.

  * Either:

    * :math:`{{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is :math:`\epsilon`.

    * :math:`{{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is :math:`\epsilon`.

  * Or:

    * :math:`{{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is :math:`()`.

    * :math:`{{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is :math:`()`.

    * The value type :math:`{\mathit{valtype}}_2` matches the value type :math:`{\mathit{valtype}}_1`.


* The table type :math:`({\mathit{limits}}_1~{\mathit{reftype}}_1)` matches the table type :math:`({\mathit{limits}}_2~{\mathit{reftype}}_2)` if:


  * The limits :math:`{\mathit{limits}}_1` matches the limits :math:`{\mathit{limits}}_2`.

  * The reference type :math:`{\mathit{reftype}}_1` matches the reference type :math:`{\mathit{reftype}}_2`.

  * The reference type :math:`{\mathit{reftype}}_2` matches the reference type :math:`{\mathit{reftype}}_1`.


* The memory type :math:`{\mathit{limits}}_1~\mathsf{page}` matches the memory type :math:`{\mathit{limits}}_2~\mathsf{page}` if:


  * The limits :math:`{\mathit{limits}}_1` matches the limits :math:`{\mathit{limits}}_2`.


* The memory type :math:`{\mathit{deftype}}_1` matches the memory type :math:`{\mathit{deftype}}_2` if:


  * The defined type :math:`{\mathit{deftype}}_1` matches the defined type :math:`{\mathit{deftype}}_2`.

  * The defined type :math:`{\mathit{deftype}}_2` matches the defined type :math:`{\mathit{deftype}}_1`.


* The external type :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` matches the external type :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


  * Either:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{func}~{\mathit{deftype}}_1)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{func}~{\mathit{deftype}}_2)`.

    * The defined type :math:`{\mathit{deftype}}_1` matches the defined type :math:`{\mathit{deftype}}_2`.

  * Or:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{global}~{\mathit{globaltype}}_1)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{global}~{\mathit{globaltype}}_2)`.

    * The global type :math:`{\mathit{globaltype}}_1` matches the global type :math:`{\mathit{globaltype}}_2`.
  * Or:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{table}~{\mathit{tabletype}}_1)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{table}~{\mathit{tabletype}}_2)`.

    * The table type :math:`{\mathit{tabletype}}_1` matches the table type :math:`{\mathit{tabletype}}_2`.
  * Or:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{mem}~{\mathit{memtype}}_1)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{mem}~{\mathit{memtype}}_2)`.

    * The memory type :math:`{\mathit{memtype}}_1` matches the memory type :math:`{\mathit{memtype}}_2`.
  * Or:

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{tag}~{\mathit{tagtype}}_1)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{tag}~{\mathit{tagtype}}_2)`.

    * The memory type :math:`{\mathit{tagtype}}_1` matches the memory type :math:`{\mathit{tagtype}}_2`.


* The block type :math:`{\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valid with the instruction type :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}~\rightarrow~{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` if:


  * Either:

    * :math:`{\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{{\mathit{valtype}}^?}`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\epsilon`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is :math:`{{\mathit{valtype}}^?}`.

    * If :math:`{\mathit{valtype}}` is defined, the value type :math:`{\mathit{valtype}}` is valid.

  * Or:

    * :math:`{\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{typeidx}}`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`{t_1^\ast}`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is :math:`{t_2^\ast}`.

    * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`{\mathit{typeidx}}`.

    * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`


* The catch clause :math:`{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valid if:


  * :math:`{|C{.}\mathsf{labels}|}` is greater than :math:`l`.

  * Either:

    * :math:`{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{catch}~x~l)`.

    * :math:`{|C{.}\mathsf{tags}|}` is greater than :math:`x`.

    * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{tags}{}[x]` is :math:`(\mathsf{func}~{t^\ast}~\rightarrow~\epsilon)`

    * The value type sequence :math:`{t^\ast}` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.

  * Or:

    * :math:`{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{catch\_ref}~x~l)`.

    * :math:`{|C{.}\mathsf{tags}|}` is greater than :math:`x`.

    * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{tags}{}[x]` is :math:`(\mathsf{func}~{t^\ast}~\rightarrow~\epsilon)`

    * The value type sequence :math:`{t^\ast}~(\mathsf{ref}~\mathsf{exn})` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.
  * Or:

    * :math:`{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{catch\_all}~l)`.

    * The value type sequence :math:`\epsilon` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.
  * Or:

    * :math:`{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{catch\_all\_ref}~l)`.

    * The value type sequence :math:`(\mathsf{ref}~\mathsf{exn})` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.


* The instruction :math:`\mathsf{nop}` is valid with the instruction type :math:`\epsilon~\rightarrow~\epsilon`.


* The instruction :math:`\mathsf{unreachable}` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


  * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid.


* The instruction :math:`\mathsf{drop}` is valid with the instruction type :math:`t~\rightarrow~\epsilon` if:


  * The value type :math:`t` is valid.


* The instruction :math:`(\mathsf{select}~{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?})` is valid with the instruction type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


  * The value type :math:`t` is valid.

  * Either: :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is :math:`t`.

  * Or:

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is :math:`\epsilon`.

    * The value type :math:`t` matches the value type :math:`{t'}`.

    * :math:`{t'}` is contained in :math:`{\mathit{numtype}}~{\mathit{vectype}}`.


* The instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}^\ast})` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


  * The block type :math:`{\mathit{bt}}` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * Under the context :math:`C{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_2^\ast}]`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.


* The instruction :math:`(\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast})` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


  * The block type :math:`{\mathit{bt}}` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * Under the context :math:`C{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_1^\ast}]`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.


* The instruction :math:`(\mathsf{if}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast})` is valid with the instruction type :math:`{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


  * The block type :math:`{\mathit{bt}}` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * Under the context :math:`C{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_2^\ast}]`, the instruction sequence :math:`{{\mathit{instr}}_1^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}}\,{t_2^\ast}`.

  * Under the context :math:`C{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_2^\ast}]`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_2^\ast}}\,{t_2^\ast}`.


* The instruction :math:`(\mathsf{br}~l)` is valid with the instruction type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


  * :math:`{|C{.}\mathsf{labels}|}` is greater than :math:`l`.

  * :math:`C{.}\mathsf{labels}{}[l]` is :math:`{t^\ast}`.

  * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid.


* The instruction :math:`(\mathsf{br\_if}~l)` is valid with the instruction type :math:`{t^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t^\ast}` if:


  * :math:`{|C{.}\mathsf{labels}|}` is greater than :math:`l`.

  * :math:`C{.}\mathsf{labels}{}[l]` is :math:`{t^\ast}`.


* The instruction :math:`(\mathsf{br\_table}~{l^\ast}~{l'})` is valid with the instruction type :math:`{t_1^\ast}~{t^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


  * For all :math:`l` in :math:`{l^\ast}`, :math:`{|C{.}\mathsf{labels}|}` is greater than :math:`l`.

  * For all :math:`l` in :math:`{l^\ast}`, the value type sequence :math:`{t^\ast}` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.

  * :math:`{|C{.}\mathsf{labels}|}` is greater than :math:`{l'}`.

  * The value type sequence :math:`{t^\ast}` matches the result type :math:`C{.}\mathsf{labels}{}[{l'}]`.

  * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid.


* The instruction :math:`(\mathsf{br\_on\_null}~l)` is valid with the instruction type :math:`{t^\ast}~(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})~\rightarrow~{t^\ast}~(\mathsf{ref}~{\mathit{ht}})` if:


  * :math:`{|C{.}\mathsf{labels}|}` is greater than :math:`l`.

  * :math:`C{.}\mathsf{labels}{}[l]` is :math:`{t^\ast}`.

  * The heap type :math:`{\mathit{ht}}` is valid.


* The instruction :math:`(\mathsf{br\_on\_non\_null}~l)` is valid with the instruction type :math:`{t^\ast}~(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})~\rightarrow~{t^\ast}` if:


  * :math:`{|C{.}\mathsf{labels}|}` is greater than :math:`l`.

  * :math:`C{.}\mathsf{labels}{}[l]` is :math:`{t^\ast}~(\mathsf{ref}~{\mathit{ht}})`.


* The instruction :math:`(\mathsf{br\_on\_cast}~l~{\mathit{rt}}_1~{\mathit{rt}}_2)` is valid with the instruction type :math:`{t^\ast}~{\mathit{rt}}_1~\rightarrow~{t^\ast}~{\mathit{rt}}_1 \setminus {\mathit{rt}}_2` if:


  * :math:`{|C{.}\mathsf{labels}|}` is greater than :math:`l`.

  * :math:`C{.}\mathsf{labels}{}[l]` is :math:`{t^\ast}~{\mathit{rt}}`.

  * The reference type :math:`{\mathit{rt}}_1` is valid.

  * The reference type :math:`{\mathit{rt}}_2` is valid.

  * The reference type :math:`{\mathit{rt}}_2` matches the reference type :math:`{\mathit{rt}}_1`.

  * The reference type :math:`{\mathit{rt}}_2` matches the reference type :math:`{\mathit{rt}}`.


* The instruction :math:`(\mathsf{br\_on\_cast\_fail}~l~{\mathit{rt}}_1~{\mathit{rt}}_2)` is valid with the instruction type :math:`{t^\ast}~{\mathit{rt}}_1~\rightarrow~{t^\ast}~{\mathit{rt}}_2` if:


  * :math:`{|C{.}\mathsf{labels}|}` is greater than :math:`l`.

  * :math:`C{.}\mathsf{labels}{}[l]` is :math:`{t^\ast}~{\mathit{rt}}`.

  * The reference type :math:`{\mathit{rt}}_1` is valid.

  * The reference type :math:`{\mathit{rt}}_2` is valid.

  * The reference type :math:`{\mathit{rt}}_2` matches the reference type :math:`{\mathit{rt}}_1`.

  * The reference type :math:`{\mathit{rt}}_1 \setminus {\mathit{rt}}_2` matches the reference type :math:`{\mathit{rt}}`.


* The instruction :math:`(\mathsf{call}~x)` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


  * :math:`{|C{.}\mathsf{funcs}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{funcs}{}[x]` is :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`


* The instruction :math:`(\mathsf{call\_ref}~x)` is valid with the instruction type :math:`{t_1^\ast}~(\mathsf{ref}~\mathsf{null}~x)~\rightarrow~{t_2^\ast}` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`


* The instruction :math:`(\mathsf{call\_indirect}~x~y)` is valid with the instruction type :math:`{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


  * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{tables}{}[x]` is :math:`({\mathit{lim}}~{\mathit{rt}})`.

  * The reference type :math:`{\mathit{rt}}` matches the reference type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{func})`.

  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`y`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[y]` is :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`


* The instruction :math:`\mathsf{return}` is valid with the instruction type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


  * :math:`C{.}\mathsf{return}` is :math:`{t^\ast}`.

  * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid.


* The instruction :math:`(\mathsf{return\_call}~x)` is valid with the instruction type :math:`{t_3^\ast}~{t_1^\ast}~\rightarrow~{t_4^\ast}` if:


  * :math:`{|C{.}\mathsf{funcs}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{funcs}{}[x]` is :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`

  * :math:`C{.}\mathsf{return}` is :math:`{{t'}_2^\ast}`.

  * The value type sequence :math:`{t_2^\ast}` matches the value type sequence :math:`{{t'}_2^\ast}`.

  * The instruction type :math:`{t_3^\ast}~\rightarrow~{t_4^\ast}` is valid.


* The instruction :math:`(\mathsf{return\_call\_ref}~x)` is valid with the instruction type :math:`{t_3^\ast}~{t_1^\ast}~(\mathsf{ref}~\mathsf{null}~x)~\rightarrow~{t_4^\ast}` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`

  * :math:`C{.}\mathsf{return}` is :math:`{{t'}_2^\ast}`.

  * The value type sequence :math:`{t_2^\ast}` matches the value type sequence :math:`{{t'}_2^\ast}`.

  * The instruction type :math:`{t_3^\ast}~\rightarrow~{t_4^\ast}` is valid.


* The instruction :math:`(\mathsf{return\_call\_indirect}~x~y)` is valid with the instruction type :math:`{t_3^\ast}~{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_4^\ast}` if:


  * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{tables}{}[x]` is :math:`({\mathit{lim}}~{\mathit{rt}})`.

  * The reference type :math:`{\mathit{rt}}` matches the reference type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{func})`.

  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`y`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[y]` is :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`

  * :math:`C{.}\mathsf{return}` is :math:`{{t'}_2^\ast}`.

  * The value type sequence :math:`{t_2^\ast}` matches the value type sequence :math:`{{t'}_2^\ast}`.

  * The instruction type :math:`{t_3^\ast}~\rightarrow~{t_4^\ast}` is valid.


* The instruction :math:`(\mathsf{throw}~x)` is valid with the instruction type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


  * :math:`{|C{.}\mathsf{tags}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{tags}{}[x]` is :math:`(\mathsf{func}~{t^\ast}~\rightarrow~\epsilon)`

  * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid.


* The instruction :math:`\mathsf{throw\_ref}` is valid with the instruction type :math:`{t_1^\ast}~(\mathsf{ref}~\mathsf{null}~\mathsf{exn})~\rightarrow~{t_2^\ast}` if:


  * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid.


* The instruction :math:`(\mathsf{try\_table}~{\mathit{bt}}~{{\mathit{catch}}^\ast}~{{\mathit{instr}}^\ast})` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


  * The block type :math:`{\mathit{bt}}` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * Under the context :math:`C{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_2^\ast}]`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.

  * For all :math:`{\mathit{catch}}` in :math:`{{\mathit{catch}}^\ast}`, the catch clause :math:`{\mathit{catch}}` is valid.


* The instruction :math:`({\mathit{nt}}{.}\mathsf{const}~c_{\mathit{nt}})` is valid with the instruction type :math:`\epsilon~\rightarrow~{\mathit{nt}}`.


* The instruction :math:`({\mathit{nt}} {.} {\mathit{unop}}_{\mathit{nt}})` is valid with the instruction type :math:`{\mathit{nt}}~\rightarrow~{\mathit{nt}}`.


* The instruction :math:`({\mathit{nt}} {.} {\mathit{binop}}_{\mathit{nt}})` is valid with the instruction type :math:`{\mathit{nt}}~{\mathit{nt}}~\rightarrow~{\mathit{nt}}`.


* The instruction :math:`({\mathit{nt}} {.} {\mathit{testop}}_{\mathit{nt}})` is valid with the instruction type :math:`{\mathit{nt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.


* The instruction :math:`({\mathit{nt}} {.} {\mathit{relop}}_{\mathit{nt}})` is valid with the instruction type :math:`{\mathit{nt}}~{\mathit{nt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.


* The instruction :math:`({\mathit{nt}}_1 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_2})` is valid with the instruction type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1`.


* The instruction :math:`(\mathsf{ref{.}null}~{\mathit{ht}})` is valid with the instruction type :math:`\epsilon~\rightarrow~(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})` if:


  * The heap type :math:`{\mathit{ht}}` is valid.


* The instruction :math:`(\mathsf{ref{.}func}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~(\mathsf{ref}~{\mathit{dt}})` if:


  * :math:`{|C{.}\mathsf{funcs}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{funcs}{}[x]` is :math:`{\mathit{dt}}`.

  * :math:`{|C{.}\mathsf{refs}|}` is greater than :math:`0`.

  * :math:`x` is contained in :math:`C{.}\mathsf{refs}`.


* The instruction :math:`\mathsf{ref{.}i{\scriptstyle 31}}` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~\mathsf{i{\scriptstyle 31}})`.


* The instruction :math:`\mathsf{ref{.}is\_null}` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


  * The heap type :math:`{\mathit{ht}}` is valid.


* The instruction :math:`\mathsf{ref{.}as\_non\_null}` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})~\rightarrow~(\mathsf{ref}~{\mathit{ht}})` if:


  * The heap type :math:`{\mathit{ht}}` is valid.


* The instruction :math:`\mathsf{ref{.}eq}` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{eq})~(\mathsf{ref}~\mathsf{null}~\mathsf{eq})~\rightarrow~\mathsf{i{\scriptstyle 32}}`.


* The instruction :math:`(\mathsf{ref{.}test}~{\mathit{rt}})` is valid with the instruction type :math:`{\mathit{rt}'}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


  * The reference type :math:`{\mathit{rt}}` is valid.

  * The reference type :math:`{\mathit{rt}'}` is valid.

  * The reference type :math:`{\mathit{rt}}` matches the reference type :math:`{\mathit{rt}'}`.


* The instruction :math:`(\mathsf{ref{.}cast}~{\mathit{rt}})` is valid with the instruction type :math:`{\mathit{rt}'}~\rightarrow~{\mathit{rt}}` if:


  * The reference type :math:`{\mathit{rt}}` is valid.

  * The reference type :math:`{\mathit{rt}'}` is valid.

  * The reference type :math:`{\mathit{rt}}` matches the reference type :math:`{\mathit{rt}'}`.


* The instruction :math:`({\mathsf{i{\scriptstyle 31}{.}get}}{\mathsf{\_}}{{\mathit{sx}}})` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{i{\scriptstyle 31}})~\rightarrow~\mathsf{i{\scriptstyle 32}}`.


* The instruction :math:`(\mathsf{struct{.}new}~x)` is valid with the instruction type :math:`{{\mathrm{unpack}}({\mathit{zt}})^\ast}~\rightarrow~(\mathsf{ref}~x)` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{struct}~{({\mathsf{mut}^?}~{\mathit{zt}})^\ast})`


* The instruction :math:`(\mathsf{struct{.}new\_default}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~(\mathsf{ref}~x)` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{struct}~{({\mathsf{mut}^?}~{\mathit{zt}})^\ast})`

  * :math:`{|{\mathit{zt*}}|}` is :math:`{|{\mathit{val*}}|}`.

  * For all :math:`{\mathit{val}}` in :math:`{{\mathit{val}}^\ast}` and :math:`{\mathit{zt}}` in :math:`{{\mathit{zt}}^\ast}`, :math:`{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}` is :math:`{\mathit{val}}`.


* The instruction :math:`({\mathsf{struct{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x~i)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\rightarrow~{\mathrm{unpack}}({\mathit{zt}})` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{struct}~{{\mathit{yt}}^\ast})`

  * :math:`{|{{\mathit{yt}}^\ast}|}` is greater than :math:`i`.

  * :math:`{{\mathit{yt}}^\ast}{}[i]` is :math:`({\mathsf{mut}^?}~{\mathit{zt}})`.

  * :math:`{{\mathit{sx}}^?}` is :math:`\epsilon` if and only if :math:`{\mathit{zt}}` is :math:`{\mathrm{unpack}}({\mathit{zt}})`.


* The instruction :math:`(\mathsf{struct{.}set}~x~i)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~{\mathrm{unpack}}({\mathit{zt}})~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{struct}~{{\mathit{yt}}^\ast})`

  * :math:`{|{{\mathit{yt}}^\ast}|}` is greater than :math:`i`.

  * :math:`{{\mathit{yt}}^\ast}{}[i]` is :math:`(\mathsf{mut}~{\mathit{zt}})`.


* The instruction :math:`(\mathsf{array{.}new}~x)` is valid with the instruction type :math:`{\mathrm{unpack}}({\mathit{zt}})~\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~x)` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}))`


* The instruction :math:`(\mathsf{array{.}new\_default}~x)` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~x)` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}))`

  * :math:`{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}` is :math:`{\mathit{val}}`.


* The instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)` is valid with the instruction type :math:`{{\mathrm{unpack}}({\mathit{zt}})^{n}}~\rightarrow~(\mathsf{ref}~x)` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}))`


* The instruction :math:`(\mathsf{array{.}new\_elem}~x~y)` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~x)` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{rt}}))`

  * :math:`{|C{.}\mathsf{elems}|}` is greater than :math:`y`.

  * The reference type :math:`C{.}\mathsf{elems}{}[y]` matches the reference type :math:`{\mathit{rt}}`.


* The instruction :math:`(\mathsf{array{.}new\_data}~x~y)` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~x)` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}))`

  * :math:`{\mathrm{unpack}}({\mathit{zt}})` is contained in :math:`{\mathit{numtype}}~{\mathit{vectype}}`.

  * :math:`{|C{.}\mathsf{datas}|}` is greater than :math:`y`.

  * :math:`C{.}\mathsf{datas}{}[y]` is :math:`\mathsf{ok}`.


* The instruction :math:`({\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathrm{unpack}}({\mathit{zt}})` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}))`

  * :math:`{{\mathit{sx}}^?}` is :math:`\epsilon` if and only if :math:`{\mathit{zt}}` is :math:`{\mathrm{unpack}}({\mathit{zt}})`.


* The instruction :math:`(\mathsf{array{.}set}~x)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~{\mathrm{unpack}}({\mathit{zt}})~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{array}~(\mathsf{mut}~{\mathit{zt}}))`


* The instruction :math:`\mathsf{array{.}len}` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{array})~\rightarrow~\mathsf{i{\scriptstyle 32}}`.


* The instruction :math:`(\mathsf{array{.}fill}~x)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~{\mathrm{unpack}}({\mathit{zt}})~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{array}~(\mathsf{mut}~{\mathit{zt}}))`


* The instruction :math:`(\mathsf{array{.}copy}~x_1~x_2)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x_1)~\mathsf{i{\scriptstyle 32}}~(\mathsf{ref}~\mathsf{null}~x_2)~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x_1`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x_1]` is :math:`(\mathsf{array}~(\mathsf{mut}~{\mathit{zt}}_1))`

  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x_2`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x_2]` is :math:`(\mathsf{array}~({\mathsf{mut}^?}~{\mathit{zt}}_2))`

  * The storage type :math:`{\mathit{zt}}_2` matches the storage type :math:`{\mathit{zt}}_1`.


* The instruction :math:`(\mathsf{array{.}init\_elem}~x~y)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{array}~(\mathsf{mut}~{\mathit{zt}}))`

  * :math:`{|C{.}\mathsf{elems}|}` is greater than :math:`y`.

  * The element type :math:`C{.}\mathsf{elems}{}[y]` matches the storage type :math:`{\mathit{zt}}`.


* The instruction :math:`(\mathsf{array{.}init\_data}~x~y)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{array}~(\mathsf{mut}~{\mathit{zt}}))`

  * :math:`{\mathrm{unpack}}({\mathit{zt}})` is contained in :math:`{\mathit{numtype}}~{\mathit{vectype}}`.

  * :math:`{|C{.}\mathsf{datas}|}` is greater than :math:`y`.

  * :math:`C{.}\mathsf{datas}{}[y]` is :math:`\mathsf{ok}`.


* The instruction :math:`\mathsf{extern{.}convert\_any}` is valid with the instruction type :math:`(\mathsf{ref}~{\mathsf{null}}{{{}_{1}^?}}~\mathsf{any})~\rightarrow~(\mathsf{ref}~{\mathsf{null}}{{{}_{2}^?}}~\mathsf{extern})` if:


  * :math:`{\mathsf{null}}{{{}_{1}^?}}` is :math:`{\mathsf{null}}{{{}_{2}^?}}`.


* The instruction :math:`\mathsf{any{.}convert\_extern}` is valid with the instruction type :math:`(\mathsf{ref}~{\mathsf{null}}{{{}_{1}^?}}~\mathsf{extern})~\rightarrow~(\mathsf{ref}~{\mathsf{null}}{{{}_{2}^?}}~\mathsf{any})` if:


  * :math:`{\mathsf{null}}{{{}_{1}^?}}` is :math:`{\mathsf{null}}{{{}_{2}^?}}`.


* The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` is valid with the instruction type :math:`\epsilon~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvunop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvbinop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvternop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvtestop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.


* The instruction :math:`({\mathit{sh}} {.} {\mathit{vunop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`({\mathit{sh}} {.} {\mathit{vbinop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`({\mathit{sh}} {.} {\mathit{vtestop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.


* The instruction :math:`({\mathit{sh}} {.} {\mathit{vrelop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`({\mathit{sh}} {.} {\mathit{vshiftop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`({\mathit{sh}}{.}\mathsf{bitmask})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.


* The instruction :math:`({\mathit{sh}}{.}\mathsf{swizzle})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`({\mathit{sh}}{.}\mathsf{shuffle}~{i^\ast})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * For all :math:`i` in :math:`{i^\ast}`, :math:`i` is less than :math:`2 \cdot {\mathrm{dim}}({\mathit{sh}})`.


* The instruction :math:`({\mathit{sh}}{.}\mathsf{splat})` is valid with the instruction type :math:`{\mathrm{unpack}}({\mathit{sh}})~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`({{\mathit{sh}}{.}\mathsf{extract\_lane}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~i)` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~{\mathrm{unpack}}({\mathit{sh}})` if:


  * :math:`i` is less than :math:`{\mathrm{dim}}({\mathit{sh}})`.


* The instruction :math:`({\mathit{sh}}{.}\mathsf{replace\_lane}~i)` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~{\mathrm{unpack}}({\mathit{sh}})~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * :math:`i` is less than :math:`{\mathrm{dim}}({\mathit{sh}})`.


* The instruction :math:`({\mathit{sh}}_1 {.} {{\mathit{vextunop}}}{\mathsf{\_}}{{\mathit{sh}}_2})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`({\mathit{sh}}_1 {.} {{\mathit{vextbinop}}}{\mathsf{\_}}{{\mathit{sh}}_2})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`({{\mathit{sh}}_1{.}\mathsf{narrow}}{\mathsf{\_}}{{\mathit{sh}}_2}{\mathsf{\_}}{{\mathit{sx}}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`({\mathit{sh}}_1 {.} {{\mathit{vcvtop}}}{\mathsf{\_}}{{{\mathit{zero}}^?}}{\mathsf{\_}}{{\mathit{sh}}_2}{\mathsf{\_}}{{{\mathit{half}}^?}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.


* The instruction :math:`(\mathsf{local{.}get}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~t` if:


  * :math:`{|C{.}\mathsf{locals}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{locals}{}[x]` is :math:`(\mathsf{set}~t)`.


* The instruction :math:`(\mathsf{local{.}set}~x)` is valid with the instruction type :math:`t~{\rightarrow}_{x}\,\epsilon` if:


  * :math:`{|C{.}\mathsf{locals}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{locals}{}[x]` is :math:`({\mathit{init}}~t)`.


* The instruction :math:`(\mathsf{local{.}tee}~x)` is valid with the instruction type :math:`t~{\rightarrow}_{x}\,t` if:


  * :math:`{|C{.}\mathsf{locals}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{locals}{}[x]` is :math:`({\mathit{init}}~t)`.


* The instruction :math:`(\mathsf{global{.}get}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~t` if:


  * :math:`{|C{.}\mathsf{globals}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{globals}{}[x]` is :math:`({\mathsf{mut}^?}~t)`.


* The instruction :math:`(\mathsf{global{.}set}~x)` is valid with the instruction type :math:`t~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{globals}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{globals}{}[x]` is :math:`(\mathsf{mut}~t)`.


* The instruction :math:`(\mathsf{table{.}get}~x)` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathit{rt}}` if:


  * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{tables}{}[x]` is :math:`({\mathit{lim}}~{\mathit{rt}})`.


* The instruction :math:`(\mathsf{table{.}set}~x)` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~{\mathit{rt}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{tables}{}[x]` is :math:`({\mathit{lim}}~{\mathit{rt}})`.


* The instruction :math:`(\mathsf{table{.}size}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


  * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{tables}{}[x]` is :math:`({\mathit{lim}}~{\mathit{rt}})`.


* The instruction :math:`(\mathsf{table{.}grow}~x)` is valid with the instruction type :math:`{\mathit{rt}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


  * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{tables}{}[x]` is :math:`({\mathit{lim}}~{\mathit{rt}})`.


* The instruction :math:`(\mathsf{table{.}fill}~x)` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~{\mathit{rt}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{tables}{}[x]` is :math:`({\mathit{lim}}~{\mathit{rt}})`.


* The instruction :math:`(\mathsf{table{.}copy}~x_1~x_2)` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x_1`.

  * :math:`C{.}\mathsf{tables}{}[x_1]` is :math:`({\mathit{lim}}_1~{\mathit{rt}}_1)`.

  * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x_2`.

  * :math:`C{.}\mathsf{tables}{}[x_2]` is :math:`({\mathit{lim}}_2~{\mathit{rt}}_2)`.

  * The reference type :math:`{\mathit{rt}}_2` matches the reference type :math:`{\mathit{rt}}_1`.


* The instruction :math:`(\mathsf{table{.}init}~x~y)` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{tables}{}[x]` is :math:`({\mathit{lim}}~{\mathit{rt}}_1)`.

  * :math:`{|C{.}\mathsf{elems}|}` is greater than :math:`y`.

  * :math:`C{.}\mathsf{elems}{}[y]` is :math:`{\mathit{rt}}_2`.

  * The reference type :math:`{\mathit{rt}}_2` matches the reference type :math:`{\mathit{rt}}_1`.


* The instruction :math:`(\mathsf{elem{.}drop}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{elems}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{elems}{}[x]` is :math:`{\mathit{rt}}`.


* The instruction :math:`(\mathsf{memory{.}size}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{mems}{}[x]` is :math:`{\mathit{mt}}`.


* The instruction :math:`(\mathsf{memory{.}grow}~x)` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{mems}{}[x]` is :math:`{\mathit{mt}}`.


* The instruction :math:`(\mathsf{memory{.}fill}~x)` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{mems}{}[x]` is :math:`{\mathit{mt}}`.


* The instruction :math:`(\mathsf{memory{.}copy}~x_1~x_2)` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`x_1`.

  * :math:`C{.}\mathsf{mems}{}[x_1]` is :math:`{\mathit{mt}}_1`.

  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`x_2`.

  * :math:`C{.}\mathsf{mems}{}[x_2]` is :math:`{\mathit{mt}}_2`.


* The instruction :math:`(\mathsf{memory{.}init}~x~y)` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{mems}{}[x]` is :math:`{\mathit{mt}}`.

  * :math:`{|C{.}\mathsf{datas}|}` is greater than :math:`y`.

  * :math:`C{.}\mathsf{datas}{}[y]` is :math:`\mathsf{ok}`.


* The instruction :math:`(\mathsf{data{.}drop}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{datas}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{datas}{}[x]` is :math:`\mathsf{ok}`.


* The instruction :math:`({{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}{.}\mathsf{load}}{{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 2}}}^?}}~x~{\mathit{memarg}})` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{mems}{}[x]` is :math:`{\mathit{mt}}`.

  * Either:

    * :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{nt}}`.

    * :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 2}}}^?}` is :math:`\epsilon`.

    * :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is :math:`{\mathit{nt}}`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

  * Or:

    * :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathsf{i}}{N}`.

    * :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 2}}}^?}` is :math:`(M~{\mathit{sx}})`.

    * :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is :math:`{\mathsf{i}}{N}`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.


* The instruction :math:`({{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}{.}\mathsf{store}}{{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~x~{\mathit{memarg}})` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{mems}{}[x]` is :math:`{\mathit{mt}}`.

  * Either:

    * :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{nt}}`.

    * :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is :math:`\epsilon`.

    * :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is :math:`{\mathit{nt}}`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

  * Or:

    * :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathsf{i}}{N}`.

    * :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is :math:`M`.

    * :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is :math:`{\mathsf{i}}{N}`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.


* The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{{\mathit{vloadop\_u{\kern-0.1em\scriptstyle 0}}}^?}}~x~{\mathit{memarg}})` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{mems}{}[x]` is :math:`{\mathit{mt}}`.

  * Either:

    * :math:`{{\mathit{vloadop\_u{\kern-0.1em\scriptstyle 0}}}^?}` is :math:`\epsilon`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|\mathsf{v{\scriptstyle 128}}|} / 8`.

  * Or:

    * :math:`{{\mathit{vloadop\_u{\kern-0.1em\scriptstyle 0}}}^?}` is :math:`({M}{\mathsf{x}}{N}{\mathsf{\_}}{{\mathit{sx}}})`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8 \cdot N`.
  * Or:

    * :math:`{{\mathit{vloadop\_u{\kern-0.1em\scriptstyle 0}}}^?}` is :math:`({N}{\mathsf{\_}}{\mathsf{splat}})`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.
  * Or:

    * :math:`{{\mathit{vloadop\_u{\kern-0.1em\scriptstyle 0}}}^?}` is :math:`({N}{\mathsf{\_}}{\mathsf{zero}})`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.


* The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{N}{\mathsf{\_}}{\mathsf{lane}}~x~{\mathit{memarg}}~i)` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{mems}{}[x]` is :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.

  * :math:`i` is less than :math:`128 / N`.


* The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{store}~x~{\mathit{memarg}})` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{mems}{}[x]` is :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|\mathsf{v{\scriptstyle 128}}|} / 8`.


* The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{store}}{N}{\mathsf{\_}}{\mathsf{lane}}~x~{\mathit{memarg}}~i)` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\epsilon` if:


  * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`x`.

  * :math:`C{.}\mathsf{mems}{}[x]` is :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.

  * :math:`i` is less than :math:`128 / N`.


* The instruction sequence :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is valid with the instruction type :math:`{\mathit{instrtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` if:


  * Either:

    * :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`.

    * :math:`{\mathit{instrtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` is :math:`\epsilon~\rightarrow~\epsilon`.

  * Or:

    * :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}`.

    * :math:`{\mathit{instrtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` is :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}~{x_2^\ast}}\,{t_3^\ast}`.

    * The instruction :math:`{\mathit{instr}}_1` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}}\,{t_2^\ast}`.

    * :math:`{|{\mathit{t*}}|}` is :math:`{|{\mathit{init*}}|}`.

    * :math:`{|x_{\mathit{{\scriptstyle 1}*}}|}` is :math:`{|{\mathit{init*}}|}`.

    * For all :math:`x_1` in :math:`{x_1^\ast}`, :math:`{|C{.}\mathsf{locals}|}` is greater than :math:`x_1`.

    * For all :math:`{\mathit{init}}` in :math:`{{\mathit{init}}^\ast}` and :math:`t` in :math:`{t^\ast}` and :math:`x_1` in :math:`{x_1^\ast}`, :math:`C{.}\mathsf{locals}{}[x_1]` is :math:`({\mathit{init}}~t)`.

    * Under the context :math:`C{}[{.}\mathsf{local}{}[{x_1^\ast}] = {(\mathsf{set}~t)^\ast}]`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the instruction type :math:`{t_2^\ast}~{\rightarrow}_{{x_2^\ast}}\,{t_3^\ast}`.
  * Or:

    * :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`{{\mathit{instr}}^\ast}`.

    * :math:`{\mathit{instrtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` is :math:`{\mathit{it}'}`.

    * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{\mathit{it}}`.

    * The instruction type :math:`{\mathit{it}}` matches the instruction type :math:`{\mathit{it}'}`.

    * The instruction type :math:`{\mathit{it}'}` is valid.
  * Or:

    * :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`{{\mathit{instr}}^\ast}`.

    * :math:`{\mathit{instrtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` is :math:`{t^\ast}~{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t^\ast}~{t_2^\ast}`.

    * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.

    * The value type sequence :math:`{t^\ast}` is valid.


* The expression :math:`{{\mathit{instr}}^\ast}` is valid with the value type sequence :math:`{t^\ast}` if:


  * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`\epsilon~\rightarrow~{t^\ast}`.


* :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is const if:


  * Either: :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`({\mathit{nt}}{.}\mathsf{const}~c_{\mathit{nt}})`.

  * Or: :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`({\mathit{vt}}{.}\mathsf{const}~c_{\mathit{vt}})`.
  * Or: :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{ref{.}null}~{\mathit{ht}})`.
  * Or: :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ref{.}i{\scriptstyle 31}}`.
  * Or: :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{ref{.}func}~x)`.
  * Or: :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{struct{.}new}~x)`.
  * Or: :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{struct{.}new\_default}~x)`.
  * Or: :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{array{.}new}~x)`.
  * Or: :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{array{.}new\_default}~x)`.
  * Or: :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{array{.}new\_fixed}~x~n)`.
  * Or: :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{any{.}convert\_extern}`.
  * Or: :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{extern{.}convert\_any}`.
  * Or:

    * :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{global{.}get}~x)`.

    * :math:`{|C{.}\mathsf{globals}|}` is greater than :math:`x`.

    * :math:`C{.}\mathsf{globals}{}[x]` is :math:`(t)`.
  * Or:

    * :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`({\mathsf{i}}{N} {.} {\mathit{binop}})`.

    * :math:`{\mathsf{i}}{N}` is contained in :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 64}}`.

    * :math:`{\mathit{binop}}` is contained in :math:`\mathsf{add}~\mathsf{sub}~\mathsf{mul}`.


* :math:`{{\mathit{instr}}^\ast}` is const if:


  * For all :math:`{\mathit{instr}}` in :math:`{{\mathit{instr}}^\ast}`, :math:`{\mathit{instr}}` is const.


* The type definition :math:`(\mathsf{type}~{\mathit{rectype}})` is valid with the defined type sequence :math:`{{\mathit{dt}}^\ast}` if:


  * :math:`{|C{.}\mathsf{types}|}` is :math:`x`.

  * :math:`{{\mathit{dt}}^\ast}` is :math:`{{{{\mathrm{roll}}}_{x}^\ast}}{({\mathit{rectype}})}`.

  * Under the context :math:`C{}[{.}\mathsf{types} \mathrel{{=}{\oplus}} {{\mathit{dt}}^\ast}]`, the recursive type :math:`{\mathit{rectype}}` is valid with the oktypeidx :math:`({\mathsf{ok}}{x})`.


* The local :math:`(\mathsf{local}~t)` is valid with the local type :math:`({\mathit{init}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}~t)` if:


  * Either:

    * :math:`{\mathit{init}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{set}`.

    * :math:`{{\mathrm{default}}}_{t}` is not :math:`\epsilon`.

  * Or:

    * :math:`{\mathit{init}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{unset}`.

    * :math:`{{\mathrm{default}}}_{t}` is :math:`\epsilon`.


* The function :math:`(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}})` is valid with the defined type :math:`C{.}\mathsf{types}{}[x]` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`

  * :math:`{|{\mathit{local*}}|}` is :math:`{|{\mathit{lct*}}|}`.

  * For all :math:`{{\mathit{lt}}}` in :math:`{{{\mathit{lt}}}^\ast}` and :math:`{\mathit{local}}` in :math:`{{\mathit{local}}^\ast}`, the local :math:`{\mathit{local}}` is valid with the local type :math:`{{\mathit{lt}}}`.

  * Under the context :math:`C{}[{.}\mathsf{locals} \mathrel{{=}{\oplus}} {(\mathsf{set}~t_1)^\ast}~{{{\mathit{lt}}}^\ast}]{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_2^\ast}]{}[{.}\mathsf{return} \mathrel{{=}{\oplus}} {t_2^\ast}]`, the expression :math:`{\mathit{expr}}` is valid with the value type sequence :math:`{t_2^\ast}`.


* The global :math:`(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}})` is valid with the global type :math:`{\mathit{globaltype}}` if:


  * The global type :math:`{\mathit{gt}}` is valid.

  * :math:`{\mathit{globaltype}}` is :math:`({\mathsf{mut}^?}~t)`.

  * The expression :math:`{\mathit{expr}}` is valid with the value type :math:`t`.

  * :math:`{\mathit{expr}}` is const.


* The table :math:`(\mathsf{table}~{\mathit{tabletype}}~{\mathit{expr}})` is valid with the table type :math:`{\mathit{tabletype}}` if:


  * The table type :math:`{\mathit{tt}}` is valid.

  * :math:`{\mathit{tabletype}}` is :math:`({\mathit{lim}}~{\mathit{rt}})`.

  * The expression :math:`{\mathit{expr}}` is valid with the value type :math:`{\mathit{rt}}`.

  * :math:`{\mathit{expr}}` is const.


* The memory :math:`(\mathsf{memory}~{\mathit{memtype}})` is valid with the memory type :math:`{\mathit{memtype}}` if:


  * The memory type :math:`{\mathit{memtype}}` is valid.


* The tag :math:`(\mathsf{tag}~x)` is valid with the memory type :math:`C{.}\mathsf{types}{}[x]` if:


  * :math:`{|C{.}\mathsf{types}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{types}{}[x]` is :math:`(\mathsf{func}~{\mathit{functype}})`


* The elemmode :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valid with the element type :math:`{\mathit{rt}}` if:


  * Either:

    * :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{active}~x~{\mathit{expr}})`.

    * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x`.

    * :math:`C{.}\mathsf{tables}{}[x]` is :math:`({\mathit{lim}}~{\mathit{rt}'})`.

    * The reference type :math:`{\mathit{rt}}` matches the reference type :math:`{\mathit{rt}'}`.

    * The expression :math:`{\mathit{expr}}` is valid with the value type :math:`\mathsf{i{\scriptstyle 32}}`.

    * :math:`{\mathit{expr}}` is const.

  * Or: :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{passive}`.
  * Or: :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{declare}`.


* The table segment :math:`(\mathsf{elem}~{\mathit{elemtype}}~{{\mathit{expr}}^\ast}~{\mathit{elemmode}})` is valid with the element type :math:`{\mathit{elemtype}}` if:


  * The reference type :math:`{\mathit{elemtype}}` is valid.

  * For all :math:`{\mathit{expr}}` in :math:`{{\mathit{expr}}^\ast}`,

    * The expression :math:`{\mathit{expr}}` is valid with the value type :math:`{\mathit{elemtype}}`.

    * :math:`{\mathit{expr}}` is const.

  * The elemmode :math:`{\mathit{elemmode}}` is valid with the element type :math:`{\mathit{elemtype}}`.


* The datamode :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valid with the data type :math:`\mathsf{ok}` if:


  * Either:

    * :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{active}~x~{\mathit{expr}})`.

    * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`x`.

    * :math:`C{.}\mathsf{mems}{}[x]` is :math:`{\mathit{mt}}`.

    * The expression :math:`{\mathit{expr}}` is valid with the value type :math:`\mathsf{i{\scriptstyle 32}}`.

    * :math:`{\mathit{expr}}` is const.

  * Or: :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{passive}`.


* The memory segment :math:`(\mathsf{data}~{b^\ast}~{\mathit{datamode}})` is valid with the data type :math:`\mathsf{ok}` if:


  * The datamode :math:`{\mathit{datamode}}` is valid with the data type :math:`\mathsf{ok}`.


* The start function :math:`(\mathsf{start}~x)` is valid if:


  * :math:`{|C{.}\mathsf{funcs}|}` is greater than :math:`x`.

  * The :ref:`expansion <aux-expand-deftype>` of :math:`C{.}\mathsf{funcs}{}[x]` is :math:`(\mathsf{func}~\epsilon~\rightarrow~\epsilon)`


* The import :math:`(\mathsf{import}~{\mathit{name}}_1~{\mathit{name}}_2~{\mathit{xt}})` is valid with the external type :math:`{\mathit{xt}}` if:


  * The external type :math:`{\mathit{xt}}` is valid.


* The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valid with the external type :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


  * Either:

    * :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{func}~x)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{func}~{\mathit{dt}})`.

    * :math:`{|C{.}\mathsf{funcs}|}` is greater than :math:`x`.

    * :math:`C{.}\mathsf{funcs}{}[x]` is :math:`{\mathit{dt}}`.

  * Or:

    * :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{global}~x)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{global}~{\mathit{gt}})`.

    * :math:`{|C{.}\mathsf{globals}|}` is greater than :math:`x`.

    * :math:`C{.}\mathsf{globals}{}[x]` is :math:`{\mathit{gt}}`.
  * Or:

    * :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{table}~x)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{table}~{\mathit{tt}})`.

    * :math:`{|C{.}\mathsf{tables}|}` is greater than :math:`x`.

    * :math:`C{.}\mathsf{tables}{}[x]` is :math:`{\mathit{tt}}`.
  * Or:

    * :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{mem}~x)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{mem}~{\mathit{mt}})`.

    * :math:`{|C{.}\mathsf{mems}|}` is greater than :math:`x`.

    * :math:`C{.}\mathsf{mems}{}[x]` is :math:`{\mathit{mt}}`.
  * Or:

    * :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{tag}~x)`.

    * :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`(\mathsf{tag}~{\mathit{at}})`.

    * :math:`{|C{.}\mathsf{tags}|}` is greater than :math:`x`.

    * :math:`C{.}\mathsf{tags}{}[x]` is :math:`{\mathit{at}}`.


* The export :math:`(\mathsf{export}~{\mathit{name}}~{\mathit{externidx}})` is valid with the name :math:`{\mathit{name}}` and the external type :math:`{\mathit{xt}}` if:


  * The external index :math:`{\mathit{externidx}}` is valid with the external type :math:`{\mathit{xt}}`.


* The global sequence :math:`{{\mathit{global}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is valid with the global type sequence :math:`{{\mathit{globaltype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` if:


  * Either:

    * :math:`{{\mathit{global}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`.

    * :math:`{{\mathit{globaltype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\epsilon`.

  * Or:

    * :math:`{{\mathit{global}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`{\mathit{global}}_1~{{\mathit{global}}^\ast}`.

    * :math:`{{\mathit{globaltype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`{\mathit{gt}}_1~{{\mathit{gt}}^\ast}`.

    * The global :math:`{\mathit{global}}_1` is valid with the global type :math:`{\mathit{gt}}_1`.

    * Under the context :math:`C{}[{.}\mathsf{globals} \mathrel{{=}{\oplus}} {\mathit{gt}}_1]`, the global sequence :math:`{{\mathit{global}}^\ast}` is valid with the global type sequence :math:`{{\mathit{gt}}^\ast}`.


* The type definition sequence :math:`{{\mathit{type}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is valid with the defined type sequence :math:`{{\mathit{deftype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` if:


  * Either:

    * :math:`{{\mathit{type}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`.

    * :math:`{{\mathit{deftype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\epsilon`.

  * Or:

    * :math:`{{\mathit{type}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`{\mathit{type}}_1~{{\mathit{type}}^\ast}`.

    * :math:`{{\mathit{deftype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`{{\mathit{dt}}_1^\ast}~{{\mathit{dt}}^\ast}`.

    * The type definition :math:`{\mathit{type}}_1` is valid with the defined type sequence :math:`{{\mathit{dt}}_1^\ast}`.

    * Under the context :math:`C{}[{.}\mathsf{types} \mathrel{{=}{\oplus}} {{\mathit{dt}}_1^\ast}]`, the type definition sequence :math:`{{\mathit{type}}^\ast}` is valid with the defined type sequence :math:`{{\mathit{dt}}^\ast}`.


* The module :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{tag}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` is valid with the module type :math:`{{\mathrm{clos}}}_{C}({{\mathit{xt}}_{\mathsf{i}}^\ast}~\rightarrow~{{\mathit{xt}}_{\mathsf{e}}^\ast})` if:


  * Under the context :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{recs}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{tags}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon,\; \mathsf{return}~\epsilon,\; \mathsf{refs}~\epsilon \}\end{array}`, the type definition sequence :math:`{{\mathit{type}}^\ast}` is valid with the defined type sequence :math:`{{\mathit{dt}'}^\ast}`.

  * :math:`{|{\mathit{xt}}_{\mathsf{i*}}|}` is :math:`{|{\mathit{import*}}|}`.

  * For all :math:`{\mathit{import}}` in :math:`{{\mathit{import}}^\ast}` and :math:`{\mathit{xt}}_{\mathsf{i}}` in :math:`{{\mathit{xt}}_{\mathsf{i}}^\ast}`, under the context :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{dt}'}^\ast},\; \mathsf{recs}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{tags}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon,\; \mathsf{return}~\epsilon,\; \mathsf{refs}~\epsilon \}\end{array}`, the import :math:`{\mathit{import}}` is valid with the external type :math:`{\mathit{xt}}_{\mathsf{i}}`.

  * Under the context :math:`{C'}`, the global sequence :math:`{{\mathit{global}}^\ast}` is valid with the global type sequence :math:`{{\mathit{gt}}^\ast}`.

  * :math:`{|{\mathit{tt*}}|}` is :math:`{|{\mathit{table*}}|}`.

  * For all :math:`{\mathit{table}}` in :math:`{{\mathit{table}}^\ast}` and :math:`{\mathit{tt}}` in :math:`{{\mathit{tt}}^\ast}`, under the context :math:`{C'}`, the table :math:`{\mathit{table}}` is valid with the table type :math:`{\mathit{tt}}`.

  * :math:`{|{\mathit{mt*}}|}` is :math:`{|{\mathit{mem*}}|}`.

  * For all :math:`{\mathit{mem}}` in :math:`{{\mathit{mem}}^\ast}` and :math:`{\mathit{mt}}` in :math:`{{\mathit{mt}}^\ast}`, under the context :math:`{C'}`, the memory :math:`{\mathit{mem}}` is valid with the memory type :math:`{\mathit{mt}}`.

  * :math:`{|{\mathit{tag*}}|}` is :math:`{|{\mathit{at*}}|}`.

  * For all :math:`{\mathit{at}}` in :math:`{{\mathit{at}}^\ast}` and :math:`{\mathit{tag}}` in :math:`{{\mathit{tag}}^\ast}`, under the context :math:`{C'}`, the tag :math:`{\mathit{tag}}` is valid with the memory type :math:`{\mathit{at}}`.

  * :math:`{|{\mathit{func*}}|}` is :math:`{|{\mathit{dt*}}|}`.

  * For all :math:`{\mathit{dt}}` in :math:`{{\mathit{dt}}^\ast}` and :math:`{\mathit{func}}` in :math:`{{\mathit{func}}^\ast}`, the function :math:`{\mathit{func}}` is valid with the defined type :math:`{\mathit{dt}}`.

  * :math:`{|{\mathit{rt*}}|}` is :math:`{|{\mathit{elem*}}|}`.

  * For all :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}` and :math:`{\mathit{rt}}` in :math:`{{\mathit{rt}}^\ast}`, the table segment :math:`{\mathit{elem}}` is valid with the element type :math:`{\mathit{rt}}`.

  * :math:`{|{\mathit{ok*}}|}` is :math:`{|{\mathit{data*}}|}`.

  * For all :math:`{\mathit{data}}` in :math:`{{\mathit{data}}^\ast}` and :math:`{\mathit{ok}}` in :math:`{{\mathit{ok}}^\ast}`, the memory segment :math:`{\mathit{data}}` is valid with the data type :math:`{\mathit{ok}}`.

  * If :math:`{\mathit{start}}` is defined, the start function :math:`{\mathit{start}}` is valid.

  * :math:`{|{\mathit{nm*}}|}` is :math:`{|{\mathit{export*}}|}`.

  * :math:`{|{\mathit{xt}}_{\mathsf{e*}}|}` is :math:`{|{\mathit{export*}}|}`.

  * For all :math:`{\mathit{export}}` in :math:`{{\mathit{export}}^\ast}` and :math:`{\mathit{nm}}` in :math:`{{\mathit{nm}}^\ast}` and :math:`{\mathit{xt}}_{\mathsf{e}}` in :math:`{{\mathit{xt}}_{\mathsf{e}}^\ast}`, the export :math:`{\mathit{export}}` is valid with the name :math:`{\mathit{nm}}` and the external type :math:`{\mathit{xt}}_{\mathsf{e}}`.

  * :math:`{{\mathit{nm}}^\ast}~{\mathrm{disjoint}}` is true.

  * :math:`C` is :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{dt}'}^\ast},\; \mathsf{recs}~\epsilon,\; \mathsf{funcs}~{{\mathit{dt}}_{\mathsf{i}}^\ast}~{{\mathit{dt}}^\ast},\; \mathsf{globals}~{{\mathit{gt}}_{\mathsf{i}}^\ast}~{{\mathit{gt}}^\ast},\; \mathsf{tables}~{{\mathit{tt}}_{\mathsf{i}}^\ast}~{{\mathit{tt}}^\ast},\; \mathsf{mems}~{{\mathit{mt}}_{\mathsf{i}}^\ast}~{{\mathit{mt}}^\ast},\; \mathsf{tags}~{{\mathit{at}}_{\mathsf{i}}^\ast}~{{\mathit{at}}^\ast},\; \mathsf{elems}~{{\mathit{rt}}^\ast},\; \mathsf{datas}~{{\mathit{ok}}^\ast},\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon,\; \mathsf{return}~\epsilon,\; \mathsf{refs}~{x^\ast} \}\end{array}`.

  * :math:`{C'}` is :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{dt}'}^\ast},\; \mathsf{recs}~\epsilon,\; \mathsf{funcs}~{{\mathit{dt}}_{\mathsf{i}}^\ast}~{{\mathit{dt}}^\ast},\; \mathsf{globals}~{{\mathit{gt}}_{\mathsf{i}}^\ast},\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{tags}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon,\; \mathsf{return}~\epsilon,\; \mathsf{refs}~{x^\ast} \}\end{array}`.

  * :math:`{x^\ast}` is :math:`{\mathrm{funcidx}}(({{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}))`.

  * :math:`{{\mathit{dt}}_{\mathsf{i}}^\ast}` is :math:`{\mathrm{funcs}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

  * :math:`{{\mathit{gt}}_{\mathsf{i}}^\ast}` is :math:`{\mathrm{globals}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

  * :math:`{{\mathit{tt}}_{\mathsf{i}}^\ast}` is :math:`{\mathrm{tables}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

  * :math:`{{\mathit{mt}}_{\mathsf{i}}^\ast}` is :math:`{\mathrm{mems}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

  * :math:`{{\mathit{at}}_{\mathsf{i}}^\ast}` is :math:`{\mathrm{tags}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.


* The instruction sequence :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valid with the function type :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}~\rightarrow~{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}^\ast}` if:


  * Either:

    * :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{i{\scriptstyle 32}} {.} \mathsf{add})`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}^\ast}` is :math:`\mathsf{i{\scriptstyle 32}}`.

  * Or:

    * :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{global{.}get}~x)`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\epsilon`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}^\ast}` is :math:`t`.

    * :math:`{|C{.}\mathsf{globals}|}` is greater than :math:`x`.

    * :math:`C{.}\mathsf{globals}{}[x]` is :math:`({\mathsf{mut}^?}~t)`.
  * Or:

    * :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`(\mathsf{block}~{\mathit{blocktype}}~{{\mathit{instr}}^\ast})`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`{t_1^\ast}`.

    * :math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}^\ast}` is :math:`{t_2^\ast}`.

    * The block type :math:`{\mathit{blocktype}}` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

    * Under the context :math:`C{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_2^\ast}]`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.


:math:`\mathsf{unreachable}`
............................


1. Trap.


:math:`\mathsf{nop}`
....................


1. Do nothing.


:math:`\mathsf{drop}`
.....................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Do nothing.


:math:`\mathsf{select}~{({t^\ast})^?}`
......................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_2` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_1` from the stack.

#. If :math:`c` is not :math:`0`, then:

  a. Push the value :math:`{\mathit{val}}_1` to the stack.

#. Else:

  a. Push the value :math:`{\mathit{val}}_2` to the stack.


:math:`\mathsf{if}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast}~{{\mathit{instr}}_2^\ast}`
.....................................................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c` is not :math:`0`, then:

  a. Execute the instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast})`.

#. Else:

  a. Execute the instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}_2^\ast})`.


:math:`\mathsf{label}`
......................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, a label is now on the top of the stack.

#. Pop the current label from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.


:math:`\mathsf{br}~l`
.....................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. If the top of the stack is a :math:`\mathsf{label}`, then:

  a. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Let :math:`L` be the current label.

  #. Let :math:`n` be the arity of :math:`L`.

  #. Let :math:`{{\mathit{instr}'}^\ast}` be the continuation of :math:`L`.

  #. If :math:`l` is :math:`0`, then:

    1) Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

    #) Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

    #) Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

    #) Pop the current label from the stack.

    #) Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

    #) Execute the instruction :math:`{{\mathit{instr}'}^\ast}`.

  #. Else:

    1) Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

    #) If :math:`l` is greater than :math:`0`, then:

      a) Pop the current label from the stack.

      #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

      #) Execute the instruction :math:`(\mathsf{br}~l - 1)`.

#. Else if the top of the stack is a :math:`\mathsf{handler}`, then:

  a. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

  #. Exit from :math:`\mathsf{handler}`.

  #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{br\_if}~l`
.........................


1. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c` is not :math:`0`, then:

  a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

  a. Do nothing.


:math:`\mathsf{br\_table}~{l^\ast}~{l'}`
........................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i` is less than :math:`{|{l^\ast}|}`, then:

  a. Execute the instruction :math:`(\mathsf{br}~{l^\ast}{}[i])`.

#. Else:

  a. Execute the instruction :math:`(\mathsf{br}~{l'})`.


:math:`\mathsf{br\_on\_null}~l`
...............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

  a. Push the value :math:`{\mathit{val}}` to the stack.


:math:`\mathsf{br\_on\_non\_null}~l`
....................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Do nothing.

#. Else:

  a. Push the value :math:`{\mathit{val}}` to the stack.

  #. Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{call\_indirect}~x~y`
...................................


1. Execute the instruction :math:`(\mathsf{table{.}get}~x)`.

#. Execute the instruction :math:`(\mathsf{ref{.}cast}~(\mathsf{ref}~(\mathsf{null}~()~{}^?)~y))`.

#. Execute the instruction :math:`(\mathsf{call\_ref}~y)`.


:math:`\mathsf{return\_call\_indirect}~x~y`
...........................................


1. Execute the instruction :math:`(\mathsf{table{.}get}~x)`.

#. Execute the instruction :math:`(\mathsf{ref{.}cast}~(\mathsf{ref}~(\mathsf{null}~()~{}^?)~y))`.

#. Execute the instruction :math:`(\mathsf{return\_call\_ref}~y)`.


:math:`\mathsf{frame}`
......................


1. Let :math:`F` be the current frame.

#. Let :math:`n` be the arity of :math:`F`.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Assert: Due to validation, a frame is now on the top of the stack.

#. Pop the current frame from the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.


:math:`\mathsf{return}`
.......................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. If the top of the stack is a :math:`\mathsf{frame}`, then:

  a. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Let :math:`F` be the current frame.

  #. Let :math:`n` be the arity of :math:`F`.

  #. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

  #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

  #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

  #. Pop the current frame from the stack.

  #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Else if the top of the stack is a :math:`\mathsf{label}`, then:

  a. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

  #. Pop the current label from the stack.

  #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Execute the instruction :math:`\mathsf{return}`.

#. Else:

  a. If the top of the stack is a :math:`\mathsf{handler}`, then:

    1) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

    #) Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

    #) Exit from :math:`\mathsf{handler}`.

    #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

    #) Execute the instruction :math:`\mathsf{return}`.


:math:`\mathsf{handler}`
........................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, a handler is now on the top of the stack.

#. Exit from :math:`\mathsf{handler}`.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{unop}}`
.........................................


1. Assert: Due to validation, a value of value type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{nt}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{unop}}}{{}_{{\mathit{nt}}}(c_1)}|}` is less than or equal to :math:`0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{unop}}}{{}_{{\mathit{nt}}}(c_1)}`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{binop}}`
..........................................


1. Assert: Due to validation, a value of value type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{nt}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`{\mathit{numtype}}_0` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{binop}}}{{}_{{\mathit{nt}}}(c_1, c_2)}|}` is less than or equal to :math:`0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{binop}}}{{}_{{\mathit{nt}}}(c_1, c_2)}`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{testop}}`
...........................................


1. Assert: Due to validation, a value of value type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{nt}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{testop}}}{{}_{{\mathit{nt}}}(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{relop}}`
..........................................


1. Assert: Due to validation, a value of value type :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{nt}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`{\mathit{numtype}}_0` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{relop}}}{{}_{{\mathit{nt}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}}_2 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_1}`
............................................................................


1. Assert: Due to validation, a value of value type :math:`{\mathit{nt}}_1` is on the top of the stack.

#. Pop the value :math:`({\mathit{nt}}_1{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{cvtop}}}{{}_{{\mathit{nt}}_1, {\mathit{nt}}_2}(c_1)}|}` is less than or equal to :math:`0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{cvtop}}}{{}_{{\mathit{nt}}_1, {\mathit{nt}}_2}(c_1)}`.

#. Push the value :math:`({\mathit{nt}}_2{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{ref{.}i{\scriptstyle 31}}`
.........................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Push the value :math:`(\mathsf{ref{.}i{\scriptstyle 31}}~{{\mathrm{wrap}}}_{32, 31}(i))` to the stack.


:math:`\mathsf{ref{.}is\_null}`
...............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. If :math:`{\mathit{ref}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`\mathsf{ref{.}as\_non\_null}`
....................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. If :math:`{\mathit{ref}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. Push the value :math:`{\mathit{ref}}` to the stack.


:math:`\mathsf{ref{.}eq}`
.........................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}_2` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}_1` from the stack.

#. If :math:`{\mathit{ref}}_1` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. If :math:`{\mathit{ref}}_2` is of the case :math:`\mathsf{ref{.}null}`, then:

    1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

  #. Else if :math:`{\mathit{ref}}_1` is :math:`{\mathit{ref}}_2`, then:

    1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

  #. Else:

    1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.

#. Else if :math:`{\mathit{ref}}_1` is :math:`{\mathit{ref}}_2`, then:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`{\mathsf{i{\scriptstyle 31}{.}get}}{\mathsf{\_}}{{\mathit{sx}}}`
.......................................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}i{\scriptstyle 31}}`, then:

  a. Let :math:`(\mathsf{ref{.}i{\scriptstyle 31}}~i)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{31, 32}^{{\mathit{sx}}}}}{(i)})` to the stack.


:math:`\mathsf{array{.}new}~x`
..............................


1. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)`.


:math:`\mathsf{extern{.}convert\_any}`
......................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Push the value :math:`(\mathsf{ref{.}null}~\mathsf{extern})` to the stack.

#. If the type of :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is addrref, then:

  a. Let :math:`{\mathit{addrref}}` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Push the value :math:`(\mathsf{ref{.}extern}~{\mathit{addrref}})` to the stack.


:math:`\mathsf{any{.}convert\_extern}`
......................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Push the value :math:`(\mathsf{ref{.}null}~\mathsf{any})` to the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}extern}`, then:

  a. Let :math:`(\mathsf{ref{.}extern}~{\mathit{addrref}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Push the value :math:`{\mathit{addrref}}` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvunop}}`
..........................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{|{{\mathit{vvunop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1)}|}` is greater than :math:`0`.

#. Let :math:`c` be an element of :math:`{{\mathit{vvunop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvbinop}}`
...........................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{|{{\mathit{vvbinop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2)}|}` is greater than :math:`0`.

#. Let :math:`c` be an element of :math:`{{\mathit{vvbinop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvternop}}`
............................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_3)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{|{{\mathit{vvternop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2, c_3)}|}` is greater than :math:`0`.

#. Let :math:`c` be an element of :math:`{{\mathit{vvternop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2, c_3)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} \mathsf{any\_true}`
...........................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{ine}}}_{{|\mathsf{v{\scriptstyle 128}}|}}(c_1, 0)`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vunop}}`
..........................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{vunop}}}{{}_{{\mathit{sh}}}(c_1)}|}` is less than or equal to :math:`0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vunop}}}{{}_{{\mathit{sh}}}(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vbinop}}`
...........................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{vbinop}}}{{}_{{\mathit{sh}}}(c_1, c_2)}|}` is less than or equal to :math:`0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vbinop}}}{{}_{{\mathit{sh}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{N}}{\mathsf{x}}{M} {.} \mathsf{all\_true}`
...............................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c)`.

#. If for all :math:`{({\mathit{ci}}_1)^\ast}`, :math:`{\mathit{ci}}_1` is not :math:`0`, then:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vrelop}}`
...........................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vrelop}}}{{}_{{\mathit{sh}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{N}}{\mathsf{x}}{M} {.} {\mathit{vshiftop}}`
................................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`{{c'}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c_1)`.

#. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({{{\mathit{vshiftop}}}{{}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}}{({c'}, n)}^\ast})}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{N}}{\mathsf{x}}{M}{.}\mathsf{bitmask}`
...........................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c)`.

#. Let :math:`{\mathit{ci}}` be the result for which :math:`{{\mathrm{bits}}}_{{\mathsf{i}}{32}}({\mathit{ci}})` :math:`=` :math:`{{{{{\mathrm{ilt}}}_{{|{\mathsf{i}}{N}|}}^{\mathsf{s}}}}{({\mathit{ci}}_1, 0)}^\ast}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{\mathit{ci}})` to the stack.


:math:`{{\mathsf{i}}{N}}{\mathsf{x}}{M}{.}\mathsf{swizzle}`
...........................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`{{c'}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c_1)~{0^{256 - M}}`.

#. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c_2)`.

#. Assert: Due to validation, for all :math:`{(k)^{k<M}}`, :math:`{{\mathit{ci}}^\ast}{}[k]` is less than :math:`{|{{c'}^\ast}|}`.

#. Assert: Due to validation, for all :math:`{(k)^{k<M}}`, :math:`k` is less than :math:`{|{{\mathit{ci}}^\ast}|}`.

#. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({{{c'}^\ast}{}[{{\mathit{ci}}^\ast}{}[k]]^{k<M}})}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{N}}{\mathsf{x}}{M}{.}\mathsf{shuffle}~{i^\ast}`
....................................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, for all :math:`{(k)^{k<M}}`, :math:`k` is less than :math:`{|{i^\ast}|}`.

#. Let :math:`{{c'}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c_1)~{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c_2)`.

#. Assert: Due to validation, for all :math:`{(k)^{k<M}}`, :math:`{i^\ast}{}[k]` is less than :math:`{|{{c'}^\ast}|}`.

#. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({{{c'}^\ast}{}[{i^\ast}{}[k]]^{k<M}})}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{N}}{\mathsf{x}}{M}{.}\mathsf{splat}`
.........................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0` is :math:`{\mathrm{unpack}}({\mathsf{i}}{N})`.

#. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({{{\mathrm{pack}}}_{{\mathsf{i}}{N}}(c_1)^{M}})}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}{\mathsf{x}}{M}{.}\mathsf{extract\_lane}}{\mathsf{\_}}{{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~i`
.........................................................................................................................................................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is numtype, then:

  a. Let :math:`{\mathit{nt}}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If :math:`i` is less than :math:`{|{{\mathrm{lanes}}}_{{{\mathit{nt}}}{\mathsf{x}}{M}}(c_1)|}`, then:

    1) Let :math:`c_2` be :math:`{{\mathrm{lanes}}}_{{{\mathit{nt}}}{\mathsf{x}}{M}}(c_1){}[i]`.

    #) Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c_2)` to the stack.

#. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is packtype, then:

  a. Let :math:`{\mathit{pt}}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

    1) Let :math:`{\mathit{sx}}` be :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

    #) If :math:`i` is less than :math:`{|{{\mathrm{lanes}}}_{{{\mathit{pt}}}{\mathsf{x}}{M}}(c_1)|}`, then:

      a) Let :math:`c_2` be :math:`{{{{\mathrm{extend}}}_{{|{\mathit{pt}}|}, 32}^{{\mathit{sx}}}}}{({{\mathrm{lanes}}}_{{{\mathit{pt}}}{\mathsf{x}}{M}}(c_1){}[i])}`.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c_2)` to the stack.


:math:`{{\mathsf{i}}{N}}{\mathsf{x}}{M}{.}\mathsf{replace\_lane}~i`
...................................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0` is :math:`{\mathrm{unpack}}({\mathsf{i}}{N})`.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c_1){}[{}[i] = {{\mathrm{pack}}}_{{\mathsf{i}}{N}}(c_2)])}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}_2 {.} {{\mathit{vextunop}}}{\mathsf{\_}}{{\mathit{sh}}_1}`
...............................................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vextunop}}}{{}_{{\mathit{sh}}_1, {\mathit{sh}}_2}(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}_2 {.} {{\mathit{vextbinop}}}{\mathsf{\_}}{{\mathit{sh}}_1}`
................................................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vextbinop}}}{{}_{{\mathit{sh}}_1, {\mathit{sh}}_2}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}{.}\mathsf{narrow}}{\mathsf{\_}}{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}{\mathsf{\_}}{{\mathit{sx}}}`
...................................................................................................................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(c_1)`.

#. Let :math:`{{\mathit{ci}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(c_2)`.

#. Let :math:`{{\mathit{cj}}_1^\ast}` be :math:`{{{{{\mathrm{narrow}}}_{{|{{\mathsf{i}}{N}}_1|}, {|{{\mathsf{i}}{N}}_2|}}^{{\mathit{sx}}}}}{{\mathit{ci}}_1}^\ast}`.

#. Let :math:`{{\mathit{cj}}_2^\ast}` be :math:`{{{{{\mathrm{narrow}}}_{{|{{\mathsf{i}}{N}}_1|}, {|{{\mathsf{i}}{N}}_2|}}^{{\mathit{sx}}}}}{{\mathit{ci}}_2}^\ast}`.

#. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({{\mathit{cj}}_1^\ast}~{{\mathit{cj}}_2^\ast})}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 5}}}}{\mathsf{x}}{n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}} {.} {{\mathit{vcvtop}}}{\mathsf{\_}}{{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 13}}}^?}}{\mathsf{\_}}{{{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 6}}}}{\mathsf{x}}{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}{\mathsf{\_}}{{{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}^?}}`
............................................................................................................................................................................................................................................................................................................................................................................................................................................


1. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}^?}` is not defined and :math:`{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 13}}}^?}` is not defined, then:

  a. Let :math:`{{\mathsf{i}}{N}}_1` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 6}}}`.

  #. Let :math:`{{\mathsf{i}}{N}}_2` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 5}}}`.

  #. Let :math:`M` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`M`, then:

    1) Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M}}(c_1)`.

    #) Let :math:`{{{\mathit{cj}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{vcvtop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M}}({\mathit{vcvtop}}, {\mathit{ci}})^\ast}`.

    #) If :math:`{|{{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M}}^{{-1}}}}{({{\mathit{cj}}^\ast})}^\ast}|}` is greater than :math:`0`, then:

      a) Let :math:`c` be an element of :math:`{{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M}}^{{-1}}}}{({{\mathit{cj}}^\ast})}^\ast}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. If :math:`{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 13}}}^?}` is not defined, then:

  a. Let :math:`{{\mathsf{i}}{N}}_1` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 6}}}`.

  #. Let :math:`{{\mathsf{i}}{N}}_2` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 5}}}`.

  #. Let :math:`M_1` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`M_2` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If :math:`{{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}^?}` is defined, then:

    1) Let :math:`{\mathit{half}}` be :math:`{{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}^?}`.

    #) Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(c_1){}[{\mathrm{half}}({\mathit{half}}, 0, M_2) : M_2]`.

    #) Let :math:`{{{\mathit{cj}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{vcvtop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}, {\mathit{ci}})^\ast}`.

    #) If :math:`{|{{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({{\mathit{cj}}^\ast})}^\ast}|}` is greater than :math:`0`, then:

      a) Let :math:`c` be an element of :math:`{{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({{\mathit{cj}}^\ast})}^\ast}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. If :math:`{{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}^?}` is not defined, then:

  a. Let :math:`M_1` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`M_2` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 6}}}` is numtype, then:

    1) Let :math:`{\mathit{nt}}_1` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 6}}}`.

    #) If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 5}}}` is numtype, then:

      a) Let :math:`{\mathit{nt}}_2` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 5}}}`.

      #) If :math:`{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 13}}}^?}` is defined, then:

        1. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{nt}}_1}{\mathsf{x}}{M_1}}(c_1)`.

        #. Let :math:`{{{\mathit{cj}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{vcvtop}}}_{{{\mathit{nt}}_1}{\mathsf{x}}{M_1}, {{\mathit{nt}}_2}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}, {\mathit{ci}})^\ast}~{0^{M_1}}`.

        #. If :math:`{|{{{{{\mathrm{lanes}}}_{{{\mathit{nt}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({{\mathit{cj}}^\ast})}^\ast}|}` is greater than :math:`0`, then:

          a. Let :math:`c` be an element of :math:`{{{{{\mathrm{lanes}}}_{{{\mathit{nt}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({{\mathit{cj}}^\ast})}^\ast}`.

          #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{local{.}tee}~x`
..............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Execute the instruction :math:`(\mathsf{local{.}set}~x)`.


:math:`\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}^\ast}`
............................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{m}}~\rightarrow~{t_2^{n}}` be :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`m` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{m}}` from the stack.

#. Let :math:`L` be the label whose arity is :math:`n` and whose continuation is :math:`\epsilon`.

#. Enter :math:`{{\mathit{val}}^{m}}~{{\mathit{instr}}^\ast}` with label :math:`L`.


:math:`\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast}`
...........................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{m}}~\rightarrow~{t_2^{n}}` be :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`m` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{m}}` from the stack.

#. Let :math:`L` be the label whose arity is :math:`m` and whose continuation is :math:`(\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast})`.

#. Enter :math:`{{\mathit{val}}^{m}}~{{\mathit{instr}}^\ast}` with label :math:`L`.


:math:`\mathsf{br\_on\_cast}~l~{\mathit{rt}}_1~{\mathit{rt}}_2`
...............................................................


1. Let :math:`f` be the current frame.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Let :math:`{\mathit{rt}}` be :math:`{\mathrm{Ref}}_{\mathit{type}}({\mathit{ref}})`.

#. Push the value :math:`{\mathit{ref}}` to the stack.

#. If :math:`{\mathit{rt}}` does not match :math:`{{\mathrm{inst}}}_{f{.}\mathsf{module}}({\mathit{rt}}_2)`, then:

  a. Do nothing.

#. Else:

  a. Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{br\_on\_cast\_fail}~l~{\mathit{rt}}_1~{\mathit{rt}}_2`
.....................................................................


1. Let :math:`f` be the current frame.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Let :math:`{\mathit{rt}}` be :math:`{\mathrm{Ref}}_{\mathit{type}}({\mathit{ref}})`.

#. Push the value :math:`{\mathit{ref}}` to the stack.

#. If :math:`{\mathit{rt}}` matches :math:`{{\mathrm{inst}}}_{f{.}\mathsf{module}}({\mathit{rt}}_2)`, then:

  a. Do nothing.

#. Else:

  a. Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{call}~x`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x` is less than :math:`{|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Let :math:`a` be :math:`z{.}\mathsf{module}{.}\mathsf{funcs}{}[x]`.

#. Assert: Due to validation, :math:`a` is less than :math:`{|z{.}\mathsf{funcs}|}`.

#. Push the value :math:`(\mathsf{ref{.}func}~a)` to the stack.

#. Execute the instruction :math:`(\mathsf{call\_ref}~z{.}\mathsf{funcs}{}[a]{.}\mathsf{type})`.


:math:`\mathsf{call\_ref}~y`
............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}func}`, then:

  a. Let :math:`(\mathsf{ref{.}func}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If :math:`a` is less than :math:`{|z{.}\mathsf{funcs}|}`, then:

    1) Let :math:`{\mathit{fi}}` be :math:`z{.}\mathsf{funcs}{}[a]`.

    #) Assert: Due to validation, :math:`{\mathit{fi}}{.}\mathsf{code}` is of the case :math:`\mathsf{func}`.

    #) Let :math:`(\mathsf{func}~x~{{\mathit{local}}_0^\ast}~{{\mathit{instr}}^\ast})` be :math:`{\mathit{fi}}{.}\mathsf{code}`.

    #) If for all :math:`{({\mathit{local}}_0)^\ast}`, :math:`{\mathit{local}}_0` is of the case :math:`\mathsf{local}`, then:

      a) Let :math:`{(\mathsf{local}~t)^\ast}` be :math:`{{\mathit{local}}_0^\ast}`.

      #) Assert: Due to validation, :math:`{\mathrm{expand}}({\mathit{fi}}{.}\mathsf{type})` is of the case :math:`\mathsf{func}`.

      #) Let :math:`(\mathsf{func}~{\mathit{functype}}_0)` be :math:`{\mathrm{expand}}({\mathit{fi}}{.}\mathsf{type})`.

      #) Let :math:`{t_1^{n}}~\rightarrow~{t_2^{m}}` be :math:`{\mathit{functype}}_0`.

      #) Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

      #) Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

      #) Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~{{\mathit{val}}^{n}}~{{{\mathrm{default}}}_{t}^\ast},\; \mathsf{module}~{\mathit{fi}}{.}\mathsf{module} \}\end{array}`.

      #) Let :math:`F` be the activation of :math:`f` with arity :math:`m`.

      #) Push :math:`F` to the stack.

      #) Let :math:`L` be the label whose arity is :math:`m` and whose continuation is :math:`\epsilon`.

      #) Enter :math:`{{\mathit{instr}}^\ast}` with label :math:`L`.


:math:`\mathsf{return\_call}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x` is less than :math:`{|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Let :math:`a` be :math:`z{.}\mathsf{module}{.}\mathsf{funcs}{}[x]`.

#. Assert: Due to validation, :math:`a` is less than :math:`{|z{.}\mathsf{funcs}|}`.

#. Push the value :math:`(\mathsf{ref{.}func}~a)` to the stack.

#. Execute the instruction :math:`(\mathsf{return\_call\_ref}~z{.}\mathsf{funcs}{}[a]{.}\mathsf{type})`.


:math:`\mathsf{return\_call\_ref}~y`
....................................


1. Let :math:`z` be the current state.

#. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. If the top of the stack is a :math:`\mathsf{label}`, then:

  a. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

  #. Pop the current label from the stack.

  #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Execute the instruction :math:`(\mathsf{return\_call\_ref}~y)`.

#. Else if the top of the stack is a :math:`\mathsf{handler}`, then:

  a. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

  #. Exit from :math:`\mathsf{handler}`.

  #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Execute the instruction :math:`(\mathsf{return\_call\_ref}~y)`.

#. Else:

  a. If the top of the stack is a :math:`\mathsf{frame}`, then:

    1) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

    #) Assert: Due to validation, a value is on the top of the stack.

    #) Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` from the stack.

    #) Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

    #) If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

      a) Pop the current frame from the stack.

      #) Trap.

    #) If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}func}`, then:

      a) Let :math:`(\mathsf{ref{.}func}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

      #) If :math:`a` is less than :math:`{|z{.}\mathsf{funcs}|}`, then:

        1. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{funcs}{}[a]{.}\mathsf{type})` is of the case :math:`\mathsf{func}`.

        #. Let :math:`(\mathsf{func}~{\mathit{functype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{funcs}{}[a]{.}\mathsf{type})`.

        #. Let :math:`{t_1^{n}}~\rightarrow~{t_2^{m}}` be :math:`{\mathit{functype}}_0`.

        #. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

        #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

        #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

        #. Pop the current frame from the stack.

        #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

        #. Push the value :math:`(\mathsf{ref{.}func}~a)` to the stack.

        #. Execute the instruction :math:`(\mathsf{call\_ref}~y)`.


:math:`\mathsf{throw\_ref}`
...........................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. If :math:`{{\mathit{val}}^\ast}` is not :math:`\epsilon`, then:

  a. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}exn}`, then:

    1) Let :math:`(\mathsf{ref{.}exn}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

    #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

    #) Execute the instruction :math:`\mathsf{throw\_ref}`.

#. Else:

  a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

  #. If the top of the stack is a :math:`\mathsf{label}`, then:

    1) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

    #) If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}exn}`, then:

      a) Let :math:`(\mathsf{ref{.}exn}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

      #) Pop the current label from the stack.

      #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

      #) Execute the instruction :math:`\mathsf{throw\_ref}`.

  #. Else if the top of the stack is a :math:`\mathsf{frame}`, then:

    1) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

    #) If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}exn}`, then:

      a) Let :math:`(\mathsf{ref{.}exn}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

      #) Pop the current frame from the stack.

      #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

      #) Execute the instruction :math:`\mathsf{throw\_ref}`.

  #. Else:

    1) If not the top of the stack is a :math:`\mathsf{handler}`, then:

      a) Throw the exception :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` as a result.

    #) Else:

      a) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

      #) Let :math:`({{\mathsf{handler}}_{n}}{\{}~{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}~\})` be the current context.

      #) If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}exn}`, then:

        1. Let :math:`(\mathsf{ref{.}exn}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

        #. If :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\epsilon`, then:

          a. Exit from :math:`\mathsf{handler}`.

          #. Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

          #. Execute the instruction :math:`\mathsf{throw\_ref}`.

        #. Else if :math:`a` is greater than or equal to :math:`{|z{.}\mathsf{exns}|}`, then:

          a. Let :math:`{\mathit{catch}}_0~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

          #. If :math:`{\mathit{catch}}_0` is of the case :math:`\mathsf{catch\_all}`, then:

            1) Let :math:`(\mathsf{catch\_all}~l)` be :math:`{\mathit{catch}}_0`.

            #) Exit from :math:`\mathsf{handler}`.

            #) Execute the instruction :math:`(\mathsf{br}~l)`.

          #. Else if :math:`{\mathit{catch}}_0` is of the case :math:`\mathsf{catch\_all\_ref}`, then:

            1) Let :math:`(\mathsf{catch\_all\_ref}~l)` be :math:`{\mathit{catch}}_0`.

            #) Exit from :math:`\mathsf{handler}`.

            #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

            #) Execute the instruction :math:`(\mathsf{br}~l)`.

          #. Else:

            1) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

            #) Exit from :math:`\mathsf{handler}`.

            #) Let :math:`H` be :math:`({{\mathsf{handler}}_{n}}{\{}~{{\mathit{catch}'}^\ast}~\})`.

            #) Push the handler :math:`H` to the stack.

            #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

            #) Execute the instruction :math:`\mathsf{throw\_ref}`.

        #. Else:

          a. Let :math:`{{\mathit{val}}^\ast}` be :math:`z{.}\mathsf{exns}{}[a]{.}\mathsf{fields}`.

          #. Let :math:`{\mathit{catch}}_0~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

          #. If :math:`{\mathit{catch}}_0` is of the case :math:`\mathsf{catch}`, then:

            1) Let :math:`(\mathsf{catch}~x~l)` be :math:`{\mathit{catch}}_0`.

            #) If :math:`x` is less than :math:`{|z{.}\mathsf{tags}|}` and :math:`z{.}\mathsf{exns}{}[a]{.}\mathsf{tag}` is :math:`z{.}\mathsf{tags}{}[x]`, then:

              a) Exit from :math:`\mathsf{handler}`.

              #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

              #) Execute the instruction :math:`(\mathsf{br}~l)`.

            #) Else:

              a) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

              #) Exit from :math:`\mathsf{handler}`.

              #) Let :math:`H` be :math:`({{\mathsf{handler}}_{n}}{\{}~{{\mathit{catch}'}^\ast}~\})`.

              #) Push the handler :math:`H` to the stack.

              #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

              #) Execute the instruction :math:`\mathsf{throw\_ref}`.

          #. Else if :math:`{\mathit{catch}}_0` is of the case :math:`\mathsf{catch\_ref}`, then:

            1) Let :math:`(\mathsf{catch\_ref}~x~l)` be :math:`{\mathit{catch}}_0`.

            #) If :math:`x` is less than :math:`{|z{.}\mathsf{tags}|}` and :math:`z{.}\mathsf{exns}{}[a]{.}\mathsf{tag}` is :math:`z{.}\mathsf{tags}{}[x]`, then:

              a) Exit from :math:`\mathsf{handler}`.

              #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

              #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

              #) Execute the instruction :math:`(\mathsf{br}~l)`.

            #) Else:

              a) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

              #) Exit from :math:`\mathsf{handler}`.

              #) Let :math:`H` be :math:`({{\mathsf{handler}}_{n}}{\{}~{{\mathit{catch}'}^\ast}~\})`.

              #) Push the handler :math:`H` to the stack.

              #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

              #) Execute the instruction :math:`\mathsf{throw\_ref}`.

          #. Else:

            1) If :math:`{\mathit{catch}}_0` is of the case :math:`\mathsf{catch\_all}`, then:

              a) Let :math:`(\mathsf{catch\_all}~l)` be :math:`{\mathit{catch}}_0`.

              #) Exit from :math:`\mathsf{handler}`.

              #) Execute the instruction :math:`(\mathsf{br}~l)`.

            #) Else if :math:`{\mathit{catch}}_0` is of the case :math:`\mathsf{catch\_all\_ref}`, then:

              a) Let :math:`(\mathsf{catch\_all\_ref}~l)` be :math:`{\mathit{catch}}_0`.

              #) Exit from :math:`\mathsf{handler}`.

              #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

              #) Execute the instruction :math:`(\mathsf{br}~l)`.

            #) Else:

              a) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

              #) Exit from :math:`\mathsf{handler}`.

              #) Let :math:`H` be :math:`({{\mathsf{handler}}_{n}}{\{}~{{\mathit{catch}'}^\ast}~\})`.

              #) Push the handler :math:`H` to the stack.

              #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

              #) Execute the instruction :math:`\mathsf{throw\_ref}`.


:math:`\mathsf{try\_table}~{\mathit{bt}}~{{\mathit{catch}}^\ast}~{{\mathit{instr}}^\ast}`
.........................................................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{m}}~\rightarrow~{t_2^{n}}` be :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`m` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{m}}` from the stack.

#. Let :math:`H` be :math:`({{\mathsf{handler}}_{n}}{\{}~{{\mathit{catch}}^\ast}~\})`.

#. Push the handler :math:`H` to the stack.

#. Let :math:`L` be the label whose arity is :math:`n` and whose continuation is :math:`\epsilon`.

#. Enter :math:`{{\mathit{val}}^{m}}~{{\mathit{instr}}^\ast}` with label :math:`L`.


:math:`\mathsf{ref{.}null}~x`
.............................


1. Let :math:`z` be the current state.

#. Push the value :math:`(\mathsf{ref{.}null}~z{.}\mathsf{types}{}[x])` to the stack.


:math:`\mathsf{ref{.}func}~x`
.............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x` is less than :math:`{|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Push the value :math:`(\mathsf{ref{.}func}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x])` to the stack.


:math:`\mathsf{ref{.}test}~{\mathit{rt}}`
.........................................


1. Let :math:`f` be the current frame.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Let :math:`{\mathit{rt}'}` be :math:`{\mathrm{Ref}}_{\mathit{type}}({\mathit{ref}})`.

#. If :math:`{\mathit{rt}'}` matches :math:`{{\mathrm{inst}}}_{f{.}\mathsf{module}}({\mathit{rt}})`, then:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`\mathsf{ref{.}cast}~{\mathit{rt}}`
.........................................


1. Let :math:`f` be the current frame.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Let :math:`{\mathit{rt}'}` be :math:`{\mathrm{Ref}}_{\mathit{type}}({\mathit{ref}})`.

#. If :math:`{\mathit{rt}'}` does not match :math:`{{\mathrm{inst}}}_{f{.}\mathsf{module}}({\mathit{rt}})`, then:

  a. Trap.

#. Push the value :math:`{\mathit{ref}}` to the stack.


:math:`\mathsf{struct{.}new\_default}~x`
........................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{struct}`.

#. Let :math:`(\mathsf{struct}~{{\mathit{fieldtype}}_0^\ast})` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

#. Let :math:`{({\mathsf{mut}^?}~{\mathit{zt}})^\ast}` be :math:`{{\mathit{fieldtype}}_0^\ast}`.

#. Assert: Due to validation, for all :math:`{({\mathit{val}}, {\mathit{zt}})^\ast}`, :math:`{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}` is defined.

#. Let :math:`{{\mathit{val}}^\ast}` be :math:`{{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}^\ast}`.

#. Assert: Due to validation, :math:`{|{\mathit{val*}}|}` is :math:`{|{\mathit{zt*}}|}`.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

#. Execute the instruction :math:`(\mathsf{struct{.}new}~x)`.


:math:`{\mathsf{struct{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x~i`
...................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}struct}`, then:

  a. Let :math:`(\mathsf{ref{.}struct}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If :math:`i` is less than :math:`{|z{.}\mathsf{structs}{}[a]{.}\mathsf{fields}|}` and :math:`a` is less than :math:`{|z{.}\mathsf{structs}|}`, then:

    1) Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{struct}`.

    #) Let :math:`(\mathsf{struct}~{{\mathit{fieldtype}}_0^\ast})` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

    #) Let :math:`{({\mathsf{mut}^?}~{\mathit{zt}})^\ast}` be :math:`{{\mathit{fieldtype}}_0^\ast}`.

    #) If :math:`i` is less than :math:`{|{{\mathit{zt}}^\ast}|}`, then:

      a) Push the value :math:`{{{{\mathrm{unpack}}}_{{{\mathit{zt}}^\ast}{}[i]}^{{{\mathit{sx}}^?}}}}{(z{.}\mathsf{structs}{}[a]{.}\mathsf{fields}{}[i])}` to the stack.


:math:`\mathsf{array{.}new\_default}~x`
.......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{array}`.

#. Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

#. Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be :math:`{\mathit{arraytype}}_0`.

#. Assert: Due to validation, :math:`{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}` is defined.

#. Let :math:`{\mathit{val}}` be :math:`{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}`.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)`.


:math:`\mathsf{array{.}new\_elem}~x~y`
......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n` is greater than :math:`{|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. Assert: Due to validation, :math:`{|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[i : n]|}` is :math:`n`.

#. Let :math:`{{\mathit{ref}}^\ast}` be :math:`z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[i : n]`.

#. Push the values :math:`{{\mathit{ref}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)`.


:math:`\mathsf{array{.}new\_data}~x~y`
......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{array}`.

#. Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

#. Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be :math:`{\mathit{arraytype}}_0`.

#. If :math:`i + n \cdot {|{\mathit{zt}}|} / 8` is greater than :math:`{|z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. Assert: Due to validation, the length of :math:`({\mathit{fresh}}_1)` for which :math:`{\bigoplus}\, {\mathit{fresh}}_1` :math:`=` :math:`z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}{}[i : n \cdot {|{\mathit{zt}}|} / 8]` is :math:`n`.

#. Let :math:`{{\mathit{byte}}^\ast}` be the result for which :math:`{\bigoplus}\, {{\mathit{byte}}^\ast}` :math:`=` :math:`z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}{}[i : n \cdot {|{\mathit{zt}}|} / 8]`.

#. Let :math:`{c^\ast}` be the result for which for all :math:`{({\mathit{byte}})^\ast}`, :math:`{{\mathrm{bytes}}}_{{\mathit{zt}}}({c^\ast})` is :math:`{\mathit{byte}}`.

#. Push the values :math:`{{\mathrm{unpack}}({\mathit{zt}}){.}\mathsf{const}~{{\mathrm{unpack}}}_{{\mathit{zt}}}(c)^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)`.


:math:`{\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x`
................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}array}`, then:

  a. Let :math:`(\mathsf{ref{.}array}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If :math:`a` is less than :math:`{|z{.}\mathsf{arrays}|}` and :math:`i` is greater than or equal to :math:`{|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

    1) Trap.

  #. If :math:`i` is less than :math:`{|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}` and :math:`a` is less than :math:`{|z{.}\mathsf{arrays}|}`, then:

    1) Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{array}`.

    #) Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

    #) Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be :math:`{\mathit{arraytype}}_0`.

    #) Push the value :math:`{{{{\mathrm{unpack}}}_{{\mathit{zt}}}^{{{\mathit{sx}}^?}}}}{(z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}{}[i])}` to the stack.


:math:`\mathsf{array{.}len}`
............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}array}`, then:

  a. Let :math:`(\mathsf{ref{.}array}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If :math:`a` is less than :math:`{|z{.}\mathsf{arrays}|}`, then:

    1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|})` to the stack.


:math:`\mathsf{array{.}fill}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}array}`, then:

  a. Let :math:`(\mathsf{ref{.}array}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If :math:`a` is greater than or equal to :math:`{|z{.}\mathsf{arrays}|}`, then:

    1) Do nothing.

  #. Else if :math:`i + n` is greater than :math:`{|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

    1) Trap.

  #. If :math:`n` is :math:`0`, then:

    1) Do nothing.

  #. Else:

    1) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

    #) Push the value :math:`{\mathit{val}}` to the stack.

    #) Execute the instruction :math:`(\mathsf{array{.}set}~x)`.

    #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

    #) Push the value :math:`{\mathit{val}}` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

    #) Execute the instruction :math:`(\mathsf{array{.}fill}~x)`.


:math:`\mathsf{array{.}copy}~x_1~x_2`
.....................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}null}` and the type of :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is ref, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}null}` and the type of :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is ref, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}array}`, then:

  a. Let :math:`(\mathsf{ref{.}array}~a_1)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}array}`, then:

    1) If :math:`a_1` is less than :math:`{|z{.}\mathsf{arrays}|}` and :math:`i_1 + n` is greater than :math:`{|z{.}\mathsf{arrays}{}[a_1]{.}\mathsf{fields}|}`, then:

      a) Trap.

    #) Let :math:`(\mathsf{ref{.}array}~a_2)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

    #) If :math:`a_2` is greater than or equal to :math:`{|z{.}\mathsf{arrays}|}`, then:

      a) Do nothing.

    #) Else if :math:`i_2 + n` is greater than :math:`{|z{.}\mathsf{arrays}{}[a_2]{.}\mathsf{fields}|}`, then:

      a) Trap.

    #) If :math:`n` is :math:`0`, then:

      a) Do nothing.

    #) Else if :math:`i_1` is less than or equal to :math:`i_2` and :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x_2])` is of the case :math:`\mathsf{array}`, then:

      a) Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x_2])`.

      #) Let :math:`({\mathsf{mut}^?}~{\mathit{zt}}_2)` be :math:`{\mathit{arraytype}}_0`.

      #) Let :math:`{{\mathit{sx}}^?}` be :math:`{\mathrm{sx}}({\mathit{zt}}_2)`.

      #) Push the value :math:`(\mathsf{ref{.}array}~a_1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1)` to the stack.

      #) Push the value :math:`(\mathsf{ref{.}array}~a_2)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2)` to the stack.

      #) Execute the instruction :math:`({\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x_2)`.

      #) Execute the instruction :math:`(\mathsf{array{.}set}~x_1)`.

      #) Push the value :math:`(\mathsf{ref{.}array}~a_1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1 + 1)` to the stack.

      #) Push the value :math:`(\mathsf{ref{.}array}~a_2)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2 + 1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

      #) Execute the instruction :math:`(\mathsf{array{.}copy}~x_1~x_2)`.

    #) Else:

      a) If :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x_2])` is of the case :math:`\mathsf{array}`, then:

        1. Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x_2])`.

        #. Let :math:`({\mathsf{mut}^?}~{\mathit{zt}}_2)` be :math:`{\mathit{arraytype}}_0`.

        #. Let :math:`{{\mathit{sx}}^?}` be :math:`{\mathrm{sx}}({\mathit{zt}}_2)`.

        #. Push the value :math:`(\mathsf{ref{.}array}~a_1)` to the stack.

        #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1 + n - 1)` to the stack.

        #. Push the value :math:`(\mathsf{ref{.}array}~a_2)` to the stack.

        #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2 + n - 1)` to the stack.

        #. Execute the instruction :math:`({\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x_2)`.

        #. Execute the instruction :math:`(\mathsf{array{.}set}~x_1)`.

        #. Push the value :math:`(\mathsf{ref{.}array}~a_1)` to the stack.

        #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1)` to the stack.

        #. Push the value :math:`(\mathsf{ref{.}array}~a_2)` to the stack.

        #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2)` to the stack.

        #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

        #. Execute the instruction :math:`(\mathsf{array{.}copy}~x_1~x_2)`.

  #. Else if :math:`n` is not :math:`0`, then:

    1) Do nothing.


:math:`\mathsf{array{.}init\_elem}~x~y`
.......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}array}`, then:

  a. Let :math:`(\mathsf{ref{.}array}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If :math:`a` is less than :math:`{|z{.}\mathsf{arrays}|}` and :math:`i + n` is greater than :math:`{|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

    1) Trap.

  #. If :math:`j + n` is greater than :math:`{|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

    1) Trap.

  #. If :math:`n` is :math:`0`, then:

    1) Do nothing.

  #. Else if :math:`j` is less than :math:`{|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

    1) Let :math:`{\mathit{ref}}` be :math:`z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[j]`.

    #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

    #) Push the value :math:`{\mathit{ref}}` to the stack.

    #) Execute the instruction :math:`(\mathsf{array{.}set}~x)`.

    #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

    #) Execute the instruction :math:`(\mathsf{array{.}init\_elem}~x~y)`.


:math:`\mathsf{array{.}init\_data}~x~y`
.......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}array}`, then:

  a. Let :math:`(\mathsf{ref{.}array}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If :math:`a` is less than :math:`{|z{.}\mathsf{arrays}|}` and :math:`i + n` is greater than :math:`{|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

    1) Trap.

  #. If :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{array}`, then:

    1) Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

    #) Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be :math:`{\mathit{arraytype}}_0`.

    #) If :math:`j + n \cdot {|{\mathit{zt}}|} / 8` is greater than :math:`{|z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}|}`, then:

      a) Trap.

    #) If :math:`n` is :math:`0`, then:

      a) Do nothing.

    #) Else:

      a) Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathit{zt}}}(c)` :math:`=` :math:`z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}{}[j : {|{\mathit{zt}}|} / 8]`.

      #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

      #) Push the value :math:`{\mathrm{unpack}}({\mathit{zt}}){.}\mathsf{const}~{{\mathrm{unpack}}}_{{\mathit{zt}}}(c)` to the stack.

      #) Execute the instruction :math:`(\mathsf{array{.}set}~x)`.

      #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + {|{\mathit{zt}}|} / 8)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

      #) Execute the instruction :math:`(\mathsf{array{.}init\_data}~x~y)`.

  #. Else if :math:`n` is :math:`0`, then:

    1) Do nothing.


:math:`\mathsf{local{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`z{.}\mathsf{locals}{}[x]` is defined.

#. Let :math:`{\mathit{val}}` be :math:`z{.}\mathsf{locals}{}[x]`.

#. Push the value :math:`{\mathit{val}}` to the stack.


:math:`\mathsf{global{.}get}~x`
...............................


1. Let :math:`z` be the current state.

#. Let :math:`{\mathit{val}}` be :math:`z{.}\mathsf{globals}{}[x]{.}\mathsf{value}`.

#. Push the value :math:`{\mathit{val}}` to the stack.


:math:`\mathsf{table{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i` is greater than or equal to :math:`{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. Push the value :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i]` to the stack.


:math:`\mathsf{table{.}size}~x`
...............................


1. Let :math:`z` be the current state.

#. Let :math:`n` be :math:`{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{table{.}fill}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n` is greater than :math:`{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`n` is :math:`0`, then:

  a. Do nothing.

#. Else:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

  #. Push the value :math:`{\mathit{val}}` to the stack.

  #. Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

  #. Push the value :math:`{\mathit{val}}` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`(\mathsf{table{.}fill}~x)`.


:math:`\mathsf{table{.}copy}~x~y`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n` is greater than :math:`{|z{.}\mathsf{tables}{}[y]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`j + n` is greater than :math:`{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`n` is :math:`0`, then:

  a. Do nothing.

#. Else:

  a. If :math:`j` is less than or equal to :math:`i`, then:

    1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

    #) Execute the instruction :math:`(\mathsf{table{.}get}~y)`.

    #) Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

  #. Else:

    1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + n - 1)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + n - 1)` to the stack.

    #) Execute the instruction :math:`(\mathsf{table{.}get}~y)`.

    #) Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`(\mathsf{table{.}copy}~x~y)`.


:math:`\mathsf{table{.}init}~x~y`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n` is greater than :math:`{|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`j + n` is greater than :math:`{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`n` is :math:`0`, then:

  a. Do nothing.

#. Else if :math:`i` is less than :math:`{|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

  #. Push the value :math:`z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[i]` to the stack.

  #. Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`(\mathsf{table{.}init}~x~y)`.


:math:`{{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}{.}\mathsf{load}}{{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 2}}}^?}}~x~{\mathit{ao}}`
.........................................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 2}}}^?}` is not defined, then:

  a. Let :math:`{\mathit{nt}}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}}|} / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

    1) Trap.

  #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathit{nt}}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}}|} / 8]`.

  #. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.

#. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Inn, then:

  a. If :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 2}}}^?}` is defined, then:

    1) Let :math:`{\mathit{loadop\_{\scriptstyle 0}}}` be :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 2}}}^?}`.

    #) Let :math:`(n~{\mathit{sx}})` be :math:`{\mathit{loadop\_{\scriptstyle 0}}}`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

      a) Trap.

  #. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 2}}}^?}` is defined, then:

    1) Let :math:`{\mathit{loadop\_{\scriptstyle 0}}}` be :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 2}}}^?}`.

    #) Let :math:`(n~{\mathit{sx}})` be :math:`{\mathit{loadop\_{\scriptstyle 0}}}`.

    #) Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8]`.

    #) Push the value :math:`({\mathsf{i}}{N}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{n, {|{\mathsf{i}}{N}|}}^{{\mathit{sx}}}}}{(c)})` to the stack.


:math:`{\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{{\mathit{vloadop\_u{\kern-0.1em\scriptstyle 0}}}^?}}~x~{\mathit{ao}}`
............................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|\mathsf{v{\scriptstyle 128}}|} / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}` and :math:`{{\mathit{vloadop\_u{\kern-0.1em\scriptstyle 0}}}^?}` is not defined, then:

  a. Trap.

#. If :math:`{{\mathit{vloadop\_u{\kern-0.1em\scriptstyle 0}}}^?}` is not defined, then:

  a. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{\mathsf{v{\scriptstyle 128}}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|\mathsf{v{\scriptstyle 128}}|} / 8]`.

  #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. Else:

  a. Let :math:`{\mathit{vloadop\_{\scriptstyle 0}}}` be :math:`{{\mathit{vloadop\_u{\kern-0.1em\scriptstyle 0}}}^?}`.

  #. If :math:`{\mathit{vloadop\_{\scriptstyle 0}}}` is of the case :math:`\mathsf{shape}`, then:

    1) Let :math:`({M}{\mathsf{x}}{K}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vloadop\_{\scriptstyle 0}}}`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + M \cdot K / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

      a) Trap.

    #) Let :math:`{j^{K}}` be the result for which for all :math:`{(k)^{k<K}}`, :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{M}}({j^{K}})` is :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} + k \cdot M / 8 : M / 8]`.

    #) If the type of :math:`N` for which :math:`N` :math:`=` :math:`M \cdot 2` is Jnn, then:

      a) Let :math:`{\mathsf{i}}{N}` be the result for which :math:`N` :math:`=` :math:`M \cdot 2`.

      #) Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{K}}^{{-1}}}}{({{{{{\mathrm{extend}}}_{M, N}^{{\mathit{sx}}}}}{(j)}^{K}})}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

  #. If :math:`{\mathit{vloadop\_{\scriptstyle 0}}}` is of the case :math:`\mathsf{splat}`, then:

    1) Let :math:`({N}{\mathsf{\_}}{\mathsf{splat}})` be :math:`{\mathit{vloadop\_{\scriptstyle 0}}}`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

      a) Trap.

    #) Let :math:`M` be :math:`128 / N`.

    #) If the type of :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`N` is Jnn, then:

      a) Let :math:`{\mathsf{i}}{N}` be the result for which :math:`{|{\mathsf{i}}{N}|}` :math:`=` :math:`N`.

      #) Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

      #) Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({j^{M}})}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

  #. If :math:`{\mathit{vloadop\_{\scriptstyle 0}}}` is of the case :math:`\mathsf{zero}`, then:

    1) Let :math:`({N}{\mathsf{\_}}{\mathsf{zero}})` be :math:`{\mathit{vloadop\_{\scriptstyle 0}}}`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

      a) Trap.

    #) Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

    #) Let :math:`c` be :math:`{{{{\mathrm{extend}}}_{N, 128}^{\mathsf{u}}}}{(j)}`.

    #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{N}{\mathsf{\_}}{\mathsf{lane}}~x~{\mathit{ao}}~j`
.......................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. Let :math:`M` be :math:`{|\mathsf{v{\scriptstyle 128}}|} / N`.

#. If the type of :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`N` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{N}` be the result for which :math:`{|{\mathsf{i}}{N}|}` :math:`=` :math:`N`.

  #. Let :math:`k` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(k)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

  #. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c_1){}[{}[j] = k])}`.

  #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{memory{.}size}~x`
................................


1. Let :math:`z` be the current state.

#. Let :math:`n \cdot 64 \, {\mathrm{Ki}}` be :math:`{|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{memory{.}fill}~x`
................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n` is greater than :math:`{|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. If :math:`n` is :math:`0`, then:

  a. Do nothing.

#. Else:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

  #. Push the value :math:`{\mathit{val}}` to the stack.

  #. Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8}~x)`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

  #. Push the value :math:`{\mathit{val}}` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`(\mathsf{memory{.}fill}~x)`.


:math:`\mathsf{memory{.}copy}~x_1~x_2`
......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1)` from the stack.

#. If :math:`i_1 + n` is greater than :math:`{|z{.}\mathsf{mems}{}[x_1]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. If :math:`i_2 + n` is greater than :math:`{|z{.}\mathsf{mems}{}[x_2]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. If :math:`n` is :math:`0`, then:

  a. Do nothing.

#. Else:

  a. If :math:`i_1` is less than or equal to :math:`i_2`, then:

    1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2)` to the stack.

    #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{load}}{8~\mathsf{u}}~x_2)`.

    #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8}~x_1)`.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1 + 1)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2 + 1)` to the stack.

  #. Else:

    1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1 + n - 1)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2 + n - 1)` to the stack.

    #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{load}}{8~\mathsf{u}}~x_2)`.

    #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8}~x_1)`.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`(\mathsf{memory{.}copy}~x_1~x_2)`.


:math:`\mathsf{memory{.}init}~x~y`
..................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n` is greater than :math:`{|z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. If :math:`j + n` is greater than :math:`{|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. If :math:`n` is :math:`0`, then:

  a. Do nothing.

#. Else if :math:`i` is less than :math:`{|z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}|}`, then:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}{}[i])` to the stack.

  #. Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8}~x)`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`(\mathsf{memory{.}init}~x~y)`.


:math:`\mathsf{throw}~x`
........................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x` is less than :math:`{|z{.}\mathsf{tags}|}`.

#. Let :math:`a` be :math:`{|z{.}\mathsf{exns}|}`.

#. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{tags}{}[x]{.}\mathsf{type})` is of the case :math:`\mathsf{func}`.

#. Let :math:`(\mathsf{func}~{\mathit{functype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{tags}{}[x]{.}\mathsf{type})`.

#. Let :math:`{t^{n}}~\rightarrow~{\mathit{valtype}}_1` be :math:`{\mathit{functype}}_0`.

#. Assert: Due to validation, :math:`{\mathit{valtype}}_1` is :math:`\epsilon`.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Let :math:`{\mathit{exn}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{tag}~z{.}\mathsf{tags}{}[x],\; \mathsf{fields}~{{\mathit{val}}^{n}} \}\end{array}`.

#. Perform :math:`z{}[{.}\mathsf{exns} \mathrel{{=}{\oplus}} {\mathit{exn}}]`.

#. Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

#. Execute the instruction :math:`\mathsf{throw\_ref}`.


:math:`\mathsf{struct{.}new}~x`
...............................


1. Let :math:`z` be the current state.

#. Let :math:`a` be :math:`{|z{.}\mathsf{structs}|}`.

#. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{struct}`.

#. Let :math:`(\mathsf{struct}~{{\mathit{fieldtype}}_0^{n}})` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

#. Let :math:`{({\mathsf{mut}^?}~{\mathit{zt}})^{n}}` be :math:`{{\mathit{fieldtype}}_0^{n}}`.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Let :math:`{\mathit{si}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~z{.}\mathsf{types}{}[x],\; \mathsf{fields}~{{{\mathrm{pack}}}_{{\mathit{zt}}}({\mathit{val}})^{n}} \}\end{array}`.

#. Push the value :math:`(\mathsf{ref{.}struct}~a)` to the stack.

#. Perform :math:`z{}[{.}\mathsf{structs} \mathrel{{=}{\oplus}} {\mathit{si}}]`.


:math:`\mathsf{struct{.}set}~x~i`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}struct}`, then:

  a. Let :math:`(\mathsf{ref{.}struct}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{struct}`.

  #. Let :math:`(\mathsf{struct}~{{\mathit{fieldtype}}_0^\ast})` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

  #. Let :math:`{({\mathsf{mut}^?}~{\mathit{zt}})^\ast}` be :math:`{{\mathit{fieldtype}}_0^\ast}`.

  #. If :math:`i` is less than :math:`{|{{\mathit{zt}}^\ast}|}`, then:

    1) Perform :math:`z{}[{.}\mathsf{structs}{}[a]{.}\mathsf{fields}{}[i] = {{\mathrm{pack}}}_{{{\mathit{zt}}^\ast}{}[i]}({\mathit{val}})]`.


:math:`\mathsf{array{.}new\_fixed}~x~n`
.......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Let :math:`a` be :math:`{|z{.}\mathsf{arrays}|}`.

#. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{array}`.

#. Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

#. Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be :math:`{\mathit{arraytype}}_0`.

#. Let :math:`{\mathit{ai}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~z{.}\mathsf{types}{}[x],\; \mathsf{fields}~{{{\mathrm{pack}}}_{{\mathit{zt}}}({\mathit{val}})^{n}} \}\end{array}`.

#. Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

#. Perform :math:`z{}[{.}\mathsf{arrays} \mathrel{{=}{\oplus}} {\mathit{ai}}]`.


:math:`\mathsf{array{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}array}`, then:

  a. Let :math:`(\mathsf{ref{.}array}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If :math:`a` is less than :math:`{|z{.}\mathsf{arrays}|}` and :math:`i` is greater than or equal to :math:`{|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

    1) Trap.

  #. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{array}`.

  #. Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

  #. Let :math:`({\mathsf{mut}^?}~{\mathit{zt}})` be :math:`{\mathit{arraytype}}_0`.

  #. Perform :math:`z{}[{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}{}[i] = {{\mathrm{pack}}}_{{\mathit{zt}}}({\mathit{val}})]`.


:math:`\mathsf{local{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{locals}{}[x] = {\mathit{val}}]`.


:math:`\mathsf{global{.}set}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = {\mathit{val}}]`.


:math:`\mathsf{table{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i` is greater than or equal to :math:`{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. Perform :math:`z{}[{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i] = {\mathit{ref}}]`.


:math:`\mathsf{table{.}grow}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Either:

  a. Let :math:`{\mathit{ti}}` be :math:`{\mathrm{growtable}}(z{.}\mathsf{tables}{}[x], n, {\mathit{ref}})`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|})` to the stack.

  #. Perform :math:`z{}[{.}\mathsf{tables}{}[x] = {\mathit{ti}}]`.

#. Or:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{32}^{{-1}}}}{({-1})})` to the stack.


:math:`\mathsf{elem{.}drop}~x`
..............................


1. Let :math:`z` be the current state.

#. Perform :math:`z{}[{.}\mathsf{elems}{}[x]{.}\mathsf{refs} = \epsilon]`.


:math:`{{\mathit{nt}}{.}\mathsf{store}}{{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}}~x~{\mathit{ao}}`
...................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`{\mathit{nt}}`, then:

  a. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}}|} / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}` and :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is not defined, then:

    1) Trap.

  #. If :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is not defined, then:

    1) Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathit{nt}}}(c)`.

    #) Perform :math:`z{}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}}|} / 8] = {b^\ast}]`.

#. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. If :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is defined, then:

    1) Let :math:`n` be :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

      a) Trap.

  #. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is defined, then:

    1) Let :math:`n` be :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}`.

    #) Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}({{\mathrm{wrap}}}_{{|{\mathsf{i}}{N}|}, n}(c))`.

    #) Perform :math:`z{}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8] = {b^\ast}]`.


:math:`\mathsf{v{\scriptstyle 128}}{.}\mathsf{store}~x~{\mathit{ao}}`
.....................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|\mathsf{v{\scriptstyle 128}}|} / 8` is greater than :math:`{|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{\mathsf{v{\scriptstyle 128}}}(c)`.

#. Perform :math:`z{}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|\mathsf{v{\scriptstyle 128}}|} / 8] = {b^\ast}]`.


:math:`{\mathsf{v{\scriptstyle 128}}{.}\mathsf{store}}{N}{\mathsf{\_}}{\mathsf{lane}}~x~{\mathit{ao}}~j`
........................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N` is greater than :math:`{|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. Let :math:`M` be :math:`128 / N`.

#. If the type of :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`N` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{N}` be the result for which :math:`{|{\mathsf{i}}{N}|}` :math:`=` :math:`N`.

  #. If :math:`j` is less than :math:`{|{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c)|}`, then:

    1) Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}({{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c){}[j])`.

    #) Perform :math:`z{}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8] = {b^\ast}]`.


:math:`\mathsf{memory{.}grow}~x`
................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of value type :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Either:

  a. Let :math:`{\mathit{mi}}` be :math:`{\mathrm{growmem}}(z{.}\mathsf{mems}{}[x], n)`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|} / 64 \, {\mathrm{Ki}})` to the stack.

  #. Perform :math:`z{}[{.}\mathsf{mems}{}[x] = {\mathit{mi}}]`.

#. Or:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{32}^{{-1}}}}{({-1})})` to the stack.


:math:`\mathsf{data{.}drop}~x`
..............................


1. Let :math:`z` be the current state.

#. Perform :math:`z{}[{.}\mathsf{datas}{}[x]{.}\mathsf{bytes} = \epsilon]`.


:math:`{\mathrm{Ki}}`
.....................


1. Return :math:`1024`.


:math:`{\mathrm{min}}(n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}, n_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
............................................................................................................


1. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`0`, then:

  a. Return :math:`0`.

#. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is :math:`0`, then:

  a. Return :math:`0`.

#. Assert: Due to validation, :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is greater than or equal to :math:`1`.

#. Let :math:`i` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 0}}} - 1`.

#. Assert: Due to validation, :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is greater than or equal to :math:`1`.

#. Let :math:`j` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}} - 1`.

#. Return :math:`{\mathrm{min}}(i, j)`.


:math:`{\Sigma}\, {n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`
...................................................................


1. If :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`0`.

#. Let :math:`n~{{n'}^\ast}` be :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`n + {\Sigma}\, {{n'}^\ast}`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`
........................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}|}` is :math:`1`.

#. Let :math:`w` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`w`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}`
.....................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is not defined, then:

  a. Return :math:`\epsilon`.

#. Let :math:`w` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}`.

#. Return :math:`w`.


:math:`{\bigoplus}\, {X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`
......................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{w^\ast}~{{{w'}^\ast}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{w^\ast}~{\bigoplus}\, {{{w'}^\ast}^\ast}`.


:math:`{\bigoplus}\, {X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`
......................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{w^{n}}~{({{w'}^{n}})^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{w^{n}}~{\bigoplus}\, {({{w'}^{n}})^\ast}`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}~{\mathrm{disjoint}}`
............................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return true.

#. Let :math:`w~{{w'}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`w` is not contained in :math:`{{w'}^\ast}` and :math:`{{w'}^\ast}~{\mathrm{disjoint}}`.


:math:`{{\mathrm{setminus{\kern-0.1em\scriptstyle 1}}}}_{{\mathit{TODO}}}(w, {X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
...............................................................................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`w`.

#. Let :math:`w_1~{{w'}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`w` is :math:`w_1`, then:

  a. Return :math:`\epsilon`.

#. Return :math:`{{\mathrm{setminus{\kern-0.1em\scriptstyle 1}}}}_{{\mathit{TODO}}}(w, {{w'}^\ast})`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast} \setminus {w^\ast}`
...........................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`w_1~{{w'}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{{\mathrm{setminus{\kern-0.1em\scriptstyle 1}}}}_{{\mathit{TODO}}}(w_1, {w^\ast})~{{w'}^\ast} \setminus {w^\ast}`.


:math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{{\mathit{TODO}}}(w_1, {X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
...................................................................................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{{w'}^\ast}~{{w^\ast}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`w_1~{{w'}^\ast}~{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{{\mathit{TODO}}}(w_1, {{w^\ast}^\ast})`.


:math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{{\mathit{TODO}}}({X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}, {{w^\ast}^\ast})`
...............................................................................................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`w_1~{{w'}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{{\mathit{TODO}}}(w_1, {{w^\ast}^\ast})~{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{{\mathit{TODO}}}({{w'}^\ast}, {{w^\ast}^\ast})`.


:math:`\Large\times~{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`
.....................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{w_1^\ast}~{{w^\ast}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{{\mathit{TODO}}}({w_1^\ast}, \Large\times~{{w^\ast}^\ast})`.


:math:`{\mathrm{signif}}(N_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
....................................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`32`, then:

  a. Return :math:`23`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`64`.

#. Return :math:`52`.


:math:`{\mathrm{expon}}(N_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
...................................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`32`, then:

  a. Return :math:`8`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`64`.

#. Return :math:`11`.


:math:`M`
.........


1. Return :math:`{\mathrm{signif}}(N)`.


:math:`E`
.........


1. Return :math:`{\mathrm{expon}}(N)`.


:math:`{+0}`
............


1. Return :math:`({+((0 + 0 \cdot {2^{{-M}}}) \cdot {2^{n}})})`.


:math:`{+1}`
............


1. Return :math:`({+((1 + 1 \cdot {2^{{-M}}}) \cdot {2^{0}})})`.


:math:`{{\mathrm{canon}}}_{N}`
..............................


1. Return :math:`{2^{{\mathrm{signif}}(N) - 1}}`.


:math:`{\mathrm{cont}}(b)`
..........................


1. Assert: Due to validation, :math:`128` is less than :math:`b`.

#. Assert: Due to validation, :math:`b` is less than :math:`192`.

#. Return :math:`b - 128`.


:math:`\mathsf{anyref}`
.......................


1. Return :math:`(\mathsf{ref}~(\mathsf{null}~()~{}^?)~\mathsf{any})`.


:math:`\mathsf{eqref}`
......................


1. Return :math:`(\mathsf{ref}~(\mathsf{null}~()~{}^?)~\mathsf{eq})`.


:math:`\mathsf{i{\scriptstyle 31}ref}`
......................................


1. Return :math:`(\mathsf{ref}~(\mathsf{null}~()~{}^?)~\mathsf{i{\scriptstyle 31}})`.


:math:`\mathsf{structref}`
..........................


1. Return :math:`(\mathsf{ref}~(\mathsf{null}~()~{}^?)~\mathsf{struct})`.


:math:`\mathsf{arrayref}`
.........................


1. Return :math:`(\mathsf{ref}~(\mathsf{null}~()~{}^?)~\mathsf{array})`.


:math:`\mathsf{funcref}`
........................


1. Return :math:`(\mathsf{ref}~(\mathsf{null}~()~{}^?)~\mathsf{func})`.


:math:`\mathsf{externref}`
..........................


1. Return :math:`(\mathsf{ref}~(\mathsf{null}~()~{}^?)~\mathsf{extern})`.


:math:`\mathsf{nullref}`
........................


1. Return :math:`(\mathsf{ref}~(\mathsf{null}~()~{}^?)~\mathsf{none})`.


:math:`\mathsf{nullfuncref}`
............................


1. Return :math:`(\mathsf{ref}~(\mathsf{null}~()~{}^?)~\mathsf{nofunc})`.


:math:`\mathsf{nullexternref}`
..............................


1. Return :math:`(\mathsf{ref}~(\mathsf{null}~()~{}^?)~\mathsf{noextern})`.


:math:`{|{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}|}`
......................................................................


1. If :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{i{\scriptstyle 32}}`, then:

  a. Return :math:`32`.

#. If :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{i{\scriptstyle 64}}`, then:

  a. Return :math:`64`.

#. If :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{f{\scriptstyle 32}}`, then:

  a. Return :math:`32`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{f{\scriptstyle 64}}`.

#. Return :math:`64`.


:math:`{|\mathsf{v{\scriptstyle 128}}|}`
........................................


1. Return :math:`128`.


:math:`{|{\mathit{packtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}|}`
.......................................................................


1. If :math:`{\mathit{packtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{i{\scriptstyle 8}}`, then:

  a. Return :math:`8`.

#. Assert: Due to validation, :math:`{\mathit{packtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{i{\scriptstyle 16}}`.

#. Return :math:`16`.


:math:`{|{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}|}`
.......................................................................


1. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is numtype, then:

  a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{|{\mathit{numtype}}|}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is packtype.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{|{\mathit{packtype}}|}`.


:math:`{|{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}|}`
..........................................................................


1. If the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is numtype, then:

  a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{|{\mathit{numtype}}|}`.

#. If the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is vectype, then:

  a. Let :math:`{\mathit{vectype}}` be :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{|{\mathit{vectype}}|}`.

#. Assert: Due to validation, the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is packtype.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{|{\mathit{packtype}}|}`.


:math:`{\mathrm{lanetype}}({{\mathsf{i}}{N}}{\mathsf{x}}{N})`
.............................................................


1. Return :math:`{\mathsf{i}}{N}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N_1`
...........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N_2`
...........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{pt}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`N_1`
...........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`N_2`
...........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`0`
.........


1. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Inn, then:

  a. Return :math:`0`.

#. Assert: Due to validation, the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{+0}`.


:math:`{\mathrm{dim}}({{\mathsf{i}}{N}}{\mathsf{x}}{N})`
........................................................


1. Return :math:`N`.


:math:`{|{{\mathsf{i}}{N}}{\mathsf{x}}{N}|}`
............................................


1. Return :math:`{|{\mathsf{i}}{N}|} \cdot N`.


:math:`{\mathsf{i}}{N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}`
...............................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`32`, then:

  a. Return :math:`\mathsf{i{\scriptstyle 32}}`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`64`.

#. Return :math:`\mathsf{i{\scriptstyle 64}}`.


:math:`{\mathsf{f}}{N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}`
...............................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`32`, then:

  a. Return :math:`\mathsf{f{\scriptstyle 32}}`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`64`.

#. Return :math:`\mathsf{f{\scriptstyle 64}}`.


:math:`{\mathsf{i}}{N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}`
...............................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`8`, then:

  a. Return :math:`\mathsf{i{\scriptstyle 8}}`.

#. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`16`, then:

  a. Return :math:`\mathsf{i{\scriptstyle 16}}`.

#. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`32`, then:

  a. Return :math:`\mathsf{i{\scriptstyle 32}}`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`64`.

#. Return :math:`\mathsf{i{\scriptstyle 64}}`.


:math:`{\mathrm{unpack}}({\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
......................................................................................


1. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is numtype, then:

  a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathit{numtype}}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is packtype.

#. Return :math:`\mathsf{i{\scriptstyle 32}}`.


:math:`{\mathrm{unpack}}({\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
.........................................................................................


1. If the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valtype, then:

  a. Let :math:`{\mathit{valtype}}` be :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathit{valtype}}`.

#. Assert: Due to validation, the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is packtype.

#. Return :math:`\mathsf{i{\scriptstyle 32}}`.


:math:`{\mathrm{unpack}}({\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
.........................................................................................


1. If the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is numtype, then:

  a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathit{numtype}}`.

#. If the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is packtype, then:

  a. Return :math:`\mathsf{i{\scriptstyle 32}}`.


:math:`{\mathrm{unpack}}({\mathit{vectype}})`
.............................................


1. Return :math:`{\mathit{vectype}}`.


:math:`{\mathrm{unpack}}({\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
.........................................................................................


1. If the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is consttype, then:

  a. Let :math:`{\mathit{consttype}}` be :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathit{consttype}}`.

#. If the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is packtype, then:

  a. Return :math:`\mathsf{i{\scriptstyle 32}}`.

#. If the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is lanetype, then:

  a. Let :math:`{\mathit{lanetype}}` be :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{unpack}}({\mathit{lanetype}})`.


:math:`{\mathrm{sx}}({\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
.....................................................................................


1. If the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is consttype, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is packtype.

#. Return :math:`\mathsf{s}`.


:math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}{.}\mathsf{const}~c`
.......................................................................................


1. If the type of :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is numtype, then:

  a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`({\mathit{numtype}}{.}\mathsf{const}~c)`.

#. Assert: Due to validation, the type of :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is vectype.

#. Let :math:`{\mathit{vectype}}` be :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`({\mathit{vectype}}{.}\mathsf{const}~c)`.


:math:`{\mathrm{unpack}}({{\mathsf{i}}{N}}{\mathsf{x}}{N})`
...........................................................


1. Return :math:`{\mathrm{unpack}}({\mathsf{i}}{N})`.


:math:`(\mathsf{ref}~{\mathsf{null}}{{{}_{1}^?}}~{\mathit{ht}}_1) \setminus (\mathsf{ref}~(\mathsf{null}~{{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}~{}^?)~{\mathit{ht}}_2)`
............................................................................................................................................................................


1. If :math:`{{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is :math:`()`, then:

  a. Return :math:`(\mathsf{ref}~(\mathsf{null}~\epsilon~{}^?)~{\mathit{ht}}_1)`.

#. Assert: Due to validation, :math:`{{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is not defined.

#. Return :math:`(\mathsf{ref}~{\mathsf{null}}{{{}_{1}^?}}~{\mathit{ht}}_1)`.


:math:`{\mathrm{free}}_{\mathit{opt}}({{\mathit{free}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?})`
...................................................................................................


1. If :math:`{{\mathit{free}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}` is not defined, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. Let :math:`{\mathit{free}}` be :math:`{{\mathit{free}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^?}`.

#. Return :math:`{\mathit{free}}`.


:math:`{\mathrm{free}}_{\mathit{list}}({{\mathit{free}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
.......................................................................................................


1. If :math:`{{\mathit{free}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. Let :math:`{\mathit{free}}~{{\mathit{free}'}^\ast}` be :math:`{{\mathit{free}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return `free ++ $free_list(free'*{free' <- free'*})`.


:math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{\mathit{typeidx}},\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~{\mathit{funcidx}},\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{globalidx}}({\mathit{globalidx}})`
..................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~{\mathit{globalidx}},\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`
................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~{\mathit{tableidx}},\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`
............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~{\mathit{memidx}},\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{elemidx}}({\mathit{elemidx}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~{\mathit{elemidx}},\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{dataidx}}({\mathit{dataidx}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~{\mathit{dataidx}},\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{localidx}}({\mathit{localidx}})`
................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~{\mathit{localidx}},\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`
................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~{\mathit{labelidx}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{externidx}}({\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
..........................................................................................................


1. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~{\mathit{funcidx}})` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.

#. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~{\mathit{globalidx}})` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{globalidx}}({\mathit{globalidx}})`.

#. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~{\mathit{tableidx}})` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. Assert: Due to validation, :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{mem}`.

#. Let :math:`(\mathsf{mem}~{\mathit{memidx}})` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`.


:math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{packtype}}({\mathit{packtype}})`
................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{lanetype}}({\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
........................................................................................................


1. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is numtype, then:

  a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. Assert: Due to validation, the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is packtype.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{packtype}}({\mathit{packtype}})`.


:math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{consttype}}({\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
..........................................................................................................


1. If the type of :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is numtype, then:

  a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. Assert: Due to validation, the type of :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is vectype.

#. Let :math:`{\mathit{vectype}}` be :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.


:math:`{\mathrm{free}}_{\mathit{absheaptype}}({\mathit{absheaptype}})`
......................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{rectype}}((\mathsf{rec}~{{\mathit{subtype}}^\ast}))`
....................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{subtype}}({\mathit{subtype}})^\ast})`.


:math:`{\mathrm{free}}_{\mathit{deftype}}(({\mathit{rectype}} {.} n))`
......................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{rectype}}({\mathit{rectype}})`.


:math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{typeuse}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
......................................................................................................


1. If :math:`{\mathit{typeuse}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case , then:

  a. Let :math:`{\mathit{typeidx}}` be :math:`{\mathit{typeuse}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{typeuse}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{rec}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. Assert: Due to validation, the type of :math:`{\mathit{typeuse}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is deftype.

#. Let :math:`{\mathit{deftype}}` be :math:`{\mathit{typeuse}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{deftype}}({\mathit{deftype}})`.


:math:`{\mathrm{free}}_{\mathit{heaptype}}({\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
........................................................................................................


1. If the type of :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is absheaptype, then:

  a. Let :math:`{\mathit{absheaptype}}` be :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{absheaptype}}({\mathit{absheaptype}})`.

#. Assert: Due to validation, the type of :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is typeuse.

#. Let :math:`{\mathit{typeuse}}` be :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{typeuse}})`.


:math:`{\mathrm{free}}_{\mathit{reftype}}((\mathsf{ref}~{\mathsf{null}^?}~{\mathit{heaptype}}))`
................................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{heaptype}}({\mathit{heaptype}})`.


:math:`{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
......................................................................................................


1. If the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is numtype, then:

  a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is vectype, then:

  a. Let :math:`{\mathit{vectype}}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is reftype, then:

  a. Let :math:`{\mathit{reftype}}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{reftype}}({\mathit{reftype}})`.

#. Assert: Due to validation, :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{bot}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{resulttype}}({{\mathit{valtype}}^\ast})`
........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})^\ast})`.


:math:`{\mathrm{free}}_{\mathit{storagetype}}({\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
..............................................................................................................


1. If the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valtype, then:

  a. Let :math:`{\mathit{valtype}}` be :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})`.

#. Assert: Due to validation, the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is packtype.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{packtype}}({\mathit{packtype}})`.


:math:`{\mathrm{free}}_{\mathit{fieldtype}}(({\mathsf{mut}^?}~{\mathit{storagetype}}))`
.......................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{storagetype}}({\mathit{storagetype}})`.


:math:`{\mathrm{free}}_{\mathit{functype}}({\mathit{resulttype}}_1~\rightarrow~{\mathit{resulttype}}_2)`
........................................................................................................


1. Return `$free_resulttype(resulttype_1) ++ $free_resulttype(resulttype_2)`.


:math:`{\mathrm{free}}_{\mathit{structtype}}({{\mathit{fieldtype}}^\ast})`
..........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{fieldtype}}({\mathit{fieldtype}})^\ast})`.


:math:`{\mathrm{free}}_{\mathit{arraytype}}({\mathit{fieldtype}})`
..................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{fieldtype}}({\mathit{fieldtype}})`.


:math:`{\mathrm{free}}_{\mathit{comptype}}({\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
........................................................................................................


1. If :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{struct}`, then:

  a. Let :math:`(\mathsf{struct}~{\mathit{structtype}})` be :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{structtype}}({\mathit{structtype}})`.

#. If :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{array}`, then:

  a. Let :math:`(\mathsf{array}~{\mathit{arraytype}})` be :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{arraytype}}({\mathit{arraytype}})`.

#. Assert: Due to validation, :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{func}`.

#. Let :math:`(\mathsf{func}~{\mathit{functype}})` be :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{functype}}({\mathit{functype}})`.


:math:`{\mathrm{free}}_{\mathit{subtype}}((\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{comptype}}))`
...........................................................................................................................


1. Return `$free_list($free_typeuse(typeuse)*{typeuse <- typeuse*}) ++ $free_comptype(comptype)`.


:math:`{\mathrm{free}}_{\mathit{globaltype}}(({\mathsf{mut}^?}~{\mathit{valtype}}))`
....................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})`.


:math:`{\mathrm{free}}_{\mathit{tabletype}}(({\mathit{limits}}~{\mathit{reftype}}))`
....................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{reftype}}({\mathit{reftype}})`.


:math:`{\mathrm{free}}_{\mathit{memtype}}({\mathit{limits}}~\mathsf{page})`
...........................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{elemtype}}({\mathit{reftype}})`
...............................................................


1. Return :math:`{\mathrm{free}}_{\mathit{reftype}}({\mathit{reftype}})`.


:math:`{\mathrm{free}}_{\mathit{datatype}}(\mathsf{ok})`
........................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{externtype}}({\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
............................................................................................................


1. If :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~{\mathit{typeuse}})` be :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{typeuse}})`.

#. If :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~{\mathit{globaltype}})` be :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{globaltype}}({\mathit{globaltype}})`.

#. If :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~{\mathit{tabletype}})` be :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{tabletype}}({\mathit{tabletype}})`.

#. Assert: Due to validation, :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{mem}`.

#. Let :math:`(\mathsf{mem}~{\mathit{memtype}})` be :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{memtype}}({\mathit{memtype}})`.


:math:`{\mathrm{free}}_{\mathit{moduletype}}({{\mathit{externtype}}_1^\ast}~\rightarrow~{{\mathit{externtype}}_2^\ast})`
........................................................................................................................


1. Return `$free_list($free_externtype(externtype_1)*{externtype_1 <- externtype_1*}) ++ $free_list($free_externtype(externtype_2)*{externtype_2 <- externtype_2*})`.


:math:`{\mathrm{free}}_{\mathit{blocktype}}({\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
..........................................................................................................


1. If :math:`{\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case , then:

  a. Let :math:`{{\mathit{valtype}}^?}` be :math:`{\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{opt}}({{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})^?})`.

#. Assert: Due to validation, :math:`{\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case .

#. Let :math:`{\mathit{funcidx}}` be :math:`{\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.


:math:`{\mathrm{free}}_{\mathit{shape}}({{\mathit{lanetype}}}{\mathsf{x}}{{\mathit{dim}}})`
...........................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{lanetype}}({\mathit{lanetype}})`.


:math:`{\mathrm{shift}}_{\mathit{labelidxs}}({{\mathit{labelidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
.................................................................................................................


1. If :math:`{{\mathit{labelidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`n_0~{{\mathit{labelidx}'}^\ast}` be :math:`{{\mathit{labelidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`n_0` is :math:`0`, then:

  a. Return :math:`{\mathrm{shift}}_{\mathit{labelidxs}}({{\mathit{labelidx}'}^\ast})`.

#. Let :math:`{\mathit{labelidx}}~{{\mathit{labelidx}'}^\ast}` be :math:`{{\mathit{labelidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathit{labelidx}} - 1~{\mathrm{shift}}_{\mathit{labelidxs}}({{\mathit{labelidx}'}^\ast})`.


:math:`{\mathrm{free}}_{\mathit{block}}({{\mathit{instr}}^\ast})`
.................................................................


1. Let :math:`{\mathit{free}}` be :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{instr}}({\mathit{instr}})^\ast})`.

#. Return :math:`{\mathit{free}}{}[{.}\mathsf{labels} = {\mathrm{shift}}_{\mathit{labelidxs}}({\mathit{free}}{.}\mathsf{labels})]`.


:math:`{\mathrm{free}}_{\mathit{instr}}({\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
..................................................................................................


1. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{nop}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{unreachable}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{drop}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{select}`, then:

  a. Let :math:`(\mathsf{select}~{({{\mathit{valtype}}^\ast})^?})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{opt}}({{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})^\ast})^?})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{block}`, then:

  a. Let :math:`(\mathsf{block}~{\mathit{blocktype}}~{{\mathit{instr}}^\ast})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_blocktype(blocktype) ++ $free_block(instr*{instr <- instr*})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{loop}`, then:

  a. Let :math:`(\mathsf{loop}~{\mathit{blocktype}}~{{\mathit{instr}}^\ast})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_blocktype(blocktype) ++ $free_block(instr*{instr <- instr*})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{if}`, then:

  a. Let :math:`(\mathsf{if}~{\mathit{blocktype}}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_blocktype(blocktype) ++ $free_block(instr_1*{instr_1 <- instr_1*}) ++ $free_block(instr_2*{instr_2 <- instr_2*})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{br}`, then:

  a. Let :math:`(\mathsf{br}~{\mathit{labelidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{br\_if}`, then:

  a. Let :math:`(\mathsf{br\_if}~{\mathit{labelidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{br\_table}`, then:

  a. Let :math:`(\mathsf{br\_table}~{{\mathit{labelidx}}^\ast}~{\mathit{labelidx}'})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_list($free_labelidx(labelidx)*{}) ++ $free_labelidx(labelidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{br\_on\_null}`, then:

  a. Let :math:`(\mathsf{br\_on\_null}~{\mathit{labelidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{br\_on\_non\_null}`, then:

  a. Let :math:`(\mathsf{br\_on\_non\_null}~{\mathit{labelidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{br\_on\_cast}`, then:

  a. Let :math:`(\mathsf{br\_on\_cast}~{\mathit{labelidx}}~{\mathit{reftype}}_1~{\mathit{reftype}}_2)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_labelidx(labelidx) ++ $free_reftype(reftype_1) ++ $free_reftype(reftype_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{br\_on\_cast\_fail}`, then:

  a. Let :math:`(\mathsf{br\_on\_cast\_fail}~{\mathit{labelidx}}~{\mathit{reftype}}_1~{\mathit{reftype}}_2)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_labelidx(labelidx) ++ $free_reftype(reftype_1) ++ $free_reftype(reftype_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{call}`, then:

  a. Let :math:`(\mathsf{call}~{\mathit{funcidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{call\_ref}`, then:

  a. Let :math:`(\mathsf{call\_ref}~{\mathit{typeuse}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{typeuse}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{call\_indirect}`, then:

  a. Let :math:`(\mathsf{call\_indirect}~{\mathit{tableidx}}~{\mathit{typeuse}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_tableidx(tableidx) ++ $free_typeuse(typeuse)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{return}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{return\_call}`, then:

  a. Let :math:`(\mathsf{return\_call}~{\mathit{funcidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{return\_call\_ref}`, then:

  a. Let :math:`(\mathsf{return\_call\_ref}~{\mathit{typeuse}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{typeuse}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{return\_call\_indirect}`, then:

  a. Let :math:`(\mathsf{return\_call\_indirect}~{\mathit{tableidx}}~{\mathit{typeuse}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_tableidx(tableidx) ++ $free_typeuse(typeuse)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{const}`, then:

  a. Let :math:`({\mathit{numtype}}{.}\mathsf{const}~{\mathit{numlit}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{unop}`, then:

  a. Let :math:`({\mathit{numtype}} {.} {\mathit{unop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{binop}`, then:

  a. Let :math:`({\mathit{numtype}} {.} {\mathit{binop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{testop}`, then:

  a. Let :math:`({\mathit{numtype}} {.} {\mathit{testop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{relop}`, then:

  a. Let :math:`({\mathit{numtype}} {.} {\mathit{relop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{cvtop}`, then:

  a. Let :math:`({\mathit{numtype}}_1 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{numtype}}_2})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_numtype(numtype_1) ++ $free_numtype(numtype_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vconst}`, then:

  a. Let :math:`({\mathit{vectype}}{.}\mathsf{const}~{\mathit{veclit}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vvunop}`, then:

  a. Let :math:`({\mathit{vectype}} {.} {\mathit{vvunop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vvbinop}`, then:

  a. Let :math:`({\mathit{vectype}} {.} {\mathit{vvbinop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vvternop}`, then:

  a. Let :math:`({\mathit{vectype}} {.} {\mathit{vvternop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vvtestop}`, then:

  a. Let :math:`({\mathit{vectype}} {.} {\mathit{vvtestop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vunop}`, then:

  a. Let :math:`({\mathit{shape}} {.} {\mathit{vunop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vbinop}`, then:

  a. Let :math:`({\mathit{shape}} {.} {\mathit{vbinop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vtestop}`, then:

  a. Let :math:`({\mathit{shape}} {.} {\mathit{vtestop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vrelop}`, then:

  a. Let :math:`({\mathit{shape}} {.} {\mathit{vrelop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vshiftop}`, then:

  a. Let :math:`({\mathit{ishape}} {.} {\mathit{vshiftop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{ishape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vbitmask}`, then:

  a. Let :math:`({\mathit{ishape}}{.}\mathsf{bitmask})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{ishape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vswizzle}`, then:

  a. Let :math:`({\mathit{ishape}}{.}\mathsf{swizzle})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{ishape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vshuffle}`, then:

  a. Let :math:`({\mathit{ishape}}{.}\mathsf{shuffle}~{{\mathit{laneidx}}^\ast})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{ishape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vextunop}`, then:

  a. Let :math:`({\mathit{ishape}}_1 {.} {{\mathit{vextunop}}}{\mathsf{\_}}{{\mathit{ishape}}_2})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_shape(ishape_1) ++ $free_shape(ishape_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vextbinop}`, then:

  a. Let :math:`({\mathit{ishape}}_1 {.} {{\mathit{vextbinop}}}{\mathsf{\_}}{{\mathit{ishape}}_2})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_shape(ishape_1) ++ $free_shape(ishape_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vnarrow}`, then:

  a. Let :math:`({{\mathit{ishape}}_1{.}\mathsf{narrow}}{\mathsf{\_}}{{\mathit{ishape}}_2}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_shape(ishape_1) ++ $free_shape(ishape_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vcvtop}`, then:

  a. Let :math:`({\mathit{shape}}_1 {.} {{\mathit{vcvtop}}}{\mathsf{\_}}{{{\mathit{zero}}^?}}{\mathsf{\_}}{{\mathit{shape}}_2}{\mathsf{\_}}{{{\mathit{half}}^?}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_shape(shape_1) ++ $free_shape(shape_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vsplat}`, then:

  a. Let :math:`({\mathit{shape}}{.}\mathsf{splat})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vextract\_lane}`, then:

  a. Let :math:`({{\mathit{shape}}{.}\mathsf{extract\_lane}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~{\mathit{laneidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vreplace\_lane}`, then:

  a. Let :math:`({\mathit{shape}}{.}\mathsf{replace\_lane}~{\mathit{laneidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Let :math:`(\mathsf{ref{.}null}~{\mathit{heaptype}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{heaptype}}({\mathit{heaptype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ref{.}is\_null}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ref{.}as\_non\_null}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ref{.}eq}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}test}`, then:

  a. Let :math:`(\mathsf{ref{.}test}~{\mathit{reftype}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{reftype}}({\mathit{reftype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}cast}`, then:

  a. Let :math:`(\mathsf{ref{.}cast}~{\mathit{reftype}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{reftype}}({\mathit{reftype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref{.}func}`, then:

  a. Let :math:`(\mathsf{ref{.}func}~{\mathit{funcidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ref{.}i{\scriptstyle 31}}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{i{\scriptstyle 31}{.}get}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{struct{.}new}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{struct{.}new\_default}`, then:

  a. Let :math:`(\mathsf{struct{.}new\_default}~{\mathit{typeidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{struct{.}get}`, then:

  a. Let :math:`({\mathsf{struct{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~{\mathit{typeidx}}~{\mathit{u{\kern-0.1em\scriptstyle 32}}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{struct{.}set}`, then:

  a. Let :math:`(\mathsf{struct{.}set}~{\mathit{typeidx}}~{\mathit{u{\kern-0.1em\scriptstyle 32}}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{array{.}new}`, then:

  a. Let :math:`(\mathsf{array{.}new}~{\mathit{typeidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{array{.}new\_default}`, then:

  a. Let :math:`(\mathsf{array{.}new\_default}~{\mathit{typeidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{array{.}new\_fixed}`, then:

  a. Let :math:`(\mathsf{array{.}new\_fixed}~{\mathit{typeidx}}~{\mathit{u{\kern-0.1em\scriptstyle 32}}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{array{.}new\_data}`, then:

  a. Let :math:`(\mathsf{array{.}new\_data}~{\mathit{typeidx}}~{\mathit{dataidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_typeidx(typeidx) ++ $free_dataidx(dataidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{array{.}new\_elem}`, then:

  a. Let :math:`(\mathsf{array{.}new\_elem}~{\mathit{typeidx}}~{\mathit{elemidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_typeidx(typeidx) ++ $free_elemidx(elemidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{array{.}get}`, then:

  a. Let :math:`({\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~{\mathit{typeidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{array{.}set}`, then:

  a. Let :math:`(\mathsf{array{.}set}~{\mathit{typeidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{array{.}len}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{array{.}fill}`, then:

  a. Let :math:`(\mathsf{array{.}fill}~{\mathit{typeidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{array{.}copy}`, then:

  a. Let :math:`(\mathsf{array{.}copy}~{\mathit{typeidx}}_1~{\mathit{typeidx}}_2)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_typeidx(typeidx_1) ++ $free_typeidx(typeidx_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{array{.}init\_data}`, then:

  a. Let :math:`(\mathsf{array{.}init\_data}~{\mathit{typeidx}}~{\mathit{dataidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_typeidx(typeidx) ++ $free_dataidx(dataidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{array{.}init\_elem}`, then:

  a. Let :math:`(\mathsf{array{.}init\_elem}~{\mathit{typeidx}}~{\mathit{elemidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_typeidx(typeidx) ++ $free_elemidx(elemidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{extern{.}convert\_any}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{any{.}convert\_extern}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{local{.}get}`, then:

  a. Let :math:`(\mathsf{local{.}get}~{\mathit{localidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{localidx}}({\mathit{localidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{local{.}set}`, then:

  a. Let :math:`(\mathsf{local{.}set}~{\mathit{localidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{localidx}}({\mathit{localidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{local{.}tee}`, then:

  a. Let :math:`(\mathsf{local{.}tee}~{\mathit{localidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{localidx}}({\mathit{localidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{global{.}get}`, then:

  a. Let :math:`(\mathsf{global{.}get}~{\mathit{globalidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{globalidx}}({\mathit{globalidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{global{.}set}`, then:

  a. Let :math:`(\mathsf{global{.}set}~{\mathit{globalidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{globalidx}}({\mathit{globalidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{table{.}get}`, then:

  a. Let :math:`(\mathsf{table{.}get}~{\mathit{tableidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{table{.}set}`, then:

  a. Let :math:`(\mathsf{table{.}set}~{\mathit{tableidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{table{.}size}`, then:

  a. Let :math:`(\mathsf{table{.}size}~{\mathit{tableidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{table{.}grow}`, then:

  a. Let :math:`(\mathsf{table{.}grow}~{\mathit{tableidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{table{.}fill}`, then:

  a. Let :math:`(\mathsf{table{.}fill}~{\mathit{tableidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{table{.}copy}`, then:

  a. Let :math:`(\mathsf{table{.}copy}~{\mathit{tableidx}}_1~{\mathit{tableidx}}_2)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_tableidx(tableidx_1) ++ $free_tableidx(tableidx_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{table{.}init}`, then:

  a. Let :math:`(\mathsf{table{.}init}~{\mathit{tableidx}}~{\mathit{elemidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_tableidx(tableidx) ++ $free_elemidx(elemidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{elem{.}drop}`, then:

  a. Let :math:`(\mathsf{elem{.}drop}~{\mathit{elemidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{elemidx}}({\mathit{elemidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{load}`, then:

  a. Let :math:`({{\mathit{numtype}}{.}\mathsf{load}}{{\mathit{loadop\_{\scriptstyle 0}}}}~{\mathit{memidx}}~{\mathit{memarg}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If :math:`{\mathit{loadop\_{\scriptstyle 0}}}` is defined, then:

    1) Return `$free_numtype(numtype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{store}`, then:

  a. Let :math:`({{\mathit{numtype}}{.}\mathsf{store}}{{{\mathit{sz}}^?}}~{\mathit{memidx}}~{\mathit{memarg}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_numtype(numtype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vload}`, then:

  a. Let :math:`({{\mathit{vectype}}{.}\mathsf{load}}{{{\mathit{vloadop}}^?}}~{\mathit{memidx}}~{\mathit{memarg}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_vectype(vectype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vload\_lane}`, then:

  a. Let :math:`({{\mathit{vectype}}{.}\mathsf{load}}{{\mathit{sz}}}{\mathsf{\_}}{\mathsf{lane}}~{\mathit{memidx}}~{\mathit{memarg}}~{\mathit{laneidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_vectype(vectype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vstore}`, then:

  a. Let :math:`({\mathit{vectype}}{.}\mathsf{store}~{\mathit{memidx}}~{\mathit{memarg}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_vectype(vectype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{vstore\_lane}`, then:

  a. Let :math:`({{\mathit{vectype}}{.}\mathsf{store}}{{\mathit{sz}}}{\mathsf{\_}}{\mathsf{lane}}~{\mathit{memidx}}~{\mathit{memarg}}~{\mathit{laneidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_vectype(vectype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{memory{.}size}`, then:

  a. Let :math:`(\mathsf{memory{.}size}~{\mathit{memidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{memory{.}grow}`, then:

  a. Let :math:`(\mathsf{memory{.}grow}~{\mathit{memidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{memory{.}fill}`, then:

  a. Let :math:`(\mathsf{memory{.}fill}~{\mathit{memidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{memory{.}copy}`, then:

  a. Let :math:`(\mathsf{memory{.}copy}~{\mathit{memidx}}_1~{\mathit{memidx}}_2)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_memidx(memidx_1) ++ $free_memidx(memidx_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{memory{.}init}`, then:

  a. Let :math:`(\mathsf{memory{.}init}~{\mathit{memidx}}~{\mathit{dataidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_memidx(memidx) ++ $free_dataidx(dataidx)`.

#. Assert: Due to validation, :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{data{.}drop}`.

#. Let :math:`(\mathsf{data{.}drop}~{\mathit{dataidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{dataidx}}({\mathit{dataidx}})`.


:math:`{\mathrm{free}}_{\mathit{expr}}({{\mathit{instr}}^\ast})`
................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{instr}}({\mathit{instr}})^\ast})`.


:math:`{\mathrm{free}}_{\mathit{type}}((\mathsf{type}~{\mathit{rectype}}))`
...........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{rectype}}({\mathit{rectype}})`.


:math:`{\mathrm{free}}_{\mathit{local}}((\mathsf{local}~t))`
............................................................


1. Return :math:`{\mathrm{free}}_{\mathit{valtype}}(t)`.


:math:`{\mathrm{free}}_{\mathit{func}}((\mathsf{func}~{\mathit{typeidx}}~{{\mathit{local}}^\ast}~{\mathit{expr}}))`
...................................................................................................................


1. Return `$free_typeidx(typeidx) ++ $free_list($free_local(local)*{local <- local*}) ++ update($free_block(expr).LOCALS, [])`.


:math:`{\mathrm{free}}_{\mathit{global}}((\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}))`
..................................................................................................


1. Return `$free_globaltype(globaltype) ++ $free_expr(expr)`.


:math:`{\mathrm{free}}_{\mathit{table}}((\mathsf{table}~{\mathit{tabletype}}~{\mathit{expr}}))`
...............................................................................................


1. Return `$free_tabletype(tabletype) ++ $free_expr(expr)`.


:math:`{\mathrm{free}}_{\mathit{mem}}((\mathsf{memory}~{\mathit{memtype}}))`
............................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{memtype}}({\mathit{memtype}})`.


:math:`{\mathrm{free}}_{\mathit{tag}}((\mathsf{tag}~{\mathit{typeidx}}))`
.........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.


:math:`{\mathrm{free}}_{\mathit{elemmode}}({\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
........................................................................................................


1. If :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{active}`, then:

  a. Let :math:`(\mathsf{active}~{\mathit{tableidx}}~{\mathit{expr}})` be :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_tableidx(tableidx) ++ $free_expr(expr)`.

#. If :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{passive}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. Assert: Due to validation, :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{declare}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{datamode}}({\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
........................................................................................................


1. If :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{active}`, then:

  a. Let :math:`(\mathsf{active}~{\mathit{memidx}}~{\mathit{expr}})` be :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return `$free_memidx(memidx) ++ $free_expr(expr)`.

#. Assert: Due to validation, :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{passive}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{elem}}((\mathsf{elem}~{\mathit{reftype}}~{{\mathit{expr}}^\ast}~{\mathit{elemmode}}))`
......................................................................................................................


1. Return `$free_reftype(reftype) ++ $free_list($free_expr(expr)*{expr <- expr*}) ++ $free_elemmode(elemmode)`.


:math:`{\mathrm{free}}_{\mathit{data}}((\mathsf{data}~{{\mathit{byte}}^\ast}~{\mathit{datamode}}))`
...................................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{datamode}}({\mathit{datamode}})`.


:math:`{\mathrm{free}}_{\mathit{start}}((\mathsf{start}~{\mathit{funcidx}}))`
.............................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.


:math:`{\mathrm{free}}_{\mathit{export}}((\mathsf{export}~{\mathit{name}}~{\mathit{externidx}}))`
.................................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{externidx}}({\mathit{externidx}})`.


:math:`{\mathrm{free}}_{\mathit{import}}((\mathsf{import}~{\mathit{name}}_1~{\mathit{name}}_2~{\mathit{externtype}}))`
......................................................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{externtype}}({\mathit{externtype}})`.


:math:`{\mathrm{free}}_{\mathit{module}}((\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{tag}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast}))`
............................................................................................................................................................................................................................................................................................................................


1. Return `$free_list($free_type(type)*{type <- type*}) ++ $free_list($free_import(import)*{import <- import*}) ++ $free_list($free_func(func)*{func <- func*}) ++ $free_list($free_global(global)*{global <- global*}) ++ $free_list($free_table(table)*{table <- table*}) ++ $free_list($free_mem(mem)*{mem <- mem*}) ++ $free_list($free_tag(tag)*{tag <- tag*}) ++ $free_list($free_elem(elem)*{elem <- elem*}) ++ $free_list($free_data(data)*{data <- data*}) ++ $free_opt($free_start(start)?{start <- start?}) ++ $free_list($free_export(export)*{export <- export*})`.


:math:`{\mathrm{funcidx}}({\mathit{module}})`
.............................................


1. Return :math:`{\mathrm{free}}_{\mathit{module}}({\mathit{module}}){.}\mathsf{funcs}`.


:math:`{\mathrm{dataidx}}({{\mathit{func}}^\ast})`
..................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{func}}({\mathit{func}})^\ast}){.}\mathsf{datas}`.


:math:`{{\mathit{tv}}}{{}[ {{\mathit{typevar}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast} := {{\mathit{typeuse}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} ]}`
.....................................................................................................................................................................


1. If :math:`{{\mathit{typevar}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon` and :math:`{{\mathit{typeuse}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`{\mathit{tv}}`.

#. Assert: Due to validation, :math:`{|{{\mathit{typeuse}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|}` is greater than or equal to :math:`1`.

#. Let :math:`{\mathit{tu}}_1~{{\mathit{tu}'}^\ast}` be :math:`{{\mathit{typeuse}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{typevar}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}|}` is greater than or equal to :math:`1`.

#. Let :math:`{\mathit{tv}}_1~{{\mathit{tv}'}^\ast}` be :math:`{{\mathit{typevar}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{tv}}` is :math:`{\mathit{tv}}_1`, then:

  a. Return :math:`{\mathit{tu}}_1`.

#. Return :math:`{{\mathit{tv}}}{{}[ {{\mathit{tv}'}^\ast} := {{\mathit{tu}'}^\ast} ]}`.


:math:`{{\mathit{pt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{\mathit{pt}}`.


:math:`{{\mathit{nt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{\mathit{nt}}`.


:math:`{{\mathit{vt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{\mathit{vt}}`.


:math:`{{\mathit{typeuse}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
........................................................................................................................


1. If the type of :math:`{\mathit{typeuse}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is typevar, then:

  a. Let :math:`{\mathit{tv}'}` be :math:`{\mathit{typeuse}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{{\mathit{tv}'}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. Assert: Due to validation, the type of :math:`{\mathit{typeuse}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is deftype.

#. Let :math:`{\mathit{dt}}` be :math:`{\mathit{typeuse}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{{\mathit{dt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.


:math:`{{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.........................................................................................................................


1. If the type of :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is typevar, then:

  a. Let :math:`{\mathit{tv}'}` be :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{{\mathit{tv}'}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. If the type of :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is deftype, then:

  a. Let :math:`{\mathit{dt}}` be :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{{\mathit{dt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. Let :math:`{\mathit{ht}}` be :math:`{\mathit{heaptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{\mathit{ht}}`.


:math:`{(\mathsf{ref}~{\mathsf{null}^?}~{\mathit{ht}})}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
............................................................................................................


1. Return :math:`(\mathsf{ref}~{\mathsf{null}^?}~{{\mathit{ht}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
........................................................................................................................


1. If the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is numtype, then:

  a. Let :math:`{\mathit{nt}}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{{\mathit{nt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. If the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is vectype, then:

  a. Let :math:`{\mathit{vt}}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{{\mathit{vt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. If the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is reftype, then:

  a. Let :math:`{\mathit{rt}}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{{\mathit{rt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. Assert: Due to validation, :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{bot}`.

#. Return :math:`\mathsf{bot}`.


:math:`{{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
............................................................................................................................


1. If the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valtype, then:

  a. Let :math:`t` be :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`{t}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. Assert: Due to validation, the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is packtype.

#. Let :math:`{\mathit{pt}}` be :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{{\mathit{pt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.


:math:`{({\mathsf{mut}^?}~{\mathit{zt}})}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
..............................................................................................


1. Return :math:`({\mathsf{mut}^?}~{{\mathit{zt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.........................................................................................................................


1. If :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{struct}`, then:

  a. Let :math:`(\mathsf{struct}~{{\mathit{yt}}^\ast})` be :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`(\mathsf{struct}~{{{\mathit{yt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast})`.

#. If :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{array}`, then:

  a. Let :math:`(\mathsf{array}~{\mathit{yt}})` be :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`(\mathsf{array}~{{\mathit{yt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. Assert: Due to validation, :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{func}`.

#. Let :math:`(\mathsf{func}~{\mathit{ft}})` be :math:`{\mathit{comptype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`(\mathsf{func}~{{\mathit{ft}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{tu}'}^\ast}~{\mathit{ct}})}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...................................................................................................................................


1. Return :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{{\mathit{tu}'}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}~{{\mathit{ct}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{(\mathsf{rec}~{{\mathit{st}}^\ast})}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.................................................................................................


1. Return :math:`(\mathsf{rec}~{{{\mathit{st}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast})`.


:math:`{({\mathit{qt}} {.} i)}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...................................................................................


1. Return :math:`({{\mathit{qt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]} {.} i)`.


:math:`{{t_1^\ast}~\rightarrow~{t_2^\ast}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...............................................................................................


1. Return :math:`{{t_1}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}~\rightarrow~{{t_2}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}`.


:math:`{({\mathsf{mut}^?}~t)}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
..................................................................................


1. Return :math:`({\mathsf{mut}^?}~{t}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{({\mathit{lim}}~{\mathit{rt}})}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
............................................................................................


1. Return :math:`({\mathit{lim}}~{{\mathit{rt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{{\mathit{lim}}~\mathsf{page}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
..........................................................................................


1. Return :math:`{\mathit{lim}}~\mathsf{page}`.


:math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................................................................


1. If :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~{\mathit{dt}})` be :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`(\mathsf{func}~{{\mathit{dt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. If :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~{\mathit{gt}})` be :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`(\mathsf{global}~{{\mathit{gt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. If :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~{\mathit{tt}})` be :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`(\mathsf{table}~{{\mathit{tt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. Assert: Due to validation, :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{mem}`.

#. Let :math:`(\mathsf{mem}~{\mathit{mt}})` be :math:`{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`(\mathsf{mem}~{{\mathit{mt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{{{\mathit{xt}}_1^\ast}~\rightarrow~{{\mathit{xt}}_2^\ast}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.......................................................................................................................


1. Return :math:`{{{\mathit{xt}}_1}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}~\rightarrow~{{{\mathit{xt}}_2}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}`.


:math:`{t}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.............................................


1. Return :math:`{t}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{rt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{rt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{dt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{dt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{gt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{gt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{tt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{tt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{mt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{mt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{mmt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
..........................................................


1. Return :math:`{{\mathit{mmt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{{\mathit{deftype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}}{{}[ {:=}\, {{\mathit{tu}}^\ast} ]}`
..............................................................................................................


1. If :math:`{{\mathit{deftype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{dt}}_1~{{\mathit{dt}}^\ast}` be :math:`{{\mathit{deftype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{{\mathit{dt}}_1}{{}[ {:=}\, {{\mathit{tu}}^\ast} ]}~{{{\mathit{dt}}^\ast}}{{}[ {:=}\, {{\mathit{tu}}^\ast} ]}`.


:math:`{{\mathrm{roll}}}_{x}({\mathit{rectype}})`
.................................................


1. Assert: Due to validation, :math:`{\mathit{rectype}}` is of the case :math:`\mathsf{rec}`.

#. Let :math:`(\mathsf{rec}~{{\mathit{subtype}}^{n}})` be :math:`{\mathit{rectype}}`.

#. Return :math:`(\mathsf{rec}~{{{\mathit{subtype}}}{{}[ {x + i^{i<n}} := {(\mathsf{rec}~i)^{i<n}} ]}^{n}})`.


:math:`{\mathrm{unroll}}({\mathit{rectype}})`
.............................................


1. Assert: Due to validation, :math:`{\mathit{rectype}}` is of the case :math:`\mathsf{rec}`.

#. Let :math:`(\mathsf{rec}~{{\mathit{subtype}}^{n}})` be :math:`{\mathit{rectype}}`.

#. Return :math:`(\mathsf{rec}~{{{\mathit{subtype}}}{{}[ {(\mathsf{rec}~i)^{i<n}} := {({\mathit{rectype}} {.} i)^{i<n}} ]}^{n}})`.


:math:`{{{{\mathrm{roll}}}_{x}^\ast}}{({\mathit{rectype}})}`
............................................................


1. Assert: Due to validation, :math:`{{\mathrm{roll}}}_{x}({\mathit{rectype}})` is of the case :math:`\mathsf{rec}`.

#. Let :math:`(\mathsf{rec}~{{\mathit{subtype}}^{n}})` be :math:`{{\mathrm{roll}}}_{x}({\mathit{rectype}})`.

#. Return :math:`{((\mathsf{rec}~{{\mathit{subtype}}^{n}}) {.} i)^{i<n}}`.


:math:`{\mathrm{unroll}}(({\mathit{rectype}} {.} i))`
.....................................................


1. Assert: Due to validation, :math:`{\mathrm{unroll}}({\mathit{rectype}})` is of the case :math:`\mathsf{rec}`.

#. Let :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` be :math:`{\mathrm{unroll}}({\mathit{rectype}})`.

#. Return :math:`{{\mathit{subtype}}^\ast}{}[i]`.


:math:`{\mathrm{expand}}({\mathit{deftype}})`
.............................................


1. Assert: Due to validation, :math:`{\mathrm{unroll}}({\mathit{deftype}})` is of the case :math:`\mathsf{sub}`.

#. Let :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{comptype}})` be :math:`{\mathrm{unroll}}({\mathit{deftype}})`.

#. Return :math:`{\mathit{comptype}}`.


:math:`{\mathrm{funcs}}({{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
.............................................................................................


1. If :math:`{{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~x)` be :math:`{\mathit{externidx}}_0`.

  #. Return :math:`x~{\mathrm{funcs}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
...............................................................................................


1. If :math:`{{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~x)` be :math:`{\mathit{externidx}}_0`.

  #. Return :math:`x~{\mathrm{globals}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
..............................................................................................


1. If :math:`{{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~x)` be :math:`{\mathit{externidx}}_0`.

  #. Return :math:`x~{\mathrm{tables}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
............................................................................................


1. If :math:`{{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~x)` be :math:`{\mathit{externidx}}_0`.

  #. Return :math:`x~{\mathrm{mems}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{tags}}({{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
............................................................................................


1. If :math:`{{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is of the case :math:`\mathsf{tag}`, then:

  a. Let :math:`(\mathsf{tag}~x)` be :math:`{\mathit{externidx}}_0`.

  #. Return :math:`x~{\mathrm{tags}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{tags}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{funcs}}({{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
..............................................................................................


1. If :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~{\mathit{dt}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{dt}}~{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
................................................................................................


1. If :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~{\mathit{gt}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{gt}}~{\mathrm{globals}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
...............................................................................................


1. If :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~{\mathit{tt}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{tt}}~{\mathrm{tables}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
.............................................................................................


1. If :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~{\mathit{mt}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{mt}}~{\mathrm{mems}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{tags}}({{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
.............................................................................................


1. If :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{tag}`, then:

  a. Let :math:`(\mathsf{tag}~{\mathit{at}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{at}}~{\mathrm{tags}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{externtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{tags}}({{\mathit{xt}}^\ast})`.






1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{align}~0,\; \mathsf{offset}~0 \}\end{array}`.


:math:`{{\mathrm{signed}}}_{N}(i)`
..................................


1. If :math:`0` is less than or equal to :math:`{2^{N - 1}}`, then:

  a. Return :math:`i`.

#. Assert: Due to validation, :math:`{2^{N - 1}}` is less than or equal to :math:`i`.

#. Assert: Due to validation, :math:`i` is less than :math:`{2^{N}}`.

#. Return :math:`i - {2^{N}}`.


:math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{(i)}`
...............................................


1. Let :math:`j` be the result for which :math:`{{\mathrm{signed}}}_{N}(j)` :math:`=` :math:`i`.

#. Return :math:`j`.


:math:`{{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}}{{}_{{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}({\mathit{num\_u{\kern-0.1em\scriptstyle 3}}})}`
......................................................................................................................................................................


1. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{clz}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{iclz}}}_{N}({\mathit{iN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ctz}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{ictz}}}_{N}({\mathit{iN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{popcnt}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{ipopcnt}}}_{N}({\mathit{iN}})`.

#. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Assert: Due to validation, :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{extend}`.

  #. Let :math:`({\mathsf{extend}}{M}{\mathsf{\_}}{\mathsf{s}})` be :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}`.

  #. Let :math:`{\mathit{iN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{{{\mathrm{extend}}}_{M, N}^{\mathsf{s}}}}{({{\mathrm{wrap}}}_{N, M}({\mathit{iN}}))}`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{abs}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{fabs}}}_{N}({\mathit{fN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{neg}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{fneg}}}_{N}({\mathit{fN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{sqrt}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{fsqrt}}}_{N}({\mathit{fN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ceil}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{fceil}}}_{N}({\mathit{fN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{floor}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{ffloor}}}_{N}({\mathit{fN}})`.

#. If :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{trunc}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Return :math:`{{\mathrm{ftrunc}}}_{N}({\mathit{fN}})`.

#. Assert: Due to validation, :math:`{\mathit{unop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{nearest}`.

#. Assert: Due to validation, the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

#. Return :math:`{{\mathrm{fnearest}}}_{N}({\mathit{fN}})`.


:math:`{{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}}{{}_{{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}({\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}, {\mathit{num\_u{\kern-0.1em\scriptstyle 5}}})}`
.....................................................................................................................................................................................................................


1. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{add}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{iadd}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{sub}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{isub}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{mul}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{imul}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{div}`, then:

    1) Let :math:`({\mathsf{div}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{{{\mathrm{idiv}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{rem}`, then:

    1) Let :math:`({\mathsf{rem}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{{{\mathrm{irem}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{and}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{iand}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{or}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{ior}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{xor}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{ixor}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{shl}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{ishl}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{shr}`, then:

    1) Let :math:`({\mathsf{shr}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{{{\mathrm{ishr}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{rotl}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{irotl}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{rotr}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{irotr}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{add}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fadd}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{sub}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fsub}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{mul}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fmul}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{div}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fdiv}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{min}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fmin}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{max}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fmax}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{binop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{copysign}`.

#. Assert: Due to validation, the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

#. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

#. Return :math:`{{\mathrm{fcopysign}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.


:math:`{\mathsf{eqz}}{{}_{{\mathsf{i}}{N}}({\mathit{iN}})}`
...........................................................


1. Return :math:`{{\mathrm{ieqz}}}_{N}({\mathit{iN}})`.


:math:`{{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}}{{}_{{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}({\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}, {\mathit{num\_u{\kern-0.1em\scriptstyle 5}}})}`
.....................................................................................................................................................................................................................


1. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{eq}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{ieq}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ne}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{ine}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{lt}`, then:

    1) Let :math:`({\mathsf{lt}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{{{\mathrm{ilt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{gt}`, then:

    1) Let :math:`({\mathsf{gt}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{{{\mathrm{igt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{le}`, then:

    1) Let :math:`({\mathsf{le}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{{{\mathrm{ile}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ge}`, then:

    1) Let :math:`({\mathsf{ge}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{{{\mathrm{ige}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

#. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{eq}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{feq}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ne}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fne}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{lt}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{flt}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{gt}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fgt}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{le}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

  #. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

  #. Return :math:`{{\mathrm{fle}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{relop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ge}`.

#. Assert: Due to validation, the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

#. Let :math:`{\mathit{fN}}_2` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 5}}}`.

#. Return :math:`{{\mathrm{fge}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.


:math:`{{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}{{}_{{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, {\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}}({\mathit{num\_u{\kern-0.1em\scriptstyle 3}}})}`
.............................................................................................................................................................................................................................................


1. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{{\mathsf{i}}{N}}_1` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` is Inn, then:

    1) Let :math:`{{\mathsf{i}}{N}}_2` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}`.

    #) Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{extend}`, then:

      a) Let :math:`({\mathsf{extend}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

      #) Return :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

#. If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{wrap}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{{\mathsf{i}}{N}}_1` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` is Inn, then:

    1) Let :math:`{{\mathsf{i}}{N}}_2` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}`.

    #) Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

    #) Return :math:`{{\mathrm{wrap}}}_{N_1, N_2}({\mathit{iN}}_1)`.

#. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{{\mathsf{f}}{N}}_1` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` is Inn, then:

    1) Let :math:`{{\mathsf{i}}{N}}_2` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}`.

    #) Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{trunc}`, then:

      a) Let :math:`({\mathsf{trunc}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

      #) Return :math:`{{{{\mathrm{trunc}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{fN}}_1)}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{trunc\_sat}`, then:

      a) Let :math:`({\mathsf{trunc\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

      #) Return :math:`{{{{\mathrm{trunc\_sat}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{fN}}_1)}`.

#. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` is Fnn, then:

  a. Let :math:`{{\mathsf{f}}{N}}_2` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}`.

  #. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

    1) Let :math:`{{\mathsf{i}}{N}}_1` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{convert}`, then:

      a) Let :math:`({\mathsf{convert}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

      #) Return :math:`{{{{\mathrm{convert}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

#. If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{promote}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{{\mathsf{f}}{N}}_1` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` is Fnn, then:

    1) Let :math:`{{\mathsf{f}}{N}}_2` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}`.

    #) Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

    #) Return :math:`{{\mathrm{promote}}}_{N_1, N_2}({\mathit{fN}}_1)`.

#. If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{demote}` and the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{{\mathsf{f}}{N}}_1` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` is Fnn, then:

    1) Let :math:`{{\mathsf{f}}{N}}_2` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}`.

    #) Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

    #) Return :math:`{{\mathrm{demote}}}_{N_1, N_2}({\mathit{fN}}_1)`.

#. Assert: Due to validation, :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{reinterpret}`.

#. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` is Fnn, then:

  a. Let :math:`{{\mathsf{f}}{N}}_2` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}`.

  #. If the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

    1) Let :math:`{{\mathsf{i}}{N}}_1` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

    #) If :math:`{|{{\mathsf{i}}{N}}_1|}` is :math:`{|{{\mathsf{f}}{N}}_2|}`, then:

      a) Return :math:`{{\mathrm{reinterpret}}}_{{{\mathsf{i}}{N}}_1, {{\mathsf{f}}{N}}_2}({\mathit{iN}}_1)`.

#. Assert: Due to validation, the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{{\mathsf{f}}{N}}_1` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Assert: Due to validation, the type of :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}` is Inn.

#. Let :math:`{{\mathsf{i}}{N}}_2` be :math:`{\mathit{numtype}}_{\mathit{u{\kern-0.1em\scriptstyle 4}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{num\_u{\kern-0.1em\scriptstyle 3}}}`.

#. Assert: Due to validation, :math:`{|{{\mathsf{f}}{N}}_1|}` is :math:`{|{{\mathsf{i}}{N}}_2|}`.

#. Return :math:`{{\mathrm{reinterpret}}}_{{{\mathsf{f}}{N}}_1, {{\mathsf{i}}{N}}_2}({\mathit{fN}}_1)`.


:math:`{{{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}^{{-1}}}}{({b^\ast})}`
...................................................................


1. Let :math:`n` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(n)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`n`.


:math:`{{{{\mathrm{bytes}}}_{{\mathsf{f}}{N}}^{{-1}}}}{({b^\ast})}`
...................................................................


1. Let :math:`p` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{f}}{N}}(p)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`p`.


:math:`{{\mathrm{pack}}}_{{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}(c)`
..........................................................................................


1. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is numtype, then:

  a. Return :math:`c`.

#. Assert: Due to validation, the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is packtype.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{{\mathrm{wrap}}}_{{|{\mathrm{unpack}}({\mathit{packtype}})|}, {|{\mathit{packtype}}|}}(c)`.


:math:`{{\mathrm{unpack}}}_{{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}(c)`
............................................................................................


1. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is numtype, then:

  a. Return :math:`c`.

#. Assert: Due to validation, the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is packtype.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{{{{\mathrm{extend}}}_{{|{\mathit{packtype}}|}, {|{\mathrm{unpack}}({\mathit{packtype}})|}}^{\mathsf{u}}}}{(c)}`.


:math:`{{\mathrm{pack}}}_{{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}(c)`
.............................................................................................


1. If the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is consttype, then:

  a. Return :math:`c`.

#. Assert: Due to validation, the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is packtype.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{{\mathrm{wrap}}}_{{|{\mathrm{unpack}}({\mathit{packtype}})|}, {|{\mathit{packtype}}|}}(c)`.


:math:`{{\mathrm{unpack}}}_{{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}(c)`
...............................................................................................


1. If the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is consttype, then:

  a. Return :math:`c`.

#. Assert: Due to validation, the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is packtype.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{{{{\mathrm{extend}}}_{{|{\mathit{packtype}}|}, {|{\mathrm{unpack}}({\mathit{packtype}})|}}^{\mathsf{u}}}}{(c)}`.


:math:`{{{{\mathrm{lanes}}}_{{\mathit{sh}}}^{{-1}}}}{({c^\ast})}`
.................................................................


1. Let :math:`{\mathit{vc}}` be the result for which :math:`{{\mathrm{lanes}}}_{{\mathit{sh}}}({\mathit{vc}})` :math:`=` :math:`{c^\ast}`.

#. Return :math:`{\mathit{vc}}`.


:math:`{\mathrm{half}}({\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}, i, j)`
......................................................................................


1. If :math:`{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{low}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is Jnn, then:

  a. Return :math:`i`.

#. If :math:`{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{high}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is Jnn, then:

  a. Return :math:`j`.

#. Assert: Due to validation, :math:`{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{low}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is Fnn.

#. Return :math:`i`.


:math:`{\mathsf{not}}{{}_{\mathsf{v{\scriptstyle 128}}}({\mathit{v{\kern-0.1em\scriptstyle 128}}})}`
....................................................................................................


1. Return :math:`{{\mathrm{inot}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}})`.


:math:`{{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}{{}_{\mathsf{v{\scriptstyle 128}}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)}`
.................................................................................................................................................................................................


1. If :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{and}`, then:

  a. Return :math:`{{\mathrm{iand}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. If :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{andnot}`, then:

  a. Return :math:`{{\mathrm{iandnot}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. If :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{or}`, then:

  a. Return :math:`{{\mathrm{ior}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{xor}`.

#. Return :math:`{{\mathrm{ixor}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.


:math:`{\mathsf{bitselect}}{{}_{\mathsf{v{\scriptstyle 128}}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_3)}`
......................................................................................................................................................................................................


1. Return :math:`{{\mathrm{ibitselect}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_3)`.


:math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{vN}}_1)`
.............................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathit{vN}}_1)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{f}}}_{N}(c_1)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{ivunop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{vN}}_1)`
.............................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathit{vN}}_1)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}(c_1)^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}}{{}_{{{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}}({\mathit{vN}}_1)}`
............................................................................................................................................................


1. If :math:`{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{abs}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{ivunop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{iabs}}, {\mathit{vN}}_1)`.

#. If :math:`{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{neg}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{ivunop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ineg}}, {\mathit{vN}}_1)`.

#. If :math:`{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{popcnt}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{ivunop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ipopcnt}}, {\mathit{vN}}_1)`.

#. If :math:`{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{abs}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fabs}}, {\mathit{vN}}_1)`.

#. If :math:`{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{neg}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fneg}}, {\mathit{vN}}_1)`.

#. If :math:`{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{sqrt}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fsqrt}}, {\mathit{vN}}_1)`.

#. If :math:`{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ceil}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fceil}}, {\mathit{vN}}_1)`.

#. If :math:`{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{floor}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{ffloor}}, {\mathit{vN}}_1)`.

#. If :math:`{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{trunc}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{ftrunc}}, {\mathit{vN}}_1)`.

#. Assert: Due to validation, :math:`{\mathit{vunop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{nearest}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fnearest}}, {\mathit{vN}}_1)`.


:math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`
...............................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathit{vN}}_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathit{vN}}_2)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{f}}}_{N}(c_1, c_2)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{ivbinop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`
...............................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathit{vN}}_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathit{vN}}_2)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}(c_1, c_2)^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{sx}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`
................................................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathit{vN}}_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathit{vN}}_2)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}({\mathit{sx}}, c_1, c_2)^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}}{{}_{{{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}}({\mathit{vN}}_1, {\mathit{vN}}_2)}`
..............................................................................................................................................................................


1. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{add}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{ivbinop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{iadd}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{sub}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{ivbinop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{isub}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{mul}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{ivbinop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{imul}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

#. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{add\_sat}`, then:

    1) Let :math:`({\mathsf{add\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{iadd}}_{{\mathit{sat}}}, {\mathit{sx}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

  #. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{sub\_sat}`, then:

    1) Let :math:`({\mathsf{sub\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{isub}}_{{\mathit{sat}}}, {\mathit{sx}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

  #. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{min}`, then:

    1) Let :math:`({\mathsf{min}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{imin}}, {\mathit{sx}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

  #. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{max}`, then:

    1) Let :math:`({\mathsf{max}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{imax}}, {\mathit{sx}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is  and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{iavgr}}, \mathsf{u}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is  and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{iq{\kern-0.1em\scriptstyle 15\kern-0.1em}mulr}}_{{\mathit{sat}}}, \mathsf{s}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{add}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fadd}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{sub}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fsub}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{mul}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fmul}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{div}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fdiv}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{min}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fmin}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{max}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fmax}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

#. If :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{pmin}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fpmin}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{vbinop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{pmax}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fpmax}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.


:math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`
...............................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathit{vN}}_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathit{vN}}_2)`.

#. Assert: Due to validation, the type of :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`{|{\mathsf{f}}{N}|}` is Inn.

#. Let :math:`{\mathsf{i}}{N}` be the result for which :math:`{|{\mathsf{i}}{N}|}` :math:`=` :math:`{|{\mathsf{f}}{N}|}`.

#. Let :math:`{c^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{f}}}_{N}(c_1, c_2))}^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivrelop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`
...............................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathit{vN}}_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathit{vN}}_2)`.

#. Let :math:`{c^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{f}}}_{N}(c_1, c_2))}^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivrelopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{sx}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`
................................................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathit{vN}}_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathit{vN}}_2)`.

#. Let :math:`{c^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{f}}}_{N}({\mathit{sx}}, c_1, c_2))}^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}}{{}_{{{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}}({\mathit{vN}}_1, {\mathit{vN}}_2)}`
..............................................................................................................................................................................


1. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{eq}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{ivrelop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ieq}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

#. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ne}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{ivrelop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ine}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

#. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{lt}`, then:

    1) Let :math:`({\mathsf{lt}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{\mathrm{ivrelopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ilt}}, {\mathit{sx}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

  #. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{gt}`, then:

    1) Let :math:`({\mathsf{gt}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{\mathrm{ivrelopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{igt}}, {\mathit{sx}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

  #. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{le}`, then:

    1) Let :math:`({\mathsf{le}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{\mathrm{ivrelopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ile}}, {\mathit{sx}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

  #. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ge}`, then:

    1) Let :math:`({\mathsf{ge}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}`.

    #) Return :math:`{{\mathrm{ivrelopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ige}}, {\mathit{sx}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

#. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{eq}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{feq}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

#. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ne}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fne}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

#. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{lt}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{flt}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

#. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{gt}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fgt}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

#. If :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{le}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fle}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{vrelop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{ge}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fge}}, {\mathit{vN}}_1, {\mathit{vN}}_2)`.


:math:`{{\mathrm{vcvtop}}}_{{{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}}{\mathsf{x}}{M_1}, {{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}, {\mathit{lane\_u{\kern-0.1em\scriptstyle 5}}})`
......................................................................................................................................................................................................................................................................................................


1. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is Jnn, then:

  a. Let :math:`{{\mathsf{i}}{N}}_1` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

  #. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Jnn, then:

    1) Let :math:`{{\mathsf{i}}{N}}_2` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

    #) Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{lane\_u{\kern-0.1em\scriptstyle 5}}}`.

    #) If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is of the case :math:`\mathsf{extend}`, then:

      a) Let :math:`({\mathsf{extend}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

      #) Let :math:`{\mathit{iN}}_2` be :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

      #) Return :math:`{\mathit{iN}}_2`.

#. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Fnn, then:

  a. Let :math:`{{\mathsf{f}}{N}}_2` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is Jnn, then:

    1) Let :math:`{{\mathsf{i}}{N}}_1` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

    #) Let :math:`{\mathit{iN}}_1` be :math:`{\mathit{lane\_u{\kern-0.1em\scriptstyle 5}}}`.

    #) If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is of the case :math:`\mathsf{convert}`, then:

      a) Let :math:`({\mathsf{convert}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

      #) Let :math:`{\mathit{fN}}_2` be :math:`{{{{\mathrm{convert}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

      #) Return :math:`{\mathit{fN}}_2`.

#. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is Fnn, then:

  a. Let :math:`{{\mathsf{f}}{N}}_1` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

  #. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Inn, then:

    1) Let :math:`{{\mathsf{i}}{N}}_2` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

    #) Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{lane\_u{\kern-0.1em\scriptstyle 5}}}`.

    #) If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is of the case :math:`\mathsf{trunc\_sat}`, then:

      a) Let :math:`({\mathsf{trunc\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

      #) Let :math:`{{\mathit{iN}}_2^?}` be :math:`{{{{\mathrm{trunc\_sat}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{fN}}_1)}`.

      #) Return :math:`{{\mathit{iN}}_2^?}`.

#. If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is :math:`\mathsf{demote}` and the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is Fnn, then:

  a. Let :math:`{{\mathsf{f}}{N}}_1` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

  #. If the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Fnn, then:

    1) Let :math:`{{\mathsf{f}}{N}}_2` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

    #) Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{lane\_u{\kern-0.1em\scriptstyle 5}}}`.

    #) Let :math:`{{\mathit{fN}}_2^\ast}` be :math:`{{\mathrm{demote}}}_{N_1, N_2}({\mathit{fN}}_1)`.

    #) Return :math:`{{\mathit{fN}}_2^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is :math:`\mathsf{promote}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is Fnn.

#. Let :math:`{{\mathsf{f}}{N}}_1` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Fnn.

#. Let :math:`{{\mathsf{f}}{N}}_2` be :math:`{\mathit{lanetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`{\mathit{lane\_u{\kern-0.1em\scriptstyle 5}}}`.

#. Let :math:`{{\mathit{fN}}_2^\ast}` be :math:`{{\mathrm{promote}}}_{N_1, N_2}({\mathit{fN}}_1)`.

#. Return :math:`{{\mathit{fN}}_2^\ast}`.


:math:`{({\mathsf{extadd\_pairwise}}{\mathsf{\_}}{{\mathit{sx}}})}{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}(c_1)}`
.............................................................................................................................................................


1. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(c_1)`.

#. Let :math:`{{\mathit{cj}}_1~{\mathit{cj}}_2^\ast}` be the result for which :math:`{\bigoplus}\, {{\mathit{cj}}_1~{\mathit{cj}}_2^\ast}` :math:`=` :math:`{{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{ci}})}^\ast}`.

#. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({{{\mathrm{iadd}}}_{N_2}({\mathit{cj}}_1, {\mathit{cj}}_2)^\ast})}`.

#. Return :math:`c`.


:math:`{{\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}(c_1, c_2)}`
.....................................................................................................................................................................


1. If :math:`{\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{extmul}`, then:

  a. Let :math:`({\mathsf{extmul}}{\mathsf{\_}}{{\mathit{sx}}}{\mathsf{\_}}{{\mathit{half}}})` be :math:`{\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(c_1){}[{\mathrm{half}}({\mathit{half}}, 0, M_2) : M_2]`.

  #. Let :math:`{{\mathit{ci}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(c_2){}[{\mathrm{half}}({\mathit{half}}, 0, M_2) : M_2]`.

  #. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({{{\mathrm{imul}}}_{N_2}({{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{ci}}_1)}, {{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{ci}}_2)})^\ast})}`.

  #. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is .

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(c_1)`.

#. Let :math:`{{\mathit{ci}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(c_2)`.

#. Let :math:`{{\mathit{cj}}_1~{\mathit{cj}}_2^\ast}` be the result for which :math:`{\bigoplus}\, {{\mathit{cj}}_1~{\mathit{cj}}_2^\ast}` :math:`=` :math:`{{{\mathrm{imul}}}_{N_2}({{{{\mathrm{extend}}}_{N_1, N_2}^{\mathsf{s}}}}{({\mathit{ci}}_1)}, {{{{\mathrm{extend}}}_{N_1, N_2}^{\mathsf{s}}}}{({\mathit{ci}}_2)})^\ast}`.

#. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({{{\mathrm{iadd}}}_{N_2}({\mathit{cj}}_1, {\mathit{cj}}_2)^\ast})}`.

#. Return :math:`c`.


:math:`{{\mathit{vshiftop\_u{\kern-0.1em\scriptstyle 0}}}}{{}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}}{({\mathit{lane}}, n)}`
........................................................................................................................


1. If :math:`{\mathit{vshiftop\_u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{shl}`, then:

  a. Return :math:`{{\mathrm{ishl}}}_{N}({\mathit{lane}}, n)`.

#. Assert: Due to validation, :math:`{\mathit{vshiftop\_u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{shr}`.

#. Let :math:`({\mathsf{shr}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vshiftop\_u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{{{{\mathrm{ishr}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}, n)}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}(t)`
....................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{t}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}({\mathit{rt}})`
................................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{{\mathit{rt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}({\mathit{gt}})`
................................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{{\mathit{gt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}({\mathit{tt}})`
................................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{{\mathit{tt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}({\mathit{mt}})`
................................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{{\mathit{mt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{default}}}_{{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}`
.........................................................................................


1. If the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`({\mathsf{i}}{N}{.}\mathsf{const}~0)`.

#. If the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`({\mathsf{f}}{N}{.}\mathsf{const}~{+0})`.

#. If the type of :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is Vnn, then:

  a. Let :math:`{\mathsf{v}}{N}` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`({\mathsf{v}}{N}{.}\mathsf{const}~0)`.

#. Assert: Due to validation, :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{ref}`.

#. Let :math:`(\mathsf{ref}~{{\mathsf{null}^?}}_0~{\mathit{ht}})` be :math:`{\mathit{valtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. If :math:`{{\mathsf{null}^?}}_0` is :math:`(\mathsf{null}~()~{}^?)`, then:

  a. Return :math:`(\mathsf{ref{.}null}~{\mathit{ht}})`.

#. Assert: Due to validation, :math:`{{\mathsf{null}^?}}_0` is :math:`(\mathsf{null}~\epsilon~{}^?)`.

#. Return :math:`\epsilon`.


:math:`{{\mathrm{pack}}}_{{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}({\mathit{val}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
..................................................................................................................................................


1. Let :math:`{\mathit{val}}` be :math:`{\mathit{val}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valtype, then:

  a. Return :math:`{\mathit{val}}`.

#. Assert: Due to validation, :math:`{\mathit{val}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{const}`.

#. Let :math:`({\mathit{numtype}}_0{.}\mathsf{const}~i)` be :math:`{\mathit{val}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0` is :math:`\mathsf{i{\scriptstyle 32}}`.

#. Assert: Due to validation, the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is packtype.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`({\mathit{packtype}}{.}\mathsf{pack}~{{\mathrm{wrap}}}_{32, {|{\mathit{packtype}}|}}(i))`.


:math:`{{{{\mathrm{unpack}}}_{{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}}^{{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}}}{({\mathit{fieldval}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}})}`
...........................................................................................................................................................................................................................


1. If :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Assert: Due to validation, the type of :math:`{\mathit{fieldval}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is val.

  #. Let :math:`{\mathit{val}}` be :math:`{\mathit{fieldval}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. Assert: Due to validation, the type of :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is valtype.

  #. Return :math:`{\mathit{val}}`.

#. Else:

  a. Let :math:`{\mathit{sx}}` be :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

  #. Assert: Due to validation, :math:`{\mathit{fieldval}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is of the case :math:`\mathsf{pack}`.

  #. Let :math:`({\mathit{packtype}}{.}\mathsf{pack}~i)` be :math:`{\mathit{fieldval}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. Assert: Due to validation, :math:`{\mathit{storagetype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`{\mathit{packtype}}`.

  #. Return :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{{|{\mathit{packtype}}|}, 32}^{{\mathit{sx}}}}}{(i)})`.


:math:`{\mathrm{funcs}}({{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
..............................................................................................


1. If :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~{\mathit{fa}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{fa}}~{\mathrm{funcs}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xa}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
................................................................................................


1. If :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~{\mathit{ga}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ga}}~{\mathrm{globals}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xa}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
...............................................................................................


1. If :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~{\mathit{ta}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ta}}~{\mathrm{tables}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xa}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
.............................................................................................


1. If :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~{\mathit{ma}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ma}}~{\mathrm{mems}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xa}}^\ast})`.


:math:`{\mathrm{tags}}({{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
.............................................................................................


1. If :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{tag}`, then:

  a. Let :math:`(\mathsf{tag}~{\mathit{ha}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ha}}~{\mathrm{tags}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{externaddr}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Return :math:`{\mathrm{tags}}({{\mathit{xa}}^\ast})`.


:math:`{\mathrm{store}}`
........................


1. Return.


:math:`{\mathrm{frame}}`
........................


1. Let :math:`f` be the current frame.

#. Return :math:`f`.


:math:`{\mathrm{tagaddr}}`
..........................


1. Let :math:`f` be the current frame.

#. Return :math:`f{.}\mathsf{module}{.}\mathsf{tags}`.


:math:`{\mathrm{moduleinst}}`
.............................


1. Let :math:`f` be the current frame.

#. Return :math:`f{.}\mathsf{module}`.


:math:`{\mathrm{funcinst}}`
...........................


1. Return :math:`s{.}\mathsf{funcs}`.


:math:`{\mathrm{globalinst}}`
.............................


1. Return :math:`s{.}\mathsf{globals}`.


:math:`{\mathrm{tableinst}}`
............................


1. Return :math:`s{.}\mathsf{tables}`.


:math:`{\mathrm{meminst}}`
..........................


1. Return :math:`s{.}\mathsf{mems}`.


:math:`{\mathrm{taginst}}`
..........................


1. Return :math:`s{.}\mathsf{tags}`.


:math:`{\mathrm{eleminst}}`
...........................


1. Return :math:`s{.}\mathsf{elems}`.


:math:`{\mathrm{datainst}}`
...........................


1. Return :math:`s{.}\mathsf{datas}`.


:math:`{\mathrm{structinst}}`
.............................


1. Return :math:`s{.}\mathsf{structs}`.


:math:`{\mathrm{arrayinst}}`
............................


1. Return :math:`s{.}\mathsf{arrays}`.


:math:`{\mathrm{exninst}}`
..........................


1. Return :math:`s{.}\mathsf{exns}`.


:math:`{\mathrm{type}}(x)`
..........................


1. Let :math:`f` be the current frame.

#. Return :math:`f{.}\mathsf{module}{.}\mathsf{types}{}[x]`.


:math:`{\mathrm{func}}(x)`
..........................


1. Let :math:`f` be the current frame.

#. Return :math:`s{.}\mathsf{funcs}{}[f{.}\mathsf{module}{.}\mathsf{funcs}{}[x]]`.


:math:`{\mathrm{global}}(x)`
............................


1. Let :math:`f` be the current frame.

#. Return :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]`.


:math:`{\mathrm{table}}(x)`
...........................


1. Let :math:`f` be the current frame.

#. Return :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]`.


:math:`{\mathrm{mem}}(x)`
.........................


1. Let :math:`f` be the current frame.

#. Return :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]`.


:math:`{\mathrm{tag}}(x)`
.........................


1. Let :math:`f` be the current frame.

#. Return :math:`s{.}\mathsf{tags}{}[f{.}\mathsf{module}{.}\mathsf{tags}{}[x]]`.


:math:`{\mathrm{elem}}(x)`
..........................


1. Let :math:`f` be the current frame.

#. Return :math:`s{.}\mathsf{elems}{}[f{.}\mathsf{module}{.}\mathsf{elems}{}[x]]`.


:math:`{\mathrm{data}}(x)`
..........................


1. Let :math:`f` be the current frame.

#. Return :math:`s{.}\mathsf{datas}{}[f{.}\mathsf{module}{.}\mathsf{datas}{}[x]]`.


:math:`{\mathrm{local}}(x)`
...........................


1. Let :math:`f` be the current frame.

#. Return :math:`f{.}\mathsf{locals}{}[x]`.


:math:`{\mathrm{with}}_{\mathit{local}}(x, v)`
..............................................


1. Let :math:`f` be the current frame.

#. Replace :math:`f{.}\mathsf{locals}{}[x]` with :math:`v`.


:math:`{\mathrm{with}}_{\mathit{global}}(x, v)`
...............................................


1. Let :math:`f` be the current frame.

#. Replace :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]{.}\mathsf{value}` with :math:`v`.


:math:`{\mathrm{with}}_{\mathit{table}}(x, i, r)`
.................................................


1. Let :math:`f` be the current frame.

#. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]{.}\mathsf{refs}{}[i]` with :math:`r`.


:math:`{\mathrm{with}}_{\mathit{tableinst}}(x, {\mathit{ti}})`
..............................................................


1. Let :math:`f` be the current frame.

#. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]` with :math:`{\mathit{ti}}`.


:math:`{\mathrm{with}}_{\mathit{mem}}(x, i, j, {b^\ast})`
.........................................................


1. Let :math:`f` be the current frame.

#. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]{.}\mathsf{bytes}{}[i : j]` with :math:`{b^\ast}`.


:math:`{\mathrm{with}}_{\mathit{meminst}}(x, {\mathit{mi}})`
............................................................


1. Let :math:`f` be the current frame.

#. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]` with :math:`{\mathit{mi}}`.


:math:`{\mathrm{with}}_{\mathit{elem}}(x, {r^\ast})`
....................................................


1. Let :math:`f` be the current frame.

#. Replace :math:`s{.}\mathsf{elems}{}[f{.}\mathsf{module}{.}\mathsf{elems}{}[x]]{.}\mathsf{refs}` with :math:`{r^\ast}`.


:math:`{\mathrm{with}}_{\mathit{data}}(x, {b^\ast})`
....................................................


1. Let :math:`f` be the current frame.

#. Replace :math:`s{.}\mathsf{datas}{}[f{.}\mathsf{module}{.}\mathsf{datas}{}[x]]{.}\mathsf{bytes}` with :math:`{b^\ast}`.


:math:`{\mathrm{with}}_{\mathit{struct}}(a, i, {\mathit{fv}})`
..............................................................


1. Replace :math:`s{.}\mathsf{structs}{}[a]{.}\mathsf{fields}{}[i]` with :math:`{\mathit{fv}}`.


:math:`{\mathrm{with}}_{\mathit{array}}(a, i, {\mathit{fv}})`
.............................................................


1. Replace :math:`s{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}{}[i]` with :math:`{\mathit{fv}}`.


:math:`{\mathrm{add}}_{\mathit{structinst}}({{\mathit{si}}^\ast})`
..................................................................


1. Append :math:`{{\mathit{si}}^\ast}` to the :math:`s{.}\mathsf{structs}`.


:math:`{\mathrm{add}}_{\mathit{arrayinst}}({{\mathit{ai}}^\ast})`
.................................................................


1. Append :math:`{{\mathit{ai}}^\ast}` to the :math:`s{.}\mathsf{arrays}`.


:math:`{\mathrm{add}}_{\mathit{exninst}}({{\mathit{exn}}^\ast})`
................................................................


1. Append :math:`{{\mathit{exn}}^\ast}` to the :math:`s{.}\mathsf{exns}`.


:math:`{\mathrm{growtable}}({\mathit{tableinst}}, n, r)`
........................................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~((i, j)~{\mathit{rt}}),\; \mathsf{refs}~{{r'}^\ast} \}\end{array}` be :math:`{\mathit{tableinst}}`.

#. If :math:`{|{{r'}^\ast}|} + n` is less than or equal to :math:`j`, then:

  a. Let :math:`{i'}` be :math:`{|{{r'}^\ast}|} + n`.

  #. Let :math:`{\mathit{tableinst}'}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~(({i'}, j)~{\mathit{rt}}),\; \mathsf{refs}~{{r'}^\ast}~{r^{n}} \}\end{array}`.

  #. Return :math:`{\mathit{tableinst}'}`.


:math:`{\mathrm{growmem}}({\mathit{meminst}}, n)`
.................................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~(i, j)~\mathsf{page},\; \mathsf{bytes}~{b^\ast} \}\end{array}` be :math:`{\mathit{meminst}}`.

#. If :math:`{|{b^\ast}|} / 64 \, {\mathrm{Ki}} + n` is less than or equal to :math:`j`, then:

  a. Let :math:`{i'}` be :math:`{|{b^\ast}|} / 64 \, {\mathrm{Ki}} + n`.

  #. Let :math:`{\mathit{meminst}'}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({i'}, j)~\mathsf{page},\; \mathsf{bytes}~{b^\ast}~{0^{n \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

  #. Return :math:`{\mathit{meminst}'}`.


:math:`{{\mathrm{blocktype}}}_{z}({\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}})`
................................................................................................


1. If :math:`{\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case , then:

  a. Let :math:`x` be :math:`{\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{func}`.

  #. Let :math:`(\mathsf{func}~{\mathit{ft}})` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

  #. Return :math:`{\mathit{ft}}`.

#. Assert: Due to validation, :math:`{\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case .

#. Let :math:`{t^?}` be :math:`{\mathit{blocktype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`\epsilon~\rightarrow~{t^?}`.


:math:`{{{\mathrm{alloctype}}^\ast}}{({{\mathit{type}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})}`
.......................................................................................................


1. If :math:`{{\mathit{type}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{{\mathit{type}'}^\ast}~{\mathit{type}}` be :math:`{{\mathit{type}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{type}}` is of the case :math:`\mathsf{type}`.

#. Let :math:`(\mathsf{type}~{\mathit{rectype}})` be :math:`{\mathit{type}}`.

#. Let :math:`{{\mathit{deftype}'}^\ast}` be :math:`{{{\mathrm{alloctype}}^\ast}}{({{\mathit{type}'}^\ast})}`.

#. Let :math:`x` be :math:`{|{{\mathit{deftype}'}^\ast}|}`.

#. Let :math:`{{\mathit{deftype}}^\ast}` be :math:`{{{{{\mathrm{roll}}}_{x}^\ast}}{({\mathit{rectype}})}}{{}[ {:=}\, {{\mathit{deftype}'}^\ast} ]}`.

#. Return :math:`{{\mathit{deftype}'}^\ast}~{{\mathit{deftype}}^\ast}`.


:math:`{\mathrm{allocfunc}}({\mathit{deftype}}, {\mathit{code}}, {\mathit{moduleinst}})`
........................................................................................


1. Let :math:`{\mathit{funcinst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{deftype}},\; \mathsf{module}~{\mathit{moduleinst}},\; \mathsf{code}~{\mathit{code}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{funcs}|}`.

#. Append :math:`{\mathit{funcinst}}` to the :math:`s{.}\mathsf{funcs}`.

#. Return :math:`a`.


:math:`{\mathrm{allocfuncs}}({{\mathit{deftype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}, {{{\mathit{code}}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {{\mathit{moduleinst}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast})`
........................................................................................................................................................................................................................................


1. If :math:`{{\mathit{deftype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Assert: Due to validation, :math:`{{{\mathit{code}}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\epsilon`.

  #. Assert: Due to validation, :math:`{{\mathit{moduleinst}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is :math:`\epsilon`.

  #. Return :math:`\epsilon`.

#. Else:

  a. Let :math:`{\mathit{dt}}~{{\mathit{dt}'}^\ast}` be :math:`{{\mathit{deftype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

  #. Assert: Due to validation, :math:`{|{{{\mathit{code}}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|}` is greater than or equal to :math:`1`.

  #. Let :math:`{\mathit{code}}~{{{\mathit{code}}'}^\ast}` be :math:`{{{\mathit{code}}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

  #. Assert: Due to validation, :math:`{|{{\mathit{moduleinst}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}|}` is greater than or equal to :math:`1`.

  #. Let :math:`{\mathit{moduleinst}}~{{\mathit{moduleinst}'}^\ast}` be :math:`{{\mathit{moduleinst}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}`.

  #. Let :math:`{\mathit{fa}}` be :math:`{\mathrm{allocfunc}}({\mathit{dt}}, {\mathit{code}}, {\mathit{moduleinst}})`.

  #. Let :math:`{{\mathit{fa}'}^\ast}` be :math:`{\mathrm{allocfuncs}}({{\mathit{dt}'}^\ast}, {{{\mathit{code}}'}^\ast}, {{\mathit{moduleinst}'}^\ast})`.

  #. Return :math:`{\mathit{fa}}~{{\mathit{fa}'}^\ast}`.


:math:`{\mathrm{allocglobal}}({\mathit{globaltype}}, {\mathit{val}})`
.....................................................................


1. Let :math:`{\mathit{globalinst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{globaltype}},\; \mathsf{value}~{\mathit{val}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{globals}|}`.

#. Append :math:`{\mathit{globalinst}}` to the :math:`s{.}\mathsf{globals}`.

#. Return :math:`a`.


:math:`{\mathrm{allocglobals}}({{\mathit{globaltype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}, {{\mathit{val}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
....................................................................................................................................................................


1. If :math:`{{\mathit{globaltype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Assert: Due to validation, :math:`{{\mathit{val}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\epsilon`.

  #. Return :math:`\epsilon`.

#. Else:

  a. Let :math:`{\mathit{globaltype}}~{{\mathit{globaltype}'}^\ast}` be :math:`{{\mathit{globaltype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

  #. Assert: Due to validation, :math:`{|{{\mathit{val}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|}` is greater than or equal to :math:`1`.

  #. Let :math:`{\mathit{val}}~{{\mathit{val}'}^\ast}` be :math:`{{\mathit{val}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

  #. Let :math:`{\mathit{ga}}` be :math:`{\mathrm{allocglobal}}({\mathit{globaltype}}, {\mathit{val}})`.

  #. Let :math:`{{\mathit{ga}'}^\ast}` be :math:`{\mathrm{allocglobals}}({{\mathit{globaltype}'}^\ast}, {{\mathit{val}'}^\ast})`.

  #. Return :math:`{\mathit{ga}}~{{\mathit{ga}'}^\ast}`.


:math:`{\mathrm{alloctable}}(((i, j)~{\mathit{rt}}), {\mathit{ref}})`
.....................................................................


1. Let :math:`{\mathit{tableinst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~((i, j)~{\mathit{rt}}),\; \mathsf{refs}~{{\mathit{ref}}^{i}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{tables}|}`.

#. Append :math:`{\mathit{tableinst}}` to the :math:`s{.}\mathsf{tables}`.

#. Return :math:`a`.


:math:`{\mathrm{alloctables}}({{\mathit{tabletype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}, {{\mathit{ref}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
..................................................................................................................................................................


1. If :math:`{{\mathit{tabletype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon` and :math:`{{\mathit{ref}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{{\mathit{ref}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|}` is greater than or equal to :math:`1`.

#. Let :math:`{\mathit{ref}}~{{\mathit{ref}'}^\ast}` be :math:`{{\mathit{ref}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{tabletype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}|}` is greater than or equal to :math:`1`.

#. Let :math:`{\mathit{tabletype}}~{{\mathit{tabletype}'}^\ast}` be :math:`{{\mathit{tabletype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Let :math:`{\mathit{ta}}` be :math:`{\mathrm{alloctable}}({\mathit{tabletype}}, {\mathit{ref}})`.

#. Let :math:`{{\mathit{ta}'}^\ast}` be :math:`{\mathrm{alloctables}}({{\mathit{tabletype}'}^\ast}, {{\mathit{ref}'}^\ast})`.

#. Return :math:`{\mathit{ta}}~{{\mathit{ta}'}^\ast}`.


:math:`{\mathrm{allocmem}}((i, j)~\mathsf{page})`
.................................................


1. Let :math:`{\mathit{meminst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~(i, j)~\mathsf{page},\; \mathsf{bytes}~{0^{i \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{mems}|}`.

#. Append :math:`{\mathit{meminst}}` to the :math:`s{.}\mathsf{mems}`.

#. Return :math:`a`.


:math:`{\mathrm{allocmems}}({{\mathit{memtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
...............................................................................................


1. If :math:`{{\mathit{memtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{memtype}}~{{\mathit{memtype}'}^\ast}` be :math:`{{\mathit{memtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Let :math:`{\mathit{ma}}` be :math:`{\mathrm{allocmem}}({\mathit{memtype}})`.

#. Let :math:`{{\mathit{ma}'}^\ast}` be :math:`{\mathrm{allocmems}}({{\mathit{memtype}'}^\ast})`.

#. Return :math:`{\mathit{ma}}~{{\mathit{ma}'}^\ast}`.


:math:`{\mathrm{alloctag}}({\mathit{tagtype}})`
...............................................


1. Let :math:`{\mathit{taginst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{tagtype}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{tags}|}`.

#. Append :math:`{\mathit{taginst}}` to the :math:`s{.}\mathsf{tags}`.

#. Return :math:`a`.


:math:`{\mathrm{alloctags}}({{\mathit{tagtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast})`
...............................................................................................


1. If :math:`{{\mathit{tagtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{at}}~{{\mathit{at}'}^\ast}` be :math:`{{\mathit{tagtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Let :math:`{\mathit{aa}}` be :math:`{\mathrm{alloctag}}({\mathit{at}})`.

#. Let :math:`{{\mathit{aa}'}^\ast}` be :math:`{\mathrm{alloctags}}({{\mathit{at}'}^\ast})`.

#. Return :math:`{\mathit{aa}}~{{\mathit{aa}'}^\ast}`.


:math:`{\mathrm{allocelem}}({\mathit{elemtype}}, {{\mathit{ref}}^\ast})`
........................................................................


1. Let :math:`{\mathit{eleminst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{elemtype}},\; \mathsf{refs}~{{\mathit{ref}}^\ast} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{elems}|}`.

#. Append :math:`{\mathit{eleminst}}` to the :math:`s{.}\mathsf{elems}`.

#. Return :math:`a`.


:math:`{\mathrm{allocelems}}({{\mathit{elemtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}, {{\mathit{ref}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
................................................................................................................................................................


1. If :math:`{{\mathit{elemtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon` and :math:`{{\mathit{ref}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{{\mathit{ref}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|}` is greater than or equal to :math:`1`.

#. Let :math:`{{\mathit{ref}}^\ast}~{{{\mathit{ref}'}^\ast}^\ast}` be :math:`{{\mathit{ref}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{elemtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}|}` is greater than or equal to :math:`1`.

#. Let :math:`{\mathit{rt}}~{{\mathit{rt}'}^\ast}` be :math:`{{\mathit{elemtype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Let :math:`{\mathit{ea}}` be :math:`{\mathrm{allocelem}}({\mathit{rt}}, {{\mathit{ref}}^\ast})`.

#. Let :math:`{{\mathit{ea}'}^\ast}` be :math:`{\mathrm{allocelems}}({{\mathit{rt}'}^\ast}, {{{\mathit{ref}'}^\ast}^\ast})`.

#. Return :math:`{\mathit{ea}}~{{\mathit{ea}'}^\ast}`.


:math:`{\mathrm{allocdata}}(\mathsf{ok}, {{\mathit{byte}}^\ast})`
.................................................................


1. Let :math:`{\mathit{datainst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{bytes}~{{\mathit{byte}}^\ast} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{datas}|}`.

#. Append :math:`{\mathit{datainst}}` to the :math:`s{.}\mathsf{datas}`.

#. Return :math:`a`.


:math:`{\mathrm{allocdatas}}({{\mathit{datatype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}, {{\mathit{byte}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.................................................................................................................................................................


1. If :math:`{{\mathit{datatype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon` and :math:`{{\mathit{byte}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{{\mathit{byte}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|}` is greater than or equal to :math:`1`.

#. Let :math:`{b^\ast}~{{{b'}^\ast}^\ast}` be :math:`{{\mathit{byte}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{datatype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}|}` is greater than or equal to :math:`1`.

#. Let :math:`{\mathit{ok}}~{{\mathit{ok}'}^\ast}` be :math:`{{\mathit{datatype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Let :math:`{\mathit{da}}` be :math:`{\mathrm{allocdata}}({\mathit{ok}}, {b^\ast})`.

#. Let :math:`{{\mathit{da}'}^\ast}` be :math:`{\mathrm{allocdatas}}({{\mathit{ok}'}^\ast}, {{{b'}^\ast}^\ast})`.

#. Return :math:`{\mathit{da}}~{{\mathit{da}'}^\ast}`.


:math:`{\mathrm{allocexport}}({\mathit{moduleinst}}, (\mathsf{export}~{\mathit{name}}~{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}))`
.....................................................................................................................................................


1. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{func}~{\mathit{moduleinst}}{.}\mathsf{funcs}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{global}~{\mathit{moduleinst}}{.}\mathsf{globals}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{table}~{\mathit{moduleinst}}{.}\mathsf{tables}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

  #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{mem}~{\mathit{moduleinst}}{.}\mathsf{mems}{}[x]) \}\end{array}`.

#. Assert: Due to validation, :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{tag}`.

#. Let :math:`(\mathsf{tag}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{tag}~{\mathit{moduleinst}}{.}\mathsf{tags}{}[x]) \}\end{array}`.


:math:`{{{\mathrm{allocexport}}^\ast}}{({\mathit{moduleinst}}, {{\mathit{export}}^\ast})}`
..........................................................................................


1. Return :math:`{{\mathrm{allocexport}}({\mathit{moduleinst}}, {\mathit{export}})^\ast}`.


:math:`{\mathrm{allocmodule}}({\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}_{\mathsf{g}}^\ast}, {{\mathit{ref}}_{\mathsf{t}}^\ast}, {{{\mathit{ref}}_{\mathsf{e}}^\ast}^\ast})`
..................................................................................................................................................................................................


1. Let :math:`{{\mathit{fa}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ga}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{globals}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{aa}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{tags}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ma}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{mems}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ta}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{tables}}({{\mathit{externaddr}}^\ast})`.

#. Assert: Due to validation, :math:`{\mathit{module}}` is of the case :math:`\mathsf{module}`.

#. Let :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{tag}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be :math:`{\mathit{module}}`.

#. Let :math:`{{\mathit{fa}}^\ast}` be :math:`{{|s{.}\mathsf{funcs}|} + i_{\mathsf{f}}^{i_{\mathsf{f}}<{|{{\mathit{func}}^\ast}|}}}`.

#. Let :math:`{{\mathit{ga}}^\ast}` be :math:`{{|s{.}\mathsf{globals}|} + i_{\mathsf{g}}^{i_{\mathsf{g}}<{|{{\mathit{global}}^\ast}|}}}`.

#. Let :math:`{{\mathit{ta}}^\ast}` be :math:`{{|s{.}\mathsf{tables}|} + i_{\mathsf{t}}^{i_{\mathsf{t}}<{|{{\mathit{table}}^\ast}|}}}`.

#. Let :math:`{{\mathit{aa}}^\ast}` be :math:`{{|s{.}\mathsf{tags}|} + i_{\mathsf{a}}^{i_{\mathsf{a}}<{|{{\mathit{tag}}^\ast}|}}}`.

#. Let :math:`{{\mathit{ma}}^\ast}` be :math:`{{|s{.}\mathsf{mems}|} + i_{\mathsf{m}}^{i_{\mathsf{m}}<{|{{\mathit{mem}}^\ast}|}}}`.

#. Let :math:`{{\mathit{ea}}^\ast}` be :math:`{{|s{.}\mathsf{elems}|} + i_{\mathsf{e}}^{i_{\mathsf{e}}<{|{{\mathit{elem}}^\ast}|}}}`.

#. Let :math:`{{\mathit{da}}^\ast}` be :math:`{{|s{.}\mathsf{datas}|} + i_{\mathsf{d}}^{i_{\mathsf{d}}<{|{{\mathit{data}}^\ast}|}}}`.

#. Assert: Due to validation, for all :math:`{({\mathit{mem}})^\ast}`, :math:`{\mathit{mem}}` is of the case :math:`\mathsf{memory}`.

#. Let :math:`{(\mathsf{memory}~{\mathit{memtype}})^\ast}` be :math:`{{\mathit{mem}}^\ast}`.

#. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{{{\mathrm{alloctype}}^\ast}}{({{\mathit{type}}^\ast})}`.

#. Assert: Due to validation, for all :math:`{({\mathit{tag}})^\ast}`, :math:`{\mathit{tag}}` is of the case :math:`\mathsf{tag}`.

#. Let :math:`{(\mathsf{tag}~y)^\ast}` be :math:`{{\mathit{tag}}^\ast}`.

#. Assert: Due to validation, for all :math:`{({\mathit{data}})^\ast}`, :math:`{\mathit{data}}` is of the case :math:`\mathsf{data}`.

#. Let :math:`{(\mathsf{data}~{{\mathit{byte}}^\ast}~{\mathit{datamode}})^\ast}` be :math:`{{\mathit{data}}^\ast}`.

#. Assert: Due to validation, for all :math:`{({\mathit{global}})^\ast}`, :math:`{\mathit{global}}` is of the case :math:`\mathsf{global}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_{\mathsf{g}})^\ast}` be :math:`{{\mathit{global}}^\ast}`.

#. Assert: Due to validation, for all :math:`{({\mathit{table}})^\ast}`, :math:`{\mathit{table}}` is of the case :math:`\mathsf{table}`.

#. Let :math:`{(\mathsf{table}~{\mathit{tabletype}}~{\mathit{expr}}_{\mathsf{t}})^\ast}` be :math:`{{\mathit{table}}^\ast}`.

#. Assert: Due to validation, for all :math:`{({\mathit{elem}})^\ast}`, :math:`{\mathit{elem}}` is of the case :math:`\mathsf{elem}`.

#. Let :math:`{(\mathsf{elem}~{\mathit{elemtype}}~{{\mathit{expr}}_{\mathsf{e}}^\ast}~{\mathit{elemmode}})^\ast}` be :math:`{{\mathit{elem}}^\ast}`.

#. Assert: Due to validation, for all :math:`{({\mathit{func}})^\ast}`, :math:`{\mathit{func}}` is of the case :math:`\mathsf{func}`.

#. Let :math:`{(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}}_{\mathsf{f}})^\ast}` be :math:`{{\mathit{func}}^\ast}`.

#. Let :math:`{{\mathit{xi}}^\ast}` be :math:`{{{\mathrm{allocexport}}^\ast}}{(\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~{{\mathit{fa}}_{\mathsf{i}}^\ast}~{{\mathit{fa}}^\ast},\; \mathsf{globals}~{{\mathit{ga}}_{\mathsf{i}}^\ast}~{{\mathit{ga}}^\ast},\; \mathsf{tables}~{{\mathit{ta}}_{\mathsf{i}}^\ast}~{{\mathit{ta}}^\ast},\; \mathsf{mems}~{{\mathit{ma}}_{\mathsf{i}}^\ast}~{{\mathit{ma}}^\ast},\; \mathsf{tags}~{{\mathit{aa}}_{\mathsf{i}}^\ast}~{{\mathit{aa}}^\ast},\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{exports}~\epsilon \}\end{array}, {{\mathit{export}}^\ast})}`.

#. Let :math:`{\mathit{moduleinst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{dt}}^\ast},\; \mathsf{funcs}~{{\mathit{fa}}_{\mathsf{i}}^\ast}~{{\mathit{fa}}^\ast},\; \mathsf{globals}~{{\mathit{ga}}_{\mathsf{i}}^\ast}~{{\mathit{ga}}^\ast},\; \mathsf{tables}~{{\mathit{ta}}_{\mathsf{i}}^\ast}~{{\mathit{ta}}^\ast},\; \mathsf{mems}~{{\mathit{ma}}_{\mathsf{i}}^\ast}~{{\mathit{ma}}^\ast},\; \mathsf{tags}~{{\mathit{aa}}_{\mathsf{i}}^\ast}~{{\mathit{aa}}^\ast},\; \mathsf{elems}~{{\mathit{ea}}^\ast},\; \mathsf{datas}~{{\mathit{da}}^\ast},\; \mathsf{exports}~{{\mathit{xi}}^\ast} \}\end{array}`.

#. Let :math:`n_0` be :math:`{\mathrm{allocfuncs}}({{{\mathit{dt}}^\ast}{}[x]^\ast}, {(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}}_{\mathsf{f}})^\ast}, {{\mathit{moduleinst}}^{{|{{\mathit{func}}^\ast}|}}})`.

#. Assert: Due to validation, :math:`n_0` is :math:`{{\mathit{fa}}^\ast}`.

#. Let :math:`n_0` be :math:`{\mathrm{allocglobals}}({{{\mathit{globaltype}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}^\ast}, {{\mathit{val}}_{\mathsf{g}}^\ast})`.

#. Assert: Due to validation, :math:`n_0` is :math:`{{\mathit{ga}}^\ast}`.

#. Let :math:`n_0` be :math:`{\mathrm{alloctables}}({{{\mathit{tabletype}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}^\ast}, {{\mathit{ref}}_{\mathsf{t}}^\ast})`.

#. Assert: Due to validation, :math:`n_0` is :math:`{{\mathit{ta}}^\ast}`.

#. Let :math:`n_0` be :math:`{\mathrm{allocmems}}({{{\mathit{memtype}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}^\ast})`.

#. Assert: Due to validation, :math:`n_0` is :math:`{{\mathit{ma}}^\ast}`.

#. Let :math:`n_0` be :math:`{\mathrm{alloctags}}({{{\mathit{dt}}^\ast}{}[y]^\ast})`.

#. Assert: Due to validation, :math:`n_0` is :math:`{{\mathit{aa}}^\ast}`.

#. Let :math:`n_0` be :math:`{\mathrm{allocelems}}({{{\mathit{elemtype}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}^\ast}, {{{\mathit{ref}}_{\mathsf{e}}^\ast}^\ast})`.

#. Assert: Due to validation, :math:`n_0` is :math:`{{\mathit{ea}}^\ast}`.

#. Let :math:`n_0` be :math:`{\mathrm{allocdatas}}({\mathsf{ok}^{{|{{\mathit{data}}^\ast}|}}}, {{{\mathit{byte}}^\ast}^\ast})`.

#. Assert: Due to validation, :math:`n_0` is :math:`{{\mathit{da}}^\ast}`.

#. Return :math:`{\mathit{moduleinst}}`.


:math:`{{\mathrm{runelem}}}_{x}((\mathsf{elem}~{\mathit{rt}}~{e^{n}}~{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}))`
...................................................................................................................................


1. If :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{passive}`, then:

  a. Return :math:`\epsilon`.

#. If :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{declare}`, then:

  a. Return :math:`(\mathsf{elem{.}drop}~x)`.

#. Assert: Due to validation, :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{active}`.

#. Let :math:`(\mathsf{active}~y~{{\mathit{instr}}^\ast})` be :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{{\mathit{instr}}^\ast}~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)~(\mathsf{table{.}init}~y~x)~(\mathsf{elem{.}drop}~x)`.


:math:`{{\mathrm{rundata}}}_{x}((\mathsf{data}~{b^{n}}~{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}))`
.....................................................................................................................


1. If :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is :math:`\mathsf{passive}`, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}` is of the case :math:`\mathsf{active}`.

#. Let :math:`(\mathsf{active}~y~{{\mathit{instr}}^\ast})` be :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}`.

#. Return :math:`{{\mathit{instr}}^\ast}~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)~(\mathsf{memory{.}init}~y~x)~(\mathsf{data{.}drop}~x)`.


:math:`{{{\mathrm{evalglobal}}^\ast}}{(z, {{\mathit{globaltype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}, {{\mathit{expr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
.................................................................................................................................................................................


1. Let :math:`z` be the current frame.

#. If :math:`{{\mathit{globaltype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon` and :math:`{{\mathit{expr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\epsilon`, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{{\mathit{expr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|}` is greater than or equal to :math:`1`.

#. Let :math:`{\mathit{expr}}~{{\mathit{expr}'}^\ast}` be :math:`{{\mathit{expr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{globaltype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}|}` is greater than or equal to :math:`1`.

#. Let :math:`{\mathit{gt}}~{{\mathit{gt}'}^\ast}` be :math:`{{\mathit{globaltype}}_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

#. Let :math:`{\mathit{val}}` be :math:`{\mathrm{eval}}_{\mathit{expr}}({\mathit{expr}})`.

#. Let :math:`f` be :math:`z`.

#. Let :math:`a` be :math:`{\mathrm{allocglobal}}({\mathit{gt}}, {\mathit{val}})`.

#. Append :math:`a` to the :math:`f{.}\mathsf{module}{.}\mathsf{globals}`.

#. Let :math:`{{\mathit{val}'}^\ast}` be :math:`{{{\mathrm{evalglobal}}^\ast}}{(z, {{\mathit{gt}'}^\ast}, {{\mathit{expr}'}^\ast})}`.

#. Return :math:`{\mathit{val}}~{{\mathit{val}'}^\ast}`.


:math:`{\mathrm{instantiate}}(z, {\mathit{module}}, {{\mathit{externaddr}}^\ast})`
..................................................................................


1. Let :math:`{{\mathit{xt}}_{\mathsf{i}}^\ast}~\rightarrow~{{\mathit{xt}}_{\mathsf{e}}^\ast}` be :math:`{\mathrm{Module}}_{\mathit{ok}}({\mathit{module}})`.

#. Assert: Due to validation, :math:`{\mathit{module}}` is of the case :math:`\mathsf{module}`.

#. Let :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{tag}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be :math:`{\mathit{module}}`.

#. Assert: Due to validation, :math:`{{\mathrm{Externaddr}}_{\mathit{type}}({\mathit{externaddr}}, {\mathit{xt}}_{\mathsf{i}})^\ast}`.

#. Let :math:`{{\mathit{instr}}_{\mathsf{d}}^\ast}` be :math:`{\bigoplus}\, {{{\mathrm{rundata}}}_{i_{\mathsf{d}}}({{\mathit{data}}^\ast}{}[i_{\mathsf{d}}])^{i_{\mathsf{d}}<{|{{\mathit{data}}^\ast}|}}}`.

#. Let :math:`{{\mathit{instr}}_{\mathsf{e}}^\ast}` be :math:`{\bigoplus}\, {{{\mathrm{runelem}}}_{i_{\mathsf{e}}}({{\mathit{elem}}^\ast}{}[i_{\mathsf{e}}])^{i_{\mathsf{e}}<{|{{\mathit{elem}}^\ast}|}}}`.

#. Assert: Due to validation, for all :math:`{({\mathit{start}})^?}`, :math:`{\mathit{start}}` is of the case :math:`\mathsf{start}`.

#. Let :math:`{(\mathsf{start}~x)^?}` be :math:`{{\mathit{start}}^?}`.

#. Let :math:`{\mathit{moduleinst}}_0` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{{\mathrm{alloctype}}^\ast}}{({{\mathit{type}}^\ast})},\; \mathsf{funcs}~{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})~{{|s{.}\mathsf{funcs}|} + i_{\mathsf{f}}^{i_{\mathsf{f}}<{|{{\mathit{func}}^\ast}|}}},\; \mathsf{globals}~{\mathrm{globals}}({{\mathit{externaddr}}^\ast}),\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{tags}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{exports}~\epsilon \}\end{array}`.

#. Assert: Due to validation, for all :math:`{({\mathit{data}})^\ast}`, :math:`{\mathit{data}}` is of the case :math:`\mathsf{data}`.

#. Assert: Due to validation, for all :math:`{({\mathit{table}})^\ast}`, :math:`{\mathit{table}}` is of the case :math:`\mathsf{table}`.

#. Let :math:`{(\mathsf{table}~{\mathit{tabletype}}~{\mathit{expr}}_{\mathsf{t}})^\ast}` be :math:`{{\mathit{table}}^\ast}`.

#. Assert: Due to validation, for all :math:`{({\mathit{global}})^\ast}`, :math:`{\mathit{global}}` is of the case :math:`\mathsf{global}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_{\mathsf{g}})^\ast}` be :math:`{{\mathit{global}}^\ast}`.

#. Assert: Due to validation, for all :math:`{({\mathit{elem}})^\ast}`, :math:`{\mathit{elem}}` is of the case :math:`\mathsf{elem}`.

#. Let :math:`{(\mathsf{elem}~{\mathit{reftype}}~{{\mathit{expr}}_{\mathsf{e}}^\ast}~{\mathit{elemmode}})^\ast}` be :math:`{{\mathit{elem}}^\ast}`.

#. Let :math:`{{\mathit{instr}}_{\mathsf{s}}^?}` be :math:`{(\mathsf{call}~x)^?}`.

#. Let :math:`z` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~\epsilon,\; \mathsf{module}~{\mathit{moduleinst}}_0 \}\end{array}`.

#. Push the activation of :math:`z` to the stack.

#. Let :math:`{{\mathit{val}}_{\mathsf{g}}^\ast}` be :math:`{{{\mathrm{evalglobal}}^\ast}}{(z, {{\mathit{globaltype}}^\ast}, {{\mathit{expr}}_{\mathsf{g}}^\ast})}`.

#. Pop the activation of :math:`{z'}` from the stack.

#. Push the activation of :math:`{z'}` to the stack.

#. Let :math:`{{\mathit{ref}}_{\mathsf{t}}^\ast}` be :math:`{{\mathrm{eval}}_{\mathit{expr}}({\mathit{expr}}_{\mathsf{t}})^\ast}`.

#. Pop the activation of :math:`f` from the stack.

#. Push the activation of :math:`{z'}` to the stack.

#. Let :math:`{{{\mathit{ref}}_{\mathsf{e}}^\ast}^\ast}` be :math:`{{{\mathrm{eval}}_{\mathit{expr}}({\mathit{expr}}_{\mathsf{e}})^\ast}^\ast}`.

#. Pop the activation of :math:`f` from the stack.

#. Let :math:`{\mathit{moduleinst}}` be :math:`{\mathrm{allocmodule}}({\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}_{\mathsf{g}}^\ast}, {{\mathit{ref}}_{\mathsf{t}}^\ast}, {{{\mathit{ref}}_{\mathsf{e}}^\ast}^\ast})`.

#. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~\epsilon,\; \mathsf{module}~{\mathit{moduleinst}} \}\end{array}`.

#. Push the activation of :math:`f` with arity :math:`0` to the stack.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{e}}^\ast}`.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{d}}^\ast}`.

#. If :math:`{{\mathit{instr}}_{\mathsf{s}}^?}` is defined, then:

  a. Execute the instruction :math:`{\mathit{instr}}_{\mathsf{s}}`.

#. Pop the activation of :math:`f` with arity :math:`0` from the stack.

#. Return :math:`f{.}\mathsf{module}`.


:math:`{\mathrm{invoke}}({\mathit{funcaddr}}, {{\mathit{val}}^\ast})`
.....................................................................


1. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~\epsilon,\; \mathsf{module}~\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{tags}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{exports}~\epsilon \}\end{array} \}\end{array}`.

#. Assert: Due to validation, :math:`{\mathrm{expand}}(s{.}\mathsf{funcs}{}[{\mathit{funcaddr}}]{.}\mathsf{type})` is of the case :math:`\mathsf{func}`.

#. Let :math:`(\mathsf{func}~{\mathit{functype}}_0)` be :math:`{\mathrm{expand}}(s{.}\mathsf{funcs}{}[{\mathit{funcaddr}}]{.}\mathsf{type})`.

#. Let :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` be :math:`{\mathit{functype}}_0`.

#. Assert: Due to validation, :math:`{{\mathrm{Val}}_{\mathit{type}}({\mathit{val}}, t_1)^\ast}`.

#. Let :math:`k` be :math:`{|{t_2^\ast}|}`.

#. Push the activation of :math:`f` with arity :math:`k` to the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

#. Push the value :math:`(\mathsf{ref{.}func}~{\mathit{funcaddr}})` to the stack.

#. Execute the instruction :math:`(\mathsf{call\_ref}~s{.}\mathsf{funcs}{}[{\mathit{funcaddr}}]{.}\mathsf{type})`.

#. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Pop the activation of :math:`f` with arity :math:`k` from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Return :math:`{{\mathit{val}}^{k}}`.


:math:`{\mathrm{allocXs}}({\mathit{TODO}}, {\mathit{TODO}}, {X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}, {Y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
................................................................................................................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}` is :math:`\epsilon`, then:

  a. Assert: Due to validation, :math:`{Y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is :math:`\epsilon`.

  #. Return :math:`\epsilon`.

#. Else:

  a. Let :math:`X~{{X'}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 0}}}^\ast}`.

  #. Assert: Due to validation, :math:`{|{Y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|}` is greater than or equal to :math:`1`.

  #. Let :math:`Y~{{Y'}^\ast}` be :math:`{Y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

  #. Let :math:`a` be :math:`{\mathrm{allocX}}({\mathit{TODO}}, {\mathit{TODO}}, X, Y)`.

  #. Let :math:`{{a'}^\ast}` be :math:`{\mathrm{allocXs}}({\mathit{TODO}}, {\mathit{TODO}}, {{X'}^\ast}, {{Y'}^\ast})`.

  #. Return :math:`a~{{a'}^\ast}`.


:math:`{\mathit{TODO}}`
.......................


1. Return :math:`0`.


:math:`{\mathrm{eval}}_{\mathit{expr}}({{\mathit{instr}}^\ast})`
................................................................


1. Execute the instruction :math:`{{\mathit{instr}}^\ast}`.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Return :math:`{\mathit{val}}`.


== Complete.
watsup 0.4 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...
Numtype_ok
- the number type numtype is valid.

Vectype_ok
- the vector type vectype is valid.

Heaptype_ok
- the heap type heaptype_u0 is valid if:
  - Either: heaptype_u0 is absheaptype.
  - Or:
    - heaptype_u0 is (_IDX typeidx).
    - |C.TYPES| is greater than typeidx.
    - C.TYPES[typeidx] is dt.
  - Or:
    - heaptype_u0 is (REC i).
    - |C.RECS| is greater than i.
    - C.RECS[i] is st.

Reftype_ok
- the reference type (REF (NULL ()? ?) heaptype) is valid if:
  - the heap type heaptype is valid.

Valtype_ok
- the value type valtype_u0 is valid if:
  - Either:
    - valtype_u0 is numtype.
    - the number type numtype is valid.
  - Or:
    - valtype_u0 is vectype.
    - the vector type vectype is valid.
  - Or:
    - valtype_u0 is reftype.
    - the reference type reftype is valid.
  - Or: valtype_u0 is BOT.

Resulttype_ok
- the value type sequence t* is valid if:
  - For all t in t*, the value type t is valid.

Instrtype_ok
- the instruction type t_1* ->_ x* t_2* is valid if:
  - the value type sequence t_1* is valid.
  - the value type sequence t_2* is valid.
  - |x*| is |lct*|.
  - For all x in x*, |C.LOCALS| is greater than x.
  - For all lct in lct* and x in x*, C.LOCALS[x] is lct.

Packtype_ok
- the packed type packtype is valid.

Storagetype_ok
- the storage type storagetype_u0 is valid if:
  - Either:
    - storagetype_u0 is valtype.
    - the value type valtype is valid.
  - Or:
    - storagetype_u0 is packtype.
    - the packed type packtype is valid.

Fieldtype_ok
- the field type ((MUT ()? ?) storagetype) is valid if:
  - the storage type storagetype is valid.

Functype_ok
- the function type t_1* -> t_2* is valid if:
  - the value type sequence t_1* is valid.
  - the value type sequence t_2* is valid.

Comptype_ok
- the composite type comptype_u0 is valid if:
  - Either:
    - comptype_u0 is (STRUCT fieldtype*).
    - For all fieldtype in fieldtype*, the field type fieldtype is valid.
  - Or:
    - comptype_u0 is (ARRAY fieldtype).
    - the field type fieldtype is valid.
  - Or:
    - comptype_u0 is (FUNC functype).
    - the function type functype is valid.

Packtype_sub
- the packed type packtype matches the packed type packtype.

Numtype_sub
- the number type numtype matches the number type numtype.

Deftype_sub
- the defined type deftype_1 matches the defined type deftype_2 if:
  - Either: $clos_deftype(C, deftype_1) is $clos_deftype(C, deftype_2).
  - Or:
    - $unrolldt(deftype_1) is (SUB fin typeuse* ct).
    - |typeuse*| is greater than i.
    - the type use typeuse*[i] matches the heap type deftype_2.

Heaptype_sub
- the heap type heaptype_u0 matches the heap type heaptype_u1 if:
  - Either:
    - heaptype_u0 is heaptype.
    - heaptype_u1 is heaptype.
  - Or:
    - heaptype_u0 is heaptype_1.
    - heaptype_u1 is heaptype_2.
    - the heap type heaptype' is valid.
    - the heap type heaptype_1 matches the heap type heaptype'.
    - the heap type heaptype' matches the heap type heaptype_2.
  - Or:
    - heaptype_u0 is EQ.
    - heaptype_u1 is ANY.
  - Or:
    - heaptype_u0 is I31.
    - heaptype_u1 is EQ.
  - Or:
    - heaptype_u0 is STRUCT.
    - heaptype_u1 is EQ.
  - Or:
    - heaptype_u0 is ARRAY.
    - heaptype_u1 is EQ.
  - Or:
    - heaptype_u0 is deftype.
    - heaptype_u1 is STRUCT.
    - The :ref:`expansion <aux-expand-deftype>` of deftype is (STRUCT fieldtype*)
  - Or:
    - heaptype_u0 is deftype.
    - heaptype_u1 is ARRAY.
    - The :ref:`expansion <aux-expand-deftype>` of deftype is (ARRAY fieldtype)
  - Or:
    - heaptype_u0 is deftype.
    - heaptype_u1 is FUNC.
    - The :ref:`expansion <aux-expand-deftype>` of deftype is (FUNC functype)
  - Or:
    - heaptype_u0 is deftype_1.
    - heaptype_u1 is deftype_2.
    - the defined type deftype_1 matches the defined type deftype_2.
  - Or:
    - heaptype_u0 is (_IDX typeidx).
    - heaptype_u1 is heaptype.
    - |C.TYPES| is greater than typeidx.
    - the defined type C.TYPES[typeidx] matches the heap type heaptype.
  - Or:
    - heaptype_u0 is heaptype.
    - heaptype_u1 is (_IDX typeidx).
    - |C.TYPES| is greater than typeidx.
    - the heap type heaptype matches the defined type C.TYPES[typeidx].
  - Or:
    - heaptype_u0 is (REC i).
    - heaptype_u1 is typeuse*[j].
    - |typeuse*| is greater than j.
    - |C.RECS| is greater than i.
    - C.RECS[i] is (SUB fin typeuse* ct).
  - Or:
    - heaptype_u0 is NONE.
    - heaptype_u1 is heaptype.
    - the heap type heaptype matches the heap type ANY.
  - Or:
    - heaptype_u0 is NOFUNC.
    - heaptype_u1 is heaptype.
    - the heap type heaptype matches the heap type FUNC.
  - Or:
    - heaptype_u0 is NOEXTERN.
    - heaptype_u1 is heaptype.
    - the heap type heaptype matches the heap type EXTERN.
  - Or:
    - heaptype_u0 is BOT.
    - heaptype_u1 is heaptype.

Reftype_sub
- the reference type (REF (NULL _u0? ?) ht_1) matches the reference type (REF (NULL _u1? ?) ht_2) if:
  - the heap type ht_1 matches the heap type ht_2.
  - Either:
    - _u0? is ?().
    - _u1? is ?().
  - Or:
    - _u0? is ()?.
    - _u1? is ?(()).

Vectype_sub
- the vector type vectype matches the vector type vectype.

Valtype_sub
- the value type valtype_u0 matches the value type valtype_u1 if:
  - Either:
    - valtype_u0 is numtype_1.
    - valtype_u1 is numtype_2.
    - the number type numtype_1 matches the number type numtype_2.
  - Or:
    - valtype_u0 is vectype_1.
    - valtype_u1 is vectype_2.
    - the vector type vectype_1 matches the vector type vectype_2.
  - Or:
    - valtype_u0 is reftype_1.
    - valtype_u1 is reftype_2.
    - the reference type reftype_1 matches the reference type reftype_2.
  - Or:
    - valtype_u0 is BOT.
    - valtype_u1 is valtype.

Storagetype_sub
- the storage type storagetype_u0 matches the storage type storagetype_u1 if:
  - Either:
    - storagetype_u0 is valtype_1.
    - storagetype_u1 is valtype_2.
    - the value type valtype_1 matches the value type valtype_2.
  - Or:
    - storagetype_u0 is packtype_1.
    - storagetype_u1 is packtype_2.
    - the packed type packtype_1 matches the packed type packtype_2.

Fieldtype_sub
- the field type ((MUT _u0? ?) zt_1) matches the field type ((MUT _u1? ?) zt_2) if:
  - the storage type zt_1 matches the storage type zt_2.
  - Either:
    - _u0? is ?().
    - _u1? is ?().
  - Or:
    - _u0? is ?(()).
    - _u1? is ?(()).
    - the storage type zt_2 matches the storage type zt_1.

Resulttype_sub
- the value type sequence t_1* matches the value type sequence t_2* if:
  - |t_2*| is |t_1*|.
  - For all t_1 in t_1* and t_2 in t_2*, the value type t_1 matches the value type t_2.

Functype_sub
- the function type t_11* -> t_12* matches the function type t_21* -> t_22* if:
  - the value type sequence t_21* matches the value type sequence t_11*.
  - the value type sequence t_12* matches the value type sequence t_22*.

Comptype_sub
- the composite type comptype_u0 matches the composite type comptype_u1 if:
  - Either:
    - comptype_u0 is (STRUCT yt_1* :: [yt'_1]).
    - comptype_u1 is (STRUCT yt_2*).
    - |yt_2*| is |yt_1*|.
    - For all yt_1 in yt_1* and yt_2 in yt_2*, the field type yt_1 matches the field type yt_2.
  - Or:
    - comptype_u0 is (ARRAY yt_1).
    - comptype_u1 is (ARRAY yt_2).
    - the field type yt_1 matches the field type yt_2.
  - Or:
    - comptype_u0 is (FUNC ft_1).
    - comptype_u1 is (FUNC ft_2).
    - the function type ft_1 matches the function type ft_2.

Subtype_ok
- the sub type (SUB (FINAL ()? ?) (_IDX x)* comptype) is valid with the oktypeidx (OK x_0) if:
  - |x*| is less than or equal to 1.
  - For all x in x*, x is less than x_0.
  - |x*| is |comptype'*|.
  - |x'**| is |comptype'*|.
  - For all x in x*, |C.TYPES| is greater than x.
  - For all comptype' in comptype'* and x in x* and x'* in x'**, $unrolldt(C.TYPES[x]) is (SUB (_IDX x')* comptype').
  - the composite type comptype is valid.
  - For all comptype' in comptype'*, the composite type comptype matches the composite type comptype'.

Subtype_ok2
- the sub type (SUB (FINAL ()? ?) typeuse* compttype) is valid with the oktypeidxnat (OK x i) if:
  - |typeuse*| is less than or equal to 1.
  - For all typeuse in typeuse*, $before(typeuse, x, i) is true.
  - |typeuse*| is |comptype'*|.
  - |typeuse'**| is |comptype'*|.
  - For all comptype' in comptype'* and typeuse in typeuse* and typeuse'* in typeuse'**, $unrollht(C, typeuse) is (SUB typeuse'* comptype').
  - the composite type comptype is valid.
  - For all comptype' in comptype'*, the composite type comptype matches the composite type comptype'.

Rectype_ok2
- the recursive type (REC subtype_u0*) is valid with the oktypeidxnat (OK x i) if:
  - Either: subtype_u0* is [].
  - Or:
    - subtype_u0* is [subtype_1] :: subtype*.
    - the sub type subtype_1 is valid with the oktypeidxnat (OK x i).
    - the recursive type (REC subtype*) is valid with the oktypeidxnat (OK (x + 1) (i + 1)).

Rectype_ok
- the recursive type (REC subtype_u0*) is valid with the oktypeidx (OK x) if:
  - Either: subtype_u0* is [].
  - Or:
    - subtype_u0* is [subtype_1] :: subtype*.
    - the sub type subtype_1 is valid with the oktypeidx (OK x).
    - the recursive type (REC subtype*) is valid with the oktypeidx (OK (x + 1)).
  - Or:
    - subtype_u0* is subtype*.
    - Under the context C with .RECS prepended by subtype*, the recursive type (REC subtype*) is valid with the oktypeidxnat (OK x 0).

Deftype_ok
- the defined type (DEF rectype i) is valid if:
  - the recursive type rectype is valid with the oktypeidx (OK x).
  - rectype is (REC subtype^n).
  - i is less than n.

Limits_ok
- the limits (n, m) is valid with the nat k if:
  - n is less than or equal to m.
  - m is less than or equal to k.

Globaltype_ok
- the global type ((MUT ()? ?) t) is valid if:
  - the value type t is valid.

Tabletype_ok
- the table type (limits reftype) is valid if:
  - the limits limits is valid with the nat ((2 ^ 32) - 1).
  - the reference type reftype is valid.

Memtype_ok
- the memory type limits PAGE is valid if:
  - the limits limits is valid with the nat (2 ^ 16).

Tagtype_ok
- the memory type deftype is valid if:
  - the defined type deftype is valid.
  - The :ref:`expansion <aux-expand-deftype>` of deftype is (FUNC functype)

Externtype_ok
- the external type externtype_u0 is valid if:
  - Either:
    - externtype_u0 is (FUNC deftype).
    - the defined type deftype is valid.
    - The :ref:`expansion <aux-expand-deftype>` of deftype is (FUNC functype)
  - Or:
    - externtype_u0 is (GLOBAL globaltype).
    - the global type globaltype is valid.
  - Or:
    - externtype_u0 is (TABLE tabletype).
    - the table type tabletype is valid.
  - Or:
    - externtype_u0 is (MEM memtype).
    - the memory type memtype is valid.
  - Or:
    - externtype_u0 is (TAG tagtype).
    - the memory type tagtype is valid.

Instrtype_sub
- the instruction type t_11* ->_ x_1* t_12* matches the instruction type t_21* ->_ x_2* t_22* if:
  - the value type sequence t_21* matches the value type sequence t_11*.
  - the value type sequence t_12* matches the value type sequence t_22*.
  - x* is $setminus_(localidx, x_2*, x_1*).
  - |x*| is |t*|.
  - For all x in x*, |C.LOCALS| is greater than x.
  - For all t in t* and x in x*, C.LOCALS[x] is (SET t).

Limits_sub
- the limits (n_1, m_1) matches the limits (n_2, m_2) if:
  - n_1 is greater than or equal to n_2.
  - m_1 is less than or equal to m_2.

Globaltype_sub
- the global type ((MUT _u0? ?) valtype_1) matches the global type ((MUT _u1? ?) valtype_2) if:
  - the value type valtype_1 matches the value type valtype_2.
  - Either:
    - _u0? is ?().
    - _u1? is ?().
  - Or:
    - _u0? is ?(()).
    - _u1? is ?(()).
    - the value type valtype_2 matches the value type valtype_1.

Tabletype_sub
- the table type (limits_1 reftype_1) matches the table type (limits_2 reftype_2) if:
  - the limits limits_1 matches the limits limits_2.
  - the reference type reftype_1 matches the reference type reftype_2.
  - the reference type reftype_2 matches the reference type reftype_1.

Memtype_sub
- the memory type limits_1 PAGE matches the memory type limits_2 PAGE if:
  - the limits limits_1 matches the limits limits_2.

Tagtype_sub
- the memory type deftype_1 matches the memory type deftype_2 if:
  - the defined type deftype_1 matches the defined type deftype_2.
  - the defined type deftype_2 matches the defined type deftype_1.

Externtype_sub
- the external type externtype_u0 matches the external type externtype_u1 if:
  - Either:
    - externtype_u0 is (FUNC deftype_1).
    - externtype_u1 is (FUNC deftype_2).
    - the defined type deftype_1 matches the defined type deftype_2.
  - Or:
    - externtype_u0 is (GLOBAL globaltype_1).
    - externtype_u1 is (GLOBAL globaltype_2).
    - the global type globaltype_1 matches the global type globaltype_2.
  - Or:
    - externtype_u0 is (TABLE tabletype_1).
    - externtype_u1 is (TABLE tabletype_2).
    - the table type tabletype_1 matches the table type tabletype_2.
  - Or:
    - externtype_u0 is (MEM memtype_1).
    - externtype_u1 is (MEM memtype_2).
    - the memory type memtype_1 matches the memory type memtype_2.
  - Or:
    - externtype_u0 is (TAG tagtype_1).
    - externtype_u1 is (TAG tagtype_2).
    - the memory type tagtype_1 matches the memory type tagtype_2.

Blocktype_ok
- the block type blocktype_u0 is valid with the instruction type valtype_u1* -> valtype_u2* if:
  - Either:
    - blocktype_u0 is (_RESULT valtype?).
    - valtype_u1* is [].
    - valtype_u2* is valtype?.
    - If valtype is defined, the value type valtype is valid.
  - Or:
    - blocktype_u0 is (_IDX typeidx).
    - valtype_u1* is t_1*.
    - valtype_u2* is t_2*.
    - |C.TYPES| is greater than typeidx.
    - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[typeidx] is (FUNC t_1* -> t_2*)

Catch_ok
- the catch clause catch_u0 is valid if:
  - |C.LABELS| is greater than l.
  - Either:
    - catch_u0 is (CATCH x l).
    - |C.TAGS| is greater than x.
    - The :ref:`expansion <aux-expand-deftype>` of C.TAGS[x] is (FUNC t* -> [])
    - the value type sequence t* matches the result type C.LABELS[l].
  - Or:
    - catch_u0 is (CATCH_REF x l).
    - |C.TAGS| is greater than x.
    - The :ref:`expansion <aux-expand-deftype>` of C.TAGS[x] is (FUNC t* -> [])
    - the value type sequence t* :: [(REF EXN)] matches the result type C.LABELS[l].
  - Or:
    - catch_u0 is (CATCH_ALL l).
    - the value type sequence [] matches the result type C.LABELS[l].
  - Or:
    - catch_u0 is (CATCH_ALL_REF l).
    - the value type sequence [(REF EXN)] matches the result type C.LABELS[l].

Instr_ok/nop
- the instruction NOP is valid with the instruction type [] -> [].

Instr_ok/unreachable
- the instruction UNREACHABLE is valid with the instruction type t_1* -> t_2* if:
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/drop
- the instruction DROP is valid with the instruction type [t] -> [] if:
  - the value type t is valid.

Instr_ok/select
- the instruction (SELECT valtype_u0?) is valid with the instruction type [t, t, I32] -> [t] if:
  - the value type t is valid.
  - Either: valtype_u0? is ?([t]).
  - Or:
    - valtype_u0? is ?().
    - the value type t matches the value type t'.
    - t' is contained in [numtype, vectype].

Instr_ok/block
- the instruction (BLOCK bt instr*) is valid with the instruction type t_1* -> t_2* if:
  - the block type bt is valid with the instruction type t_1* -> t_2*.
  - Under the context C with .LABELS prepended by [t_2*], the instruction sequence instr* is valid with the instruction type t_1* ->_ x* t_2*.

Instr_ok/loop
- the instruction (LOOP bt instr*) is valid with the instruction type t_1* -> t_2* if:
  - the block type bt is valid with the instruction type t_1* -> t_2*.
  - Under the context C with .LABELS prepended by [t_1*], the instruction sequence instr* is valid with the instruction type t_1* ->_ x* t_2*.

Instr_ok/if
- the instruction (IF bt instr_1* ELSE instr_2*) is valid with the instruction type t_1* :: [I32] -> t_2* if:
  - the block type bt is valid with the instruction type t_1* -> t_2*.
  - Under the context C with .LABELS prepended by [t_2*], the instruction sequence instr_1* is valid with the instruction type t_1* ->_ x_1* t_2*.
  - Under the context C with .LABELS prepended by [t_2*], the instruction sequence instr_2* is valid with the instruction type t_1* ->_ x_2* t_2*.

Instr_ok/br
- the instruction (BR l) is valid with the instruction type t_1* :: t* -> t_2* if:
  - |C.LABELS| is greater than l.
  - C.LABELS[l] is t*.
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/br_if
- the instruction (BR_IF l) is valid with the instruction type t* :: [I32] -> t* if:
  - |C.LABELS| is greater than l.
  - C.LABELS[l] is t*.

Instr_ok/br_table
- the instruction (BR_TABLE l* l') is valid with the instruction type t_1* :: t* :: [I32] -> t_2* if:
  - For all l in l*, |C.LABELS| is greater than l.
  - For all l in l*, the value type sequence t* matches the result type C.LABELS[l].
  - |C.LABELS| is greater than l'.
  - the value type sequence t* matches the result type C.LABELS[l'].
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/br_on_null
- the instruction (BR_ON_NULL l) is valid with the instruction type t* :: [(REF NULL ht)] -> t* :: [(REF ht)] if:
  - |C.LABELS| is greater than l.
  - C.LABELS[l] is t*.
  - the heap type ht is valid.

Instr_ok/br_on_non_null
- the instruction (BR_ON_NON_NULL l) is valid with the instruction type t* :: [(REF NULL ht)] -> t* if:
  - |C.LABELS| is greater than l.
  - C.LABELS[l] is t* :: [(REF ht)].

Instr_ok/br_on_cast
- the instruction (BR_ON_CAST l rt_1 rt_2) is valid with the instruction type t* :: [rt_1] -> t* :: [$diffrt(rt_1, rt_2)] if:
  - |C.LABELS| is greater than l.
  - C.LABELS[l] is t* :: [rt].
  - the reference type rt_1 is valid.
  - the reference type rt_2 is valid.
  - the reference type rt_2 matches the reference type rt_1.
  - the reference type rt_2 matches the reference type rt.

Instr_ok/br_on_cast_fail
- the instruction (BR_ON_CAST_FAIL l rt_1 rt_2) is valid with the instruction type t* :: [rt_1] -> t* :: [rt_2] if:
  - |C.LABELS| is greater than l.
  - C.LABELS[l] is t* :: [rt].
  - the reference type rt_1 is valid.
  - the reference type rt_2 is valid.
  - the reference type rt_2 matches the reference type rt_1.
  - the reference type $diffrt(rt_1, rt_2) matches the reference type rt.

Instr_ok/call
- the instruction (CALL x) is valid with the instruction type t_1* -> t_2* if:
  - |C.FUNCS| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.FUNCS[x] is (FUNC t_1* -> t_2*)

Instr_ok/call_ref
- the instruction (CALL_REF (_IDX x)) is valid with the instruction type t_1* :: [(REF NULL (_IDX x))] -> t_2* if:
  - |C.TYPES| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (FUNC t_1* -> t_2*)

Instr_ok/call_indirect
- the instruction (CALL_INDIRECT x (_IDX y)) is valid with the instruction type t_1* :: [I32] -> t_2* if:
  - |C.TABLES| is greater than x.
  - C.TABLES[x] is (lim rt).
  - the reference type rt matches the reference type (REF NULL FUNC).
  - |C.TYPES| is greater than y.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[y] is (FUNC t_1* -> t_2*)

Instr_ok/return
- the instruction RETURN is valid with the instruction type t_1* :: t* -> t_2* if:
  - C.RETURN is ?(t*).
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/return_call
- the instruction (RETURN_CALL x) is valid with the instruction type t_3* :: t_1* -> t_4* if:
  - |C.FUNCS| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.FUNCS[x] is (FUNC t_1* -> t_2*)
  - C.RETURN is ?(t'_2*).
  - the value type sequence t_2* matches the value type sequence t'_2*.
  - the instruction type t_3* -> t_4* is valid.

Instr_ok/return_call_ref
- the instruction (RETURN_CALL_REF (_IDX x)) is valid with the instruction type t_3* :: t_1* :: [(REF NULL (_IDX x))] -> t_4* if:
  - |C.TYPES| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (FUNC t_1* -> t_2*)
  - C.RETURN is ?(t'_2*).
  - the value type sequence t_2* matches the value type sequence t'_2*.
  - the instruction type t_3* -> t_4* is valid.

Instr_ok/return_call_indirect
- the instruction (RETURN_CALL_INDIRECT x (_IDX y)) is valid with the instruction type t_3* :: t_1* :: [I32] -> t_4* if:
  - |C.TABLES| is greater than x.
  - C.TABLES[x] is (lim rt).
  - the reference type rt matches the reference type (REF NULL FUNC).
  - |C.TYPES| is greater than y.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[y] is (FUNC t_1* -> t_2*)
  - C.RETURN is ?(t'_2*).
  - the value type sequence t_2* matches the value type sequence t'_2*.
  - the instruction type t_3* -> t_4* is valid.

Instr_ok/throw
- the instruction (THROW x) is valid with the instruction type t_1* :: t* -> t_2* if:
  - |C.TAGS| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.TAGS[x] is (FUNC t* -> [])
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/throw_ref
- the instruction THROW_REF is valid with the instruction type t_1* :: [(REF NULL EXN)] -> t_2* if:
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/try_table
- the instruction (TRY_TABLE bt catch* instr*) is valid with the instruction type t_1* -> t_2* if:
  - the block type bt is valid with the instruction type t_1* -> t_2*.
  - Under the context C with .LABELS prepended by [t_2*], the instruction sequence instr* is valid with the instruction type t_1* ->_ x* t_2*.
  - For all catch in catch*, the catch clause catch is valid.

Instr_ok/const
- the instruction (nt.CONST c_nt) is valid with the instruction type [] -> [nt].

Instr_ok/unop
- the instruction (UNOP nt unop_nt) is valid with the instruction type [nt] -> [nt].

Instr_ok/binop
- the instruction (BINOP nt binop_nt) is valid with the instruction type [nt, nt] -> [nt].

Instr_ok/testop
- the instruction (TESTOP nt testop_nt) is valid with the instruction type [nt] -> [I32].

Instr_ok/relop
- the instruction (RELOP nt relop_nt) is valid with the instruction type [nt, nt] -> [I32].

Instr_ok/cvtop
- the instruction (CVTOP nt_1 nt_2 cvtop) is valid with the instruction type [nt_2] -> [nt_1].

Instr_ok/ref.null
- the instruction (REF.NULL ht) is valid with the instruction type [] -> [(REF NULL ht)] if:
  - the heap type ht is valid.

Instr_ok/ref.func
- the instruction (REF.FUNC x) is valid with the instruction type [] -> [(REF dt)] if:
  - |C.FUNCS| is greater than x.
  - C.FUNCS[x] is dt.
  - |C.REFS| is greater than 0.
  - x is contained in C.REFS.

Instr_ok/ref.i31
- the instruction REF.I31 is valid with the instruction type [I32] -> [(REF I31)].

Instr_ok/ref.is_null
- the instruction REF.IS_NULL is valid with the instruction type [(REF NULL ht)] -> [I32] if:
  - the heap type ht is valid.

Instr_ok/ref.as_non_null
- the instruction REF.AS_NON_NULL is valid with the instruction type [(REF NULL ht)] -> [(REF ht)] if:
  - the heap type ht is valid.

Instr_ok/ref.eq
- the instruction REF.EQ is valid with the instruction type [(REF NULL EQ), (REF NULL EQ)] -> [I32].

Instr_ok/ref.test
- the instruction (REF.TEST rt) is valid with the instruction type [rt'] -> [I32] if:
  - the reference type rt is valid.
  - the reference type rt' is valid.
  - the reference type rt matches the reference type rt'.

Instr_ok/ref.cast
- the instruction (REF.CAST rt) is valid with the instruction type [rt'] -> [rt] if:
  - the reference type rt is valid.
  - the reference type rt' is valid.
  - the reference type rt matches the reference type rt'.

Instr_ok/i31.get
- the instruction (I31.GET sx) is valid with the instruction type [(REF NULL I31)] -> [I32].

Instr_ok/struct.new
- the instruction (STRUCT.NEW x) is valid with the instruction type $unpack(zt)* -> [(REF (_IDX x))] if:
  - |C.TYPES| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (STRUCT (mut zt)*)

Instr_ok/struct.new_default
- the instruction (STRUCT.NEW_DEFAULT x) is valid with the instruction type [] -> [(REF (_IDX x))] if:
  - |C.TYPES| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (STRUCT (mut zt)*)
  - |zt*| is |val*|.
  - For all val in val* and zt in zt*, $default_($unpack(zt)) is ?(val).

Instr_ok/struct.get
- the instruction (STRUCT.GET sx? x i) is valid with the instruction type [(REF NULL (_IDX x))] -> [$unpack(zt)] if:
  - |C.TYPES| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (STRUCT yt*)
  - |yt*| is greater than i.
  - yt*[i] is (mut zt).
  - ((sx? is ?()) is equivalent to (zt is $unpack(zt))).

Instr_ok/struct.set
- the instruction (STRUCT.SET x i) is valid with the instruction type [(REF NULL (_IDX x)), $unpack(zt)] -> [] if:
  - |C.TYPES| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (STRUCT yt*)
  - |yt*| is greater than i.
  - yt*[i] is (MUT zt).

Instr_ok/array.new
- the instruction (ARRAY.NEW x) is valid with the instruction type [$unpack(zt), I32] -> [(REF (_IDX x))] if:
  - |C.TYPES| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (ARRAY (mut zt))

Instr_ok/array.new_default
- the instruction (ARRAY.NEW_DEFAULT x) is valid with the instruction type [I32] -> [(REF (_IDX x))] if:
  - |C.TYPES| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (ARRAY (mut zt))
  - $default_($unpack(zt)) is ?(val).

Instr_ok/array.new_fixed
- the instruction (ARRAY.NEW_FIXED x n) is valid with the instruction type $unpack(zt)^n -> [(REF (_IDX x))] if:
  - |C.TYPES| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (ARRAY (mut zt))

Instr_ok/array.new_elem
- the instruction (ARRAY.NEW_ELEM x y) is valid with the instruction type [I32, I32] -> [(REF (_IDX x))] if:
  - |C.TYPES| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (ARRAY (mut rt))
  - |C.ELEMS| is greater than y.
  - the reference type C.ELEMS[y] matches the reference type rt.

Instr_ok/array.new_data
- the instruction (ARRAY.NEW_DATA x y) is valid with the instruction type [I32, I32] -> [(REF (_IDX x))] if:
  - |C.TYPES| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (ARRAY (mut zt))
  - $unpack(zt) is contained in [numtype, vectype].
  - |C.DATAS| is greater than y.
  - C.DATAS[y] is OK.

Instr_ok/array.get
- the instruction (ARRAY.GET sx? x) is valid with the instruction type [(REF NULL (_IDX x)), I32] -> [$unpack(zt)] if:
  - |C.TYPES| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (ARRAY (mut zt))
  - ((sx? is ?()) is equivalent to (zt is $unpack(zt))).

Instr_ok/array.set
- the instruction (ARRAY.SET x) is valid with the instruction type [(REF NULL (_IDX x)), I32, $unpack(zt)] -> [] if:
  - |C.TYPES| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (ARRAY (MUT zt))

Instr_ok/array.len
- the instruction ARRAY.LEN is valid with the instruction type [(REF NULL ARRAY)] -> [I32].

Instr_ok/array.fill
- the instruction (ARRAY.FILL x) is valid with the instruction type [(REF NULL (_IDX x)), I32, $unpack(zt), I32] -> [] if:
  - |C.TYPES| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (ARRAY (MUT zt))

Instr_ok/array.copy
- the instruction (ARRAY.COPY x_1 x_2) is valid with the instruction type [(REF NULL (_IDX x_1)), I32, (REF NULL (_IDX x_2)), I32, I32] -> [] if:
  - |C.TYPES| is greater than x_1.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x_1] is (ARRAY (MUT zt_1))
  - |C.TYPES| is greater than x_2.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x_2] is (ARRAY (mut zt_2))
  - the storage type zt_2 matches the storage type zt_1.

Instr_ok/array.init_elem
- the instruction (ARRAY.INIT_ELEM x y) is valid with the instruction type [(REF NULL (_IDX x)), I32, I32, I32] -> [] if:
  - |C.TYPES| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (ARRAY (MUT zt))
  - |C.ELEMS| is greater than y.
  - the element type C.ELEMS[y] matches the storage type zt.

Instr_ok/array.init_data
- the instruction (ARRAY.INIT_DATA x y) is valid with the instruction type [(REF NULL (_IDX x)), I32, I32, I32] -> [] if:
  - |C.TYPES| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (ARRAY (MUT zt))
  - $unpack(zt) is contained in [numtype, vectype].
  - |C.DATAS| is greater than y.
  - C.DATAS[y] is OK.

Instr_ok/extern.convert_any
- the instruction EXTERN.CONVERT_ANY is valid with the instruction type [(REF nul1 ANY)] -> [(REF nul2 EXTERN)] if:
  - nul1 is nul2.

Instr_ok/any.convert_extern
- the instruction ANY.CONVERT_EXTERN is valid with the instruction type [(REF nul1 EXTERN)] -> [(REF nul2 ANY)] if:
  - nul1 is nul2.

Instr_ok/vconst
- the instruction (V128.CONST c) is valid with the instruction type [] -> [V128].

Instr_ok/vvunop
- the instruction (VVUNOP V128 vvunop) is valid with the instruction type [V128] -> [V128].

Instr_ok/vvbinop
- the instruction (VVBINOP V128 vvbinop) is valid with the instruction type [V128, V128] -> [V128].

Instr_ok/vvternop
- the instruction (VVTERNOP V128 vvternop) is valid with the instruction type [V128, V128, V128] -> [V128].

Instr_ok/vvtestop
- the instruction (VVTESTOP V128 vvtestop) is valid with the instruction type [V128] -> [I32].

Instr_ok/vunop
- the instruction (VUNOP sh vunop) is valid with the instruction type [V128] -> [V128].

Instr_ok/vbinop
- the instruction (VBINOP sh vbinop) is valid with the instruction type [V128, V128] -> [V128].

Instr_ok/vtestop
- the instruction (VTESTOP sh vtestop) is valid with the instruction type [V128] -> [I32].

Instr_ok/vrelop
- the instruction (VRELOP sh vrelop) is valid with the instruction type [V128, V128] -> [V128].

Instr_ok/vshiftop
- the instruction (VSHIFTOP sh vshiftop) is valid with the instruction type [V128, I32] -> [V128].

Instr_ok/vbitmask
- the instruction (VBITMASK sh) is valid with the instruction type [V128] -> [I32].

Instr_ok/vswizzle
- the instruction (VSWIZZLE sh) is valid with the instruction type [V128, V128] -> [V128].

Instr_ok/vshuffle
- the instruction (VSHUFFLE sh i*) is valid with the instruction type [V128, V128] -> [V128] if:
  - For all i in i*, i is less than (2 · $dim(sh)).

Instr_ok/vsplat
- the instruction (VSPLAT sh) is valid with the instruction type [$unpackshape(sh)] -> [V128].

Instr_ok/vextract_lane
- the instruction (VEXTRACT_LANE sh sx? i) is valid with the instruction type [V128] -> [$unpackshape(sh)] if:
  - i is less than $dim(sh).

Instr_ok/vreplace_lane
- the instruction (VREPLACE_LANE sh i) is valid with the instruction type [V128, $unpackshape(sh)] -> [V128] if:
  - i is less than $dim(sh).

Instr_ok/vextunop
- the instruction (VEXTUNOP sh_1 sh_2 vextunop) is valid with the instruction type [V128] -> [V128].

Instr_ok/vextbinop
- the instruction (VEXTBINOP sh_1 sh_2 vextbinop) is valid with the instruction type [V128, V128] -> [V128].

Instr_ok/vnarrow
- the instruction (VNARROW sh_1 sh_2 sx) is valid with the instruction type [V128, V128] -> [V128].

Instr_ok/vcvtop
- the instruction (VCVTOP sh_1 sh_2 vcvtop half? zero?) is valid with the instruction type [V128] -> [V128].

Instr_ok/local.get
- the instruction (LOCAL.GET x) is valid with the instruction type [] -> [t] if:
  - |C.LOCALS| is greater than x.
  - C.LOCALS[x] is (SET t).

Instr_ok/local.set
- the instruction (LOCAL.SET x) is valid with the instruction type [t] ->_ [x] [] if:
  - |C.LOCALS| is greater than x.
  - C.LOCALS[x] is (init t).

Instr_ok/local.tee
- the instruction (LOCAL.TEE x) is valid with the instruction type [t] ->_ [x] [t] if:
  - |C.LOCALS| is greater than x.
  - C.LOCALS[x] is (init t).

Instr_ok/global.get
- the instruction (GLOBAL.GET x) is valid with the instruction type [] -> [t] if:
  - |C.GLOBALS| is greater than x.
  - C.GLOBALS[x] is (mut t).

Instr_ok/global.set
- the instruction (GLOBAL.SET x) is valid with the instruction type [t] -> [] if:
  - |C.GLOBALS| is greater than x.
  - C.GLOBALS[x] is (MUT t).

Instr_ok/table.get
- the instruction (TABLE.GET x) is valid with the instruction type [I32] -> [rt] if:
  - |C.TABLES| is greater than x.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.set
- the instruction (TABLE.SET x) is valid with the instruction type [I32, rt] -> [] if:
  - |C.TABLES| is greater than x.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.size
- the instruction (TABLE.SIZE x) is valid with the instruction type [] -> [I32] if:
  - |C.TABLES| is greater than x.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.grow
- the instruction (TABLE.GROW x) is valid with the instruction type [rt, I32] -> [I32] if:
  - |C.TABLES| is greater than x.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.fill
- the instruction (TABLE.FILL x) is valid with the instruction type [I32, rt, I32] -> [] if:
  - |C.TABLES| is greater than x.
  - C.TABLES[x] is (lim rt).

Instr_ok/table.copy
- the instruction (TABLE.COPY x_1 x_2) is valid with the instruction type [I32, I32, I32] -> [] if:
  - |C.TABLES| is greater than x_1.
  - C.TABLES[x_1] is (lim_1 rt_1).
  - |C.TABLES| is greater than x_2.
  - C.TABLES[x_2] is (lim_2 rt_2).
  - the reference type rt_2 matches the reference type rt_1.

Instr_ok/table.init
- the instruction (TABLE.INIT x y) is valid with the instruction type [I32, I32, I32] -> [] if:
  - |C.TABLES| is greater than x.
  - C.TABLES[x] is (lim rt_1).
  - |C.ELEMS| is greater than y.
  - C.ELEMS[y] is rt_2.
  - the reference type rt_2 matches the reference type rt_1.

Instr_ok/elem.drop
- the instruction (ELEM.DROP x) is valid with the instruction type [] -> [] if:
  - |C.ELEMS| is greater than x.
  - C.ELEMS[x] is rt.

Instr_ok/memory.size
- the instruction (MEMORY.SIZE x) is valid with the instruction type [] -> [I32] if:
  - |C.MEMS| is greater than x.
  - C.MEMS[x] is mt.

Instr_ok/memory.grow
- the instruction (MEMORY.GROW x) is valid with the instruction type [I32] -> [I32] if:
  - |C.MEMS| is greater than x.
  - C.MEMS[x] is mt.

Instr_ok/memory.fill
- the instruction (MEMORY.FILL x) is valid with the instruction type [I32, I32, I32] -> [] if:
  - |C.MEMS| is greater than x.
  - C.MEMS[x] is mt.

Instr_ok/memory.copy
- the instruction (MEMORY.COPY x_1 x_2) is valid with the instruction type [I32, I32, I32] -> [] if:
  - |C.MEMS| is greater than x_1.
  - C.MEMS[x_1] is mt_1.
  - |C.MEMS| is greater than x_2.
  - C.MEMS[x_2] is mt_2.

Instr_ok/memory.init
- the instruction (MEMORY.INIT x y) is valid with the instruction type [I32, I32, I32] -> [] if:
  - |C.MEMS| is greater than x.
  - C.MEMS[x] is mt.
  - |C.DATAS| is greater than y.
  - C.DATAS[y] is OK.

Instr_ok/data.drop
- the instruction (DATA.DROP x) is valid with the instruction type [] -> [] if:
  - |C.DATAS| is greater than x.
  - C.DATAS[x] is OK.

Instr_ok/load
- the instruction (LOAD numtype_u0 loadop__u2? x memarg) is valid with the instruction type [I32] -> [valtype_u3] if:
  - |C.MEMS| is greater than x.
  - C.MEMS[x] is mt.
  - Either:
    - numtype_u0 is nt.
    - loadop__u2? is ?().
    - valtype_u3 is nt.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - Or:
    - numtype_u0 is Inn.
    - loadop__u2? is ?((M sx)).
    - valtype_u3 is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store
- the instruction (STORE numtype_u0 sz_u1? x memarg) is valid with the instruction type [I32, valtype_u2] -> [] if:
  - |C.MEMS| is greater than x.
  - C.MEMS[x] is mt.
  - Either:
    - numtype_u0 is nt.
    - sz_u1? is ?().
    - valtype_u2 is nt.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - Or:
    - numtype_u0 is Inn.
    - sz_u1? is ?(M).
    - valtype_u2 is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/vload
- the instruction (VLOAD V128 vloadop__u0? x memarg) is valid with the instruction type [I32] -> [V128] if:
  - |C.MEMS| is greater than x.
  - C.MEMS[x] is mt.
  - Either:
    - vloadop__u0? is ?().
    - (2 ^ memarg.ALIGN) is less than or equal to ($vsize(V128) / 8).
  - Or:
    - vloadop__u0? is ?((SHAPE M X N sx)).
    - (2 ^ memarg.ALIGN) is less than or equal to ((M / 8) · N).
  - Or:
    - vloadop__u0? is ?((SPLAT N)).
    - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).
  - Or:
    - vloadop__u0? is ?((ZERO N)).
    - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).

Instr_ok/vload_lane
- the instruction (VLOAD_LANE V128 N x memarg i) is valid with the instruction type [I32, V128] -> [V128] if:
  - |C.MEMS| is greater than x.
  - C.MEMS[x] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).
  - i is less than (128 / N).

Instr_ok/vstore
- the instruction (VSTORE V128 x memarg) is valid with the instruction type [I32, V128] -> [] if:
  - |C.MEMS| is greater than x.
  - C.MEMS[x] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ($vsize(V128) / 8).

Instr_ok/vstore_lane
- the instruction (VSTORE_LANE V128 N x memarg i) is valid with the instruction type [I32, V128] -> [] if:
  - |C.MEMS| is greater than x.
  - C.MEMS[x] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).
  - i is less than (128 / N).

Instrs_ok
- the instruction sequence instr_u0* is valid with the instruction type instrtype_u4 if:
  - Either:
    - instr_u0* is [].
    - instrtype_u4 is [] -> [].
  - Or:
    - instr_u0* is [instr_1] :: instr_2*.
    - instrtype_u4 is t_1* ->_ x_1* :: x_2* t_3*.
    - the instruction instr_1 is valid with the instruction type t_1* ->_ x_1* t_2*.
    - |t*| is |init*|.
    - |x_1*| is |init*|.
    - For all x_1 in x_1*, |C.LOCALS| is greater than x_1.
    - For all init in init* and t in t* and x_1 in x_1*, C.LOCALS[x_1] is (init t).
    - Under the context $with_locals(C, x_1*, (SET t)*), the instruction sequence instr_2* is valid with the instruction type t_2* ->_ x_2* t_3*.
  - Or:
    - instr_u0* is instr*.
    - instrtype_u4 is it'.
    - the instruction sequence instr* is valid with the instruction type it.
    - the instruction type it matches the instruction type it'.
    - the instruction type it' is valid.
  - Or:
    - instr_u0* is instr*.
    - instrtype_u4 is t* :: t_1* ->_ x* t* :: t_2*.
    - the instruction sequence instr* is valid with the instruction type t_1* ->_ x* t_2*.
    - the value type sequence t* is valid.

Expr_ok
- the expression instr* is valid with the value type sequence t* if:
  - the instruction sequence instr* is valid with the instruction type [] -> t*.

Instr_const
- the instruction instr_u0 is constant if:
  - Either: instr_u0 is (nt.CONST c_nt).
  - Or: instr_u0 is (vt.CONST c_vt).
  - Or: instr_u0 is (REF.NULL ht).
  - Or: instr_u0 is REF.I31.
  - Or: instr_u0 is (REF.FUNC x).
  - Or: instr_u0 is (STRUCT.NEW x).
  - Or: instr_u0 is (STRUCT.NEW_DEFAULT x).
  - Or: instr_u0 is (ARRAY.NEW x).
  - Or: instr_u0 is (ARRAY.NEW_DEFAULT x).
  - Or: instr_u0 is (ARRAY.NEW_FIXED x n).
  - Or: instr_u0 is ANY.CONVERT_EXTERN.
  - Or: instr_u0 is EXTERN.CONVERT_ANY.
  - Or:
    - instr_u0 is (GLOBAL.GET x).
    - |C.GLOBALS| is greater than x.
    - C.GLOBALS[x] is (t).
  - Or:
    - instr_u0 is (BINOP Inn binop).
    - Inn is contained in [I32, I64].
    - binop is contained in [ADD, SUB, MUL].

Expr_const
- the expression instr* is constant if:
  - For all instr in instr*, the instruction instr is constant.

Type_ok
- the type definition (TYPE rectype) is valid with the defined type sequence dt* if:
  - |C.TYPES| is x.
  - dt* is $rolldt(x, rectype).
  - Under the context C with .TYPES appended by dt*, the recursive type rectype is valid with the oktypeidx (OK x).

Local_ok
- the local (LOCAL t) is valid with the local type (init_u0 t) if:
  - Either:
    - init_u0 is SET.
    - $default_(t) is different with ?().
  - Or:
    - init_u0 is UNSET.
    - $default_(t) is ?().

Func_ok
- the function (FUNC x local* expr) is valid with the defined type C.TYPES[x] if:
  - |C.TYPES| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (FUNC t_1* -> t_2*)
  - |local*| is |lct*|.
  - For all lct in lct* and local in local*, the local local is valid with the local type lct.
  - Under the context C with .LOCALS appended by (SET t_1)* :: lct* with .LABELS appended by [t_2*] with .RETURN appended by ?(t_2*), the expression expr is valid with the value type sequence t_2*.

Global_ok
- the global (GLOBAL globaltype expr) is valid with the global type globaltype if:
  - the global type gt is valid.
  - globaltype is (mut t).
  - the expression expr is valid with the value type t.
  - the expression expr is constant.

Table_ok
- the table (TABLE tabletype expr) is valid with the table type tabletype if:
  - the table type tt is valid.
  - tabletype is (lim rt).
  - the expression expr is valid with the value type rt.
  - the expression expr is constant.

Mem_ok
- the memory (MEMORY memtype) is valid with the memory type memtype if:
  - the memory type memtype is valid.

Tag_ok
- the tag (TAG x) is valid with the memory type C.TYPES[x] if:
  - |C.TYPES| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is (FUNC functype)

Elemmode_ok
- the elemmode elemmode_u0 is valid with the element type rt if:
  - Either:
    - elemmode_u0 is (ACTIVE x expr).
    - |C.TABLES| is greater than x.
    - C.TABLES[x] is (lim rt').
    - the reference type rt matches the reference type rt'.
    - the expression expr is valid with the value type I32.
    - the expression expr is constant.
  - Or: elemmode_u0 is PASSIVE.
  - Or: elemmode_u0 is DECLARE.

Elem_ok
- the table segment (ELEM elemtype expr* elemmode) is valid with the element type elemtype if:
  - the reference type elemtype is valid.
  - For all expr in expr*,
    - the expression expr is valid with the value type elemtype.
    - the expression expr is constant.
  - the elemmode elemmode is valid with the element type elemtype.

Datamode_ok
- the datamode datamode_u0 is valid with the data type OK if:
  - Either:
    - datamode_u0 is (ACTIVE x expr).
    - |C.MEMS| is greater than x.
    - C.MEMS[x] is mt.
    - the expression expr is valid with the value type I32.
    - the expression expr is constant.
  - Or: datamode_u0 is PASSIVE.

Data_ok
- the memory segment (DATA b* datamode) is valid with the data type OK if:
  - the datamode datamode is valid with the data type OK.

Start_ok
- the start function (START x) is valid if:
  - |C.FUNCS| is greater than x.
  - The :ref:`expansion <aux-expand-deftype>` of C.FUNCS[x] is (FUNC [] -> [])

Import_ok
- the import (IMPORT name_1 name_2 xt) is valid with the external type xt if:
  - the external type xt is valid.

Externidx_ok
- the external index externidx_u0 is valid with the external type externtype_u1 if:
  - Either:
    - externidx_u0 is (FUNC x).
    - externtype_u1 is (FUNC dt).
    - |C.FUNCS| is greater than x.
    - C.FUNCS[x] is dt.
  - Or:
    - externidx_u0 is (GLOBAL x).
    - externtype_u1 is (GLOBAL gt).
    - |C.GLOBALS| is greater than x.
    - C.GLOBALS[x] is gt.
  - Or:
    - externidx_u0 is (TABLE x).
    - externtype_u1 is (TABLE tt).
    - |C.TABLES| is greater than x.
    - C.TABLES[x] is tt.
  - Or:
    - externidx_u0 is (MEM x).
    - externtype_u1 is (MEM mt).
    - |C.MEMS| is greater than x.
    - C.MEMS[x] is mt.
  - Or:
    - externidx_u0 is (TAG x).
    - externtype_u1 is (TAG at).
    - |C.TAGS| is greater than x.
    - C.TAGS[x] is at.

Export_ok
- the export (EXPORT name externidx) is valid with the name name and the external type xt if:
  - the external index externidx is valid with the external type xt.

Globals_ok
- the global sequence global_u0* is valid with the global type sequence globaltype_u1* if:
  - Either:
    - global_u0* is [].
    - globaltype_u1* is [].
  - Or:
    - global_u0* is [global_1] :: global*.
    - globaltype_u1* is [gt_1] :: gt*.
    - the global global_1 is valid with the global type gt_1.
    - Under the context C with .GLOBALS appended by [gt_1], the global sequence global* is valid with the global type sequence gt*.

Types_ok
- the type definition sequence type_u0* is valid with the defined type sequence deftype_u1* if:
  - Either:
    - type_u0* is [].
    - deftype_u1* is [].
  - Or:
    - type_u0* is [type_1] :: type*.
    - deftype_u1* is dt_1* :: dt*.
    - the type definition type_1 is valid with the defined type sequence dt_1*.
    - Under the context C with .TYPES appended by dt_1*, the type definition sequence type* is valid with the defined type sequence dt*.

Module_ok
- the module (MODULE type* import* func* global* table* mem* tag* elem* data* start? export*) is valid with the module type $clos_moduletype(C, xt_I* -> xt_E*) if:
  - Under the context { TYPES: []; RECS: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; TAGS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; RETURN: ?(); REFS: []; }, the type definition sequence type* is valid with the defined type sequence dt'*.
  - |xt_I*| is |import*|.
  - For all import in import* and xt_I in xt_I*, Under the context { TYPES: dt'*; RECS: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; TAGS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; RETURN: ?(); REFS: []; }, the import import is valid with the external type xt_I.
  - Under the context C', the global sequence global* is valid with the global type sequence gt*.
  - |tt*| is |table*|.
  - For all table in table* and tt in tt*, Under the context C', the table table is valid with the table type tt.
  - |mt*| is |mem*|.
  - For all mem in mem* and mt in mt*, Under the context C', the memory mem is valid with the memory type mt.
  - |tag*| is |at*|.
  - For all at in at* and tag in tag*, Under the context C', the tag tag is valid with the memory type at.
  - |func*| is |dt*|.
  - For all dt in dt* and func in func*, the function func is valid with the defined type dt.
  - |rt*| is |elem*|.
  - For all elem in elem* and rt in rt*, the table segment elem is valid with the element type rt.
  - |ok*| is |data*|.
  - For all data in data* and ok in ok*, the memory segment data is valid with the data type ok.
  - If start is defined, the start function start is valid.
  - |nm*| is |export*|.
  - |xt_E*| is |export*|.
  - For all export in export* and nm in nm* and xt_E in xt_E*, the export export is valid with the name nm and the external type xt_E.
  - $disjoint_(name, nm*) is true.
  - C is { TYPES: dt'*; RECS: []; FUNCS: dt_I* :: dt*; GLOBALS: gt_I* :: gt*; TABLES: tt_I* :: tt*; MEMS: mt_I* :: mt*; TAGS: at_I* :: at*; ELEMS: rt*; DATAS: ok*; LOCALS: []; LABELS: []; RETURN: ?(); REFS: x*; }.
  - C' is { TYPES: dt'*; RECS: []; FUNCS: dt_I* :: dt*; GLOBALS: gt_I*; TABLES: []; MEMS: []; TAGS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; RETURN: ?(); REFS: x*; }.
  - x* is $funcidx_nonfuncs((global* table* mem* elem* data*)).
  - dt_I* is $funcsxt(xt_I*).
  - gt_I* is $globalsxt(xt_I*).
  - tt_I* is $tablesxt(xt_I*).
  - mt_I* is $memsxt(xt_I*).
  - at_I* is $tagsxt(xt_I*).

NotationTypingInstrScheme
- the instruction sequence [instr_u0] is valid with the function type valtype_u1* -> valtype_u3* if:
  - Either:
    - instr_u0 is (BINOP I32 ADD).
    - valtype_u1* is [I32, I32].
    - valtype_u3* is [I32].
  - Or:
    - instr_u0 is (GLOBAL.GET x).
    - valtype_u1* is [].
    - valtype_u3* is [t].
    - |C.GLOBALS| is greater than x.
    - C.GLOBALS[x] is (mut t).
  - Or:
    - instr_u0 is (BLOCK blocktype instr*).
    - valtype_u1* is t_1*.
    - valtype_u3* is t_2*.
    - the block type blocktype is valid with the instruction type t_1* -> t_2*.
    - Under the context C with .LABELS prepended by [t_2*], the instruction sequence instr* is valid with the function type t_1* -> t_2*.

Step_pure/unreachable
1. Trap.

Step_pure/nop
1. Do nothing.

Step_pure/drop
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Do nothing.

Step_pure/select t*?
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. Assert: Due to validation, a value is on the top of the stack.
4. Pop the value val_2 from the stack.
5. Assert: Due to validation, a value is on the top of the stack.
6. Pop the value val_1 from the stack.
7. If (c is not 0), then:
  a. Push the value val_1 to the stack.
8. Else:
  a. Push the value val_2 to the stack.

Step_pure/if bt instr_1* instr_2*
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c is not 0), then:
  a. Execute the instruction (BLOCK bt instr_1*).
4. Else:
  a. Execute the instruction (BLOCK bt instr_2*).

Step_pure/label
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, a label is now on the top of the stack.
3. Pop the current label from the stack.
4. Push the values val* to the stack.

Step_pure/br l
1. Pop all values val* from the top of the stack.
2. If the top of the stack is a LABEL_, then:
  a. Push the values val* to the stack.
  b. Let L be the current label.
  c. Let n be the arity of L.
  d. Let instr'* be the continuation of L.
  e. If (l is 0), then:
    1) Assert: Due to validation, there are at least n values on the top of the stack.
    2) Pop the values val^n from the stack.
    3) Pop all values val'* from the top of the stack.
    4) Pop the current label from the stack.
    5) Push the values val^n to the stack.
    6) Execute the instruction instr'*.
  f. Else:
    1) Pop all values val* from the top of the stack.
    2) If (l > 0), then:
      a) Pop the current label from the stack.
      b) Push the values val* to the stack.
      c) Execute the instruction (BR (l - 1)).
3. Else if the top of the stack is a HANDLER_, then:
  a. Push the values val* to the stack.
  b. Pop all values val* from the top of the stack.
  c. Exit from HANDLER_.
  d. Push the values val* to the stack.
  e. Execute the instruction (BR l).

Step_pure/br_if l
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c is not 0), then:
  a. Execute the instruction (BR l).
4. Else:
  a. Do nothing.

Step_pure/br_table l* l'
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. If (i < |l*|), then:
  a. Execute the instruction (BR l*[i]).
4. Else:
  a. Execute the instruction (BR l').

Step_pure/br_on_null l
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. If val is of the case REF.NULL, then:
  a. Execute the instruction (BR l).
4. Else:
  a. Push the value val to the stack.

Step_pure/br_on_non_null l
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. If val is of the case REF.NULL, then:
  a. Do nothing.
4. Else:
  a. Push the value val to the stack.
  b. Execute the instruction (BR l).

Step_pure/call_indirect x yy
1. Execute the instruction (TABLE.GET x).
2. Execute the instruction (REF.CAST (REF (NULL ?(()) ?) yy)).
3. Execute the instruction (CALL_REF yy).

Step_pure/return_call_indirect x yy
1. Execute the instruction (TABLE.GET x).
2. Execute the instruction (REF.CAST (REF (NULL ?(()) ?) yy)).
3. Execute the instruction (RETURN_CALL_REF yy).

Step_pure/frame
1. Let F be the current frame.
2. Let n be the arity of F.
3. Assert: Due to validation, there are at least n values on the top of the stack.
4. Assert: Due to validation, there are at least n values on the top of the stack.
5. Pop the values val^n from the stack.
6. Assert: Due to validation, a frame is now on the top of the stack.
7. Pop the current frame from the stack.
8. Push the values val^n to the stack.

Step_pure/return
1. Pop all values val* from the top of the stack.
2. If the top of the stack is a FRAME_, then:
  a. Push the values val* to the stack.
  b. Let F be the current frame.
  c. Let n be the arity of F.
  d. Assert: Due to validation, there are at least n values on the top of the stack.
  e. Pop the values val^n from the stack.
  f. Pop all values val'* from the top of the stack.
  g. Pop the current frame from the stack.
  h. Push the values val^n to the stack.
3. Else if the top of the stack is a LABEL_, then:
  a. Push the values val* to the stack.
  b. Pop all values val* from the top of the stack.
  c. Pop the current label from the stack.
  d. Push the values val* to the stack.
  e. Execute the instruction RETURN.
4. Else if the top of the stack is a HANDLER_, then:
  a. Push the values val* to the stack.
  b. Pop all values val* from the top of the stack.
  c. Exit from HANDLER_.
  d. Push the values val* to the stack.
  e. Execute the instruction RETURN.

Step_pure/handler
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, a handler is now on the top of the stack.
3. Exit from HANDLER_.
4. Push the values val* to the stack.

Step_pure/unop nt unop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (nt.CONST c_1) from the stack.
3. If (|$unop_(nt, unop, c_1)| ≤ 0), then:
  a. Trap.
4. Let c be an element of $unop_(nt, unop, c_1).
5. Push the value (nt.CONST c) to the stack.

Step_pure/binop nt binop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (nt.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type numtype_0 is on the top of the stack.
4. Pop the value (numtype_0.CONST c_1) from the stack.
5. If (|$binop_(nt, binop, c_1, c_2)| ≤ 0), then:
  a. Trap.
6. Let c be an element of $binop_(nt, binop, c_1, c_2).
7. Push the value (nt.CONST c) to the stack.

Step_pure/testop nt testop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (nt.CONST c_1) from the stack.
3. Let c be $testop_(nt, testop, c_1).
4. Push the value (I32.CONST c) to the stack.

Step_pure/relop nt relop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (nt.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type numtype_0 is on the top of the stack.
4. Pop the value (numtype_0.CONST c_1) from the stack.
5. Let c be $relop_(nt, relop, c_1, c_2).
6. Push the value (I32.CONST c) to the stack.

Step_pure/cvtop nt_2 nt_1 cvtop
1. Assert: Due to validation, a value of value type nt_1 is on the top of the stack.
2. Pop the value (nt_1.CONST c_1) from the stack.
3. If (|$cvtop__(nt_1, nt_2, cvtop, c_1)| ≤ 0), then:
  a. Trap.
4. Let c be an element of $cvtop__(nt_1, nt_2, cvtop, c_1).
5. Push the value (nt_2.CONST c) to the stack.

Step_pure/ref.i31
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. Push the value (REF.I31_NUM $wrap__(32, 31, i)) to the stack.

Step_pure/ref.is_null
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is of the case REF.NULL, then:
  a. Push the value (I32.CONST 1) to the stack.
4. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_pure/ref.as_non_null
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is of the case REF.NULL, then:
  a. Trap.
4. Push the value ref to the stack.

Step_pure/ref.eq
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value ref_2 from the stack.
3. Assert: Due to validation, a value is on the top of the stack.
4. Pop the value ref_1 from the stack.
5. If ref_1 is of the case REF.NULL, then:
  a. If ref_2 is of the case REF.NULL, then:
    1) Push the value (I32.CONST 1) to the stack.
  b. Else if (ref_1 is ref_2), then:
    1) Push the value (I32.CONST 1) to the stack.
  c. Else:
    1) Push the value (I32.CONST 0) to the stack.
6. Else if (ref_1 is ref_2), then:
  a. Push the value (I32.CONST 1) to the stack.
7. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_pure/i31.get sx
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value instr_u0 from the stack.
3. If instr_u0 is of the case REF.NULL, then:
  a. Trap.
4. If instr_u0 is of the case REF.I31_NUM, then:
  a. Let (REF.I31_NUM i) be instr_u0.
  b. Push the value (I32.CONST $extend__(31, 32, sx, i)) to the stack.

Step_pure/array.new x
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST n) from the stack.
3. Assert: Due to validation, a value is on the top of the stack.
4. Pop the value val from the stack.
5. Push the values val^n to the stack.
6. Execute the instruction (ARRAY.NEW_FIXED x n).

Step_pure/extern.convert_any
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value instr_u0 from the stack.
3. If instr_u0 is of the case REF.NULL, then:
  a. Push the value (REF.NULL EXTERN) to the stack.
4. If the type of instr_u0 is addrref, then:
  a. Let addrref be instr_u0.
  b. Push the value (REF.EXTERN addrref) to the stack.

Step_pure/any.convert_extern
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value instr_u0 from the stack.
3. If instr_u0 is of the case REF.NULL, then:
  a. Push the value (REF.NULL ANY) to the stack.
4. If instr_u0 is of the case REF.EXTERN, then:
  a. Let (REF.EXTERN addrref) be instr_u0.
  b. Push the value addrref to the stack.

Step_pure/vvunop V128 vvunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Assert: Due to validation, (|$vvunop_(V128, vvunop, c_1)| > 0).
4. Let c be an element of $vvunop_(V128, vvunop, c_1).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vvbinop V128 vvbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Assert: Due to validation, (|$vvbinop_(V128, vvbinop, c_1, c_2)| > 0).
6. Let c be an element of $vvbinop_(V128, vvbinop, c_1, c_2).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vvternop V128 vvternop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_3) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_2) from the stack.
5. Assert: Due to validation, a value of value type V128 is on the top of the stack.
6. Pop the value (V128.CONST c_1) from the stack.
7. Assert: Due to validation, (|$vvternop_(V128, vvternop, c_1, c_2, c_3)| > 0).
8. Let c be an element of $vvternop_(V128, vvternop, c_1, c_2, c_3).
9. Push the value (V128.CONST c) to the stack.

Step_pure/vvtestop V128 ANY_TRUE
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $ine_($vsize(V128), c_1, 0).
4. Push the value (I32.CONST c) to the stack.

Step_pure/vunop sh vunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (|$vunop_(sh, vunop, c_1)| ≤ 0), then:
  a. Trap.
4. Let c be an element of $vunop_(sh, vunop, c_1).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vbinop sh vbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. If (|$vbinop_(sh, vbinop, c_1, c_2)| ≤ 0), then:
  a. Trap.
6. Let c be an element of $vbinop_(sh, vbinop, c_1, c_2).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vtestop Jnn X M ALL_TRUE
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c) from the stack.
3. Let ci_1* be $lanes_(Jnn X M, c).
4. If (ci_1 is not 0)*, then:
  a. Push the value (I32.CONST 1) to the stack.
5. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_pure/vrelop sh vrelop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vrelop_(sh, vrelop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vshiftop Jnn X M vshiftop
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST n) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c'* be $lanes_(Jnn X M, c_1).
6. Let c be $invlanes_(Jnn X M, $vshiftop_(Jnn X M, vshiftop, c', n)*).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vbitmask Jnn X M
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c) from the stack.
3. Let ci_1* be $lanes_(Jnn X M, c).
4. Let ci be $ibits__1^-1(32, $ilt_($lsize(Jnn), S, ci_1, 0)*).
5. Push the value (I32.CONST ci) to the stack.

Step_pure/vswizzle Pnn X M
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c'* be $lanes_(Pnn X M, c_1) :: 0^(256 - M).
6. Let ci* be $lanes_(Pnn X M, c_2).
7. Assert: Due to validation, (ci*[k] < |c'*|)^(k<M).
8. Assert: Due to validation, (k < |ci*|)^(k<M).
9. Let c be $invlanes_(Pnn X M, c'*[ci*[k]]^(k<M)).
10. Push the value (V128.CONST c) to the stack.

Step_pure/vshuffle Pnn X M i*
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Assert: Due to validation, (k < |i*|)^(k<M).
6. Let c'* be $lanes_(Pnn X M, c_1) :: $lanes_(Pnn X M, c_2).
7. Assert: Due to validation, (i*[k] < |c'*|)^(k<M).
8. Let c be $invlanes_(Pnn X M, c'*[i*[k]]^(k<M)).
9. Push the value (V128.CONST c) to the stack.

Step_pure/vsplat Lnn X M
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. Assert: Due to validation, (numtype_0 is $lunpack(Lnn)).
4. Let c be $invlanes_(Lnn X M, $lpacknum_(Lnn, c_1)^M).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vextract_lane lanetype_u0 X M sx_u1? i
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (sx_u1? is not defined and the type of lanetype_u0 is numtype), then:
  a. Let nt be lanetype_u0.
  b. If (i < |$lanes_(nt X M, c_1)|), then:
    1) Let c_2 be $lanes_(nt X M, c_1)[i].
    2) Push the value (nt.CONST c_2) to the stack.
4. If the type of lanetype_u0 is packtype, then:
  a. Let pt be lanetype_u0.
  b. If sx_u1? is defined, then:
    1) Let ?(sx) be sx_u1?.
    2) If (i < |$lanes_(pt X M, c_1)|), then:
      a) Let c_2 be $extend__($psize(pt), 32, sx, $lanes_(pt X M, c_1)[i]).
      b) Push the value (I32.CONST c_2) to the stack.

Step_pure/vreplace_lane Lnn X M i
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, (numtype_0 is $lunpack(Lnn)).
4. Assert: Due to validation, a value of value type V128 is on the top of the stack.
5. Pop the value (V128.CONST c_1) from the stack.
6. Let c be $invlanes_(Lnn X M, $lanes_(Lnn X M, c_1) with [i] replaced by $lpacknum_(Lnn, c_2)).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vextunop sh_2 sh_1 vextunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vextunop__(sh_1, sh_2, vextunop, c_1).
4. Push the value (V128.CONST c) to the stack.

Step_pure/vextbinop sh_2 sh_1 vextbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vextbinop__(sh_1, sh_2, vextbinop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vnarrow Jnn_2 X M_2 Jnn_1 X M_1 sx
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let ci_1* be $lanes_(Jnn_1 X M_1, c_1).
6. Let ci_2* be $lanes_(Jnn_1 X M_1, c_2).
7. Let cj_1* be $narrow__($lsize(Jnn_1), $lsize(Jnn_2), sx, ci_1)*.
8. Let cj_2* be $narrow__($lsize(Jnn_1), $lsize(Jnn_2), sx, ci_2)*.
9. Let c be $invlanes_(Jnn_2 X M_2, cj_1* :: cj_2*).
10. Push the value (V128.CONST c) to the stack.

Step_pure/vcvtop lanetype_u5 X n_u0 lanetype_u6 X n_u1 vcvtop half___u4? zero___u13?
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (half___u4? is not defined and zero___u13? is not defined), then:
  a. Let Lnn_1 be lanetype_u6.
  b. Let Lnn_2 be lanetype_u5.
  c. Let M be n_u1.
  d. If (n_u0 is M), then:
    1) Let ci* be $lanes_(Lnn_1 X M, c_1).
    2) Let cj** be $setproduct_(lane_(Lnn_2), $vcvtop__(Lnn_1 X M, Lnn_2 X M, vcvtop, ci)*).
    3) If (|$invlanes_(Lnn_2 X M, cj*)*| > 0), then:
      a) Let c be an element of $invlanes_(Lnn_2 X M, cj*)*.
      b) Push the value (V128.CONST c) to the stack.
4. If zero___u13? is not defined, then:
  a. Let Lnn_1 be lanetype_u6.
  b. Let Lnn_2 be lanetype_u5.
  c. Let M_1 be n_u1.
  d. Let M_2 be n_u0.
  e. If half___u4? is defined, then:
    1) Let ?(half) be half___u4?.
    2) Let ci* be $lanes_(Lnn_1 X M_1, c_1)[$half__(Lnn_1 X M_1, Lnn_2 X M_2, half, 0, M_2) : M_2].
    3) Let cj** be $setproduct_(lane_(Lnn_2), $vcvtop__(Lnn_1 X M_1, Lnn_2 X M_2, vcvtop, ci)*).
    4) If (|$invlanes_(Lnn_2 X M_2, cj*)*| > 0), then:
      a) Let c be an element of $invlanes_(Lnn_2 X M_2, cj*)*.
      b) Push the value (V128.CONST c) to the stack.
5. If half___u4? is not defined, then:
  a. Let M_1 be n_u1.
  b. Let M_2 be n_u0.
  c. If the type of lanetype_u6 is numtype, then:
    1) Let nt_1 be lanetype_u6.
    2) If the type of lanetype_u5 is numtype, then:
      a) Let nt_2 be lanetype_u5.
      b) If zero___u13? is defined, then:
        1. Let ci* be $lanes_(nt_1 X M_1, c_1).
        2. Let cj** be $setproduct_(lane_((nt_2 : numtype <: lanetype)), $vcvtop__(nt_1 X M_1, nt_2 X M_2, vcvtop, ci)* :: [$zero(nt_2)]^M_1).
        3. If (|$invlanes_(nt_2 X M_2, cj*)*| > 0), then:
          a. Let c be an element of $invlanes_(nt_2 X M_2, cj*)*.
          b. Push the value (V128.CONST c) to the stack.

Step_pure/local.tee x
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Push the value val to the stack.
4. Push the value val to the stack.
5. Execute the instruction (LOCAL.SET x).

Step_read/block bt instr*
1. Let z be the current state.
2. Let t_1^m -> t_2^n be $blocktype_(z, bt).
3. Assert: Due to validation, there are at least m values on the top of the stack.
4. Pop the values val^m from the stack.
5. Let L be the label_n{[]}.
6. Enter val^m :: instr* with label L.

Step_read/loop bt instr*
1. Let z be the current state.
2. Let t_1^m -> t_2^n be $blocktype_(z, bt).
3. Assert: Due to validation, there are at least m values on the top of the stack.
4. Pop the values val^m from the stack.
5. Let L be the label_m{[(LOOP bt instr*)]}.
6. Enter val^m :: instr* with label L.

Step_read/br_on_cast l rt_1 rt_2
1. Let f be the current frame.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value ref from the stack.
4. Let rt be $Ref_type(ref).
5. Push the value ref to the stack.
6. If rt does not match $inst_reftype(f.MODULE, rt_2), then:
  a. Do nothing.
7. Else:
  a. Execute the instruction (BR l).

Step_read/br_on_cast_fail l rt_1 rt_2
1. Let f be the current frame.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value ref from the stack.
4. Let rt be $Ref_type(ref).
5. Push the value ref to the stack.
6. If rt matches $inst_reftype(f.MODULE, rt_2), then:
  a. Do nothing.
7. Else:
  a. Execute the instruction (BR l).

Step_read/call x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$moduleinst(z).FUNCS|).
3. Let a be $moduleinst(z).FUNCS[x].
4. Assert: Due to validation, (a < |$funcinst(z)|).
5. Push the value (REF.FUNC_ADDR a) to the stack.
6. Execute the instruction (CALL_REF $funcinst(z)[a].TYPE).

Step_read/call_ref yy
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value instr_u0 from the stack.
4. If instr_u0 is of the case REF.NULL, then:
  a. Trap.
5. If instr_u0 is of the case REF.FUNC_ADDR, then:
  a. Let (REF.FUNC_ADDR a) be instr_u0.
  b. If (a < |$funcinst(z)|), then:
    1) Let fi be $funcinst(z)[a].
    2) Assert: Due to validation, fi.CODE is of the case FUNC.
    3) Let (FUNC x local_0* instr*) be fi.CODE.
    4) If local_0 is of the case LOCAL*, then:
      a) Let (LOCAL t)* be local_0*.
      b) Assert: Due to validation, $expanddt(fi.TYPE) is of the case FUNC.
      c) Let (FUNC functype_0) be $expanddt(fi.TYPE).
      d) Let t_1^n -> t_2^m be functype_0.
      e) Assert: Due to validation, there are at least n values on the top of the stack.
      f) Pop the values val^n from the stack.
      g) Let f be { LOCALS: ?(val)^n :: $default_(t)*; MODULE: fi.MODULE; }.
      h) Let F be the activation of f with arity m.
      i) Push F to the stack.
      j) Let L be the label_m{[]}.
      k) Enter instr* with label L.

Step_read/return_call x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$moduleinst(z).FUNCS|).
3. Let a be $moduleinst(z).FUNCS[x].
4. Assert: Due to validation, (a < |$funcinst(z)|).
5. Push the value (REF.FUNC_ADDR a) to the stack.
6. Execute the instruction (RETURN_CALL_REF $funcinst(z)[a].TYPE).

Step_read/return_call_ref yy
1. Let z be the current state.
2. Pop all values val* from the top of the stack.
3. If the top of the stack is a LABEL_, then:
  a. Push the values val* to the stack.
  b. Pop all values val* from the top of the stack.
  c. Pop the current label from the stack.
  d. Push the values val* to the stack.
  e. Execute the instruction (RETURN_CALL_REF yy).
4. Else if the top of the stack is a HANDLER_, then:
  a. Push the values val* to the stack.
  b. Pop all values val* from the top of the stack.
  c. Exit from HANDLER_.
  d. Push the values val* to the stack.
  e. Execute the instruction (RETURN_CALL_REF yy).
5. Else if the top of the stack is a FRAME_, then:
  a. Push the values val* to the stack.
  b. Assert: Due to validation, a value is on the top of the stack.
  c. Pop the value instr_u0 from the stack.
  d. Pop all values val* from the top of the stack.
  e. If instr_u0 is of the case REF.NULL, then:
    1) Pop the current frame from the stack.
    2) Trap.
  f. If instr_u0 is of the case REF.FUNC_ADDR, then:
    1) Let (REF.FUNC_ADDR a) be instr_u0.
    2) If (a < |$funcinst(z)|), then:
      a) Assert: Due to validation, $expanddt($funcinst(z)[a].TYPE) is of the case FUNC.
      b) Let (FUNC functype_0) be $expanddt($funcinst(z)[a].TYPE).
      c) Let t_1^n -> t_2^m be functype_0.
      d) Assert: Due to validation, there are at least n values on the top of the stack.
      e) Pop the values val^n from the stack.
      f) Pop all values val'* from the top of the stack.
      g) Pop the current frame from the stack.
      h) Push the values val^n to the stack.
      i) Push the value (REF.FUNC_ADDR a) to the stack.
      j) Execute the instruction (CALL_REF yy).

Step_read/throw_ref
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value instr_u0 from the stack.
4. If instr_u0 is of the case REF.NULL, then:
  a. Trap.
5. Pop all values val* from the top of the stack.
6. If (val* is not []), then:
  a. If instr_u0 is of the case REF.EXN_ADDR, then:
    1) Let (REF.EXN_ADDR a) be instr_u0.
    2) Push the value (REF.EXN_ADDR a) to the stack.
    3) Execute the instruction THROW_REF.
7. Else:
  a. Pop all values val* from the top of the stack.
  b. If the top of the stack is a LABEL_, then:
    1) Push the values val* to the stack.
    2) If instr_u0 is of the case REF.EXN_ADDR, then:
      a) Let (REF.EXN_ADDR a) be instr_u0.
      b) Pop the current label from the stack.
      c) Push the value (REF.EXN_ADDR a) to the stack.
      d) Execute the instruction THROW_REF.
  c. Else if the top of the stack is a FRAME_, then:
    1) Push the values val* to the stack.
    2) If instr_u0 is of the case REF.EXN_ADDR, then:
      a) Let (REF.EXN_ADDR a) be instr_u0.
      b) Pop the current frame from the stack.
      c) Push the value (REF.EXN_ADDR a) to the stack.
      d) Execute the instruction THROW_REF.
  d. Else if not the top of the stack is a HANDLER_, then:
    1) Throw the exception instr_u0 as a result.
  e. Else:
    1) Push the values val* to the stack.
    2) Let (HANDLER_ n { catch_u1* }) be the current context.
    3) If instr_u0 is of the case REF.EXN_ADDR, then:
      a) Let (REF.EXN_ADDR a) be instr_u0.
      b) If (catch_u1* is []), then:
        1. Exit from HANDLER_.
        2. Push the value (REF.EXN_ADDR a) to the stack.
        3. Execute the instruction THROW_REF.
      c) Else if (a ≥ |$exninst(z)|), then:
        1. Let [catch_0] :: catch'* be catch_u1*.
        2. If catch_0 is of the case CATCH_ALL, then:
          a. Let (CATCH_ALL l) be catch_0.
          b. Exit from HANDLER_.
          c. Execute the instruction (BR l).
        3. Else if catch_0 is of the case CATCH_ALL_REF, then:
          a. Let (CATCH_ALL_REF l) be catch_0.
          b. Exit from HANDLER_.
          c. Push the value (REF.EXN_ADDR a) to the stack.
          d. Execute the instruction (BR l).
        4. Else:
          a. Let [catch] :: catch'* be catch_u1*.
          b. Exit from HANDLER_.
          c. Let H be (HANDLER_ n { catch'* }).
          d. Push the handler H to the stack.
          e. Push the value (REF.EXN_ADDR a) to the stack.
          f. Execute the instruction THROW_REF.
      d) Else:
        1. Let val* be $exninst(z)[a].FIELDS.
        2. Let [catch_0] :: catch'* be catch_u1*.
        3. If catch_0 is of the case CATCH, then:
          a. Let (CATCH x l) be catch_0.
          b. If ((x < |$tagaddr(z)|) and ($exninst(z)[a].TAG is $tagaddr(z)[x])), then:
            1) Exit from HANDLER_.
            2) Push the values val* to the stack.
            3) Execute the instruction (BR l).
          c. Else:
            1) Let [catch] :: catch'* be catch_u1*.
            2) Exit from HANDLER_.
            3) Let H be (HANDLER_ n { catch'* }).
            4) Push the handler H to the stack.
            5) Push the value (REF.EXN_ADDR a) to the stack.
            6) Execute the instruction THROW_REF.
        4. Else if catch_0 is of the case CATCH_REF, then:
          a. Let (CATCH_REF x l) be catch_0.
          b. If ((x < |$tagaddr(z)|) and ($exninst(z)[a].TAG is $tagaddr(z)[x])), then:
            1) Exit from HANDLER_.
            2) Push the values val* to the stack.
            3) Push the value (REF.EXN_ADDR a) to the stack.
            4) Execute the instruction (BR l).
          c. Else:
            1) Let [catch] :: catch'* be catch_u1*.
            2) Exit from HANDLER_.
            3) Let H be (HANDLER_ n { catch'* }).
            4) Push the handler H to the stack.
            5) Push the value (REF.EXN_ADDR a) to the stack.
            6) Execute the instruction THROW_REF.
        5. Else if catch_0 is of the case CATCH_ALL, then:
          a. Let (CATCH_ALL l) be catch_0.
          b. Exit from HANDLER_.
          c. Execute the instruction (BR l).
        6. Else if catch_0 is of the case CATCH_ALL_REF, then:
          a. Let (CATCH_ALL_REF l) be catch_0.
          b. Exit from HANDLER_.
          c. Push the value (REF.EXN_ADDR a) to the stack.
          d. Execute the instruction (BR l).
        7. Else:
          a. Let [catch] :: catch'* be catch_u1*.
          b. Exit from HANDLER_.
          c. Let H be (HANDLER_ n { catch'* }).
          d. Push the handler H to the stack.
          e. Push the value (REF.EXN_ADDR a) to the stack.
          f. Execute the instruction THROW_REF.

Step_read/try_table bt catch* instr*
1. Let z be the current state.
2. Let t_1^m -> t_2^n be $blocktype_(z, bt).
3. Assert: Due to validation, there are at least m values on the top of the stack.
4. Pop the values val^m from the stack.
5. Let H be (HANDLER_ n { catch* }).
6. Push the handler H to the stack.
7. Let L be the label_n{[]}.
8. Enter val^m :: instr* with label L.

Step_read/ref.null (_IDX x)
1. Let z be the current state.
2. Push the value (REF.NULL $type(z, x)) to the stack.

Step_read/ref.func x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$moduleinst(z).FUNCS|).
3. Push the value (REF.FUNC_ADDR $moduleinst(z).FUNCS[x]) to the stack.

Step_read/ref.test rt
1. Let f be the current frame.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value ref from the stack.
4. Let rt' be $Ref_type(ref).
5. If rt' matches $inst_reftype(f.MODULE, rt), then:
  a. Push the value (I32.CONST 1) to the stack.
6. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_read/ref.cast rt
1. Let f be the current frame.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value ref from the stack.
4. Let rt' be $Ref_type(ref).
5. If rt' does not match $inst_reftype(f.MODULE, rt), then:
  a. Trap.
6. Push the value ref to the stack.

Step_read/struct.new_default x
1. Let z be the current state.
2. Assert: Due to validation, $expanddt($type(z, x)) is of the case STRUCT.
3. Let (STRUCT fieldtype_0*) be $expanddt($type(z, x)).
4. Let (mut zt)* be fieldtype_0*.
5. Assert: Due to validation, $default_($unpack(zt)) is defined*.
6. Let ?(val)* be $default_($unpack(zt))*.
7. Assert: Due to validation, (|val*| is |zt*|).
8. Push the values val* to the stack.
9. Execute the instruction (STRUCT.NEW x).

Step_read/struct.get sx? x i
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value instr_u0 from the stack.
4. If instr_u0 is of the case REF.NULL, then:
  a. Trap.
5. If instr_u0 is of the case REF.STRUCT_ADDR, then:
  a. Let (REF.STRUCT_ADDR a) be instr_u0.
  b. If ((i < |$structinst(z)[a].FIELDS|) and (a < |$structinst(z)|)), then:
    1) Assert: Due to validation, $expanddt($type(z, x)) is of the case STRUCT.
    2) Let (STRUCT fieldtype_0*) be $expanddt($type(z, x)).
    3) Let (mut zt)* be fieldtype_0*.
    4) If (i < |zt*|), then:
      a) Push the value $unpackfield_(zt*[i], sx?, $structinst(z)[a].FIELDS[i]) to the stack.

Step_read/array.new_default x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, $expanddt($type(z, x)) is of the case ARRAY.
5. Let (ARRAY arraytype_0) be $expanddt($type(z, x)).
6. Let (mut zt) be arraytype_0.
7. Assert: Due to validation, $default_($unpack(zt)) is defined.
8. Let ?(val) be $default_($unpack(zt)).
9. Push the values val^n to the stack.
10. Execute the instruction (ARRAY.NEW_FIXED x n).

Step_read/array.new_elem x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If ((i + n) > |$elem(z, y).REFS|), then:
  a. Trap.
7. Assert: Due to validation, (|$elem(z, y).REFS[i : n]| is n).
8. Let ref* be $elem(z, y).REFS[i : n].
9. Push the values ref^n to the stack.
10. Execute the instruction (ARRAY.NEW_FIXED x n).

Step_read/array.new_data x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, $expanddt($type(z, x)) is of the case ARRAY.
7. Let (ARRAY arraytype_0) be $expanddt($type(z, x)).
8. Let (mut zt) be arraytype_0.
9. If ((i + ((n · $zsize(zt)) / 8)) > |$data(z, y).BYTES|), then:
  a. Trap.
10. Assert: Due to validation, (|$concatn__1^-1(byte, ($zsize(zt) / 8), $data(z, y).BYTES[i : ((n · $zsize(zt)) / 8)])| is n).
11. Let byte* be $concatn__1^-1(byte, ($zsize(zt) / 8), $data(z, y).BYTES[i : ((n · $zsize(zt)) / 8)]).
12. Let c* be $zbytes__1^-1(zt, byte)*.
13. Push the values $const($cunpack(zt), $cunpacknum_(zt, c))^n to the stack.
14. Execute the instruction (ARRAY.NEW_FIXED x n).

Step_read/array.get sx? x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value instr_u0 from the stack.
6. If instr_u0 is of the case REF.NULL, then:
  a. Trap.
7. If instr_u0 is of the case REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be instr_u0.
  b. If ((a < |$arrayinst(z)|) and (i ≥ |$arrayinst(z)[a].FIELDS|)), then:
    1) Trap.
  c. If ((i < |$arrayinst(z)[a].FIELDS|) and (a < |$arrayinst(z)|)), then:
    1) Assert: Due to validation, $expanddt($type(z, x)) is of the case ARRAY.
    2) Let (ARRAY arraytype_0) be $expanddt($type(z, x)).
    3) Let (mut zt) be arraytype_0.
    4) Push the value $unpackfield_(zt, sx?, $arrayinst(z)[a].FIELDS[i]) to the stack.

Step_read/array.len
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value instr_u0 from the stack.
4. If instr_u0 is of the case REF.NULL, then:
  a. Trap.
5. If instr_u0 is of the case REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be instr_u0.
  b. If (a < |$arrayinst(z)|), then:
    1) Push the value (I32.CONST |$arrayinst(z)[a].FIELDS|) to the stack.

Step_read/array.fill x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. Assert: Due to validation, a value is on the top of the stack.
9. Pop the value instr_u0 from the stack.
10. If instr_u0 is of the case REF.NULL, then:
  a. Trap.
11. If instr_u0 is of the case REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be instr_u0.
  b. If (a ≥ |$arrayinst(z)|), then:
    1) Do nothing.
  c. Else if ((i + n) > |$arrayinst(z)[a].FIELDS|), then:
    1) Trap.
  d. If (n is 0), then:
    1) Do nothing.
  e. Else:
    1) Push the value (REF.ARRAY_ADDR a) to the stack.
    2) Push the value (I32.CONST i) to the stack.
    3) Push the value val to the stack.
    4) Execute the instruction (ARRAY.SET x).
    5) Push the value (REF.ARRAY_ADDR a) to the stack.
    6) Push the value (I32.CONST (i + 1)) to the stack.
    7) Push the value val to the stack.
    8) Push the value (I32.CONST (n - 1)) to the stack.
    9) Execute the instruction (ARRAY.FILL x).

Step_read/array.copy x_1 x_2
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i_2) from the stack.
6. Assert: Due to validation, a value is on the top of the stack.
7. Pop the value instr_u0 from the stack.
8. Assert: Due to validation, a value of value type I32 is on the top of the stack.
9. Pop the value (I32.CONST i_1) from the stack.
10. Assert: Due to validation, a value is on the top of the stack.
11. Pop the value instr_u1 from the stack.
12. If (instr_u1 is of the case REF.NULL and the type of instr_u0 is ref), then:
  a. Trap.
13. If (instr_u0 is of the case REF.NULL and the type of instr_u1 is ref), then:
  a. Trap.
14. If instr_u1 is of the case REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a_1) be instr_u1.
  b. If instr_u0 is of the case REF.ARRAY_ADDR, then:
    1) If ((a_1 < |$arrayinst(z)|) and ((i_1 + n) > |$arrayinst(z)[a_1].FIELDS|)), then:
      a) Trap.
    2) Let (REF.ARRAY_ADDR a_2) be instr_u0.
    3) If (a_2 ≥ |$arrayinst(z)|), then:
      a) Do nothing.
    4) Else if ((i_2 + n) > |$arrayinst(z)[a_2].FIELDS|), then:
      a) Trap.
    5) If (n is 0), then:
      a) Do nothing.
    6) Else if ((i_1 ≤ i_2) and $expanddt($type(z, x_2)) is of the case ARRAY), then:
      a) Let (ARRAY arraytype_0) be $expanddt($type(z, x_2)).
      b) Let (mut zt_2) be arraytype_0.
      c) Let sx? be $sx(zt_2).
      d) Push the value (REF.ARRAY_ADDR a_1) to the stack.
      e) Push the value (I32.CONST i_1) to the stack.
      f) Push the value (REF.ARRAY_ADDR a_2) to the stack.
      g) Push the value (I32.CONST i_2) to the stack.
      h) Execute the instruction (ARRAY.GET sx? x_2).
      i) Execute the instruction (ARRAY.SET x_1).
      j) Push the value (REF.ARRAY_ADDR a_1) to the stack.
      k) Push the value (I32.CONST (i_1 + 1)) to the stack.
      l) Push the value (REF.ARRAY_ADDR a_2) to the stack.
      m) Push the value (I32.CONST (i_2 + 1)) to the stack.
      n) Push the value (I32.CONST (n - 1)) to the stack.
      o) Execute the instruction (ARRAY.COPY x_1 x_2).
    7) Else if $expanddt($type(z, x_2)) is of the case ARRAY, then:
      a) Let (ARRAY arraytype_0) be $expanddt($type(z, x_2)).
      b) Let (mut zt_2) be arraytype_0.
      c) Let sx? be $sx(zt_2).
      d) Push the value (REF.ARRAY_ADDR a_1) to the stack.
      e) Push the value (I32.CONST ((i_1 + n) - 1)) to the stack.
      f) Push the value (REF.ARRAY_ADDR a_2) to the stack.
      g) Push the value (I32.CONST ((i_2 + n) - 1)) to the stack.
      h) Execute the instruction (ARRAY.GET sx? x_2).
      i) Execute the instruction (ARRAY.SET x_1).
      j) Push the value (REF.ARRAY_ADDR a_1) to the stack.
      k) Push the value (I32.CONST i_1) to the stack.
      l) Push the value (REF.ARRAY_ADDR a_2) to the stack.
      m) Push the value (I32.CONST i_2) to the stack.
      n) Push the value (I32.CONST (n - 1)) to the stack.
      o) Execute the instruction (ARRAY.COPY x_1 x_2).
  c. Else if (n is not 0), then:
    1) Do nothing.

Step_read/array.init_elem x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST j) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. Assert: Due to validation, a value is on the top of the stack.
9. Pop the value instr_u0 from the stack.
10. If instr_u0 is of the case REF.NULL, then:
  a. Trap.
11. If instr_u0 is of the case REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be instr_u0.
  b. If ((a < |$arrayinst(z)|) and ((i + n) > |$arrayinst(z)[a].FIELDS|)), then:
    1) Trap.
  c. If ((j + n) > |$elem(z, y).REFS|), then:
    1) Trap.
  d. If (n is 0), then:
    1) Do nothing.
  e. Else if (j < |$elem(z, y).REFS|), then:
    1) Let ref be $elem(z, y).REFS[j].
    2) Push the value (REF.ARRAY_ADDR a) to the stack.
    3) Push the value (I32.CONST i) to the stack.
    4) Push the value ref to the stack.
    5) Execute the instruction (ARRAY.SET x).
    6) Push the value (REF.ARRAY_ADDR a) to the stack.
    7) Push the value (I32.CONST (i + 1)) to the stack.
    8) Push the value (I32.CONST (j + 1)) to the stack.
    9) Push the value (I32.CONST (n - 1)) to the stack.
    10) Execute the instruction (ARRAY.INIT_ELEM x y).

Step_read/array.init_data x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST j) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. Assert: Due to validation, a value is on the top of the stack.
9. Pop the value instr_u0 from the stack.
10. If instr_u0 is of the case REF.NULL, then:
  a. Trap.
11. If instr_u0 is of the case REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be instr_u0.
  b. If ((a < |$arrayinst(z)|) and ((i + n) > |$arrayinst(z)[a].FIELDS|)), then:
    1) Trap.
  c. If $expanddt($type(z, x)) is of the case ARRAY, then:
    1) Let (ARRAY arraytype_0) be $expanddt($type(z, x)).
    2) Let (mut zt) be arraytype_0.
    3) If ((j + ((n · $zsize(zt)) / 8)) > |$data(z, y).BYTES|), then:
      a) Trap.
    4) If (n is 0), then:
      a) Do nothing.
    5) Else:
      a) Let c be $zbytes__1^-1(zt, $data(z, y).BYTES[j : ($zsize(zt) / 8)]).
      b) Push the value (REF.ARRAY_ADDR a) to the stack.
      c) Push the value (I32.CONST i) to the stack.
      d) Push the value $const($cunpack(zt), $cunpacknum_(zt, c)) to the stack.
      e) Execute the instruction (ARRAY.SET x).
      f) Push the value (REF.ARRAY_ADDR a) to the stack.
      g) Push the value (I32.CONST (i + 1)) to the stack.
      h) Push the value (I32.CONST (j + ($zsize(zt) / 8))) to the stack.
      i) Push the value (I32.CONST (n - 1)) to the stack.
      j) Execute the instruction (ARRAY.INIT_DATA x y).
  d. Else if (n is 0), then:
    1) Do nothing.

Step_read/local.get x
1. Let z be the current state.
2. Assert: Due to validation, $local(z, x) is defined.
3. Let ?(val) be $local(z, x).
4. Push the value val to the stack.

Step_read/global.get x
1. Let z be the current state.
2. Let val be $global(z, x).VALUE.
3. Push the value val to the stack.

Step_read/table.get x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (i ≥ |$table(z, x).REFS|), then:
  a. Trap.
5. Push the value $table(z, x).REFS[i] to the stack.

Step_read/table.size x
1. Let z be the current state.
2. Let n be |$table(z, x).REFS|.
3. Push the value (I32.CONST n) to the stack.

Step_read/table.fill x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. If ((i + n) > |$table(z, x).REFS|), then:
  a. Trap.
9. If (n is 0), then:
  a. Do nothing.
10. Else:
  a. Push the value (I32.CONST i) to the stack.
  b. Push the value val to the stack.
  c. Execute the instruction (TABLE.SET x).
  d. Push the value (I32.CONST (i + 1)) to the stack.
  e. Push the value val to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (TABLE.FILL x).

Step_read/table.copy x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$table(z, y).REFS|), then:
  a. Trap.
9. If ((j + n) > |$table(z, x).REFS|), then:
  a. Trap.
10. If (n is 0), then:
  a. Do nothing.
11. Else:
  a. If (j ≤ i), then:
    1) Push the value (I32.CONST j) to the stack.
    2) Push the value (I32.CONST i) to the stack.
    3) Execute the instruction (TABLE.GET y).
    4) Execute the instruction (TABLE.SET x).
    5) Push the value (I32.CONST (j + 1)) to the stack.
    6) Push the value (I32.CONST (i + 1)) to the stack.
  b. Else:
    1) Push the value (I32.CONST ((j + n) - 1)) to the stack.
    2) Push the value (I32.CONST ((i + n) - 1)) to the stack.
    3) Execute the instruction (TABLE.GET y).
    4) Execute the instruction (TABLE.SET x).
    5) Push the value (I32.CONST j) to the stack.
    6) Push the value (I32.CONST i) to the stack.
  c. Push the value (I32.CONST (n - 1)) to the stack.
  d. Execute the instruction (TABLE.COPY x y).

Step_read/table.init x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$elem(z, y).REFS|), then:
  a. Trap.
9. If ((j + n) > |$table(z, x).REFS|), then:
  a. Trap.
10. If (n is 0), then:
  a. Do nothing.
11. Else if (i < |$elem(z, y).REFS|), then:
  a. Push the value (I32.CONST j) to the stack.
  b. Push the value $elem(z, y).REFS[i] to the stack.
  c. Execute the instruction (TABLE.SET x).
  d. Push the value (I32.CONST (j + 1)) to the stack.
  e. Push the value (I32.CONST (i + 1)) to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (TABLE.INIT x y).

Step_read/load numtype_u0 loadop__u2? x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If loadop__u2? is not defined, then:
  a. Let nt be numtype_u0.
  b. If (((i + ao.OFFSET) + ($size(nt) / 8)) > |$mem(z, x).BYTES|), then:
    1) Trap.
  c. Let c be $nbytes__1^-1(nt, $mem(z, x).BYTES[(i + ao.OFFSET) : ($size(nt) / 8)]).
  d. Push the value (nt.CONST c) to the stack.
5. If the type of numtype_u0 is Inn, then:
  a. If loadop__u2? is defined, then:
    1) Let ?(loadop__0) be loadop__u2?.
    2) Let (n sx) be loadop__0.
    3) If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, x).BYTES|), then:
      a) Trap.
  b. Let Inn be numtype_u0.
  c. If loadop__u2? is defined, then:
    1) Let ?(loadop__0) be loadop__u2?.
    2) Let (n sx) be loadop__0.
    3) Let c be $ibytes__1^-1(n, $mem(z, x).BYTES[(i + ao.OFFSET) : (n / 8)]).
    4) Push the value (Inn.CONST $extend__(n, $size(Inn), sx, c)) to the stack.

Step_read/vload V128 vloadop__u0? x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If ((((i + ao.OFFSET) + ($vsize(V128) / 8)) > |$mem(z, x).BYTES|) and vloadop__u0? is not defined), then:
  a. Trap.
5. If vloadop__u0? is not defined, then:
  a. Let c be $vbytes__1^-1(V128, $mem(z, x).BYTES[(i + ao.OFFSET) : ($vsize(V128) / 8)]).
  b. Push the value (V128.CONST c) to the stack.
6. Else:
  a. Let ?(vloadop__0) be vloadop__u0?.
  b. If vloadop__0 is of the case SHAPE, then:
    1) Let (SHAPE M X K sx) be vloadop__0.
    2) If (((i + ao.OFFSET) + ((M · K) / 8)) > |$mem(z, x).BYTES|), then:
      a) Trap.
    3) Let j^K be $ibytes__1^-1(M, $mem(z, x).BYTES[((i + ao.OFFSET) + ((k · M) / 8)) : (M / 8)])^(k<K).
    4) If the type of $lsizenn^-1((M · 2)) is Jnn, then:
      a) Let Jnn be $lsizenn^-1((M · 2)).
      b) Let c be $invlanes_(Jnn X K, $extend__(M, $lsizenn(Jnn), sx, j)^K).
      c) Push the value (V128.CONST c) to the stack.
  c. If vloadop__0 is of the case SPLAT, then:
    1) Let (SPLAT N) be vloadop__0.
    2) If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, x).BYTES|), then:
      a) Trap.
    3) Let M be (128 / N).
    4) If the type of $lsize^-1(N) is Jnn, then:
      a) Let Jnn be $lsize^-1(N).
      b) Let j be $ibytes__1^-1(N, $mem(z, x).BYTES[(i + ao.OFFSET) : (N / 8)]).
      c) Let c be $invlanes_(Jnn X M, j^M).
      d) Push the value (V128.CONST c) to the stack.
  d. If vloadop__0 is of the case ZERO, then:
    1) Let (ZERO N) be vloadop__0.
    2) If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, x).BYTES|), then:
      a) Trap.
    3) Let j be $ibytes__1^-1(N, $mem(z, x).BYTES[(i + ao.OFFSET) : (N / 8)]).
    4) Let c be $extend__(N, 128, U, j).
    5) Push the value (V128.CONST c) to the stack.

Step_read/vload_lane V128 N x ao j
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c_1) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, x).BYTES|), then:
  a. Trap.
7. Let M be ($vsize(V128) / N).
8. If the type of $lsize^-1(N) is Jnn, then:
  a. Let Jnn be $lsize^-1(N).
  b. Let k be $ibytes__1^-1(N, $mem(z, x).BYTES[(i + ao.OFFSET) : (N / 8)]).
  c. Let c be $invlanes_(Jnn X M, $lanes_(Jnn X M, c_1) with [j] replaced by k).
  d. Push the value (V128.CONST c) to the stack.

Step_read/memory.size x
1. Let z be the current state.
2. Let (n · (64 · $Ki())) be |$mem(z, x).BYTES|.
3. Push the value (I32.CONST n) to the stack.

Step_read/memory.fill x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. If ((i + n) > |$mem(z, x).BYTES|), then:
  a. Trap.
9. If (n is 0), then:
  a. Do nothing.
10. Else:
  a. Push the value (I32.CONST i) to the stack.
  b. Push the value val to the stack.
  c. Execute the instruction (STORE I32 ?(8) x $memarg0()).
  d. Push the value (I32.CONST (i + 1)) to the stack.
  e. Push the value val to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (MEMORY.FILL x).

Step_read/memory.copy x_1 x_2
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i_2) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i_1) from the stack.
8. If ((i_1 + n) > |$mem(z, x_1).BYTES|), then:
  a. Trap.
9. If ((i_2 + n) > |$mem(z, x_2).BYTES|), then:
  a. Trap.
10. If (n is 0), then:
  a. Do nothing.
11. Else:
  a. If (i_1 ≤ i_2), then:
    1) Push the value (I32.CONST i_1) to the stack.
    2) Push the value (I32.CONST i_2) to the stack.
    3) Execute the instruction (LOAD I32 ?((8 U)) x_2 $memarg0()).
    4) Execute the instruction (STORE I32 ?(8) x_1 $memarg0()).
    5) Push the value (I32.CONST (i_1 + 1)) to the stack.
    6) Push the value (I32.CONST (i_2 + 1)) to the stack.
  b. Else:
    1) Push the value (I32.CONST ((i_1 + n) - 1)) to the stack.
    2) Push the value (I32.CONST ((i_2 + n) - 1)) to the stack.
    3) Execute the instruction (LOAD I32 ?((8 U)) x_2 $memarg0()).
    4) Execute the instruction (STORE I32 ?(8) x_1 $memarg0()).
    5) Push the value (I32.CONST i_1) to the stack.
    6) Push the value (I32.CONST i_2) to the stack.
  c. Push the value (I32.CONST (n - 1)) to the stack.
  d. Execute the instruction (MEMORY.COPY x_1 x_2).

Step_read/memory.init x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$data(z, y).BYTES|), then:
  a. Trap.
9. If ((j + n) > |$mem(z, x).BYTES|), then:
  a. Trap.
10. If (n is 0), then:
  a. Do nothing.
11. Else if (i < |$data(z, y).BYTES|), then:
  a. Push the value (I32.CONST j) to the stack.
  b. Push the value (I32.CONST $data(z, y).BYTES[i]) to the stack.
  c. Execute the instruction (STORE I32 ?(8) x $memarg0()).
  d. Push the value (I32.CONST (j + 1)) to the stack.
  e. Push the value (I32.CONST (i + 1)) to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (MEMORY.INIT x y).

Step/throw x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$tagaddr(z)|).
3. Let a be |$exninst(z)|.
4. Assert: Due to validation, $expanddt($tag(z, x).TYPE) is of the case FUNC.
5. Let (FUNC functype_0) be $expanddt($tag(z, x).TYPE).
6. Let t^n -> valtype_1 be functype_0.
7. Assert: Due to validation, (valtype_1 is []).
8. Assert: Due to validation, there are at least n values on the top of the stack.
9. Pop the values val^n from the stack.
10. Let exn be { TAG: $tagaddr(z)[x]; FIELDS: val^n; }.
11. Perform $add_exninst(z, [exn]).
12. Push the value (REF.EXN_ADDR a) to the stack.
13. Execute the instruction THROW_REF.

Step/struct.new x
1. Let z be the current state.
2. Let a be |$structinst(z)|.
3. Assert: Due to validation, $expanddt($type(z, x)) is of the case STRUCT.
4. Let (STRUCT fieldtype_0^n) be $expanddt($type(z, x)).
5. Let (mut zt)^n be fieldtype_0^n.
6. Assert: Due to validation, there are at least n values on the top of the stack.
7. Pop the values val^n from the stack.
8. Let si be { TYPE: $type(z, x); FIELDS: $packfield_(zt, val)^n; }.
9. Push the value (REF.STRUCT_ADDR a) to the stack.
10. Perform $add_structinst(z, [si]).

Step/struct.set x i
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value instr_u0 from the stack.
6. If instr_u0 is of the case REF.NULL, then:
  a. Trap.
7. If instr_u0 is of the case REF.STRUCT_ADDR, then:
  a. Let (REF.STRUCT_ADDR a) be instr_u0.
  b. Assert: Due to validation, $expanddt($type(z, x)) is of the case STRUCT.
  c. Let (STRUCT fieldtype_0*) be $expanddt($type(z, x)).
  d. Let (mut zt)* be fieldtype_0*.
  e. If (i < |zt*|), then:
    1) Perform $with_struct(z, a, i, $packfield_(zt*[i], val)).

Step/array.new_fixed x n
1. Let z be the current state.
2. Assert: Due to validation, there are at least n values on the top of the stack.
3. Pop the values val^n from the stack.
4. Let a be |$arrayinst(z)|.
5. Assert: Due to validation, $expanddt($type(z, x)) is of the case ARRAY.
6. Let (ARRAY arraytype_0) be $expanddt($type(z, x)).
7. Let (mut zt) be arraytype_0.
8. Let ai be { TYPE: $type(z, x); FIELDS: $packfield_(zt, val)^n; }.
9. Push the value (REF.ARRAY_ADDR a) to the stack.
10. Perform $add_arrayinst(z, [ai]).

Step/array.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value is on the top of the stack.
7. Pop the value instr_u0 from the stack.
8. If instr_u0 is of the case REF.NULL, then:
  a. Trap.
9. If instr_u0 is of the case REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be instr_u0.
  b. If ((a < |$arrayinst(z)|) and (i ≥ |$arrayinst(z)[a].FIELDS|)), then:
    1) Trap.
  c. Assert: Due to validation, $expanddt($type(z, x)) is of the case ARRAY.
  d. Let (ARRAY arraytype_0) be $expanddt($type(z, x)).
  e. Let (mut zt) be arraytype_0.
  f. Perform $with_array(z, a, i, $packfield_(zt, val)).

Step/local.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_local(z, x, val).

Step/global.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_global(z, x, val).

Step/table.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value ref from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (i ≥ |$table(z, x).REFS|), then:
  a. Trap.
7. Perform $with_table(z, x, i, ref).

Step/table.grow x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value ref from the stack.
6. Either:
  a. Let ti be $growtable($table(z, x), n, ref).
  b. Push the value (I32.CONST |$table(z, x).REFS|) to the stack.
  c. Perform $with_tableinst(z, x, ti).
7. Or:
  a. Push the value (I32.CONST $invsigned_(32, (- 1))) to the stack.

Step/elem.drop x
1. Let z be the current state.
2. Perform $with_elem(z, x, []).

Step/store nt sz_u0? x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type numtype_u1 is on the top of the stack.
3. Pop the value (numtype_u1.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (numtype_u1 is nt), then:
  a. If ((((i + ao.OFFSET) + ($size(nt) / 8)) > |$mem(z, x).BYTES|) and sz_u0? is not defined), then:
    1) Trap.
  b. If sz_u0? is not defined, then:
    1) Let b* be $nbytes_(nt, c).
    2) Perform $with_mem(z, x, (i + ao.OFFSET), ($size(nt) / 8), b*).
7. If the type of numtype_u1 is Inn, then:
  a. If sz_u0? is defined, then:
    1) Let ?(n) be sz_u0?.
    2) If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, x).BYTES|), then:
      a) Trap.
  b. Let Inn be numtype_u1.
  c. If sz_u0? is defined, then:
    1) Let ?(n) be sz_u0?.
    2) Let b* be $ibytes_(n, $wrap__($size(Inn), n, c)).
    3) Perform $with_mem(z, x, (i + ao.OFFSET), (n / 8), b*).

Step/vstore V128 x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + ($vsize(V128) / 8)) > |$mem(z, x).BYTES|), then:
  a. Trap.
7. Let b* be $vbytes_(V128, c).
8. Perform $with_mem(z, x, (i + ao.OFFSET), ($vsize(V128) / 8), b*).

Step/vstore_lane V128 N x ao j
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + N) > |$mem(z, x).BYTES|), then:
  a. Trap.
7. Let M be (128 / N).
8. If the type of $lsize^-1(N) is Jnn, then:
  a. Let Jnn be $lsize^-1(N).
  b. If (j < |$lanes_(Jnn X M, c)|), then:
    1) Let b* be $ibytes_(N, $lanes_(Jnn X M, c)[j]).
    2) Perform $with_mem(z, x, (i + ao.OFFSET), (N / 8), b*).

Step/memory.grow x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Either:
  a. Let mi be $growmem($mem(z, x), n).
  b. Push the value (I32.CONST (|$mem(z, x).BYTES| / (64 · $Ki()))) to the stack.
  c. Perform $with_meminst(z, x, mi).
5. Or:
  a. Push the value (I32.CONST $invsigned_(32, (- 1))) to the stack.

Step/data.drop x
1. Let z be the current state.
2. Perform $with_data(z, x, []).

Ki
1. Return 1024.

min n_u0 n_u1
1. If (n_u0 is 0), then:
  a. Return 0.
2. If (n_u1 is 0), then:
  a. Return 0.
3. Assert: Due to validation, (n_u0 ≥ 1).
4. Let i be (n_u0 - 1).
5. Assert: Due to validation, (n_u1 ≥ 1).
6. Let j be (n_u1 - 1).
7. Return $min(i, j).

sum n_u0*
1. If (n_u0* is []), then:
  a. Return 0.
2. Let [n] :: n'* be n_u0*.
3. Return (n + $sum(n'*)).

opt_ X X_u0*
1. If (X_u0* is []), then:
  a. Return ?().
2. Assert: Due to validation, (|X_u0*| is 1).
3. Let [w] be X_u0*.
4. Return ?(w).

list_ X X_u0?
1. If X_u0? is not defined, then:
  a. Return [].
2. Let ?(w) be X_u0?.
3. Return [w].

concat_ X X_u0*
1. If (X_u0* is []), then:
  a. Return [].
2. Let [w*] :: w'** be X_u0*.
3. Return w* :: $concat_(X, w'**).

concatn_ X X_u0* n
1. If (X_u0* is []), then:
  a. Return [].
2. Let [w^n] :: w'^n* be X_u0*.
3. Return w^n :: $concatn_(X, w'^n*, n).

disjoint_ X X_u0*
1. If (X_u0* is []), then:
  a. Return true.
2. Let [w] :: w'* be X_u0*.
3. Return (w is not contained in w'* and $disjoint_(X, w'*)).

setminus1_ X w X_u0*
1. If (X_u0* is []), then:
  a. Return [w].
2. Let [w_1] :: w'* be X_u0*.
3. If (w is w_1), then:
  a. Return [].
4. Return $setminus1_(X, w, w'*).

setminus_ X X_u0* w*
1. If (X_u0* is []), then:
  a. Return [].
2. Let [w_1] :: w'* be X_u0*.
3. Return $setminus1_(X, w_1, w*) :: $setminus_(X, w'*, w*).

setproduct2_ X w_1 X_u0*
1. If (X_u0* is []), then:
  a. Return [].
2. Let [w'*] :: w** be X_u0*.
3. Return [[w_1] :: w'*] :: $setproduct2_(X, w_1, w**).

setproduct1_ X X_u0* w**
1. If (X_u0* is []), then:
  a. Return [].
2. Let [w_1] :: w'* be X_u0*.
3. Return $setproduct2_(X, w_1, w**) :: $setproduct1_(X, w'*, w**).

setproduct_ X X_u0*
1. If (X_u0* is []), then:
  a. Return [[]].
2. Let [w_1*] :: w** be X_u0*.
3. Return $setproduct1_(X, w_1*, $setproduct_(X, w**)).

signif N_u0
1. If (N_u0 is 32), then:
  a. Return 23.
2. Assert: Due to validation, (N_u0 is 64).
3. Return 52.

expon N_u0
1. If (N_u0 is 32), then:
  a. Return 8.
2. Assert: Due to validation, (N_u0 is 64).
3. Return 11.

M N
1. Return $signif(N).

E N
1. Return $expon(N).

fzero N
1. Return (POS (SUBNORM 0)).

fone N
1. Return (POS (NORM 1 0)).

canon_ N
1. Return (2 ^ ($signif(N) - 1)).

cont b
1. Assert: Due to validation, (128 < b).
2. Assert: Due to validation, (b < 192).
3. Return (b - 128).

ANYREF
1. Return (REF (NULL ?(()) ?) ANY).

EQREF
1. Return (REF (NULL ?(()) ?) EQ).

I31REF
1. Return (REF (NULL ?(()) ?) I31).

STRUCTREF
1. Return (REF (NULL ?(()) ?) STRUCT).

ARRAYREF
1. Return (REF (NULL ?(()) ?) ARRAY).

FUNCREF
1. Return (REF (NULL ?(()) ?) FUNC).

EXTERNREF
1. Return (REF (NULL ?(()) ?) EXTERN).

NULLREF
1. Return (REF (NULL ?(()) ?) NONE).

NULLFUNCREF
1. Return (REF (NULL ?(()) ?) NOFUNC).

NULLEXTERNREF
1. Return (REF (NULL ?(()) ?) NOEXTERN).

size numtype_u0
1. If (numtype_u0 is I32), then:
  a. Return 32.
2. If (numtype_u0 is I64), then:
  a. Return 64.
3. If (numtype_u0 is F32), then:
  a. Return 32.
4. Assert: Due to validation, (numtype_u0 is F64).
5. Return 64.

vsize V128
1. Return 128.

psize packtype_u0
1. If (packtype_u0 is I8), then:
  a. Return 8.
2. Assert: Due to validation, (packtype_u0 is I16).
3. Return 16.

lsize lanetype_u0
1. If the type of lanetype_u0 is numtype, then:
  a. Let numtype be lanetype_u0.
  b. Return $size(numtype).
2. Assert: Due to validation, the type of lanetype_u0 is packtype.
3. Let packtype be lanetype_u0.
4. Return $psize(packtype).

zsize storagetype_u0
1. If the type of storagetype_u0 is numtype, then:
  a. Let numtype be storagetype_u0.
  b. Return $size(numtype).
2. If the type of storagetype_u0 is vectype, then:
  a. Let vectype be storagetype_u0.
  b. Return $vsize(vectype).
3. Assert: Due to validation, the type of storagetype_u0 is packtype.
4. Let packtype be storagetype_u0.
5. Return $psize(packtype).

lanetype Lnn X N
1. Return Lnn.

sizenn nt
1. Return $size(nt).

sizenn1 nt
1. Return $size(nt).

sizenn2 nt
1. Return $size(nt).

psizenn pt
1. Return $psize(pt).

lsizenn lt
1. Return $lsize(lt).

lsizenn1 lt
1. Return $lsize(lt).

lsizenn2 lt
1. Return $lsize(lt).

zero numtype_u0
1. If the type of numtype_u0 is Inn, then:
  a. Return 0.
2. Assert: Due to validation, the type of numtype_u0 is Fnn.
3. Let Fnn be numtype_u0.
4. Return $fzero($size(Fnn)).

dim Lnn X N
1. Return N.

shsize Lnn X N
1. Return ($lsize(Lnn) · N).

IN N_u0
1. If (N_u0 is 32), then:
  a. Return I32.
2. Assert: Due to validation, (N_u0 is 64).
3. Return I64.

FN N_u0
1. If (N_u0 is 32), then:
  a. Return F32.
2. Assert: Due to validation, (N_u0 is 64).
3. Return F64.

JN N_u0
1. If (N_u0 is 8), then:
  a. Return I8.
2. If (N_u0 is 16), then:
  a. Return I16.
3. If (N_u0 is 32), then:
  a. Return I32.
4. Assert: Due to validation, (N_u0 is 64).
5. Return I64.

lunpack lanetype_u0
1. If the type of lanetype_u0 is numtype, then:
  a. Let numtype be lanetype_u0.
  b. Return numtype.
2. Assert: Due to validation, the type of lanetype_u0 is packtype.
3. Return I32.

unpack storagetype_u0
1. If the type of storagetype_u0 is valtype, then:
  a. Let valtype be storagetype_u0.
  b. Return valtype.
2. Assert: Due to validation, the type of storagetype_u0 is packtype.
3. Return I32.

nunpack storagetype_u0
1. If the type of storagetype_u0 is numtype, then:
  a. Let numtype be storagetype_u0.
  b. Return numtype.
2. If the type of storagetype_u0 is packtype, then:
  a. Return I32.

vunpack vectype
1. Return vectype.

cunpack storagetype_u0
1. If the type of storagetype_u0 is consttype, then:
  a. Let consttype be storagetype_u0.
  b. Return consttype.
2. If the type of storagetype_u0 is packtype, then:
  a. Return I32.
3. If the type of storagetype_u0 is lanetype, then:
  a. Let lanetype be storagetype_u0.
  b. Return $lunpack(lanetype).

sx storagetype_u0
1. If the type of storagetype_u0 is consttype, then:
  a. Return ?().
2. Assert: Due to validation, the type of storagetype_u0 is packtype.
3. Return ?(S).

const consttype_u0 c
1. If the type of consttype_u0 is numtype, then:
  a. Let numtype be consttype_u0.
  b. Return (numtype.CONST c).
2. Assert: Due to validation, the type of consttype_u0 is vectype.
3. Let vectype be consttype_u0.
4. Return (vectype.CONST c).

unpackshape Lnn X N
1. Return $lunpack(Lnn).

diffrt (REF nul1 ht_1) (REF (NULL _u0? ?) ht_2)
1. If (_u0? is ?(())), then:
  a. Return (REF (NULL ?() ?) ht_1).
2. Assert: Due to validation, _u0? is not defined.
3. Return (REF nul1 ht_1).

free_opt free_u0?
1. If free_u0? is not defined, then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
2. Let ?(free) be free_u0?.
3. Return free.

free_list free_u0*
1. If (free_u0* is []), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
2. Let [free] :: free'* be free_u0*.
3. Return free ++ $free_list(free'*).

free_typeidx typeidx
1. Return { TYPES: [typeidx]; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_funcidx funcidx
1. Return { TYPES: []; FUNCS: [funcidx]; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_globalidx globalidx
1. Return { TYPES: []; FUNCS: []; GLOBALS: [globalidx]; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_tableidx tableidx
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: [tableidx]; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_memidx memidx
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: [memidx]; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_elemidx elemidx
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: [elemidx]; DATAS: []; LOCALS: []; LABELS: []; }.

free_dataidx dataidx
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: [dataidx]; LOCALS: []; LABELS: []; }.

free_localidx localidx
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: [localidx]; LABELS: []; }.

free_labelidx labelidx
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: [labelidx]; }.

free_externidx externidx_u0
1. If externidx_u0 is of the case FUNC, then:
  a. Let (FUNC funcidx) be externidx_u0.
  b. Return $free_funcidx(funcidx).
2. If externidx_u0 is of the case GLOBAL, then:
  a. Let (GLOBAL globalidx) be externidx_u0.
  b. Return $free_globalidx(globalidx).
3. If externidx_u0 is of the case TABLE, then:
  a. Let (TABLE tableidx) be externidx_u0.
  b. Return $free_tableidx(tableidx).
4. Assert: Due to validation, externidx_u0 is of the case MEM.
5. Let (MEM memidx) be externidx_u0.
6. Return $free_memidx(memidx).

free_numtype numtype
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_packtype packtype
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_lanetype lanetype_u0
1. If the type of lanetype_u0 is numtype, then:
  a. Let numtype be lanetype_u0.
  b. Return $free_numtype(numtype).
2. Assert: Due to validation, the type of lanetype_u0 is packtype.
3. Let packtype be lanetype_u0.
4. Return $free_packtype(packtype).

free_vectype vectype
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_consttype consttype_u0
1. If the type of consttype_u0 is numtype, then:
  a. Let numtype be consttype_u0.
  b. Return $free_numtype(numtype).
2. Assert: Due to validation, the type of consttype_u0 is vectype.
3. Let vectype be consttype_u0.
4. Return $free_vectype(vectype).

free_absheaptype absheaptype
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_rectype (REC subtype*)
1. Return $free_list($free_subtype(subtype)*).

free_deftype (DEF rectype n)
1. Return $free_rectype(rectype).

free_typeuse typeuse_u0
1. If typeuse_u0 is of the case _IDX, then:
  a. Let (_IDX typeidx) be typeuse_u0.
  b. Return $free_typeidx(typeidx).
2. If typeuse_u0 is of the case REC, then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
3. Assert: Due to validation, the type of typeuse_u0 is deftype.
4. Let deftype be typeuse_u0.
5. Return $free_deftype(deftype).

free_heaptype heaptype_u0
1. If the type of heaptype_u0 is absheaptype, then:
  a. Let absheaptype be heaptype_u0.
  b. Return $free_absheaptype(absheaptype).
2. Assert: Due to validation, the type of heaptype_u0 is typeuse.
3. Let typeuse be heaptype_u0.
4. Return $free_typeuse(typeuse).

free_reftype (REF nul heaptype)
1. Return $free_heaptype(heaptype).

free_valtype valtype_u0
1. If the type of valtype_u0 is numtype, then:
  a. Let numtype be valtype_u0.
  b. Return $free_numtype(numtype).
2. If the type of valtype_u0 is vectype, then:
  a. Let vectype be valtype_u0.
  b. Return $free_vectype(vectype).
3. If the type of valtype_u0 is reftype, then:
  a. Let reftype be valtype_u0.
  b. Return $free_reftype(reftype).
4. Assert: Due to validation, (valtype_u0 is BOT).
5. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_resulttype valtype*
1. Return $free_list($free_valtype(valtype)*).

free_storagetype storagetype_u0
1. If the type of storagetype_u0 is valtype, then:
  a. Let valtype be storagetype_u0.
  b. Return $free_valtype(valtype).
2. Assert: Due to validation, the type of storagetype_u0 is packtype.
3. Let packtype be storagetype_u0.
4. Return $free_packtype(packtype).

free_fieldtype (mut storagetype)
1. Return $free_storagetype(storagetype).

free_functype resulttype_1 -> resulttype_2
1. Return $free_resulttype(resulttype_1) ++ $free_resulttype(resulttype_2).

free_structtype fieldtype*
1. Return $free_list($free_fieldtype(fieldtype)*).

free_arraytype fieldtype
1. Return $free_fieldtype(fieldtype).

free_comptype comptype_u0
1. If comptype_u0 is of the case STRUCT, then:
  a. Let (STRUCT structtype) be comptype_u0.
  b. Return $free_structtype(structtype).
2. If comptype_u0 is of the case ARRAY, then:
  a. Let (ARRAY arraytype) be comptype_u0.
  b. Return $free_arraytype(arraytype).
3. Assert: Due to validation, comptype_u0 is of the case FUNC.
4. Let (FUNC functype) be comptype_u0.
5. Return $free_functype(functype).

free_subtype (SUB fin typeuse* comptype)
1. Return $free_list($free_typeuse(typeuse)*) ++ $free_comptype(comptype).

free_globaltype (mut valtype)
1. Return $free_valtype(valtype).

free_tabletype (limits reftype)
1. Return $free_reftype(reftype).

free_memtype limits PAGE
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_elemtype reftype
1. Return $free_reftype(reftype).

free_datatype OK
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_externtype externtype_u0
1. If externtype_u0 is of the case FUNC, then:
  a. Let (FUNC typeuse) be externtype_u0.
  b. Return $free_typeuse(typeuse).
2. If externtype_u0 is of the case GLOBAL, then:
  a. Let (GLOBAL globaltype) be externtype_u0.
  b. Return $free_globaltype(globaltype).
3. If externtype_u0 is of the case TABLE, then:
  a. Let (TABLE tabletype) be externtype_u0.
  b. Return $free_tabletype(tabletype).
4. Assert: Due to validation, externtype_u0 is of the case MEM.
5. Let (MEM memtype) be externtype_u0.
6. Return $free_memtype(memtype).

free_moduletype externtype_1* -> externtype_2*
1. Return $free_list($free_externtype(externtype_1)*) ++ $free_list($free_externtype(externtype_2)*).

free_blocktype blocktype_u0
1. If blocktype_u0 is of the case _RESULT, then:
  a. Let (_RESULT valtype?) be blocktype_u0.
  b. Return $free_opt($free_valtype(valtype)?).
2. Assert: Due to validation, blocktype_u0 is of the case _IDX.
3. Let (_IDX funcidx) be blocktype_u0.
4. Return $free_funcidx(funcidx).

free_shape lanetype X dim
1. Return $free_lanetype(lanetype).

shift_labelidxs labelidx_u0*
1. If (labelidx_u0* is []), then:
  a. Return [].
2. Let [n_0] :: labelidx'* be labelidx_u0*.
3. If (n_0 is 0), then:
  a. Return $shift_labelidxs(labelidx'*).
4. Let [labelidx] :: labelidx'* be labelidx_u0*.
5. Return [(labelidx - 1)] :: $shift_labelidxs(labelidx'*).

free_block instr*
1. Let free be $free_list($free_instr(instr)*).
2. Return free with .LABELS replaced by $shift_labelidxs(free.LABELS).

free_instr instr_u0
1. If (instr_u0 is NOP), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
2. If (instr_u0 is UNREACHABLE), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
3. If (instr_u0 is DROP), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
4. If instr_u0 is of the case SELECT, then:
  a. Let (SELECT valtype*?) be instr_u0.
  b. Return $free_opt($free_list($free_valtype(valtype)*)?).
5. If instr_u0 is of the case BLOCK, then:
  a. Let (BLOCK blocktype instr*) be instr_u0.
  b. Return $free_blocktype(blocktype) ++ $free_block(instr*).
6. If instr_u0 is of the case LOOP, then:
  a. Let (LOOP blocktype instr*) be instr_u0.
  b. Return $free_blocktype(blocktype) ++ $free_block(instr*).
7. If instr_u0 is of the case IF, then:
  a. Let (IF blocktype instr_1* ELSE instr_2*) be instr_u0.
  b. Return $free_blocktype(blocktype) ++ $free_block(instr_1*) ++ $free_block(instr_2*).
8. If instr_u0 is of the case BR, then:
  a. Let (BR labelidx) be instr_u0.
  b. Return $free_labelidx(labelidx).
9. If instr_u0 is of the case BR_IF, then:
  a. Let (BR_IF labelidx) be instr_u0.
  b. Return $free_labelidx(labelidx).
10. If instr_u0 is of the case BR_TABLE, then:
  a. Let (BR_TABLE labelidx* labelidx') be instr_u0.
  b. Return $free_list($free_labelidx(labelidx)*) ++ $free_labelidx(labelidx).
11. If instr_u0 is of the case BR_ON_NULL, then:
  a. Let (BR_ON_NULL labelidx) be instr_u0.
  b. Return $free_labelidx(labelidx).
12. If instr_u0 is of the case BR_ON_NON_NULL, then:
  a. Let (BR_ON_NON_NULL labelidx) be instr_u0.
  b. Return $free_labelidx(labelidx).
13. If instr_u0 is of the case BR_ON_CAST, then:
  a. Let (BR_ON_CAST labelidx reftype_1 reftype_2) be instr_u0.
  b. Return $free_labelidx(labelidx) ++ $free_reftype(reftype_1) ++ $free_reftype(reftype_2).
14. If instr_u0 is of the case BR_ON_CAST_FAIL, then:
  a. Let (BR_ON_CAST_FAIL labelidx reftype_1 reftype_2) be instr_u0.
  b. Return $free_labelidx(labelidx) ++ $free_reftype(reftype_1) ++ $free_reftype(reftype_2).
15. If instr_u0 is of the case CALL, then:
  a. Let (CALL funcidx) be instr_u0.
  b. Return $free_funcidx(funcidx).
16. If instr_u0 is of the case CALL_REF, then:
  a. Let (CALL_REF typeuse) be instr_u0.
  b. Return $free_typeuse(typeuse).
17. If instr_u0 is of the case CALL_INDIRECT, then:
  a. Let (CALL_INDIRECT tableidx typeuse) be instr_u0.
  b. Return $free_tableidx(tableidx) ++ $free_typeuse(typeuse).
18. If (instr_u0 is RETURN), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
19. If instr_u0 is of the case RETURN_CALL, then:
  a. Let (RETURN_CALL funcidx) be instr_u0.
  b. Return $free_funcidx(funcidx).
20. If instr_u0 is of the case RETURN_CALL_REF, then:
  a. Let (RETURN_CALL_REF typeuse) be instr_u0.
  b. Return $free_typeuse(typeuse).
21. If instr_u0 is of the case RETURN_CALL_INDIRECT, then:
  a. Let (RETURN_CALL_INDIRECT tableidx typeuse) be instr_u0.
  b. Return $free_tableidx(tableidx) ++ $free_typeuse(typeuse).
22. If instr_u0 is of the case CONST, then:
  a. Let (numtype.CONST numlit) be instr_u0.
  b. Return $free_numtype(numtype).
23. If instr_u0 is of the case UNOP, then:
  a. Let (UNOP numtype unop) be instr_u0.
  b. Return $free_numtype(numtype).
24. If instr_u0 is of the case BINOP, then:
  a. Let (BINOP numtype binop) be instr_u0.
  b. Return $free_numtype(numtype).
25. If instr_u0 is of the case TESTOP, then:
  a. Let (TESTOP numtype testop) be instr_u0.
  b. Return $free_numtype(numtype).
26. If instr_u0 is of the case RELOP, then:
  a. Let (RELOP numtype relop) be instr_u0.
  b. Return $free_numtype(numtype).
27. If instr_u0 is of the case CVTOP, then:
  a. Let (CVTOP numtype_1 numtype_2 cvtop) be instr_u0.
  b. Return $free_numtype(numtype_1) ++ $free_numtype(numtype_2).
28. If instr_u0 is of the case VCONST, then:
  a. Let (vectype.CONST veclit) be instr_u0.
  b. Return $free_vectype(vectype).
29. If instr_u0 is of the case VVUNOP, then:
  a. Let (VVUNOP vectype vvunop) be instr_u0.
  b. Return $free_vectype(vectype).
30. If instr_u0 is of the case VVBINOP, then:
  a. Let (VVBINOP vectype vvbinop) be instr_u0.
  b. Return $free_vectype(vectype).
31. If instr_u0 is of the case VVTERNOP, then:
  a. Let (VVTERNOP vectype vvternop) be instr_u0.
  b. Return $free_vectype(vectype).
32. If instr_u0 is of the case VVTESTOP, then:
  a. Let (VVTESTOP vectype vvtestop) be instr_u0.
  b. Return $free_vectype(vectype).
33. If instr_u0 is of the case VUNOP, then:
  a. Let (VUNOP shape vunop) be instr_u0.
  b. Return $free_shape(shape).
34. If instr_u0 is of the case VBINOP, then:
  a. Let (VBINOP shape vbinop) be instr_u0.
  b. Return $free_shape(shape).
35. If instr_u0 is of the case VTESTOP, then:
  a. Let (VTESTOP shape vtestop) be instr_u0.
  b. Return $free_shape(shape).
36. If instr_u0 is of the case VRELOP, then:
  a. Let (VRELOP shape vrelop) be instr_u0.
  b. Return $free_shape(shape).
37. If instr_u0 is of the case VSHIFTOP, then:
  a. Let (VSHIFTOP ishape vshiftop) be instr_u0.
  b. Return $free_shape(ishape).
38. If instr_u0 is of the case VBITMASK, then:
  a. Let (VBITMASK ishape) be instr_u0.
  b. Return $free_shape(ishape).
39. If instr_u0 is of the case VSWIZZLE, then:
  a. Let (VSWIZZLE ishape) be instr_u0.
  b. Return $free_shape(ishape).
40. If instr_u0 is of the case VSHUFFLE, then:
  a. Let (VSHUFFLE ishape laneidx*) be instr_u0.
  b. Return $free_shape(ishape).
41. If instr_u0 is of the case VEXTUNOP, then:
  a. Let (VEXTUNOP ishape_1 ishape_2 vextunop) be instr_u0.
  b. Return $free_shape(ishape_1) ++ $free_shape(ishape_2).
42. If instr_u0 is of the case VEXTBINOP, then:
  a. Let (VEXTBINOP ishape_1 ishape_2 vextbinop) be instr_u0.
  b. Return $free_shape(ishape_1) ++ $free_shape(ishape_2).
43. If instr_u0 is of the case VNARROW, then:
  a. Let (VNARROW ishape_1 ishape_2 sx) be instr_u0.
  b. Return $free_shape(ishape_1) ++ $free_shape(ishape_2).
44. If instr_u0 is of the case VCVTOP, then:
  a. Let (VCVTOP shape_1 shape_2 vcvtop half? zero?) be instr_u0.
  b. Return $free_shape(shape_1) ++ $free_shape(shape_2).
45. If instr_u0 is of the case VSPLAT, then:
  a. Let (VSPLAT shape) be instr_u0.
  b. Return $free_shape(shape).
46. If instr_u0 is of the case VEXTRACT_LANE, then:
  a. Let (VEXTRACT_LANE shape sx? laneidx) be instr_u0.
  b. Return $free_shape(shape).
47. If instr_u0 is of the case VREPLACE_LANE, then:
  a. Let (VREPLACE_LANE shape laneidx) be instr_u0.
  b. Return $free_shape(shape).
48. If instr_u0 is of the case REF.NULL, then:
  a. Let (REF.NULL heaptype) be instr_u0.
  b. Return $free_heaptype(heaptype).
49. If (instr_u0 is REF.IS_NULL), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
50. If (instr_u0 is REF.AS_NON_NULL), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
51. If (instr_u0 is REF.EQ), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
52. If instr_u0 is of the case REF.TEST, then:
  a. Let (REF.TEST reftype) be instr_u0.
  b. Return $free_reftype(reftype).
53. If instr_u0 is of the case REF.CAST, then:
  a. Let (REF.CAST reftype) be instr_u0.
  b. Return $free_reftype(reftype).
54. If instr_u0 is of the case REF.FUNC, then:
  a. Let (REF.FUNC funcidx) be instr_u0.
  b. Return $free_funcidx(funcidx).
55. If (instr_u0 is REF.I31), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
56. If instr_u0 is of the case I31.GET, then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
57. If instr_u0 is of the case STRUCT.NEW, then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
58. If instr_u0 is of the case STRUCT.NEW_DEFAULT, then:
  a. Let (STRUCT.NEW_DEFAULT typeidx) be instr_u0.
  b. Return $free_typeidx(typeidx).
59. If instr_u0 is of the case STRUCT.GET, then:
  a. Let (STRUCT.GET sx? typeidx u32) be instr_u0.
  b. Return $free_typeidx(typeidx).
60. If instr_u0 is of the case STRUCT.SET, then:
  a. Let (STRUCT.SET typeidx u32) be instr_u0.
  b. Return $free_typeidx(typeidx).
61. If instr_u0 is of the case ARRAY.NEW, then:
  a. Let (ARRAY.NEW typeidx) be instr_u0.
  b. Return $free_typeidx(typeidx).
62. If instr_u0 is of the case ARRAY.NEW_DEFAULT, then:
  a. Let (ARRAY.NEW_DEFAULT typeidx) be instr_u0.
  b. Return $free_typeidx(typeidx).
63. If instr_u0 is of the case ARRAY.NEW_FIXED, then:
  a. Let (ARRAY.NEW_FIXED typeidx u32) be instr_u0.
  b. Return $free_typeidx(typeidx).
64. If instr_u0 is of the case ARRAY.NEW_DATA, then:
  a. Let (ARRAY.NEW_DATA typeidx dataidx) be instr_u0.
  b. Return $free_typeidx(typeidx) ++ $free_dataidx(dataidx).
65. If instr_u0 is of the case ARRAY.NEW_ELEM, then:
  a. Let (ARRAY.NEW_ELEM typeidx elemidx) be instr_u0.
  b. Return $free_typeidx(typeidx) ++ $free_elemidx(elemidx).
66. If instr_u0 is of the case ARRAY.GET, then:
  a. Let (ARRAY.GET sx? typeidx) be instr_u0.
  b. Return $free_typeidx(typeidx).
67. If instr_u0 is of the case ARRAY.SET, then:
  a. Let (ARRAY.SET typeidx) be instr_u0.
  b. Return $free_typeidx(typeidx).
68. If (instr_u0 is ARRAY.LEN), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
69. If instr_u0 is of the case ARRAY.FILL, then:
  a. Let (ARRAY.FILL typeidx) be instr_u0.
  b. Return $free_typeidx(typeidx).
70. If instr_u0 is of the case ARRAY.COPY, then:
  a. Let (ARRAY.COPY typeidx_1 typeidx_2) be instr_u0.
  b. Return $free_typeidx(typeidx_1) ++ $free_typeidx(typeidx_2).
71. If instr_u0 is of the case ARRAY.INIT_DATA, then:
  a. Let (ARRAY.INIT_DATA typeidx dataidx) be instr_u0.
  b. Return $free_typeidx(typeidx) ++ $free_dataidx(dataidx).
72. If instr_u0 is of the case ARRAY.INIT_ELEM, then:
  a. Let (ARRAY.INIT_ELEM typeidx elemidx) be instr_u0.
  b. Return $free_typeidx(typeidx) ++ $free_elemidx(elemidx).
73. If (instr_u0 is EXTERN.CONVERT_ANY), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
74. If (instr_u0 is ANY.CONVERT_EXTERN), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
75. If instr_u0 is of the case LOCAL.GET, then:
  a. Let (LOCAL.GET localidx) be instr_u0.
  b. Return $free_localidx(localidx).
76. If instr_u0 is of the case LOCAL.SET, then:
  a. Let (LOCAL.SET localidx) be instr_u0.
  b. Return $free_localidx(localidx).
77. If instr_u0 is of the case LOCAL.TEE, then:
  a. Let (LOCAL.TEE localidx) be instr_u0.
  b. Return $free_localidx(localidx).
78. If instr_u0 is of the case GLOBAL.GET, then:
  a. Let (GLOBAL.GET globalidx) be instr_u0.
  b. Return $free_globalidx(globalidx).
79. If instr_u0 is of the case GLOBAL.SET, then:
  a. Let (GLOBAL.SET globalidx) be instr_u0.
  b. Return $free_globalidx(globalidx).
80. If instr_u0 is of the case TABLE.GET, then:
  a. Let (TABLE.GET tableidx) be instr_u0.
  b. Return $free_tableidx(tableidx).
81. If instr_u0 is of the case TABLE.SET, then:
  a. Let (TABLE.SET tableidx) be instr_u0.
  b. Return $free_tableidx(tableidx).
82. If instr_u0 is of the case TABLE.SIZE, then:
  a. Let (TABLE.SIZE tableidx) be instr_u0.
  b. Return $free_tableidx(tableidx).
83. If instr_u0 is of the case TABLE.GROW, then:
  a. Let (TABLE.GROW tableidx) be instr_u0.
  b. Return $free_tableidx(tableidx).
84. If instr_u0 is of the case TABLE.FILL, then:
  a. Let (TABLE.FILL tableidx) be instr_u0.
  b. Return $free_tableidx(tableidx).
85. If instr_u0 is of the case TABLE.COPY, then:
  a. Let (TABLE.COPY tableidx_1 tableidx_2) be instr_u0.
  b. Return $free_tableidx(tableidx_1) ++ $free_tableidx(tableidx_2).
86. If instr_u0 is of the case TABLE.INIT, then:
  a. Let (TABLE.INIT tableidx elemidx) be instr_u0.
  b. Return $free_tableidx(tableidx) ++ $free_elemidx(elemidx).
87. If instr_u0 is of the case ELEM.DROP, then:
  a. Let (ELEM.DROP elemidx) be instr_u0.
  b. Return $free_elemidx(elemidx).
88. If instr_u0 is of the case LOAD, then:
  a. Let (LOAD numtype loadop__0 memidx memarg) be instr_u0.
  b. If loadop__0 is defined, then:
    1) Return $free_numtype(numtype) ++ $free_memidx(memidx).
89. If instr_u0 is of the case STORE, then:
  a. Let (STORE numtype sz? memidx memarg) be instr_u0.
  b. Return $free_numtype(numtype) ++ $free_memidx(memidx).
90. If instr_u0 is of the case VLOAD, then:
  a. Let (VLOAD vectype vloadop? memidx memarg) be instr_u0.
  b. Return $free_vectype(vectype) ++ $free_memidx(memidx).
91. If instr_u0 is of the case VLOAD_LANE, then:
  a. Let (VLOAD_LANE vectype sz memidx memarg laneidx) be instr_u0.
  b. Return $free_vectype(vectype) ++ $free_memidx(memidx).
92. If instr_u0 is of the case VSTORE, then:
  a. Let (VSTORE vectype memidx memarg) be instr_u0.
  b. Return $free_vectype(vectype) ++ $free_memidx(memidx).
93. If instr_u0 is of the case VSTORE_LANE, then:
  a. Let (VSTORE_LANE vectype sz memidx memarg laneidx) be instr_u0.
  b. Return $free_vectype(vectype) ++ $free_memidx(memidx).
94. If instr_u0 is of the case MEMORY.SIZE, then:
  a. Let (MEMORY.SIZE memidx) be instr_u0.
  b. Return $free_memidx(memidx).
95. If instr_u0 is of the case MEMORY.GROW, then:
  a. Let (MEMORY.GROW memidx) be instr_u0.
  b. Return $free_memidx(memidx).
96. If instr_u0 is of the case MEMORY.FILL, then:
  a. Let (MEMORY.FILL memidx) be instr_u0.
  b. Return $free_memidx(memidx).
97. If instr_u0 is of the case MEMORY.COPY, then:
  a. Let (MEMORY.COPY memidx_1 memidx_2) be instr_u0.
  b. Return $free_memidx(memidx_1) ++ $free_memidx(memidx_2).
98. If instr_u0 is of the case MEMORY.INIT, then:
  a. Let (MEMORY.INIT memidx dataidx) be instr_u0.
  b. Return $free_memidx(memidx) ++ $free_dataidx(dataidx).
99. Assert: Due to validation, instr_u0 is of the case DATA.DROP.
100. Let (DATA.DROP dataidx) be instr_u0.
101. Return $free_dataidx(dataidx).

free_expr instr*
1. Return $free_list($free_instr(instr)*).

free_type (TYPE rectype)
1. Return $free_rectype(rectype).

free_local (LOCAL t)
1. Return $free_valtype(t).

free_func (FUNC typeidx local* expr)
1. Return $free_typeidx(typeidx) ++ $free_list($free_local(local)*) ++ $free_block(expr) with .LOCALS replaced by [].

free_global (GLOBAL globaltype expr)
1. Return $free_globaltype(globaltype) ++ $free_expr(expr).

free_table (TABLE tabletype expr)
1. Return $free_tabletype(tabletype) ++ $free_expr(expr).

free_mem (MEMORY memtype)
1. Return $free_memtype(memtype).

free_tag (TAG typeidx)
1. Return $free_typeidx(typeidx).

free_elemmode elemmode_u0
1. If elemmode_u0 is of the case ACTIVE, then:
  a. Let (ACTIVE tableidx expr) be elemmode_u0.
  b. Return $free_tableidx(tableidx) ++ $free_expr(expr).
2. If (elemmode_u0 is PASSIVE), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
3. Assert: Due to validation, (elemmode_u0 is DECLARE).
4. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_datamode datamode_u0
1. If datamode_u0 is of the case ACTIVE, then:
  a. Let (ACTIVE memidx expr) be datamode_u0.
  b. Return $free_memidx(memidx) ++ $free_expr(expr).
2. Assert: Due to validation, (datamode_u0 is PASSIVE).
3. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_elem (ELEM reftype expr* elemmode)
1. Return $free_reftype(reftype) ++ $free_list($free_expr(expr)*) ++ $free_elemmode(elemmode).

free_data (DATA byte* datamode)
1. Return $free_datamode(datamode).

free_start (START funcidx)
1. Return $free_funcidx(funcidx).

free_export (EXPORT name externidx)
1. Return $free_externidx(externidx).

free_import (IMPORT name_1 name_2 externtype)
1. Return $free_externtype(externtype).

free_module (MODULE type* import* func* global* table* mem* tag* elem* data* start? export*)
1. Return $free_list($free_type(type)*) ++ $free_list($free_import(import)*) ++ $free_list($free_func(func)*) ++ $free_list($free_global(global)*) ++ $free_list($free_table(table)*) ++ $free_list($free_mem(mem)*) ++ $free_list($free_tag(tag)*) ++ $free_list($free_elem(elem)*) ++ $free_list($free_data(data)*) ++ $free_opt($free_start(start)?) ++ $free_list($free_export(export)*).

funcidx_module module
1. Return $free_module(module).FUNCS.

dataidx_funcs func*
1. Return $free_list($free_func(func)*).DATAS.

subst_typevar tv typevar_u0* typeuse_u1*
1. If ((typevar_u0* is []) and (typeuse_u1* is [])), then:
  a. Return tv.
2. Assert: Due to validation, (|typeuse_u1*| ≥ 1).
3. Let [tu_1] :: tu'* be typeuse_u1*.
4. Assert: Due to validation, (|typevar_u0*| ≥ 1).
5. Let [tv_1] :: tv'* be typevar_u0*.
6. If (tv is tv_1), then:
  a. Return tu_1.
7. Return $subst_typevar(tv, tv'*, tu'*).

subst_packtype pt tv* tu*
1. Return pt.

subst_numtype nt tv* tu*
1. Return nt.

subst_vectype vt tv* tu*
1. Return vt.

subst_typeuse typeuse_u0 tv* tu*
1. If the type of typeuse_u0 is typevar, then:
  a. Let tv' be typeuse_u0.
  b. Return $subst_typevar(tv', tv*, tu*).
2. Assert: Due to validation, the type of typeuse_u0 is deftype.
3. Let dt be typeuse_u0.
4. Return $subst_deftype(dt, tv*, tu*).

subst_heaptype heaptype_u0 tv* tu*
1. If the type of heaptype_u0 is typevar, then:
  a. Let tv' be heaptype_u0.
  b. Return $subst_typevar(tv', tv*, tu*).
2. If the type of heaptype_u0 is deftype, then:
  a. Let dt be heaptype_u0.
  b. Return $subst_deftype(dt, tv*, tu*).
3. Let ht be heaptype_u0.
4. Return ht.

subst_reftype (REF nul ht) tv* tu*
1. Return (REF nul $subst_heaptype(ht, tv*, tu*)).

subst_valtype valtype_u0 tv* tu*
1. If the type of valtype_u0 is numtype, then:
  a. Let nt be valtype_u0.
  b. Return $subst_numtype(nt, tv*, tu*).
2. If the type of valtype_u0 is vectype, then:
  a. Let vt be valtype_u0.
  b. Return $subst_vectype(vt, tv*, tu*).
3. If the type of valtype_u0 is reftype, then:
  a. Let rt be valtype_u0.
  b. Return $subst_reftype(rt, tv*, tu*).
4. Assert: Due to validation, (valtype_u0 is BOT).
5. Return BOT.

subst_storagetype storagetype_u0 tv* tu*
1. If the type of storagetype_u0 is valtype, then:
  a. Let t be storagetype_u0.
  b. Return $subst_valtype(t, tv*, tu*).
2. Assert: Due to validation, the type of storagetype_u0 is packtype.
3. Let pt be storagetype_u0.
4. Return $subst_packtype(pt, tv*, tu*).

subst_fieldtype (mut zt) tv* tu*
1. Return (mut $subst_storagetype(zt, tv*, tu*)).

subst_comptype comptype_u0 tv* tu*
1. If comptype_u0 is of the case STRUCT, then:
  a. Let (STRUCT yt*) be comptype_u0.
  b. Return (STRUCT $subst_fieldtype(yt, tv*, tu*)*).
2. If comptype_u0 is of the case ARRAY, then:
  a. Let (ARRAY yt) be comptype_u0.
  b. Return (ARRAY $subst_fieldtype(yt, tv*, tu*)).
3. Assert: Due to validation, comptype_u0 is of the case FUNC.
4. Let (FUNC ft) be comptype_u0.
5. Return (FUNC $subst_functype(ft, tv*, tu*)).

subst_subtype (SUB fin tu'* ct) tv* tu*
1. Return (SUB fin $subst_typeuse(tu', tv*, tu*)* $subst_comptype(ct, tv*, tu*)).

subst_rectype (REC st*) tv* tu*
1. Return (REC $subst_subtype(st, tv*, tu*)*).

subst_deftype (DEF qt i) tv* tu*
1. Return (DEF $subst_rectype(qt, tv*, tu*) i).

subst_functype t_1* -> t_2* tv* tu*
1. Return $subst_valtype(t_1, tv*, tu*)* -> $subst_valtype(t_2, tv*, tu*)*.

subst_globaltype (mut t) tv* tu*
1. Return (mut $subst_valtype(t, tv*, tu*)).

subst_tabletype (lim rt) tv* tu*
1. Return (lim $subst_reftype(rt, tv*, tu*)).

subst_memtype lim PAGE tv* tu*
1. Return lim PAGE.

subst_externtype externtype_u0 tv* tu*
1. If externtype_u0 is of the case FUNC, then:
  a. Let (FUNC dt) be externtype_u0.
  b. Return (FUNC $subst_deftype(dt, tv*, tu*)).
2. If externtype_u0 is of the case GLOBAL, then:
  a. Let (GLOBAL gt) be externtype_u0.
  b. Return (GLOBAL $subst_globaltype(gt, tv*, tu*)).
3. If externtype_u0 is of the case TABLE, then:
  a. Let (TABLE tt) be externtype_u0.
  b. Return (TABLE $subst_tabletype(tt, tv*, tu*)).
4. Assert: Due to validation, externtype_u0 is of the case MEM.
5. Let (MEM mt) be externtype_u0.
6. Return (MEM $subst_memtype(mt, tv*, tu*)).

subst_moduletype xt_1* -> xt_2* tv* tu*
1. Return $subst_externtype(xt_1, tv*, tu*)* -> $subst_externtype(xt_2, tv*, tu*)*.

subst_all_valtype t tu^n
1. Return $subst_valtype(t, (_IDX i)^(i<n), tu^n).

subst_all_reftype rt tu^n
1. Return $subst_reftype(rt, (_IDX i)^(i<n), tu^n).

subst_all_deftype dt tu^n
1. Return $subst_deftype(dt, (_IDX i)^(i<n), tu^n).

subst_all_globaltype gt tu^n
1. Return $subst_globaltype(gt, (_IDX i)^(i<n), tu^n).

subst_all_tabletype tt tu^n
1. Return $subst_tabletype(tt, (_IDX i)^(i<n), tu^n).

subst_all_memtype mt tu^n
1. Return $subst_memtype(mt, (_IDX i)^(i<n), tu^n).

subst_all_moduletype mmt tu^n
1. Return $subst_moduletype(mmt, (_IDX i)^(i<n), tu^n).

subst_all_deftypes deftype_u0* tu*
1. If (deftype_u0* is []), then:
  a. Return [].
2. Let [dt_1] :: dt* be deftype_u0*.
3. Return [$subst_all_deftype(dt_1, tu*)] :: $subst_all_deftypes(dt*, tu*).

rollrt x rectype
1. Assert: Due to validation, rectype is of the case REC.
2. Let (REC subtype^n) be rectype.
3. Return (REC $subst_subtype(subtype, (_IDX (x + i))^(i<n), (REC i)^(i<n))^n).

unrollrt rectype
1. Assert: Due to validation, rectype is of the case REC.
2. Let (REC subtype^n) be rectype.
3. Return (REC $subst_subtype(subtype, (REC i)^(i<n), (DEF rectype i)^(i<n))^n).

rolldt x rectype
1. Assert: Due to validation, $rollrt(x, rectype) is of the case REC.
2. Let (REC subtype^n) be $rollrt(x, rectype).
3. Return (DEF (REC subtype^n) i)^(i<n).

unrolldt (DEF rectype i)
1. Assert: Due to validation, $unrollrt(rectype) is of the case REC.
2. Let (REC subtype*) be $unrollrt(rectype).
3. Return subtype*[i].

expanddt deftype
1. Assert: Due to validation, $unrolldt(deftype) is of the case SUB.
2. Let (SUB fin typeuse* comptype) be $unrolldt(deftype).
3. Return comptype.

funcsxx externidx_u0*
1. If (externidx_u0* is []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be externidx_u0*.
3. If externidx_0 is of the case FUNC, then:
  a. Let (FUNC x) be externidx_0.
  b. Return [x] :: $funcsxx(xx*).
4. Let [externidx] :: xx* be externidx_u0*.
5. Return $funcsxx(xx*).

globalsxx externidx_u0*
1. If (externidx_u0* is []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be externidx_u0*.
3. If externidx_0 is of the case GLOBAL, then:
  a. Let (GLOBAL x) be externidx_0.
  b. Return [x] :: $globalsxx(xx*).
4. Let [externidx] :: xx* be externidx_u0*.
5. Return $globalsxx(xx*).

tablesxx externidx_u0*
1. If (externidx_u0* is []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be externidx_u0*.
3. If externidx_0 is of the case TABLE, then:
  a. Let (TABLE x) be externidx_0.
  b. Return [x] :: $tablesxx(xx*).
4. Let [externidx] :: xx* be externidx_u0*.
5. Return $tablesxx(xx*).

memsxx externidx_u0*
1. If (externidx_u0* is []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be externidx_u0*.
3. If externidx_0 is of the case MEM, then:
  a. Let (MEM x) be externidx_0.
  b. Return [x] :: $memsxx(xx*).
4. Let [externidx] :: xx* be externidx_u0*.
5. Return $memsxx(xx*).

tagsxx externidx_u0*
1. If (externidx_u0* is []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be externidx_u0*.
3. If externidx_0 is of the case TAG, then:
  a. Let (TAG x) be externidx_0.
  b. Return [x] :: $tagsxx(xx*).
4. Let [externidx] :: xx* be externidx_u0*.
5. Return $tagsxx(xx*).

funcsxt externtype_u0*
1. If (externtype_u0* is []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype_u0*.
3. If externtype_0 is of the case FUNC, then:
  a. Let (FUNC dt) be externtype_0.
  b. Return [dt] :: $funcsxt(xt*).
4. Let [externtype] :: xt* be externtype_u0*.
5. Return $funcsxt(xt*).

globalsxt externtype_u0*
1. If (externtype_u0* is []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype_u0*.
3. If externtype_0 is of the case GLOBAL, then:
  a. Let (GLOBAL gt) be externtype_0.
  b. Return [gt] :: $globalsxt(xt*).
4. Let [externtype] :: xt* be externtype_u0*.
5. Return $globalsxt(xt*).

tablesxt externtype_u0*
1. If (externtype_u0* is []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype_u0*.
3. If externtype_0 is of the case TABLE, then:
  a. Let (TABLE tt) be externtype_0.
  b. Return [tt] :: $tablesxt(xt*).
4. Let [externtype] :: xt* be externtype_u0*.
5. Return $tablesxt(xt*).

memsxt externtype_u0*
1. If (externtype_u0* is []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype_u0*.
3. If externtype_0 is of the case MEM, then:
  a. Let (MEM mt) be externtype_0.
  b. Return [mt] :: $memsxt(xt*).
4. Let [externtype] :: xt* be externtype_u0*.
5. Return $memsxt(xt*).

tagsxt externtype_u0*
1. If (externtype_u0* is []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be externtype_u0*.
3. If externtype_0 is of the case TAG, then:
  a. Let (TAG at) be externtype_0.
  b. Return [at] :: $tagsxt(xt*).
4. Let [externtype] :: xt* be externtype_u0*.
5. Return $tagsxt(xt*).

memarg0
1. Return { ALIGN: 0; OFFSET: 0; }.

signed_ N i
1. If (0 ≤ (2 ^ (N - 1))), then:
  a. Return i.
2. Assert: Due to validation, ((2 ^ (N - 1)) ≤ i).
3. Assert: Due to validation, (i < (2 ^ N)).
4. Return (i - (2 ^ N)).

invsigned_ N i
1. Let j be $signed__1^-1(N, i).
2. Return j.

unop_ numtype_u1 unop__u0 num__u3
1. If ((unop__u0 is CLZ) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN be num__u3.
  c. Return [$iclz_($sizenn(Inn), iN)].
2. If ((unop__u0 is CTZ) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN be num__u3.
  c. Return [$ictz_($sizenn(Inn), iN)].
3. If ((unop__u0 is POPCNT) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN be num__u3.
  c. Return [$ipopcnt_($sizenn(Inn), iN)].
4. If the type of numtype_u1 is Inn, then:
  a. Let Inn be numtype_u1.
  b. Assert: Due to validation, unop__u0 is of the case EXTEND.
  c. Let (EXTEND M) be unop__u0.
  d. Let iN be num__u3.
  e. Return [$extend__(M, $sizenn(Inn), S, $wrap__($sizenn(Inn), M, iN))].
5. If ((unop__u0 is ABS) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN be num__u3.
  c. Return $fabs_($sizenn(Fnn), fN).
6. If ((unop__u0 is NEG) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN be num__u3.
  c. Return $fneg_($sizenn(Fnn), fN).
7. If ((unop__u0 is SQRT) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN be num__u3.
  c. Return $fsqrt_($sizenn(Fnn), fN).
8. If ((unop__u0 is CEIL) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN be num__u3.
  c. Return $fceil_($sizenn(Fnn), fN).
9. If ((unop__u0 is FLOOR) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN be num__u3.
  c. Return $ffloor_($sizenn(Fnn), fN).
10. If ((unop__u0 is TRUNC) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN be num__u3.
  c. Return $ftrunc_($sizenn(Fnn), fN).
11. Assert: Due to validation, (unop__u0 is NEAREST).
12. Assert: Due to validation, the type of numtype_u1 is Fnn.
13. Let Fnn be numtype_u1.
14. Let fN be num__u3.
15. Return $fnearest_($sizenn(Fnn), fN).

binop_ numtype_u1 binop__u0 num__u3 num__u5
1. If ((binop__u0 is ADD) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return [$iadd_($sizenn(Inn), iN_1, iN_2)].
2. If ((binop__u0 is SUB) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return [$isub_($sizenn(Inn), iN_1, iN_2)].
3. If ((binop__u0 is MUL) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return [$imul_($sizenn(Inn), iN_1, iN_2)].
4. If the type of numtype_u1 is Inn, then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. If binop__u0 is of the case DIV, then:
    1) Let (DIV sx) be binop__u0.
    2) Return $list_(num_((Inn : Inn <: numtype)), $idiv_($sizenn(Inn), sx, iN_1, iN_2)).
  e. If binop__u0 is of the case REM, then:
    1) Let (REM sx) be binop__u0.
    2) Return $list_(num_((Inn : Inn <: numtype)), $irem_($sizenn(Inn), sx, iN_1, iN_2)).
5. If ((binop__u0 is AND) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return [$iand_($sizenn(Inn), iN_1, iN_2)].
6. If ((binop__u0 is OR) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return [$ior_($sizenn(Inn), iN_1, iN_2)].
7. If ((binop__u0 is XOR) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return [$ixor_($sizenn(Inn), iN_1, iN_2)].
8. If ((binop__u0 is SHL) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return [$ishl_($sizenn(Inn), iN_1, iN_2)].
9. If the type of numtype_u1 is Inn, then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. If binop__u0 is of the case SHR, then:
    1) Let (SHR sx) be binop__u0.
    2) Return [$ishr_($sizenn(Inn), sx, iN_1, iN_2)].
10. If ((binop__u0 is ROTL) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return [$irotl_($sizenn(Inn), iN_1, iN_2)].
11. If ((binop__u0 is ROTR) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return [$irotr_($sizenn(Inn), iN_1, iN_2)].
12. If ((binop__u0 is ADD) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $fadd_($sizenn(Fnn), fN_1, fN_2).
13. If ((binop__u0 is SUB) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $fsub_($sizenn(Fnn), fN_1, fN_2).
14. If ((binop__u0 is MUL) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $fmul_($sizenn(Fnn), fN_1, fN_2).
15. If ((binop__u0 is DIV) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $fdiv_($sizenn(Fnn), fN_1, fN_2).
16. If ((binop__u0 is MIN) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $fmin_($sizenn(Fnn), fN_1, fN_2).
17. If ((binop__u0 is MAX) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $fmax_($sizenn(Fnn), fN_1, fN_2).
18. Assert: Due to validation, (binop__u0 is COPYSIGN).
19. Assert: Due to validation, the type of numtype_u1 is Fnn.
20. Let Fnn be numtype_u1.
21. Let fN_1 be num__u3.
22. Let fN_2 be num__u5.
23. Return $fcopysign_($sizenn(Fnn), fN_1, fN_2).

testop_ Inn EQZ iN
1. Return $ieqz_($sizenn(Inn), iN).

relop_ numtype_u1 relop__u0 num__u3 num__u5
1. If ((relop__u0 is EQ) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return $ieq_($sizenn(Inn), iN_1, iN_2).
2. If ((relop__u0 is NE) and the type of numtype_u1 is Inn), then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. Return $ine_($sizenn(Inn), iN_1, iN_2).
3. If the type of numtype_u1 is Inn, then:
  a. Let Inn be numtype_u1.
  b. Let iN_1 be num__u3.
  c. Let iN_2 be num__u5.
  d. If relop__u0 is of the case LT, then:
    1) Let (LT sx) be relop__u0.
    2) Return $ilt_($sizenn(Inn), sx, iN_1, iN_2).
  e. If relop__u0 is of the case GT, then:
    1) Let (GT sx) be relop__u0.
    2) Return $igt_($sizenn(Inn), sx, iN_1, iN_2).
  f. If relop__u0 is of the case LE, then:
    1) Let (LE sx) be relop__u0.
    2) Return $ile_($sizenn(Inn), sx, iN_1, iN_2).
  g. If relop__u0 is of the case GE, then:
    1) Let (GE sx) be relop__u0.
    2) Return $ige_($sizenn(Inn), sx, iN_1, iN_2).
4. If ((relop__u0 is EQ) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $feq_($sizenn(Fnn), fN_1, fN_2).
5. If ((relop__u0 is NE) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $fne_($sizenn(Fnn), fN_1, fN_2).
6. If ((relop__u0 is LT) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $flt_($sizenn(Fnn), fN_1, fN_2).
7. If ((relop__u0 is GT) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $fgt_($sizenn(Fnn), fN_1, fN_2).
8. If ((relop__u0 is LE) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn be numtype_u1.
  b. Let fN_1 be num__u3.
  c. Let fN_2 be num__u5.
  d. Return $fle_($sizenn(Fnn), fN_1, fN_2).
9. Assert: Due to validation, (relop__u0 is GE).
10. Assert: Due to validation, the type of numtype_u1 is Fnn.
11. Let Fnn be numtype_u1.
12. Let fN_1 be num__u3.
13. Let fN_2 be num__u5.
14. Return $fge_($sizenn(Fnn), fN_1, fN_2).

cvtop__ numtype_u1 numtype_u4 cvtop___u0 num__u3
1. If the type of numtype_u1 is Inn, then:
  a. Let Inn_1 be numtype_u1.
  b. If the type of numtype_u4 is Inn, then:
    1) Let Inn_2 be numtype_u4.
    2) Let iN_1 be num__u3.
    3) If cvtop___u0 is of the case EXTEND, then:
      a) Let (EXTEND sx) be cvtop___u0.
      b) Return [$extend__($sizenn1(Inn_1), $sizenn2(Inn_2), sx, iN_1)].
2. If ((cvtop___u0 is WRAP) and the type of numtype_u1 is Inn), then:
  a. Let Inn_1 be numtype_u1.
  b. If the type of numtype_u4 is Inn, then:
    1) Let Inn_2 be numtype_u4.
    2) Let iN_1 be num__u3.
    3) Return [$wrap__($sizenn1(Inn_1), $sizenn2(Inn_2), iN_1)].
3. If the type of numtype_u1 is Fnn, then:
  a. Let Fnn_1 be numtype_u1.
  b. If the type of numtype_u4 is Inn, then:
    1) Let Inn_2 be numtype_u4.
    2) Let fN_1 be num__u3.
    3) If cvtop___u0 is of the case TRUNC, then:
      a) Let (TRUNC sx) be cvtop___u0.
      b) Return $list_(num_((Inn_2 : Inn <: numtype)), $trunc__($sizenn1(Fnn_1), $sizenn2(Inn_2), sx, fN_1)).
    4) If cvtop___u0 is of the case TRUNC_SAT, then:
      a) Let (TRUNC_SAT sx) be cvtop___u0.
      b) Return $list_(num_((Inn_2 : Inn <: numtype)), $trunc_sat__($sizenn1(Fnn_1), $sizenn2(Inn_2), sx, fN_1)).
4. If the type of numtype_u4 is Fnn, then:
  a. Let Fnn_2 be numtype_u4.
  b. If the type of numtype_u1 is Inn, then:
    1) Let Inn_1 be numtype_u1.
    2) Let iN_1 be num__u3.
    3) If cvtop___u0 is of the case CONVERT, then:
      a) Let (CONVERT sx) be cvtop___u0.
      b) Return [$convert__($sizenn1(Inn_1), $sizenn2(Fnn_2), sx, iN_1)].
5. If ((cvtop___u0 is PROMOTE) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn_1 be numtype_u1.
  b. If the type of numtype_u4 is Fnn, then:
    1) Let Fnn_2 be numtype_u4.
    2) Let fN_1 be num__u3.
    3) Return $promote__($sizenn1(Fnn_1), $sizenn2(Fnn_2), fN_1).
6. If ((cvtop___u0 is DEMOTE) and the type of numtype_u1 is Fnn), then:
  a. Let Fnn_1 be numtype_u1.
  b. If the type of numtype_u4 is Fnn, then:
    1) Let Fnn_2 be numtype_u4.
    2) Let fN_1 be num__u3.
    3) Return $demote__($sizenn1(Fnn_1), $sizenn2(Fnn_2), fN_1).
7. Assert: Due to validation, (cvtop___u0 is REINTERPRET).
8. If the type of numtype_u4 is Fnn, then:
  a. Let Fnn_2 be numtype_u4.
  b. If the type of numtype_u1 is Inn, then:
    1) Let Inn_1 be numtype_u1.
    2) Let iN_1 be num__u3.
    3) If ($size(Inn_1) is $size(Fnn_2)), then:
      a) Return [$reinterpret__(Inn_1, Fnn_2, iN_1)].
9. Assert: Due to validation, the type of numtype_u1 is Fnn.
10. Let Fnn_1 be numtype_u1.
11. Assert: Due to validation, the type of numtype_u4 is Inn.
12. Let Inn_2 be numtype_u4.
13. Let fN_1 be num__u3.
14. Assert: Due to validation, ($size(Fnn_1) is $size(Inn_2)).
15. Return [$reinterpret__(Fnn_1, Inn_2, fN_1)].

invibytes_ N b*
1. Let n be $ibytes__1^-1(N, b*).
2. Return n.

invfbytes_ N b*
1. Let p be $fbytes__1^-1(N, b*).
2. Return p.

lpacknum_ lanetype_u0 c
1. If the type of lanetype_u0 is numtype, then:
  a. Return c.
2. Assert: Due to validation, the type of lanetype_u0 is packtype.
3. Let packtype be lanetype_u0.
4. Return $wrap__($size($lunpack(packtype)), $psize(packtype), c).

lunpacknum_ lanetype_u0 c
1. If the type of lanetype_u0 is numtype, then:
  a. Return c.
2. Assert: Due to validation, the type of lanetype_u0 is packtype.
3. Let packtype be lanetype_u0.
4. Return $extend__($psize(packtype), $size($lunpack(packtype)), U, c).

cpacknum_ storagetype_u0 c
1. If the type of storagetype_u0 is consttype, then:
  a. Return c.
2. Assert: Due to validation, the type of storagetype_u0 is packtype.
3. Let packtype be storagetype_u0.
4. Return $wrap__($size($lunpack(packtype)), $psize(packtype), c).

cunpacknum_ storagetype_u0 c
1. If the type of storagetype_u0 is consttype, then:
  a. Return c.
2. Assert: Due to validation, the type of storagetype_u0 is packtype.
3. Let packtype be storagetype_u0.
4. Return $extend__($psize(packtype), $size($lunpack(packtype)), U, c).

invlanes_ sh c*
1. Let vc be $lanes__1^-1(sh, c*).
2. Return vc.

half__ lanetype_u1 X M_1 lanetype_u2 X M_2 half___u0 i j
1. If ((half___u0 is LOW) and (the type of lanetype_u1 is Jnn and the type of lanetype_u2 is Jnn)), then:
  a. Return i.
2. If ((half___u0 is HIGH) and (the type of lanetype_u1 is Jnn and the type of lanetype_u2 is Jnn)), then:
  a. Return j.
3. Assert: Due to validation, (half___u0 is LOW).
4. Assert: Due to validation, the type of lanetype_u2 is Fnn.
5. Return i.

vvunop_ V128 NOT v128
1. Return [$inot_($vsize(V128), v128)].

vvbinop_ V128 vvbinop_u0 v128_1 v128_2
1. If (vvbinop_u0 is AND), then:
  a. Return [$iand_($vsize(V128), v128_1, v128_2)].
2. If (vvbinop_u0 is ANDNOT), then:
  a. Return [$iandnot_($vsize(V128), v128_1, v128_2)].
3. If (vvbinop_u0 is OR), then:
  a. Return [$ior_($vsize(V128), v128_1, v128_2)].
4. Assert: Due to validation, (vvbinop_u0 is XOR).
5. Return [$ixor_($vsize(V128), v128_1, v128_2)].

vvternop_ V128 BITSELECT v128_1 v128_2 v128_3
1. Return [$ibitselect_($vsize(V128), v128_1, v128_2, v128_3)].

fvunop_ Fnn X M $f_ vN_1
1. Let c_1* be $lanes_(Fnn X M, vN_1).
2. Let c** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $f_($sizenn(Fnn), c_1)*).
3. Return $invlanes_(Fnn X M, c*)*.

ivunop_ Jnn X M $f_ vN_1
1. Let c_1* be $lanes_(Jnn X M, vN_1).
2. Let c* be $f_($lsizenn(Jnn), c_1)*.
3. Return [$invlanes_(Jnn X M, c*)].

vunop_ lanetype_u1 X M vunop__u0 vN_1
1. If ((vunop__u0 is ABS) and the type of lanetype_u1 is Jnn), then:
  a. Let Jnn be lanetype_u1.
  b. Return $ivunop_(Jnn X M, $iabs_, vN_1).
2. If ((vunop__u0 is NEG) and the type of lanetype_u1 is Jnn), then:
  a. Let Jnn be lanetype_u1.
  b. Return $ivunop_(Jnn X M, $ineg_, vN_1).
3. If ((vunop__u0 is POPCNT) and the type of lanetype_u1 is Jnn), then:
  a. Let Jnn be lanetype_u1.
  b. Return $ivunop_(Jnn X M, $ipopcnt_, vN_1).
4. If ((vunop__u0 is ABS) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Return $fvunop_(Fnn X M, $fabs_, vN_1).
5. If ((vunop__u0 is NEG) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Return $fvunop_(Fnn X M, $fneg_, vN_1).
6. If ((vunop__u0 is SQRT) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Return $fvunop_(Fnn X M, $fsqrt_, vN_1).
7. If ((vunop__u0 is CEIL) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Return $fvunop_(Fnn X M, $fceil_, vN_1).
8. If ((vunop__u0 is FLOOR) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Return $fvunop_(Fnn X M, $ffloor_, vN_1).
9. If ((vunop__u0 is TRUNC) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Return $fvunop_(Fnn X M, $ftrunc_, vN_1).
10. Assert: Due to validation, (vunop__u0 is NEAREST).
11. Assert: Due to validation, the type of lanetype_u1 is Fnn.
12. Let Fnn be lanetype_u1.
13. Return $fvunop_(Fnn X M, $fnearest_, vN_1).

fvbinop_ Fnn X M $f_ vN_1 vN_2
1. Let c_1* be $lanes_(Fnn X M, vN_1).
2. Let c_2* be $lanes_(Fnn X M, vN_2).
3. Let c** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $f_($sizenn(Fnn), c_1, c_2)*).
4. Return $invlanes_(Fnn X M, c*)*.

ivbinop_ Jnn X M $f_ vN_1 vN_2
1. Let c_1* be $lanes_(Jnn X M, vN_1).
2. Let c_2* be $lanes_(Jnn X M, vN_2).
3. Let c* be $f_($lsizenn(Jnn), c_1, c_2)*.
4. Return [$invlanes_(Jnn X M, c*)].

ivbinopsx_ Jnn X M $f_ sx vN_1 vN_2
1. Let c_1* be $lanes_(Jnn X M, vN_1).
2. Let c_2* be $lanes_(Jnn X M, vN_2).
3. Let c* be $f_($lsizenn(Jnn), sx, c_1, c_2)*.
4. Return [$invlanes_(Jnn X M, c*)].

vbinop_ lanetype_u1 X M vbinop__u0 vN_1 vN_2
1. If ((vbinop__u0 is ADD) and the type of lanetype_u1 is Jnn), then:
  a. Let Jnn be lanetype_u1.
  b. Return $ivbinop_(Jnn X M, $iadd_, vN_1, vN_2).
2. If ((vbinop__u0 is SUB) and the type of lanetype_u1 is Jnn), then:
  a. Let Jnn be lanetype_u1.
  b. Return $ivbinop_(Jnn X M, $isub_, vN_1, vN_2).
3. If ((vbinop__u0 is MUL) and the type of lanetype_u1 is Jnn), then:
  a. Let Jnn be lanetype_u1.
  b. Return $ivbinop_(Jnn X M, $imul_, vN_1, vN_2).
4. If the type of lanetype_u1 is Jnn, then:
  a. Let Jnn be lanetype_u1.
  b. If vbinop__u0 is of the case ADD_SAT, then:
    1) Let (ADD_SAT sx) be vbinop__u0.
    2) Return $ivbinopsx_(Jnn X M, $iadd_sat_, sx, vN_1, vN_2).
  c. If vbinop__u0 is of the case SUB_SAT, then:
    1) Let (SUB_SAT sx) be vbinop__u0.
    2) Return $ivbinopsx_(Jnn X M, $isub_sat_, sx, vN_1, vN_2).
  d. If vbinop__u0 is of the case MIN, then:
    1) Let (MIN sx) be vbinop__u0.
    2) Return $ivbinopsx_(Jnn X M, $imin_, sx, vN_1, vN_2).
  e. If vbinop__u0 is of the case MAX, then:
    1) Let (MAX sx) be vbinop__u0.
    2) Return $ivbinopsx_(Jnn X M, $imax_, sx, vN_1, vN_2).
5. If ((vbinop__u0 is AVGRU) and the type of lanetype_u1 is Jnn), then:
  a. Let Jnn be lanetype_u1.
  b. Return $ivbinopsx_(Jnn X M, $iavgr_, U, vN_1, vN_2).
6. If ((vbinop__u0 is Q15MULR_SATS) and the type of lanetype_u1 is Jnn), then:
  a. Let Jnn be lanetype_u1.
  b. Return $ivbinopsx_(Jnn X M, $iq15mulr_sat_, S, vN_1, vN_2).
7. If ((vbinop__u0 is ADD) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Return $fvbinop_(Fnn X M, $fadd_, vN_1, vN_2).
8. If ((vbinop__u0 is SUB) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Return $fvbinop_(Fnn X M, $fsub_, vN_1, vN_2).
9. If ((vbinop__u0 is MUL) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Return $fvbinop_(Fnn X M, $fmul_, vN_1, vN_2).
10. If ((vbinop__u0 is DIV) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Return $fvbinop_(Fnn X M, $fdiv_, vN_1, vN_2).
11. If ((vbinop__u0 is MIN) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Return $fvbinop_(Fnn X M, $fmin_, vN_1, vN_2).
12. If ((vbinop__u0 is MAX) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Return $fvbinop_(Fnn X M, $fmax_, vN_1, vN_2).
13. If ((vbinop__u0 is PMIN) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Return $fvbinop_(Fnn X M, $fpmin_, vN_1, vN_2).
14. Assert: Due to validation, (vbinop__u0 is PMAX).
15. Assert: Due to validation, the type of lanetype_u1 is Fnn.
16. Let Fnn be lanetype_u1.
17. Return $fvbinop_(Fnn X M, $fpmax_, vN_1, vN_2).

fvrelop_ Fnn X M $f_ vN_1 vN_2
1. Let c_1* be $lanes_(Fnn X M, vN_1).
2. Let c_2* be $lanes_(Fnn X M, vN_2).
3. Assert: Due to validation, the type of $size^-1($size(Fnn)) is Inn.
4. Let Inn be $size^-1($size(Fnn)).
5. Let c* be $extend__(1, $sizenn(Fnn), S, $f_($sizenn(Fnn), c_1, c_2))*.
6. Return $invlanes_(Inn X M, c*).

ivrelop_ Jnn X M $f_ vN_1 vN_2
1. Let c_1* be $lanes_(Jnn X M, vN_1).
2. Let c_2* be $lanes_(Jnn X M, vN_2).
3. Let c* be $extend__(1, $lsizenn(Jnn), S, $f_($lsizenn(Jnn), c_1, c_2))*.
4. Return $invlanes_(Jnn X M, c*).

ivrelopsx_ Jnn X M $f_ sx vN_1 vN_2
1. Let c_1* be $lanes_(Jnn X M, vN_1).
2. Let c_2* be $lanes_(Jnn X M, vN_2).
3. Let c* be $extend__(1, $lsizenn(Jnn), S, $f_($lsizenn(Jnn), sx, c_1, c_2))*.
4. Return $invlanes_(Jnn X M, c*).

vrelop_ lanetype_u1 X M vrelop__u0 vN_1 vN_2
1. If ((vrelop__u0 is EQ) and the type of lanetype_u1 is Jnn), then:
  a. Let Jnn be lanetype_u1.
  b. Return $ivrelop_(Jnn X M, $ieq_, vN_1, vN_2).
2. If ((vrelop__u0 is NE) and the type of lanetype_u1 is Jnn), then:
  a. Let Jnn be lanetype_u1.
  b. Return $ivrelop_(Jnn X M, $ine_, vN_1, vN_2).
3. If the type of lanetype_u1 is Jnn, then:
  a. Let Jnn be lanetype_u1.
  b. If vrelop__u0 is of the case LT, then:
    1) Let (LT sx) be vrelop__u0.
    2) Return $ivrelopsx_(Jnn X M, $ilt_, sx, vN_1, vN_2).
  c. If vrelop__u0 is of the case GT, then:
    1) Let (GT sx) be vrelop__u0.
    2) Return $ivrelopsx_(Jnn X M, $igt_, sx, vN_1, vN_2).
  d. If vrelop__u0 is of the case LE, then:
    1) Let (LE sx) be vrelop__u0.
    2) Return $ivrelopsx_(Jnn X M, $ile_, sx, vN_1, vN_2).
  e. If vrelop__u0 is of the case GE, then:
    1) Let (GE sx) be vrelop__u0.
    2) Return $ivrelopsx_(Jnn X M, $ige_, sx, vN_1, vN_2).
4. If ((vrelop__u0 is EQ) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Return $fvrelop_(Fnn X M, $feq_, vN_1, vN_2).
5. If ((vrelop__u0 is NE) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Return $fvrelop_(Fnn X M, $fne_, vN_1, vN_2).
6. If ((vrelop__u0 is LT) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Return $fvrelop_(Fnn X M, $flt_, vN_1, vN_2).
7. If ((vrelop__u0 is GT) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Return $fvrelop_(Fnn X M, $fgt_, vN_1, vN_2).
8. If ((vrelop__u0 is LE) and the type of lanetype_u1 is Fnn), then:
  a. Let Fnn be lanetype_u1.
  b. Return $fvrelop_(Fnn X M, $fle_, vN_1, vN_2).
9. Assert: Due to validation, (vrelop__u0 is GE).
10. Assert: Due to validation, the type of lanetype_u1 is Fnn.
11. Let Fnn be lanetype_u1.
12. Return $fvrelop_(Fnn X M, $fge_, vN_1, vN_2).

vcvtop__ lanetype_u3 X M_1 lanetype_u0 X M_2 vcvtop___u2 lane__u5
1. If the type of lanetype_u3 is Jnn, then:
  a. Let Jnn_1 be lanetype_u3.
  b. If the type of lanetype_u0 is Jnn, then:
    1) Let Jnn_2 be lanetype_u0.
    2) Let iN_1 be lane__u5.
    3) If vcvtop___u2 is of the case EXTEND, then:
      a) Let (EXTEND sx) be vcvtop___u2.
      b) Let iN_2 be $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), sx, iN_1).
      c) Return [iN_2].
2. If the type of lanetype_u0 is Fnn, then:
  a. Let Fnn_2 be lanetype_u0.
  b. If the type of lanetype_u3 is Jnn, then:
    1) Let Jnn_1 be lanetype_u3.
    2) Let iN_1 be lane__u5.
    3) If vcvtop___u2 is of the case CONVERT, then:
      a) Let (CONVERT sx) be vcvtop___u2.
      b) Let fN_2 be $convert__($lsizenn1(Jnn_1), $lsizenn2(Fnn_2), sx, iN_1).
      c) Return [fN_2].
3. If the type of lanetype_u3 is Fnn, then:
  a. Let Fnn_1 be lanetype_u3.
  b. If the type of lanetype_u0 is Inn, then:
    1) Let Inn_2 be lanetype_u0.
    2) Let fN_1 be lane__u5.
    3) If vcvtop___u2 is of the case TRUNC_SAT, then:
      a) Let (TRUNC_SAT sx) be vcvtop___u2.
      b) Let iN_2? be $trunc_sat__($lsizenn1(Fnn_1), $lsizenn2(Inn_2), sx, fN_1).
      c) Return $list_(lane_((Inn_2 : Inn <: lanetype)), iN_2?).
4. If ((vcvtop___u2 is DEMOTE) and the type of lanetype_u3 is Fnn), then:
  a. Let Fnn_1 be lanetype_u3.
  b. If the type of lanetype_u0 is Fnn, then:
    1) Let Fnn_2 be lanetype_u0.
    2) Let fN_1 be lane__u5.
    3) Let fN_2* be $demote__($lsizenn1(Fnn_1), $lsizenn2(Fnn_2), fN_1).
    4) Return fN_2*.
5. Assert: Due to validation, (vcvtop___u2 is PROMOTE).
6. Assert: Due to validation, the type of lanetype_u3 is Fnn.
7. Let Fnn_1 be lanetype_u3.
8. Assert: Due to validation, the type of lanetype_u0 is Fnn.
9. Let Fnn_2 be lanetype_u0.
10. Let fN_1 be lane__u5.
11. Let fN_2* be $promote__($lsizenn1(Fnn_1), $lsizenn2(Fnn_2), fN_1).
12. Return fN_2*.

vextunop__ Jnn_1 X M_1 Jnn_2 X M_2 (EXTADD_PAIRWISE sx) c_1
1. Let ci* be $lanes_(Jnn_1 X M_1, c_1).
2. Let [cj_1, cj_2]* be $concat__1^-1(iN($lsizenn2((Jnn_2 : Jnn <: lanetype))), $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), sx, ci)*).
3. Let c be $invlanes_(Jnn_2 X M_2, $iadd_($lsizenn2(Jnn_2), cj_1, cj_2)*).
4. Return c.

vextbinop__ Jnn_1 X M_1 Jnn_2 X M_2 vextbinop___u0 c_1 c_2
1. If vextbinop___u0 is of the case EXTMUL, then:
  a. Let (EXTMUL sx half) be vextbinop___u0.
  b. Let ci_1* be $lanes_(Jnn_1 X M_1, c_1)[$half__(Jnn_1 X M_1, Jnn_2 X M_2, half, 0, M_2) : M_2].
  c. Let ci_2* be $lanes_(Jnn_1 X M_1, c_2)[$half__(Jnn_1 X M_1, Jnn_2 X M_2, half, 0, M_2) : M_2].
  d. Let c be $invlanes_(Jnn_2 X M_2, $imul_($lsizenn2(Jnn_2), $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), sx, ci_1), $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), sx, ci_2))*).
  e. Return c.
2. Assert: Due to validation, (vextbinop___u0 is DOTS).
3. Let ci_1* be $lanes_(Jnn_1 X M_1, c_1).
4. Let ci_2* be $lanes_(Jnn_1 X M_1, c_2).
5. Let [cj_1, cj_2]* be $concat__1^-1(iN($lsizenn2((Jnn_2 : Jnn <: lanetype))), $imul_($lsizenn2(Jnn_2), $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), S, ci_1), $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), S, ci_2))*).
6. Let c be $invlanes_(Jnn_2 X M_2, $iadd_($lsizenn2(Jnn_2), cj_1, cj_2)*).
7. Return c.

vshiftop_ Jnn X M vshiftop__u0 lane n
1. If (vshiftop__u0 is SHL), then:
  a. Return $ishl_($lsizenn(Jnn), lane, n).
2. Assert: Due to validation, vshiftop__u0 is of the case SHR.
3. Let (SHR sx) be vshiftop__u0.
4. Return $ishr_($lsizenn(Jnn), sx, lane, n).

inst_valtype moduleinst t
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_valtype(t, dt*).

inst_reftype moduleinst rt
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_reftype(rt, dt*).

inst_globaltype moduleinst gt
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_globaltype(gt, dt*).

inst_tabletype moduleinst tt
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_tabletype(tt, dt*).

inst_memtype moduleinst mt
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_memtype(mt, dt*).

default_ valtype_u0
1. If the type of valtype_u0 is Inn, then:
  a. Let Inn be valtype_u0.
  b. Return ?((Inn.CONST 0)).
2. If the type of valtype_u0 is Fnn, then:
  a. Let Fnn be valtype_u0.
  b. Return ?((Fnn.CONST $fzero($size(Fnn)))).
3. If the type of valtype_u0 is Vnn, then:
  a. Let Vnn be valtype_u0.
  b. Return ?((Vnn.CONST 0)).
4. Assert: Due to validation, valtype_u0 is of the case REF.
5. Let (REF nul_0 ht) be valtype_u0.
6. If (nul_0 is (NULL ?(()) ?)), then:
  a. Return ?((REF.NULL ht)).
7. Assert: Due to validation, (nul_0 is (NULL ?() ?)).
8. Return ?().

packfield_ storagetype_u0 val_u1
1. Let val be val_u1.
2. If the type of storagetype_u0 is valtype, then:
  a. Return val.
3. Assert: Due to validation, val_u1 is of the case CONST.
4. Let (numtype_0.CONST i) be val_u1.
5. Assert: Due to validation, (numtype_0 is I32).
6. Assert: Due to validation, the type of storagetype_u0 is packtype.
7. Let packtype be storagetype_u0.
8. Return (PACK packtype $wrap__(32, $psize(packtype), i)).

unpackfield_ storagetype_u0 sx_u1? fieldval_u2
1. If sx_u1? is not defined, then:
  a. Assert: Due to validation, the type of fieldval_u2 is val.
  b. Let val be fieldval_u2.
  c. Assert: Due to validation, the type of storagetype_u0 is valtype.
  d. Return val.
2. Else:
  a. Let ?(sx) be sx_u1?.
  b. Assert: Due to validation, fieldval_u2 is of the case PACK.
  c. Let (PACK packtype i) be fieldval_u2.
  d. Assert: Due to validation, (storagetype_u0 is packtype).
  e. Return (I32.CONST $extend__($psize(packtype), 32, sx, i)).

funcsxa externaddr_u0*
1. If (externaddr_u0* is []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be externaddr_u0*.
3. If externaddr_0 is of the case FUNC, then:
  a. Let (FUNC fa) be externaddr_0.
  b. Return [fa] :: $funcsxa(xa*).
4. Let [externaddr] :: xa* be externaddr_u0*.
5. Return $funcsxa(xa*).

globalsxa externaddr_u0*
1. If (externaddr_u0* is []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be externaddr_u0*.
3. If externaddr_0 is of the case GLOBAL, then:
  a. Let (GLOBAL ga) be externaddr_0.
  b. Return [ga] :: $globalsxa(xa*).
4. Let [externaddr] :: xa* be externaddr_u0*.
5. Return $globalsxa(xa*).

tablesxa externaddr_u0*
1. If (externaddr_u0* is []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be externaddr_u0*.
3. If externaddr_0 is of the case TABLE, then:
  a. Let (TABLE ta) be externaddr_0.
  b. Return [ta] :: $tablesxa(xa*).
4. Let [externaddr] :: xa* be externaddr_u0*.
5. Return $tablesxa(xa*).

memsxa externaddr_u0*
1. If (externaddr_u0* is []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be externaddr_u0*.
3. If externaddr_0 is of the case MEM, then:
  a. Let (MEM ma) be externaddr_0.
  b. Return [ma] :: $memsxa(xa*).
4. Let [externaddr] :: xa* be externaddr_u0*.
5. Return $memsxa(xa*).

tagsxa externaddr_u0*
1. If (externaddr_u0* is []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be externaddr_u0*.
3. If externaddr_0 is of the case TAG, then:
  a. Let (TAG ha) be externaddr_0.
  b. Return [ha] :: $tagsxa(xa*).
4. Let [externaddr] :: xa* be externaddr_u0*.
5. Return $tagsxa(xa*).

store
1. Return.

frame
1. Let f be the current frame.
2. Return f.

tagaddr
1. Let f be the current frame.
2. Return f.MODULE.TAGS.

moduleinst
1. Let f be the current frame.
2. Return f.MODULE.

funcinst
1. Return s.FUNCS.

globalinst
1. Return s.GLOBALS.

tableinst
1. Return s.TABLES.

meminst
1. Return s.MEMS.

taginst
1. Return s.TAGS.

eleminst
1. Return s.ELEMS.

datainst
1. Return s.DATAS.

structinst
1. Return s.STRUCTS.

arrayinst
1. Return s.ARRAYS.

exninst
1. Return s.EXNS.

type x
1. Let f be the current frame.
2. Return f.MODULE.TYPES[x].

func x
1. Let f be the current frame.
2. Return s.FUNCS[f.MODULE.FUNCS[x]].

global x
1. Let f be the current frame.
2. Return s.GLOBALS[f.MODULE.GLOBALS[x]].

table x
1. Let f be the current frame.
2. Return s.TABLES[f.MODULE.TABLES[x]].

mem x
1. Let f be the current frame.
2. Return s.MEMS[f.MODULE.MEMS[x]].

tag x
1. Let f be the current frame.
2. Return s.TAGS[f.MODULE.TAGS[x]].

elem x
1. Let f be the current frame.
2. Return s.ELEMS[f.MODULE.ELEMS[x]].

data x
1. Let f be the current frame.
2. Return s.DATAS[f.MODULE.DATAS[x]].

local x
1. Let f be the current frame.
2. Return f.LOCALS[x].

with_local x v
1. Let f be the current frame.
2. Replace f.LOCALS[x] with ?(v).

with_global x v
1. Let f be the current frame.
2. Replace s.GLOBALS[f.MODULE.GLOBALS[x]].VALUE with v.

with_table x i r
1. Let f be the current frame.
2. Replace s.TABLES[f.MODULE.TABLES[x]].REFS[i] with r.

with_tableinst x ti
1. Let f be the current frame.
2. Replace s.TABLES[f.MODULE.TABLES[x]] with ti.

with_mem x i j b*
1. Let f be the current frame.
2. Replace s.MEMS[f.MODULE.MEMS[x]].BYTES[i : j] with b*.

with_meminst x mi
1. Let f be the current frame.
2. Replace s.MEMS[f.MODULE.MEMS[x]] with mi.

with_elem x r*
1. Let f be the current frame.
2. Replace s.ELEMS[f.MODULE.ELEMS[x]].REFS with r*.

with_data x b*
1. Let f be the current frame.
2. Replace s.DATAS[f.MODULE.DATAS[x]].BYTES with b*.

with_struct a i fv
1. Replace s.STRUCTS[a].FIELDS[i] with fv.

with_array a i fv
1. Replace s.ARRAYS[a].FIELDS[i] with fv.

add_structinst si*
1. Append si* to the s.STRUCTS.

add_arrayinst ai*
1. Append ai* to the s.ARRAYS.

add_exninst exn*
1. Append exn* to the s.EXNS.

growtable tableinst n r
1. Let { TYPE: ((i, j) rt); REFS: r'*; } be tableinst.
2. If ((|r'*| + n) ≤ j), then:
  a. Let i' be (|r'*| + n).
  b. Let tableinst' be { TYPE: ((i', j) rt); REFS: r'* :: r^n; }.
  c. Return tableinst'.

growmem meminst n
1. Let { TYPE: (i, j) PAGE; BYTES: b*; } be meminst.
2. If (((|b*| / (64 · $Ki())) + n) ≤ j), then:
  a. Let i' be ((|b*| / (64 · $Ki())) + n).
  b. Let meminst' be { TYPE: (i', j) PAGE; BYTES: b* :: 0^(n · (64 · $Ki())); }.
  c. Return meminst'.

blocktype_ z blocktype_u0
1. If blocktype_u0 is of the case _IDX, then:
  a. Let (_IDX x) be blocktype_u0.
  b. Assert: Due to validation, $expanddt($type(z, x)) is of the case FUNC.
  c. Let (FUNC ft) be $expanddt($type(z, x)).
  d. Return ft.
2. Assert: Due to validation, blocktype_u0 is of the case _RESULT.
3. Let (_RESULT t?) be blocktype_u0.
4. Return [] -> t?.

alloctypes type_u0*
1. If (type_u0* is []), then:
  a. Return [].
2. Let type'* :: [type] be type_u0*.
3. Assert: Due to validation, type is of the case TYPE.
4. Let (TYPE rectype) be type.
5. Let deftype'* be $alloctypes(type'*).
6. Let x be |deftype'*|.
7. Let deftype* be $subst_all_deftypes($rolldt(x, rectype), deftype'*).
8. Return deftype'* :: deftype*.

allocfunc deftype funccode moduleinst
1. Let funcinst be { TYPE: deftype; MODULE: moduleinst; CODE: funccode; }.
2. Let a be |s.FUNCS|.
3. Append funcinst to the s.FUNCS.
4. Return a.

allocfuncs deftype_u0* funccode_u1* moduleinst_u2*
1. If (deftype_u0* is []), then:
  a. Assert: Due to validation, (funccode_u1* is []).
  b. Assert: Due to validation, (moduleinst_u2* is []).
  c. Return [].
2. Else:
  a. Let [dt] :: dt'* be deftype_u0*.
  b. Assert: Due to validation, (|funccode_u1*| ≥ 1).
  c. Let [funccode] :: funccode'* be funccode_u1*.
  d. Assert: Due to validation, (|moduleinst_u2*| ≥ 1).
  e. Let [moduleinst] :: moduleinst'* be moduleinst_u2*.
  f. Let fa be $allocfunc(dt, funccode, moduleinst).
  g. Let fa'* be $allocfuncs(dt'*, funccode'*, moduleinst'*).
  h. Return [fa] :: fa'*.

allocglobal globaltype val
1. Let globalinst be { TYPE: globaltype; VALUE: val; }.
2. Let a be |s.GLOBALS|.
3. Append globalinst to the s.GLOBALS.
4. Return a.

allocglobals globaltype_u0* val_u1*
1. If (globaltype_u0* is []), then:
  a. Assert: Due to validation, (val_u1* is []).
  b. Return [].
2. Else:
  a. Let [globaltype] :: globaltype'* be globaltype_u0*.
  b. Assert: Due to validation, (|val_u1*| ≥ 1).
  c. Let [val] :: val'* be val_u1*.
  d. Let ga be $allocglobal(globaltype, val).
  e. Let ga'* be $allocglobals(globaltype'*, val'*).
  f. Return [ga] :: ga'*.

alloctable ((i, j) rt) ref
1. Let tableinst be { TYPE: ((i, j) rt); REFS: ref^i; }.
2. Let a be |s.TABLES|.
3. Append tableinst to the s.TABLES.
4. Return a.

alloctables tabletype_u0* ref_u1*
1. If ((tabletype_u0* is []) and (ref_u1* is [])), then:
  a. Return [].
2. Assert: Due to validation, (|ref_u1*| ≥ 1).
3. Let [ref] :: ref'* be ref_u1*.
4. Assert: Due to validation, (|tabletype_u0*| ≥ 1).
5. Let [tabletype] :: tabletype'* be tabletype_u0*.
6. Let ta be $alloctable(tabletype, ref).
7. Let ta'* be $alloctables(tabletype'*, ref'*).
8. Return [ta] :: ta'*.

allocmem (i, j) PAGE
1. Let meminst be { TYPE: (i, j) PAGE; BYTES: 0^(i · (64 · $Ki())); }.
2. Let a be |s.MEMS|.
3. Append meminst to the s.MEMS.
4. Return a.

allocmems memtype_u0*
1. If (memtype_u0* is []), then:
  a. Return [].
2. Let [memtype] :: memtype'* be memtype_u0*.
3. Let ma be $allocmem(memtype).
4. Let ma'* be $allocmems(memtype'*).
5. Return [ma] :: ma'*.

alloctag tagtype
1. Let taginst be { TYPE: tagtype; }.
2. Let a be |s.TAGS|.
3. Append taginst to the s.TAGS.
4. Return a.

alloctags tagtype_u0*
1. If (tagtype_u0* is []), then:
  a. Return [].
2. Let [at] :: at'* be tagtype_u0*.
3. Let aa be $alloctag(at).
4. Let aa'* be $alloctags(at'*).
5. Return [aa] :: aa'*.

allocelem elemtype ref*
1. Let eleminst be { TYPE: elemtype; REFS: ref*; }.
2. Let a be |s.ELEMS|.
3. Append eleminst to the s.ELEMS.
4. Return a.

allocelems elemtype_u0* ref_u1*
1. If ((elemtype_u0* is []) and (ref_u1* is [])), then:
  a. Return [].
2. Assert: Due to validation, (|ref_u1*| ≥ 1).
3. Let [ref*] :: ref'** be ref_u1*.
4. Assert: Due to validation, (|elemtype_u0*| ≥ 1).
5. Let [rt] :: rt'* be elemtype_u0*.
6. Let ea be $allocelem(rt, ref*).
7. Let ea'* be $allocelems(rt'*, ref'**).
8. Return [ea] :: ea'*.

allocdata OK byte*
1. Let datainst be { BYTES: byte*; }.
2. Let a be |s.DATAS|.
3. Append datainst to the s.DATAS.
4. Return a.

allocdatas datatype_u0* byte_u1*
1. If ((datatype_u0* is []) and (byte_u1* is [])), then:
  a. Return [].
2. Assert: Due to validation, (|byte_u1*| ≥ 1).
3. Let [b*] :: b'** be byte_u1*.
4. Assert: Due to validation, (|datatype_u0*| ≥ 1).
5. Let [ok] :: ok'* be datatype_u0*.
6. Let da be $allocdata(ok, b*).
7. Let da'* be $allocdatas(ok'*, b'**).
8. Return [da] :: da'*.

allocexport moduleinst (EXPORT name externidx_u0)
1. If externidx_u0 is of the case FUNC, then:
  a. Let (FUNC x) be externidx_u0.
  b. Return { NAME: name; ADDR: (FUNC moduleinst.FUNCS[x]); }.
2. If externidx_u0 is of the case GLOBAL, then:
  a. Let (GLOBAL x) be externidx_u0.
  b. Return { NAME: name; ADDR: (GLOBAL moduleinst.GLOBALS[x]); }.
3. If externidx_u0 is of the case TABLE, then:
  a. Let (TABLE x) be externidx_u0.
  b. Return { NAME: name; ADDR: (TABLE moduleinst.TABLES[x]); }.
4. If externidx_u0 is of the case MEM, then:
  a. Let (MEM x) be externidx_u0.
  b. Return { NAME: name; ADDR: (MEM moduleinst.MEMS[x]); }.
5. Assert: Due to validation, externidx_u0 is of the case TAG.
6. Let (TAG x) be externidx_u0.
7. Return { NAME: name; ADDR: (TAG moduleinst.TAGS[x]); }.

allocexports moduleinst export*
1. Return $allocexport(moduleinst, export)*.

allocmodule module externaddr* val_G* ref_T* ref_E**
1. Let fa_I* be $funcsxa(externaddr*).
2. Let ga_I* be $globalsxa(externaddr*).
3. Let aa_I* be $tagsxa(externaddr*).
4. Let ma_I* be $memsxa(externaddr*).
5. Let ta_I* be $tablesxa(externaddr*).
6. Assert: Due to validation, module is of the case MODULE.
7. Let (MODULE type* import* func* global* table* mem* tag* elem* data* start? export*) be module.
8. Let fa* be (|s.FUNCS| + i_F)^(i_F<|func*|).
9. Let ga* be (|s.GLOBALS| + i_G)^(i_G<|global*|).
10. Let ta* be (|s.TABLES| + i_T)^(i_T<|table*|).
11. Let aa* be (|s.TAGS| + i_A)^(i_A<|tag*|).
12. Let ma* be (|s.MEMS| + i_M)^(i_M<|mem*|).
13. Let ea* be (|s.ELEMS| + i_E)^(i_E<|elem*|).
14. Let da* be (|s.DATAS| + i_D)^(i_D<|data*|).
15. Assert: Due to validation, mem is of the case MEMORY*.
16. Let (MEMORY memtype)* be mem*.
17. Let dt* be $alloctypes(type*).
18. Assert: Due to validation, tag is of the case TAG*.
19. Let (TAG y)* be tag*.
20. Assert: Due to validation, data is of the case DATA*.
21. Let (DATA byte* datamode)* be data*.
22. Assert: Due to validation, global is of the case GLOBAL*.
23. Let (GLOBAL globaltype expr_G)* be global*.
24. Assert: Due to validation, table is of the case TABLE*.
25. Let (TABLE tabletype expr_T)* be table*.
26. Assert: Due to validation, elem is of the case ELEM*.
27. Let (ELEM elemtype expr_E* elemmode)* be elem*.
28. Assert: Due to validation, func is of the case FUNC*.
29. Let (FUNC x local* expr_F)* be func*.
30. Let xi* be $allocexports({ TYPES: []; FUNCS: fa_I* :: fa*; GLOBALS: ga_I* :: ga*; TABLES: ta_I* :: ta*; MEMS: ma_I* :: ma*; TAGS: aa_I* :: aa*; ELEMS: []; DATAS: []; EXPORTS: []; }, export*).
31. Let moduleinst be { TYPES: dt*; FUNCS: fa_I* :: fa*; GLOBALS: ga_I* :: ga*; TABLES: ta_I* :: ta*; MEMS: ma_I* :: ma*; TAGS: aa_I* :: aa*; ELEMS: ea*; DATAS: da*; EXPORTS: xi*; }.
32. Let n_0 be $allocfuncs(dt*[x]*, (FUNC x local* expr_F)*, moduleinst^|func*|).
33. Assert: Due to validation, (n_0 is fa*).
34. Let n_0 be $allocglobals($subst_all_globaltype(globaltype, dt*)*, val_G*).
35. Assert: Due to validation, (n_0 is ga*).
36. Let n_0 be $alloctables($subst_all_tabletype(tabletype, dt*)*, ref_T*).
37. Assert: Due to validation, (n_0 is ta*).
38. Let n_0 be $allocmems($subst_all_memtype(memtype, dt*)*).
39. Assert: Due to validation, (n_0 is ma*).
40. Let n_0 be $alloctags(dt*[y]*).
41. Assert: Due to validation, (n_0 is aa*).
42. Let n_0 be $allocelems($subst_all_reftype(elemtype, dt*)*, ref_E**).
43. Assert: Due to validation, (n_0 is ea*).
44. Let n_0 be $allocdatas(OK^|data*|, byte**).
45. Assert: Due to validation, (n_0 is da*).
46. Return moduleinst.

runelem_ x (ELEM rt e^n elemmode_u0)
1. If (elemmode_u0 is PASSIVE), then:
  a. Return [].
2. If (elemmode_u0 is DECLARE), then:
  a. Return [(ELEM.DROP x)].
3. Assert: Due to validation, elemmode_u0 is of the case ACTIVE.
4. Let (ACTIVE y instr*) be elemmode_u0.
5. Return instr* :: [(I32.CONST 0), (I32.CONST n), (TABLE.INIT y x), (ELEM.DROP x)].

rundata_ x (DATA b^n datamode_u0)
1. If (datamode_u0 is PASSIVE), then:
  a. Return [].
2. Assert: Due to validation, datamode_u0 is of the case ACTIVE.
3. Let (ACTIVE y instr*) be datamode_u0.
4. Return instr* :: [(I32.CONST 0), (I32.CONST n), (MEMORY.INIT y x), (DATA.DROP x)].

evalglobals z globaltype_u0* expr_u1*
1. Let z be the current frame.
2. If ((globaltype_u0* is []) and (expr_u1* is [])), then:
  a. Return [].
3. Assert: Due to validation, (|expr_u1*| ≥ 1).
4. Let [expr] :: expr'* be expr_u1*.
5. Assert: Due to validation, (|globaltype_u0*| ≥ 1).
6. Let [gt] :: gt'* be globaltype_u0*.
7. Let [val] be $eval_expr(expr).
8. Let f be z.
9. Let a be $allocglobal(gt, val).
10. Append a to the f.MODULE.GLOBALS.
11. Let val'* be $evalglobals(z, gt'*, expr'*).
12. Return [val] :: val'*.

instantiate z module externaddr*
1. Let xt_I* -> xt_E* be $Module_ok(module).
2. Assert: Due to validation, module is of the case MODULE.
3. Let (MODULE type* import* func* global* table* mem* tag* elem* data* start? export*) be module.
4. Assert: Due to validation, $Externaddr_type(externaddr, xt_I)*.
5. Let instr_D* be $concat_(instr, $rundata_(i_D, data*[i_D])^(i_D<|data*|)).
6. Let instr_E* be $concat_(instr, $runelem_(i_E, elem*[i_E])^(i_E<|elem*|)).
7. Assert: Due to validation, start is of the case START?.
8. Let (START x)? be start?.
9. Let moduleinst_0 be { TYPES: $alloctypes(type*); FUNCS: $funcsxa(externaddr*) :: (|s.FUNCS| + i_F)^(i_F<|func*|); GLOBALS: $globalsxa(externaddr*); TABLES: []; MEMS: []; TAGS: []; ELEMS: []; DATAS: []; EXPORTS: []; }.
10. Assert: Due to validation, data is of the case DATA*.
11. Assert: Due to validation, table is of the case TABLE*.
12. Let (TABLE tabletype expr_T)* be table*.
13. Assert: Due to validation, global is of the case GLOBAL*.
14. Let (GLOBAL globaltype expr_G)* be global*.
15. Assert: Due to validation, elem is of the case ELEM*.
16. Let (ELEM reftype expr_E* elemmode)* be elem*.
17. Let instr_S? be (CALL x)?.
18. Let z be { LOCALS: []; MODULE: moduleinst_0; }.
19. Push the activation of z to the stack.
20. Let val_G* be $evalglobals(z, globaltype*, expr_G*).
21. Pop the activation of z' from the stack.
22. Push the activation of z' to the stack.
23. Let [ref_T]* be $eval_expr(expr_T)*.
24. Pop the activation of _f from the stack.
25. Push the activation of z' to the stack.
26. Let [ref_E]** be $eval_expr(expr_E)**.
27. Pop the activation of _f from the stack.
28. Let moduleinst be $allocmodule(module, externaddr*, val_G*, ref_T*, ref_E**).
29. Let f be { LOCALS: []; MODULE: moduleinst; }.
30. Push the activation of f with arity 0 to the stack.
31. Execute the sequence (instr_E*).
32. Execute the sequence (instr_D*).
33. If instr_S? is defined, then:
  a. Execute the instruction instr_S.
34. Pop the activation of f with arity 0 from the stack.
35. Return f.MODULE.

invoke funcaddr val*
1. Let f be { LOCALS: []; MODULE: { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; TAGS: []; ELEMS: []; DATAS: []; EXPORTS: []; }; }.
2. Assert: Due to validation, $expanddt(s.FUNCS[funcaddr].TYPE) is of the case FUNC.
3. Let (FUNC functype_0) be $expanddt(s.FUNCS[funcaddr].TYPE).
4. Let t_1* -> t_2* be functype_0.
5. Assert: Due to validation, $Val_type(val, t_1)*.
6. Let k be |t_2*|.
7. Push the activation of f with arity k to the stack.
8. Push the values val* to the stack.
9. Push the value (REF.FUNC_ADDR funcaddr) to the stack.
10. Execute the instruction (CALL_REF s.FUNCS[funcaddr].TYPE).
11. Pop all values val* from the top of the stack.
12. Pop the activation of f with arity k from the stack.
13. Push the values val* to the stack.
14. Pop the values val^k from the stack.
15. Return val^k.

allocXs X Y X_u0* Y_u1*
1. If (X_u0* is []), then:
  a. Assert: Due to validation, (Y_u1* is []).
  b. Return [].
2. Else:
  a. Let [X] :: X'* be X_u0*.
  b. Assert: Due to validation, (|Y_u1*| ≥ 1).
  c. Let [Y] :: Y'* be Y_u1*.
  d. Let a be $allocX(X, Y, X, Y).
  e. Let a'* be $allocXs(X, Y, X'*, Y'*).
  f. Return [a] :: a'*.

var X
1. Return 0.

eval_expr instr*
1. Execute the instruction instr*.
2. Pop the value val from the stack.
3. Return [val].

== Complete.
```
