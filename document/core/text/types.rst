.. index:: type
   pair: text format; type
.. _text-type:

Types
-----

.. index:: number type
   pair: text format; number type
.. _text-numtype:

Number Types
~~~~~~~~~~~~

$${grammar: Tnumtype}


.. index:: vector type
   pair: text format; vector type
.. _text-vectype:

Vector Types
~~~~~~~~~~~~

$${grammar: Tvectype}


.. index:: heap type
   pair: text format; heap type
.. _text-heaptype:
.. _text-absheaptype:

Heap Types
~~~~~~~~~~

$${grammar: Tabsheaptype Theaptype_}


.. index:: reference type
   pair: text format; reference type
.. _text-reftype:
.. _text-null:

Reference Types
~~~~~~~~~~~~~~~

$${grammar: Tnull Treftype_/base}

Abbreviations
.............

There are shorthands for references to abstract heap types.

$${grammar: Treftype_/abbrev}


.. index:: value type, number type, vector type, reference type
   pair: text format; value type
.. _text-valtype:

Value Types
~~~~~~~~~~~

$${grammar: Tvaltype_}


.. index:: composite type, aggregate type, structure type, array type, function type, field type, storage type, value type, packed type, mutability, result type
   pair: text format; composite type
   pair: text format; aggregate type
   pair: text format; structure type
   pair: text format; array type
   pair: text format; function type
   pair: text format; field type
   pair: text format; storage type
   pair: text format; packed type
.. _text-comptype:
.. _text-aggrtype:
.. _text-structtype:
.. _text-arraytype:
.. _text-functype:
.. _text-param:
.. _text-result:
.. _text-fieldtype:
.. _text-storagetype:
.. _text-packtype:

Composite Types
~~~~~~~~~~~~~~~

Composite types are parsed into their respective abstract representation,
paired with the local :ref:`identifier context <text-context>` generated by their bound field or parameter identifiers:

$${grammar:
  Tcomptype_
  {Tfield_/base Tparam_/base Tresult_/base}
  Tfieldtype_
  Tstoragetype_
  Tpacktype
}

.. note::
   The optional identifier names for parameters in a function type only have documentation purpose.
   They cannot be referenced from anywhere.

Abbreviations
.............

Multiple anonymous structure fields or parameters or multiple results may be combined into a single declaration:

$${grammar: {Tfield_/abbrev Tparam_/abbrev Tresult_/abbrev}}


.. index:: recursive type, sub type, composite type
   pair: text format; recursive type
   pair: text format; sub type
.. _text-rectype:
.. _text-subtype:
.. _text-typedef:
.. _text-final:

Recursive Types
~~~~~~~~~~~~~~~

Recursive types are parsed into their respective abstract representation,
paired with the :ref:`identifier context <text-context>` generated by their bound identifiers:

$${grammar: Tfinal Tsubtype_/base Ttypedef_ Trectype_/base}


Abbreviations
.............

Final sub types with no super-types can omit the ${grammar-case: "sub"} keyword and its arguments:

$${grammar: Tsubtype_/abbrev}

Similarly, singular recursive types can omit the ${grammar-case: "rec"} keyword:

$${grammar: Trectype_/abbrev}


.. index:: address type
   pair: text format; address type
.. _text-addrtype:

Address Types
~~~~~~~~~~~~~

$${grammar: Taddrtype/base}

Abbreviations
.............

The address type can be omitted, in which case it defaults ${addrtype: I32}:

$${grammar: Taddrtype/abbrev}


.. index:: limits
   pair: text format; limits
.. _text-limits:

Limits
~~~~~~

$${grammar: Tlimits}


.. index:: tag type, type use
   pair: text format; tag type
.. _text-tagtype:

Tag Types
~~~~~~~~~

$${grammar: Ttagtype_}


.. index:: global type, mutability, value type
   pair: text format; global type
   pair: text format; mutability
.. _text-globaltype:

Global Types
~~~~~~~~~~~~

$${grammar: Tglobaltype_}


.. index:: memory type, limits, page size
   pair: text format; memory type
.. _text-memtype:

Memory Types
~~~~~~~~~~~~

$${grammar: Tmemtype_}


.. index:: table type, reference type, limits
   pair: text format; table type
.. _text-tabletype:

Table Types
~~~~~~~~~~~

$${grammar: Ttabletype_}


.. index:: external type, tag type, global type, memory type, table type, function type
   pair: text format; external type
.. _text-externtype:

External Types
~~~~~~~~~~~~~~

$${grammar: Texterntype_}


.. index:: type use
   pair: text format; type use
.. _text-typeuse:

Type Uses
~~~~~~~~~

A *type use* is a reference to a :ref:`type definition <text-type>`.
Where it is required to reference a :ref:`function type <text-functype>`,
it may optionally be augmented by explicit inlined :ref:`parameter <text-param>` and :ref:`result <text-result>` declarations.
That allows binding symbolic :ref:`identifiers <text-id>` to name the :ref:`local indices <text-localidx>` of parameters.
If inline declarations are given, then their types must match the referenced :ref:`function type <text-type>`.

$${grammar: Ttypeuse_/base}

.. note::
   If inline declarations are given, their types must be *syntactically* equal to the types from the indexed definition;
   possible type :ref:`substitutions <notation-subst>` from other definitions that might make them equal are not taken into account.
   This is to simplify syntactic pre-processing.

The synthesized attribute of a ${grammar-case: Ttypeuse} is a pair consisting of both the used :ref:`type index <syntax-typeidx>` and the local :ref:`identifier context <text-context>` containing possible parameter identifiers.

.. note::
   Both productions overlap for the case that the function type is ${comptype: FUNC eps -> eps}.
   However, in that case, they also produce the same results, so that the choice is immaterial.

   The :ref:`well-formedness <text-context-wf>` condition on ${:I'} ensures that the parameters do not contain duplicate identifiers.


.. _text-typeuse-abbrev:

Abbreviations
.............

A type use may also be replaced entirely by inline :ref:`parameter <text-param>` and :ref:`result <text-result>` declarations.
In that case, a :ref:`type index <syntax-typeidx>` is automatically inserted:

$${grammar: Ttypeuse_/abbrev}

where ${:x} is the smallest existing :ref:`type index <syntax-typeidx>` whose :ref:`recursive type <syntax-rectype>` definition parses into a singular, final :ref:`function type <syntax-functype>` with the same parameters and results.
If no such index exists, then a new :ref:`recursive type <text-rectype>` of the same form is inserted at the end of the module.

Abbreviations are expanded in the order they appear, such that previously inserted type definitions are reused by consecutive expansions.
