.. index:: ! text format, Unicode, UTF-8, S-expression, identifier, file extension, abstract syntax

Conventions
-----------

The textual format for WebAssembly :ref:`modules <module>` is a rendering of their :ref:`abstract syntax <syntax-module>` into |SExpressions|_.

Like the :ref:`binary format <binary>`, the text format is defined by an *attribute grammar*.
A text string is a well-formed description of a module if and only if it is generated by the grammar.
Each production of this grammar has at most one synthesized attribute: the abstract syntax that the respective character sequence expresses.
Thus, the attribute grammar implicitly defines a *parsing* function.
Some productions also take a :ref:`context <text-context>` as an inherited attribute
that records bound :ref:`identifiers <text-id>`.

Except for a few exceptions, the core of the text grammar closely mirrors the grammar of the abstract syntax.
However, it also defines a number of *abbreviations* that are "syntactic sugar" over the core syntax.

The recommended extension for files containing WebAssembly modules in text format is "``.wat``".
Files with this extension are assumed to be encoded in UTF-8, as per |Unicode|_ (Section 2.5).


.. index:: grammar notation, notation, Unicode
   single: text format; grammar
   pair: text format; notation
.. _text-grammar:

Grammar
~~~~~~~

The following conventions are adopted in defining grammar rules of the text format.
They mirror the conventions used for :ref:`abstract syntax <grammar>` and for the :ref:`binary format <binary>`.
In order to distinguish symbols of the textual syntax from symbols of the abstract syntax, ${grammar-case: Ttypewriter} font is adopted for the former.

* Terminal symbols are either literal strings of characters enclosed in quotes
  or expressed as |Unicode|_ scalar values: ${grammar-case: "module"}, ${grammar-case: U+0A}.
  (All characters written literally are unambiguously drawn from the 7-bit |ASCII|_ subset of Unicode.)

* Nonterminal symbols are written in typewriter font: ${grammar-case: Tvaltype}, ${grammar-case: Tinstr}.

* ${grammar-case: $(T)^n} is a sequence of ${:n>=0} iterations of ${:T}.

* ${grammar-case: $(T)*} is a possibly empty sequence of iterations of ${:T}.
  (This is a shorthand for ${grammar-case: $(T)^n} used where ${:n} is not relevant.)

* ${grammar-case: $(T)+} is a possibly empty sequence of iterations of ${:T}.
  (This is a shorthand for ${grammar-case: $(T)^n} used where ${:n} is not relevant.)

* ${grammar-case: $(T)?} is an optional occurrence of ${:T}.
  (This is a shorthand for ${grammar-case: $(T)^n} where ${:n<=1}.)

* ${grammar-case: x:$(T)} denotes the same language as the nonterminal ${:T}, but also binds the variable ${:x} to the attribute synthesized for ${:T}.
  A pattern may also be used instead of a variable, e.g., ${grammar-case: 7:$(T)}.

* Productions are written ${grammar: Tsym}, where each ${:A_i} is the attribute that is synthesized for ${grammar-case: Tsym} in the given case, usually from attribute variables bound in ${:T_i}.

* Large productions may be split into multiple definitions, indicated by ending the first one with explicit ellipses, ${grammar: Tsymsplit/1}, and starting continuations with ellipses, ${grammar: Tsymsplit/2}.

* Some productions are augmented by side conditions in parentheses, which restrict the applicability of the production. They provide a shorthand for a combinatorial expansion of the production into many separate cases.

* If the same meta variable or non-terminal symbol appears multiple times in a production (in the syntax or in an attribute), then all those occurrences must have the same instantiation.

.. _text-syntactic:

* A distinction is made between *lexical* and *syntactic* productions. For the latter, arbitrary :ref:`white space <text-space>` is allowed in any place where the grammar contains spaces. The productions defining :ref:`lexical syntax <text-lexical>` and the syntax of :ref:`values <text-value>` are considered lexical, all others are syntactic.

.. note::
   For example, the :ref:`textual grammar <text-numtype>` for :ref:`number types <syntax-numtype>` is given as follows:

   $${grammar: Tnumtype}

   The :ref:`textual grammar <text-limits>` for :ref:`limits <syntax-limits>` is defined as follows:   

   $${grammar: Tlimits_}

   The variables ${:n} and ${:m} name the attributes of the respective ${grammar-case: Tu64} nonterminals, which in this case are the actual :ref:`unsigned integers <syntax-uint>` those parse into.
   The attribute of the complete production then is the abstract syntax for the limit, expressed in terms of the former values.

   The variable ${:N} is a *parameter* to the grammer symbol that can be instantiated differently at each use site.
   In this example, it controls the value range of the limits.


.. index:: ! abbreviations, rewrite rule
.. _text-abbreviations:

Abbreviations
~~~~~~~~~~~~~

In addition to the core grammar, which corresponds directly to the :ref:`abstract syntax <syntax>`, the textual syntax also defines a number of *abbreviations* that can be used for convenience and readability.

Abbreviations are defined by *rewrite rules* specifying their expansion into the core syntax:

$${grammar: Tabbrev}

These expansions are assumed to be applied, recursively and in order of appearance, before applying the core grammar rules to construct the abstract syntax.


.. index:: ! identifier context, identifier, index, index space
.. _text-context-wf:
.. _text-context:

Contexts
~~~~~~~~

The text format allows the use of symbolic :ref:`identifiers <text-id>` in place of :ref:`indices <syntax-index>`.
To resolve these identifiers into concrete indices,
some grammar productions are indexed by an *identifier context* ${:I} as a synthesized attribute that records the declared identifiers in each :ref:`index space <syntax-index>`.
In addition, the context records the types defined in the module, so that :ref:`parameter <text-param>` indices can be computed for :ref:`functions <text-func>`.

It is convenient to define identifier contexts as :ref:`records <notation-record>` ${:I} with abstract syntax as follows:

$${syntax: idctxt}

For each index space, such a context contains the list of :ref:`names <syntax-name>` assigned to the defined indices,
which were denoted by the corresponding :ref:`identifiers <text-id>`.
Unnamed indices are associated with empty (${:eps}) entries in these lists.
Fields have *dependent* name spaces, and hence a separate list of field identifiers per type.

An identifier context is *well-formed* if no index space contains duplicate identifiers.
For fields, names need only be unique within a single type.



Conventions
...........

To avoid unnecessary clutter, empty components are omitted when writing out identifier contexts.
For example, the record ${idctxt: {}} is shorthand for an :ref:`identifier context <text-context>` whose components are all empty.


.. index:: list
   pair: text format; list
.. _text-list:

Lists
~~~~~

:ref:`Lists <syntax-list>` are written as plain sequences, but with a restriction on the length of these sequence.

$${grammar: Tlist}
