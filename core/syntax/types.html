<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Types &#8212; WebAssembly 3.0 (2025-10-08)</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=057308f9" />
    <script src="../_static/documentation_options.js?v=d9024698"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>window.MathJax = {"tex": {"maxBuffer": 30720, "macros": {"multicolumn": ["", 2]}}, "options": {"menuOptions": {"settings": {"enrich": false}}}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Instructions" href="instructions.html" />
    <link rel="prev" title="Values" href="values.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/webassembly.png" alt="Logo of WebAssembly"/>
            </a></p><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro/index.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Structure</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="conventions.html">Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="values.html">Values</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="instructions.html">Instructions</a></li>
<li class="toctree-l2"><a class="reference internal" href="modules.html">Modules</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../valid/index.html">Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../exec/index.html">Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../binary/index.html">Binary Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../text/index.html">Text Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">Appendix</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index-types.html">Index of Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index-instructions.html">Index of Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index-rules.html">Index of Semantic Rules</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="../genindex.html">Index</a></li>
    
    <li class="toctree-l1"><a href="../_download/WebAssembly.pdf">Download as PDF</a></li>
    
</ul>

<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="types">
<span id="index-0"></span><h1>Types<a class="headerlink" href="#types" title="Link to this heading">¶</a></h1>
<p>Various entities in WebAssembly are classified by types.
Types are checked during <a class="reference internal" href="../valid/index.html#valid"><span class="std std-ref">validation</span></a>, <a class="reference internal" href="../exec/modules.html#exec-instantiation"><span class="std std-ref">instantiation</span></a>, and possibly <a class="reference internal" href="instructions.html#syntax-call-indirect"><span class="std std-ref">execution</span></a>.</p>
<section id="number-types">
<span id="syntax-numtype"></span><span id="index-1"></span><h2>Number Types<a class="headerlink" href="#number-types" title="Link to this heading">¶</a></h2>
<p><em>Number types</em> classify numeric values.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}[t]{&#64;{}l&#64;{}rrl&#64;{}l&#64;{}}
&amp; {\href{../syntax/types.html#syntax-numtype}{\mathit{numtype}}} &amp; ::= &amp; \href{../syntax/types.html#syntax-numtype}{\mathsf{i\scriptstyle32}} ~~|~~ \href{../syntax/types.html#syntax-numtype}{\mathsf{i\scriptstyle64}} ~~|~~ \href{../syntax/types.html#syntax-numtype}{\mathsf{f\scriptstyle32}} ~~|~~ \href{../syntax/types.html#syntax-numtype}{\mathsf{f\scriptstyle64}} \\
\end{array}\end{split}\]</div>
<p>The types <span class="math notranslate nohighlight">\(\mathsf{i{\scriptstyle 32}}\)</span> and <span class="math notranslate nohighlight">\(\mathsf{i{\scriptstyle 64}}\)</span> classify 32 and 64 bit integers, respectively.
Integers are not inherently signed or unsigned, their interpretation is determined by individual operations.</p>
<p>The types <span class="math notranslate nohighlight">\(\mathsf{f{\scriptstyle 32}}\)</span> and <span class="math notranslate nohighlight">\(\mathsf{f{\scriptstyle 64}}\)</span> classify 32 and 64 bit floating-point data, respectively.
They correspond to the respective binary floating-point representations, also known as <em>single</em> and <em>double</em> precision, as defined by the <a class="reference external" href="https://ieeexplore.ieee.org/document/8766229">IEEE 754</a> standard (Section 3.3).</p>
<p>Number types are <em>transparent</em>, meaning that their bit patterns can be observed.
Values of number type can be stored in <a class="reference internal" href="modules.html#syntax-mem"><span class="std std-ref">memories</span></a>.</p>
<section id="conventions">
<span id="bitwidth-valtype"></span><span id="bitwidth-numtype"></span><h3>Conventions<a class="headerlink" href="#conventions" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The notation <span class="math notranslate nohighlight">\({|t|}\)</span> denotes the <em>bit width</em> of a number type <span class="math notranslate nohighlight">\(t\)</span>.
That is, <span class="math notranslate nohighlight">\({|\mathsf{i{\scriptstyle 32}}|} = {|\mathsf{f{\scriptstyle 32}}|} = 32\)</span> and <span class="math notranslate nohighlight">\({|\mathsf{i{\scriptstyle 64}}|} = {|\mathsf{f{\scriptstyle 64}}|} = 64\)</span>.</p></li>
</ul>
</section>
</section>
<section id="vector-types">
<span id="syntax-vectype"></span><span id="index-2"></span><h2>Vector Types<a class="headerlink" href="#vector-types" title="Link to this heading">¶</a></h2>
<p><em>Vector types</em> classify vectors of <a class="reference internal" href="#syntax-numtype"><span class="std std-ref">numeric</span></a> values processed by vector instructions (also known as <em>SIMD</em> instructions, single instruction multiple data).</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}[t]{&#64;{}l&#64;{}rrl&#64;{}l&#64;{}}
&amp; {\href{../syntax/types.html#syntax-vectype}{\mathit{vectype}}} &amp; ::= &amp; \href{../syntax/types.html#syntax-vectype}{\mathsf{v\scriptstyle128}} \\
\end{array}\end{split}\]</div>
<p>The type <span class="math notranslate nohighlight">\(\mathsf{v{\scriptstyle 128}}\)</span> corresponds to a 128 bit vector of packed integer or floating-point data. The packed data
can be interpreted as signed or unsigned integers, single or double precision floating-point
values, or a single 128 bit type. The interpretation is determined by individual operations.</p>
<p>Vector types, like <a class="reference internal" href="#syntax-numtype"><span class="std std-ref">number types</span></a> are <em>transparent</em>, meaning that their bit patterns can be observed.
Values of vector type can be stored in <a class="reference internal" href="modules.html#syntax-mem"><span class="std std-ref">memories</span></a>.</p>
<section id="bitwidth-vectype">
<span id="id1"></span><h3>Conventions<a class="headerlink" href="#bitwidth-vectype" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The notation <span class="math notranslate nohighlight">\({|t|}\)</span> for <a class="reference internal" href="#bitwidth-numtype"><span class="std std-ref">bit width</span></a> extends to vector types as well, that is, <span class="math notranslate nohighlight">\({|\mathsf{v{\scriptstyle 128}}|} = 128\)</span>.</p></li>
</ul>
</section>
</section>
<section id="type-uses">
<span id="syntax-typeuse"></span><span id="index-3"></span><h2>Type Uses<a class="headerlink" href="#type-uses" title="Link to this heading">¶</a></h2>
<p>A <em>type use</em> is the use site of a <a class="reference internal" href="modules.html#syntax-typeidx"><span class="std std-ref">type index</span></a> referencing a <a class="reference internal" href="#syntax-comptype"><span class="std std-ref">composite type</span></a> <a class="reference internal" href="modules.html#syntax-type"><span class="std std-ref">defined</span></a> in a <a class="reference internal" href="modules.html#syntax-module"><span class="std std-ref">module</span></a>.
It classifies objects of the respective type.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}[t]{&#64;{}l&#64;{}rrl&#64;{}l&#64;{}}
&amp; {\href{../syntax/types.html#syntax-typeuse}{\mathit{typeuse}}} &amp; ::= &amp; {\href{../syntax/modules.html#syntax-typeidx}{\mathit{typeidx}}} \\
\end{array}\end{split}\]</div>
<p>The syntax of type uses is <a class="reference internal" href="../valid/conventions.html#syntax-typeuse-ext"><span class="std std-ref">extended</span></a> with additional forms for the purpose of specifying <a class="reference internal" href="../valid/index.html#valid"><span class="std std-ref">validation</span></a> and <a class="reference internal" href="../exec/index.html#exec"><span class="std std-ref">execution</span></a>.</p>
</section>
<section id="heap-types">
<span id="syntax-absheaptype"></span><span id="syntax-heaptype"></span><span id="syntax-i31"></span><span id="type-concrete"></span><span id="type-abstract"></span><span id="index-4"></span><h2>Heap Types<a class="headerlink" href="#heap-types" title="Link to this heading">¶</a></h2>
<p><em>Heap types</em> classify objects in the runtime <a class="reference internal" href="../exec/runtime.html#store"><span class="std std-ref">store</span></a>.
There are three disjoint hierarchies of heap types:</p>
<ul class="simple">
<li><p><em>function types</em> classify <a class="reference internal" href="modules.html#syntax-func"><span class="std std-ref">functions</span></a>,</p></li>
<li><p><em>aggregate types</em> classify dynamically allocated <em>managed</em> data, such as <em>structures</em>, <em>arrays</em>, or <em>unboxed scalars</em>,</p></li>
<li><p><em>external types</em> classify <em>external</em> references possibly owned by the <a class="reference internal" href="../intro/overview.html#embedder"><span class="std std-ref">embedder</span></a>.</p></li>
</ul>
<p>The values from the latter two hierarchies are interconvertible by ways of the <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr-extern}{\mathsf{extern{.}convert\_any}}\)</span> and <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr-extern}{\mathsf{any{.}convert\_extern}}\)</span> instructions.
That is, both type hierarchies are inhabited by an isomorphic set of values, but may have different, incompatible representations in practice.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}[t]{&#64;{}l&#64;{}rrl&#64;{}l&#64;{}}
&amp; {\href{../syntax/types.html#syntax-absheaptype}{\mathit{absheaptype}}} &amp; ::= &amp; \href{../syntax/types.html#syntax-heaptype}{\mathsf{any}} ~~|~~ \href{../syntax/types.html#syntax-heaptype}{\mathsf{eq}} ~~|~~ \href{../syntax/types.html#syntax-heaptype}{\mathsf{i\scriptstyle31}} ~~|~~ \href{../syntax/types.html#syntax-heaptype}{\mathsf{struct}} ~~|~~ \href{../syntax/types.html#syntax-heaptype}{\mathsf{array}} ~~|~~ \href{../syntax/types.html#syntax-heaptype}{\mathsf{none}} \\
&amp; &amp; | &amp; \href{../syntax/types.html#syntax-heaptype}{\mathsf{func}} ~~|~~ \href{../syntax/types.html#syntax-heaptype}{\mathsf{nofunc}} \\
&amp; &amp; | &amp; \href{../syntax/types.html#syntax-heaptype}{\mathsf{exn}} ~~|~~ \href{../syntax/types.html#syntax-heaptype}{\mathsf{noexn}} \\
&amp; &amp; | &amp; \href{../syntax/types.html#syntax-heaptype}{\mathsf{extern}} ~~|~~ \href{../syntax/types.html#syntax-heaptype}{\mathsf{noextern}} \\
&amp; {\href{../syntax/types.html#syntax-heaptype}{\mathit{heaptype}}} &amp; ::= &amp; {\href{../syntax/types.html#syntax-absheaptype}{\mathit{absheaptype}}} ~~|~~ {\href{../syntax/types.html#syntax-typeuse}{\mathit{typeuse}}} \\
\end{array}\end{split}\]</div>
<p>A heap type is either <em>abstract</em> or <em>concrete</em>.
A concrete heap type consists of a <a class="reference internal" href="#syntax-typeuse"><span class="std std-ref">type use</span></a> that classifies an object of the respective <a class="reference internal" href="modules.html#syntax-type"><span class="std std-ref">type</span></a> defined in a module.
Abstract types are denoted by individual keywords.</p>
<p>The type <span class="math notranslate nohighlight">\(\mathsf{func}\)</span> denotes the common supertype of all <a class="reference internal" href="#syntax-functype"><span class="std std-ref">function types</span></a>, regardless of their concrete definition.
Dually, the type <span class="math notranslate nohighlight">\(\mathsf{nofunc}\)</span> denotes the common subtype of all <a class="reference internal" href="#syntax-functype"><span class="std std-ref">function types</span></a>, regardless of their concrete definition.
This type has no values.</p>
<p>The type <span class="math notranslate nohighlight">\(\mathsf{exn}\)</span> denotes the common supertype of all <a class="reference internal" href="../exec/runtime.html#syntax-ref-exn"><span class="std std-ref">exception references</span></a>.
This type has no concrete subtypes.
Dually, the type <span class="math notranslate nohighlight">\(\mathsf{noexn}\)</span> denotes the common subtype of all forms of exception references.
This type has no values.</p>
<p>The type <span class="math notranslate nohighlight">\(\mathsf{extern}\)</span> denotes the common supertype of all external references received through the <a class="reference internal" href="../intro/overview.html#embedder"><span class="std std-ref">embedder</span></a>.
This type has no concrete subtypes.
Dually, the type <span class="math notranslate nohighlight">\(\mathsf{noextern}\)</span> denotes the common subtype of all forms of external references.
This type has no values.</p>
<p>The type <span class="math notranslate nohighlight">\(\mathsf{any}\)</span> denotes the common supertype of all aggregate types, as well as possibly abstract values produced by <em>internalizing</em> an external reference of type <span class="math notranslate nohighlight">\(\mathsf{extern}\)</span>.
Dually, the type <span class="math notranslate nohighlight">\(\mathsf{none}\)</span> denotes the common subtype of all forms of aggregate types.
This type has no values.</p>
<p>The type <span class="math notranslate nohighlight">\(\mathsf{eq}\)</span> is a subtype of <span class="math notranslate nohighlight">\(\mathsf{any}\)</span> that includes all types for which references can be compared, i.e., aggregate values and <span class="math notranslate nohighlight">\(\mathsf{i{\scriptstyle 31}}\)</span>.</p>
<p>The types <span class="math notranslate nohighlight">\(\mathsf{struct}\)</span> and <span class="math notranslate nohighlight">\(\mathsf{array}\)</span> denote the common supertypes of all <a class="reference internal" href="#syntax-structtype"><span class="std std-ref">structure</span></a> and <a class="reference internal" href="#syntax-arraytype"><span class="std std-ref">array</span></a> aggregates, respectively.</p>
<p>The type <span class="math notranslate nohighlight">\(\mathsf{i{\scriptstyle 31}}\)</span> denotes <em>unboxed scalars</em>, that is, integers injected into references.
Their observable value range is limited to 31 bits.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Values of type <span class="math notranslate nohighlight">\(\mathsf{i{\scriptstyle 31}}\)</span> are not actually allocated in the store,
but represented in a way that allows them to be mixed with actual references into the store without ambiguity.
Engines need to perform some form of <em>pointer tagging</em> to achieve this,
which is why one bit is reserved.
Since this type is to be reliably unboxed on all hardware platforms supported by WebAssembly,
it cannot be wider than 32 bits minus the tag bit.</p>
<p>Although the types <span class="math notranslate nohighlight">\(\mathsf{none}\)</span>, <span class="math notranslate nohighlight">\(\mathsf{nofunc}\)</span>, <span class="math notranslate nohighlight">\(\mathsf{noexn}\)</span>, and <span class="math notranslate nohighlight">\(\mathsf{noextern}\)</span> are not inhabited by any values,
they can be used to form the types of all null <a class="reference internal" href="#syntax-reftype"><span class="std std-ref">references</span></a> in their respective hierarchy.
For example, <span class="math notranslate nohighlight">\((\mathsf{ref}~\mathsf{null}~\mathsf{nofunc})\)</span> is the generic type of a null reference compatible with all function reference types.</p>
</div>
<p>The syntax of abstract heap types is <a class="reference internal" href="../valid/conventions.html#syntax-heaptype-ext"><span class="std std-ref">extended</span></a> with additional forms for the purpose of specifying <a class="reference internal" href="../valid/index.html#valid"><span class="std std-ref">validation</span></a> and <a class="reference internal" href="../exec/index.html#exec"><span class="std std-ref">execution</span></a>.</p>
</section>
<section id="reference-types">
<span id="syntax-null"></span><span id="syntax-reftype"></span><span id="index-5"></span><h2>Reference Types<a class="headerlink" href="#reference-types" title="Link to this heading">¶</a></h2>
<p><em>Reference types</em> classify <a class="reference internal" href="values.html#syntax-value"><span class="std std-ref">values</span></a> that are first-class references to objects in the runtime <a class="reference internal" href="../exec/runtime.html#store"><span class="std std-ref">store</span></a>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}[t]{&#64;{}l&#64;{}rrl&#64;{}l&#64;{}}
&amp; {\href{../syntax/types.html#syntax-reftype}{\mathit{reftype}}} &amp; ::= &amp; \href{../syntax/types.html#syntax-reftype}{\mathsf{ref}}~{\href{../syntax/types.html#syntax-reftype}{\mathsf{null}}^?}~{\href{../syntax/types.html#syntax-heaptype}{\mathit{heaptype}}} \\
\end{array}\end{split}\]</div>
<p>A reference type is characterised by the <a class="reference internal" href="#syntax-heaptype"><span class="std std-ref">heap type</span></a> it points to.</p>
<p>In addition, a reference type of the form <span class="math notranslate nohighlight">\(\mathsf{ref}~\mathsf{null}~{\mathit{ht}}\)</span> is <em>nullable</em>, meaning that it can either be a proper reference to <span class="math notranslate nohighlight">\({\mathit{ht}}\)</span> or <a class="reference internal" href="#syntax-null"><span class="std std-ref">null</span></a>.
Other references are <em>non-null</em>.</p>
<p>Reference types are <em>opaque</em>, meaning that neither their size nor their bit pattern can be observed.
Values of reference type can be stored in <a class="reference internal" href="modules.html#syntax-table"><span class="std std-ref">tables</span></a> but not in <a class="reference internal" href="modules.html#syntax-mem"><span class="std std-ref">memories</span></a>.</p>
<section id="id2">
<h3>Conventions<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The reference type <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-reftype}{\mathsf{anyref}}\)</span> is an abbreviation for <span class="math notranslate nohighlight">\((\href{../syntax/types.html#syntax-reftype}{\mathsf{ref}}~\href{../syntax/types.html#syntax-reftype}{\mathsf{null}}~\href{../syntax/types.html#syntax-heaptype}{\mathsf{any}})\)</span>.</p></li>
<li><p>The reference type <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-reftype}{\mathsf{eqref}}\)</span> is an abbreviation for <span class="math notranslate nohighlight">\((\href{../syntax/types.html#syntax-reftype}{\mathsf{ref}}~\href{../syntax/types.html#syntax-reftype}{\mathsf{null}}~\href{../syntax/types.html#syntax-heaptype}{\mathsf{eq}})\)</span>.</p></li>
<li><p>The reference type <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-reftype}{\mathsf{i{\scriptstyle31}ref}}\)</span> is an abbreviation for <span class="math notranslate nohighlight">\((\href{../syntax/types.html#syntax-reftype}{\mathsf{ref}}~\href{../syntax/types.html#syntax-reftype}{\mathsf{null}}~\href{../syntax/types.html#syntax-heaptype}{\mathsf{i\scriptstyle31}})\)</span>.</p></li>
<li><p>The reference type <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-reftype}{\mathsf{structref}}\)</span> is an abbreviation for <span class="math notranslate nohighlight">\((\href{../syntax/types.html#syntax-reftype}{\mathsf{ref}}~\href{../syntax/types.html#syntax-reftype}{\mathsf{null}}~\href{../syntax/types.html#syntax-heaptype}{\mathsf{struct}})\)</span>.</p></li>
<li><p>The reference type <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-reftype}{\mathsf{arrayref}}\)</span> is an abbreviation for <span class="math notranslate nohighlight">\((\href{../syntax/types.html#syntax-reftype}{\mathsf{ref}}~\href{../syntax/types.html#syntax-reftype}{\mathsf{null}}~\href{../syntax/types.html#syntax-heaptype}{\mathsf{array}})\)</span>.</p></li>
<li><p>The reference type <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-reftype}{\mathsf{funcref}}\)</span> is an abbreviation for <span class="math notranslate nohighlight">\((\href{../syntax/types.html#syntax-reftype}{\mathsf{ref}}~\href{../syntax/types.html#syntax-reftype}{\mathsf{null}}~\href{../syntax/types.html#syntax-heaptype}{\mathsf{func}})\)</span>.</p></li>
<li><p>The reference type <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-reftype}{\mathsf{exnref}}\)</span> is an abbreviation for <span class="math notranslate nohighlight">\((\href{../syntax/types.html#syntax-reftype}{\mathsf{ref}}~\href{../syntax/types.html#syntax-reftype}{\mathsf{null}}~\href{../syntax/types.html#syntax-heaptype}{\mathsf{exn}})\)</span>.</p></li>
<li><p>The reference type <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-reftype}{\mathsf{externref}}\)</span> is an abbreviation for <span class="math notranslate nohighlight">\((\href{../syntax/types.html#syntax-reftype}{\mathsf{ref}}~\href{../syntax/types.html#syntax-reftype}{\mathsf{null}}~\href{../syntax/types.html#syntax-heaptype}{\mathsf{extern}})\)</span>.</p></li>
<li><p>The reference type <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-reftype}{\mathsf{nullref}}\)</span> is an abbreviation for <span class="math notranslate nohighlight">\((\href{../syntax/types.html#syntax-reftype}{\mathsf{ref}}~\href{../syntax/types.html#syntax-reftype}{\mathsf{null}}~\href{../syntax/types.html#syntax-heaptype}{\mathsf{none}})\)</span>.</p></li>
<li><p>The reference type <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-reftype}{\mathsf{nullfuncref}}\)</span> is an abbreviation for <span class="math notranslate nohighlight">\((\href{../syntax/types.html#syntax-reftype}{\mathsf{ref}}~\href{../syntax/types.html#syntax-reftype}{\mathsf{null}}~\href{../syntax/types.html#syntax-heaptype}{\mathsf{nofunc}})\)</span>.</p></li>
<li><p>The reference type <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-reftype}{\mathsf{nullexnref}}\)</span> is an abbreviation for <span class="math notranslate nohighlight">\((\href{../syntax/types.html#syntax-reftype}{\mathsf{ref}}~\href{../syntax/types.html#syntax-reftype}{\mathsf{null}}~\href{../syntax/types.html#syntax-heaptype}{\mathsf{noexn}})\)</span>.</p></li>
<li><p>The reference type <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-reftype}{\mathsf{nullexternref}}\)</span> is an abbreviation for <span class="math notranslate nohighlight">\((\href{../syntax/types.html#syntax-reftype}{\mathsf{ref}}~\href{../syntax/types.html#syntax-reftype}{\mathsf{null}}~\href{../syntax/types.html#syntax-heaptype}{\mathsf{noextern}})\)</span>.</p></li>
</ul>
</section>
</section>
<section id="value-types">
<span id="syntax-consttype"></span><span id="syntax-valtype"></span><span id="index-6"></span><h2>Value Types<a class="headerlink" href="#value-types" title="Link to this heading">¶</a></h2>
<p><em>Value types</em> classify the individual values that WebAssembly code can compute with and the values that a variable accepts.
They are either <a class="reference internal" href="#syntax-numtype"><span class="std std-ref">number types</span></a>, <a class="reference internal" href="#syntax-vectype"><span class="std std-ref">vector types</span></a>, or <a class="reference internal" href="#syntax-reftype"><span class="std std-ref">reference types</span></a>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}[t]{&#64;{}l&#64;{}rrl&#64;{}l&#64;{}}
&amp; {\href{../syntax/types.html#syntax-consttype}{\mathit{consttype}}} &amp; ::= &amp; {\href{../syntax/types.html#syntax-numtype}{\mathit{numtype}}} ~~|~~ {\href{../syntax/types.html#syntax-vectype}{\mathit{vectype}}} \\
&amp; {\href{../syntax/types.html#syntax-valtype}{\mathit{valtype}}} &amp; ::= &amp; {\href{../syntax/types.html#syntax-numtype}{\mathit{numtype}}} ~~|~~ {\href{../syntax/types.html#syntax-vectype}{\mathit{vectype}}} ~~|~~ {\href{../syntax/types.html#syntax-reftype}{\mathit{reftype}}} \\
\end{array}\end{split}\]</div>
<p>The syntax of value types is <a class="reference internal" href="../valid/conventions.html#syntax-valtype-ext"><span class="std std-ref">extended</span></a> with additional forms for the purpose of specifying <a class="reference internal" href="../valid/index.html#valid"><span class="std std-ref">validation</span></a>.</p>
<section id="id3">
<h3>Conventions<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The meta variable <span class="math notranslate nohighlight">\(t\)</span> ranges over value types or subclasses thereof where clear from context.</p></li>
</ul>
</section>
</section>
<section id="result-types">
<span id="syntax-resulttype"></span><span id="index-7"></span><h2>Result Types<a class="headerlink" href="#result-types" title="Link to this heading">¶</a></h2>
<p><em>Result types</em> classify the result of <a class="reference internal" href="../exec/instructions.html#exec-instr"><span class="std std-ref">executing</span></a> <a class="reference internal" href="instructions.html#syntax-instr"><span class="std std-ref">instructions</span></a> or <a class="reference internal" href="modules.html#syntax-func"><span class="std std-ref">functions</span></a>,
which is a sequence of values, written with brackets.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}[t]{&#64;{}l&#64;{}rrl&#64;{}l&#64;{}}
&amp; {\href{../syntax/types.html#syntax-resulttype}{\mathit{resulttype}}} &amp; ::= &amp; {\href{../syntax/conventions.html#syntax-list}{\mathit{list}}}({\href{../syntax/types.html#syntax-valtype}{\mathit{valtype}}}) \\
\end{array}\end{split}\]</div>
</section>
<section id="block-types">
<span id="syntax-blocktype"></span><span id="index-8"></span><h2>Block Types<a class="headerlink" href="#block-types" title="Link to this heading">¶</a></h2>
<p><em>Block types</em> classify the <em>input</em> and <em>output</em> of structured <a class="reference internal" href="instructions.html#syntax-instr-control"><span class="std std-ref">control instructions</span></a> delimiting <a class="reference internal" href="instructions.html#syntax-block"><span class="std std-ref">blocks</span></a> of instructions.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}[t]{&#64;{}l&#64;{}rrl&#64;{}l&#64;{}}
&amp; {\href{../syntax/types.html#syntax-blocktype}{\mathit{blocktype}}} &amp; ::= &amp; {{\href{../syntax/types.html#syntax-valtype}{\mathit{valtype}}}^?} \\
&amp; &amp; | &amp; {\href{../syntax/modules.html#syntax-typeidx}{\mathit{typeidx}}} \\
\end{array}\end{split}\]</div>
<p>They are given either as a <a class="reference internal" href="modules.html#syntax-funcidx"><span class="std std-ref">type index</span></a> that refers to a suitable <a class="reference internal" href="#syntax-functype"><span class="std std-ref">function type</span></a> reinterpreted as an <a class="reference internal" href="../valid/conventions.html#syntax-instrtype"><span class="std std-ref">instruction type</span></a>,
or as an optional <a class="reference internal" href="#syntax-valtype"><span class="std std-ref">value type</span></a> inline,
which is a shorthand for the instruction type <span class="math notranslate nohighlight">\(\epsilon \rightarrow {{\href{../syntax/types.html#syntax-valtype}{\mathit{valtype}}}^?}\)</span>.</p>
</section>
<section id="composite-types">
<span id="syntax-packtype"></span><span id="syntax-storagetype"></span><span id="syntax-fieldtype"></span><span id="syntax-arraytype"></span><span id="syntax-structtype"></span><span id="syntax-aggrtype"></span><span id="syntax-functype"></span><span id="syntax-comptype"></span><span id="index-9"></span><h2>Composite Types<a class="headerlink" href="#composite-types" title="Link to this heading">¶</a></h2>
<p><em>Composite types</em> are all types composed from simpler types,
including <em>function types</em>, <em>structure types</em> and <em>array types</em>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}[t]{&#64;{}l&#64;{}rrl&#64;{}l&#64;{}}
&amp; {\href{../syntax/types.html#syntax-comptype}{\mathit{comptype}}} &amp; ::= &amp; \href{../syntax/types.html#syntax-comptype}{\mathsf{struct}}~{\href{../syntax/conventions.html#syntax-list}{\mathit{list}}}({\href{../syntax/types.html#syntax-fieldtype}{\mathit{fieldtype}}}) \\
&amp; &amp; | &amp; \href{../syntax/types.html#syntax-comptype}{\mathsf{array}}~{\href{../syntax/types.html#syntax-fieldtype}{\mathit{fieldtype}}} \\
&amp; &amp; | &amp; \href{../syntax/types.html#syntax-comptype}{\mathsf{func}}~{\href{../syntax/types.html#syntax-resulttype}{\mathit{resulttype}}} \href{../syntax/types.html#syntax-comptype}{\rightarrow} {\href{../syntax/types.html#syntax-resulttype}{\mathit{resulttype}}} \\[0.8ex]
&amp; {\href{../syntax/types.html#syntax-fieldtype}{\mathit{fieldtype}}} &amp; ::= &amp; {\href{../syntax/types.html#syntax-mut}{\mathsf{mut}}^?}~{\href{../syntax/types.html#syntax-storagetype}{\mathit{storagetype}}} \\
&amp; {\href{../syntax/types.html#syntax-storagetype}{\mathit{storagetype}}} &amp; ::= &amp; {\href{../syntax/types.html#syntax-valtype}{\mathit{valtype}}} ~~|~~ {\href{../syntax/types.html#syntax-packtype}{\mathit{packtype}}} \\
&amp; {\href{../syntax/types.html#syntax-packtype}{\mathit{packtype}}} &amp; ::= &amp; \href{../syntax/types.html#syntax-storagetype}{\mathsf{i\scriptstyle8}} ~~|~~ \href{../syntax/types.html#syntax-storagetype}{\mathsf{i\scriptstyle16}} \\
\end{array}\end{split}\]</div>
<p>Function types classify the signature of <a class="reference internal" href="modules.html#syntax-func"><span class="std std-ref">functions</span></a>,
mapping a list of parameters to a list of results.
They are also used to classify the inputs and outputs of <a class="reference internal" href="instructions.html#syntax-instr"><span class="std std-ref">instructions</span></a>.</p>
<p><em>Aggregate types</em> like structure or array types consist of a list of possibly mutable, possibly packed <em>field types</em> describing their components.
Structures are heterogeneous, but require static indexing, while arrays need to be homogeneous, but allow dynamic indexing.</p>
<section id="aux-unpack">
<span id="bitwidth-fieldtype"></span><span id="id4"></span><h3>Conventions<a class="headerlink" href="#aux-unpack" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The notation <span class="math notranslate nohighlight">\({|t|}\)</span> for the <a class="reference internal" href="#bitwidth-valtype"><span class="std std-ref">bit width</span></a> of a <a class="reference internal" href="#syntax-valtype"><span class="std std-ref">value type</span></a> <span class="math notranslate nohighlight">\(t\)</span> extends to packed types as well, that is, <span class="math notranslate nohighlight">\({|\mathsf{i{\scriptstyle 8}}|} = 8\)</span> and <span class="math notranslate nohighlight">\({|\mathsf{i{\scriptstyle 16}}|} = 16\)</span>.</p></li>
<li><p>The auxiliary function <span class="math notranslate nohighlight">\(\href{../syntax/types.html#aux-unpack}{\mathrm{unpack}}\)</span> maps a storage type to the <a class="reference internal" href="#syntax-valtype"><span class="std std-ref">value type</span></a> obtained when accessing a field:</p></li>
</ul>
</section>
</section>
<section id="recursive-types">
<span id="syntax-final"></span><span id="syntax-subtype"></span><span id="syntax-rectype"></span><span id="index-10"></span><h2>Recursive Types<a class="headerlink" href="#recursive-types" title="Link to this heading">¶</a></h2>
<p><em>Recursive types</em> denote a group of mutually recursive <a class="reference internal" href="#syntax-comptype"><span class="std std-ref">composite types</span></a>, each of which can optionally declare a list of <a class="reference internal" href="#syntax-typeuse"><span class="std std-ref">type uses</span></a> of supertypes that it <a class="reference internal" href="../valid/matching.html#match-comptype"><span class="std std-ref">matches</span></a>.
Each type can also be declared <em>final</em>, preventing further subtyping.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}[t]{&#64;{}l&#64;{}rrl&#64;{}l&#64;{}}
&amp; {\href{../syntax/types.html#syntax-rectype}{\mathit{rectype}}} &amp; ::= &amp; \href{../syntax/types.html#syntax-rectype}{\mathsf{rec}}~{\href{../syntax/conventions.html#syntax-list}{\mathit{list}}}({\href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}}) \\
&amp; {\href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}} &amp; ::= &amp; \href{../syntax/types.html#syntax-subtype}{\mathsf{sub}}~{\href{../syntax/types.html#syntax-subtype}{\mathsf{final}}^?}~{{\href{../syntax/types.html#syntax-typeuse}{\mathit{typeuse}}}^\ast}~{\href{../syntax/types.html#syntax-comptype}{\mathit{comptype}}} \\
\end{array}\end{split}\]</div>
<p>In a <a class="reference internal" href="modules.html#syntax-module"><span class="std std-ref">module</span></a>, each member of a recursive type is assigned a separate <a class="reference internal" href="modules.html#syntax-typeidx"><span class="std std-ref">type index</span></a>.</p>
</section>
<section id="address-types">
<span id="syntax-addrtype"></span><h2>Address Types<a class="headerlink" href="#address-types" title="Link to this heading">¶</a></h2>
<p><em>Address types</em> are a subset of <a class="reference internal" href="#syntax-numtype"><span class="std std-ref">number types</span></a> that classify the values that can be used as offsets into
<a class="reference internal" href="modules.html#syntax-mem"><span class="std std-ref">memories</span></a> and <a class="reference internal" href="modules.html#syntax-table"><span class="std std-ref">tables</span></a>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}[t]{&#64;{}l&#64;{}rrl&#64;{}l&#64;{}}
&amp; {\href{../syntax/types.html#syntax-addrtype}{\mathit{addrtype}}} &amp; ::= &amp; \href{../syntax/types.html#syntax-numtype}{\mathsf{i\scriptstyle32}} ~~|~~ \href{../syntax/types.html#syntax-numtype}{\mathsf{i\scriptstyle64}} \\
\end{array}\end{split}\]</div>
<section id="aux-addrtype-min">
<span id="id5"></span><h3>Conventions<a class="headerlink" href="#aux-addrtype-min" title="Link to this heading">¶</a></h3>
<p>The <em>minimum</em> of two address types is defined as the address type whose <a class="reference internal" href="#bitwidth-numtype"><span class="std std-ref">bit width</span></a> is the minimum of the two.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}[t]{&#64;{}lcl&#64;{}l&#64;{}}
{\href{../syntax/types.html#aux-addrtype-min}{\mathrm{min}}}({\mathit{at}}_1, {\mathit{at}}_2) &amp; = &amp; {\mathit{at}}_1 &amp; \quad \mbox{if}~ {|{\mathit{at}}_1|} \leq {|{\mathit{at}}_2|} \\
{\href{../syntax/types.html#aux-addrtype-min}{\mathrm{min}}}({\mathit{at}}_1, {\mathit{at}}_2) &amp; = &amp; {\mathit{at}}_2 &amp; \quad \mbox{otherwise} \\
\end{array}\end{split}\]</div>
</section>
</section>
<section id="limits">
<span id="syntax-limits"></span><span id="index-11"></span><h2>Limits<a class="headerlink" href="#limits" title="Link to this heading">¶</a></h2>
<p><em>Limits</em> classify the size range of resizeable storage associated with <a class="reference internal" href="#syntax-memtype"><span class="std std-ref">memory types</span></a> and <a class="reference internal" href="#syntax-tabletype"><span class="std std-ref">table types</span></a>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}[t]{&#64;{}l&#64;{}rrl&#64;{}l&#64;{}}
&amp; {\href{../syntax/types.html#syntax-limits}{\mathit{limits}}} &amp; ::= &amp; {}[ {\href{../syntax/values.html#syntax-int}{\mathit{u\scriptstyle\kern-0.1em64}}} \href{../syntax/types.html#syntax-limits}{\,{..}\,} {{\href{../syntax/values.html#syntax-int}{\mathit{u\scriptstyle\kern-0.1em64}}}^?} ] \\
\end{array}\end{split}\]</div>
<p>If no maximum is present,
then the respective storage can grow to any valid size.</p>
</section>
<section id="tag-types">
<span id="syntax-tagtype"></span><span id="index-12"></span><h2>Tag Types<a class="headerlink" href="#tag-types" title="Link to this heading">¶</a></h2>
<p><em>Tag types</em> classify the signature <a class="reference internal" href="modules.html#syntax-tag"><span class="std std-ref">tags</span></a>
with a <a class="reference internal" href="#syntax-typeuse"><span class="std std-ref">type use</span></a> referring to the definition of a <a class="reference internal" href="#syntax-functype"><span class="std std-ref">function type</span></a> that declares the types of parameter and result values associated with the tag.
The result type is empty for exception tags.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}[t]{&#64;{}l&#64;{}rrl&#64;{}l&#64;{}}
&amp; {\href{../syntax/types.html#syntax-tagtype}{\mathit{tagtype}}} &amp; ::= &amp; {\href{../syntax/types.html#syntax-typeuse}{\mathit{typeuse}}} \\
\end{array}\end{split}\]</div>
</section>
<section id="global-types">
<span id="syntax-globaltype"></span><span id="syntax-mut"></span><span id="index-13"></span><h2>Global Types<a class="headerlink" href="#global-types" title="Link to this heading">¶</a></h2>
<p><em>Global types</em> classify <a class="reference internal" href="modules.html#syntax-global"><span class="std std-ref">global</span></a> variables, which hold a value and can either be mutable or immutable.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}[t]{&#64;{}l&#64;{}rrl&#64;{}l&#64;{}}
&amp; {\href{../syntax/types.html#syntax-globaltype}{\mathit{globaltype}}} &amp; ::= &amp; {\href{../syntax/types.html#syntax-mut}{\mathsf{mut}}^?}~{\href{../syntax/types.html#syntax-valtype}{\mathit{valtype}}} \\
\end{array}\end{split}\]</div>
</section>
<section id="memory-types">
<span id="syntax-memtype"></span><span id="index-14"></span><h2>Memory Types<a class="headerlink" href="#memory-types" title="Link to this heading">¶</a></h2>
<p><em>Memory types</em> classify linear <a class="reference internal" href="modules.html#syntax-mem"><span class="std std-ref">memories</span></a> and their size range.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}[t]{&#64;{}l&#64;{}rrl&#64;{}l&#64;{}}
&amp; {\href{../syntax/types.html#syntax-memtype}{\mathit{memtype}}} &amp; ::= &amp; {\href{../syntax/types.html#syntax-addrtype}{\mathit{addrtype}}}~{\href{../syntax/types.html#syntax-limits}{\mathit{limits}}}~\href{../syntax/types.html#syntax-memtype}{\mathsf{page}} \\
\end{array}\end{split}\]</div>
<p>The limits constrain the minimum and optionally the maximum size of a memory.
The limits are given in units of <a class="reference internal" href="../exec/runtime.html#page-size"><span class="std std-ref">page size</span></a>.</p>
</section>
<section id="table-types">
<span id="syntax-tabletype"></span><span id="index-15"></span><h2>Table Types<a class="headerlink" href="#table-types" title="Link to this heading">¶</a></h2>
<p><em>Table types</em> classify <a class="reference internal" href="modules.html#syntax-table"><span class="std std-ref">tables</span></a> over elements of <a class="reference internal" href="#syntax-reftype"><span class="std std-ref">reference type</span></a> within a size range.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}[t]{&#64;{}l&#64;{}rrl&#64;{}l&#64;{}}
&amp; {\href{../syntax/types.html#syntax-tabletype}{\mathit{tabletype}}} &amp; ::= &amp; {\href{../syntax/types.html#syntax-addrtype}{\mathit{addrtype}}}~{\href{../syntax/types.html#syntax-limits}{\mathit{limits}}}~{\href{../syntax/types.html#syntax-reftype}{\mathit{reftype}}} \\
\end{array}\end{split}\]</div>
<p>Like memories, tables are constrained by limits for their minimum and optionally maximum size.
The limits are given in numbers of entries.</p>
</section>
<section id="data-types">
<span id="syntax-datatype"></span><span id="index-16"></span><h2>Data Types<a class="headerlink" href="#data-types" title="Link to this heading">¶</a></h2>
<p><em>Data types</em> classify <a class="reference internal" href="modules.html#syntax-elem"><span class="std std-ref">data segments</span></a>.
Since the contents of a data segment requires no further classification, they merely consist of a universal marker <span class="math notranslate nohighlight">\(\mathsf{ok}\)</span> indicating well-formedness.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}[t]{&#64;{}l&#64;{}rrl&#64;{}l&#64;{}}
&amp; {\href{../syntax/types.html#syntax-datatype}{\mathit{datatype}}} &amp; ::= &amp; \href{../valid/modules.html#valid-data}{\mathsf{ok}} \\
\end{array}\end{split}\]</div>
</section>
<section id="element-types">
<span id="syntax-elemtype"></span><span id="index-17"></span><h2>Element Types<a class="headerlink" href="#element-types" title="Link to this heading">¶</a></h2>
<p><em>Element types</em> classify <a class="reference internal" href="modules.html#syntax-elem"><span class="std std-ref">element segments</span></a> by the <a class="reference internal" href="#syntax-reftype"><span class="std std-ref">reference type</span></a> of its elements.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}[t]{&#64;{}l&#64;{}rrl&#64;{}l&#64;{}}
&amp; {\href{../syntax/types.html#syntax-elemtype}{\mathit{elemtype}}} &amp; ::= &amp; {\href{../syntax/types.html#syntax-reftype}{\mathit{reftype}}} \\
\end{array}\end{split}\]</div>
</section>
<section id="external-types">
<span id="syntax-externtype"></span><span id="index-18"></span><h2>External Types<a class="headerlink" href="#external-types" title="Link to this heading">¶</a></h2>
<p><em>External types</em> classify <a class="reference internal" href="modules.html#syntax-import"><span class="std std-ref">imports</span></a> and <a class="reference internal" href="../exec/runtime.html#syntax-externaddr"><span class="std std-ref">external addresses</span></a> with their respective types.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}[t]{&#64;{}l&#64;{}rrl&#64;{}l&#64;{}}
&amp; {\href{../syntax/types.html#syntax-externtype}{\mathit{externtype}}} &amp; ::= &amp; \href{../syntax/types.html#syntax-externtype}{\mathsf{tag}}~{\href{../syntax/types.html#syntax-tagtype}{\mathit{tagtype}}} ~~|~~ \href{../syntax/types.html#syntax-externtype}{\mathsf{global}}~{\href{../syntax/types.html#syntax-globaltype}{\mathit{globaltype}}} ~~|~~ \href{../syntax/types.html#syntax-externtype}{\mathsf{mem}}~{\href{../syntax/types.html#syntax-memtype}{\mathit{memtype}}} ~~|~~ \href{../syntax/types.html#syntax-externtype}{\mathsf{table}}~{\href{../syntax/types.html#syntax-tabletype}{\mathit{tabletype}}} ~~|~~ \href{../syntax/types.html#syntax-externtype}{\mathsf{func}}~{\href{../syntax/types.html#syntax-typeuse}{\mathit{typeuse}}} \\
\end{array}\end{split}\]</div>
<p>For functions, the <a class="reference internal" href="#syntax-typeuse"><span class="std std-ref">type use</span></a> has to refer to the definition of a <a class="reference internal" href="#syntax-functype"><span class="std std-ref">function type</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Future versions of WebAssembly may have additional uses for tags, and may allow non-empty result types in the function types of tags.</p>
</div>
<section id="id6">
<h3>Conventions<a class="headerlink" href="#id6" title="Link to this heading">¶</a></h3>
<p>The following auxiliary notation is defined for sequences of external types.
It filters out entries of a specific kind in an order-preserving fashion:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}[t]{&#64;{}lcl&#64;{}l&#64;{}}
{\href{../syntax/types.html#syntax-externtype}{\mathrm{funcs}}}(\epsilon) &amp; = &amp; \epsilon \\
{\href{../syntax/types.html#syntax-externtype}{\mathrm{funcs}}}((\href{../syntax/types.html#syntax-externtype}{\mathsf{func}}~{\mathit{dt}})~{{\mathit{xt}}^\ast}) &amp; = &amp; {\mathit{dt}}~{\href{../syntax/types.html#syntax-externtype}{\mathrm{funcs}}}({{\mathit{xt}}^\ast}) \\
{\href{../syntax/types.html#syntax-externtype}{\mathrm{funcs}}}({\href{../syntax/types.html#syntax-externtype}{\mathit{externtype}}}~{{\mathit{xt}}^\ast}) &amp; = &amp; {\href{../syntax/types.html#syntax-externtype}{\mathrm{funcs}}}({{\mathit{xt}}^\ast}) &amp; \quad \mbox{otherwise} \\[0.8ex]
{\href{../syntax/types.html#syntax-externtype}{\mathrm{tables}}}(\epsilon) &amp; = &amp; \epsilon \\
{\href{../syntax/types.html#syntax-externtype}{\mathrm{tables}}}((\href{../syntax/types.html#syntax-externtype}{\mathsf{table}}~{\mathit{tt}})~{{\mathit{xt}}^\ast}) &amp; = &amp; {\mathit{tt}}~{\href{../syntax/types.html#syntax-externtype}{\mathrm{tables}}}({{\mathit{xt}}^\ast}) \\
{\href{../syntax/types.html#syntax-externtype}{\mathrm{tables}}}({\href{../syntax/types.html#syntax-externtype}{\mathit{externtype}}}~{{\mathit{xt}}^\ast}) &amp; = &amp; {\href{../syntax/types.html#syntax-externtype}{\mathrm{tables}}}({{\mathit{xt}}^\ast}) &amp; \quad \mbox{otherwise} \\[0.8ex]
{\href{../syntax/types.html#syntax-externtype}{\mathrm{mems}}}(\epsilon) &amp; = &amp; \epsilon \\
{\href{../syntax/types.html#syntax-externtype}{\mathrm{mems}}}((\href{../syntax/types.html#syntax-externtype}{\mathsf{mem}}~{\mathit{mt}})~{{\mathit{xt}}^\ast}) &amp; = &amp; {\mathit{mt}}~{\href{../syntax/types.html#syntax-externtype}{\mathrm{mems}}}({{\mathit{xt}}^\ast}) \\
{\href{../syntax/types.html#syntax-externtype}{\mathrm{mems}}}({\href{../syntax/types.html#syntax-externtype}{\mathit{externtype}}}~{{\mathit{xt}}^\ast}) &amp; = &amp; {\href{../syntax/types.html#syntax-externtype}{\mathrm{mems}}}({{\mathit{xt}}^\ast}) &amp; \quad \mbox{otherwise} \\[0.8ex]
{\href{../syntax/types.html#syntax-externtype}{\mathrm{globals}}}(\epsilon) &amp; = &amp; \epsilon \\
{\href{../syntax/types.html#syntax-externtype}{\mathrm{globals}}}((\href{../syntax/types.html#syntax-externtype}{\mathsf{global}}~{\mathit{gt}})~{{\mathit{xt}}^\ast}) &amp; = &amp; {\mathit{gt}}~{\href{../syntax/types.html#syntax-externtype}{\mathrm{globals}}}({{\mathit{xt}}^\ast}) \\
{\href{../syntax/types.html#syntax-externtype}{\mathrm{globals}}}({\href{../syntax/types.html#syntax-externtype}{\mathit{externtype}}}~{{\mathit{xt}}^\ast}) &amp; = &amp; {\href{../syntax/types.html#syntax-externtype}{\mathrm{globals}}}({{\mathit{xt}}^\ast}) &amp; \quad \mbox{otherwise} \\[0.8ex]
{\href{../syntax/types.html#syntax-externtype}{\mathrm{tags}}}(\epsilon) &amp; = &amp; \epsilon \\
{\href{../syntax/types.html#syntax-externtype}{\mathrm{tags}}}((\href{../syntax/types.html#syntax-externtype}{\mathsf{tag}}~{\mathit{jt}})~{{\mathit{xt}}^\ast}) &amp; = &amp; {\mathit{jt}}~{\href{../syntax/types.html#syntax-externtype}{\mathrm{tags}}}({{\mathit{xt}}^\ast}) \\
{\href{../syntax/types.html#syntax-externtype}{\mathrm{tags}}}({\href{../syntax/types.html#syntax-externtype}{\mathit{externtype}}}~{{\mathit{xt}}^\ast}) &amp; = &amp; {\href{../syntax/types.html#syntax-externtype}{\mathrm{tags}}}({{\mathit{xt}}^\ast}) &amp; \quad \mbox{otherwise} \\
\end{array}\end{split}\]</div>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;2017-2025, WebAssembly Community Group.
      
    </div>

    

    
  </body>
</html>