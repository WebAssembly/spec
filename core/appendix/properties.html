<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Type Soundness &#8212; WebAssembly 3.0 (2025-10-01)</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=057308f9" />
    <script src="../_static/documentation_options.js?v=909f528b"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>window.MathJax = {"tex": {"maxBuffer": 30720, "macros": {"multicolumn": ["", 2]}}, "options": {"menuOptions": {"settings": {"enrich": false}}}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Validation Algorithm" href="algorithm.html" />
    <link rel="prev" title="Implementation Limitations" href="implementation.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/webassembly.png" alt="Logo of WebAssembly"/>
            </a></p><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../syntax/index.html">Structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../valid/index.html">Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../exec/index.html">Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../binary/index.html">Binary Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../text/index.html">Text Format</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Appendix</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="embedding.html">Embedding</a></li>
<li class="toctree-l2"><a class="reference internal" href="profiles.html">Profiles</a></li>
<li class="toctree-l2"><a class="reference internal" href="implementation.html">Implementation Limitations</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Type Soundness</a></li>
<li class="toctree-l2"><a class="reference internal" href="#type-system-properties">Type System Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="algorithm.html">Validation Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="custom.html">Custom Sections and Annotations</a></li>
<li class="toctree-l2"><a class="reference internal" href="changes.html">Change History</a></li>
<li class="toctree-l2"><a class="reference internal" href="index-types.html">Index of Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="index-instructions.html">Index of Instructions</a></li>
<li class="toctree-l2"><a class="reference internal" href="index-rules.html">Index of Semantic Rules</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index-types.html">Index of Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="index-instructions.html">Index of Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="index-rules.html">Index of Semantic Rules</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="../genindex.html">Index</a></li>
    
    <li class="toctree-l1"><a href="../_download/WebAssembly.pdf">Download as PDF</a></li>
    
</ul>

<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="type-soundness">
<span id="soundness"></span><span id="index-0"></span><h1>Type Soundness<a class="headerlink" href="#type-soundness" title="Link to this heading">¶</a></h1>
<p>The <a class="reference internal" href="../valid/conventions.html#type-system"><span class="std std-ref">type system</span></a> of WebAssembly is <em>sound</em>, implying both <em>type safety</em> and <em>memory safety</em> with respect to the WebAssembly semantics. For example:</p>
<ul class="simple">
<li><p>All types declared and derived during validation are respected at run time;
e.g., every <a class="reference internal" href="../syntax/modules.html#syntax-local"><span class="std std-ref">local</span></a> or <a class="reference internal" href="../syntax/modules.html#syntax-global"><span class="std std-ref">global</span></a> variable will only contain type-correct values, every <a class="reference internal" href="../syntax/instructions.html#syntax-instr"><span class="std std-ref">instruction</span></a> will only be applied to operands of the expected type, and every <a class="reference internal" href="../syntax/modules.html#syntax-func"><span class="std std-ref">function</span></a> <a class="reference internal" href="../exec/modules.html#exec-invocation"><span class="std std-ref">invocation</span></a> always evaluates to a result of the right type (if it does not diverge, throw an exception, or <a class="reference internal" href="../intro/overview.html#trap"><span class="std std-ref">trap</span></a>).</p></li>
<li><p>No memory location will be read or written except those explicitly defined by the program, i.e., as a <a class="reference internal" href="../syntax/modules.html#syntax-local"><span class="std std-ref">local</span></a>, a <a class="reference internal" href="../syntax/modules.html#syntax-global"><span class="std std-ref">global</span></a>, an element in a <a class="reference internal" href="../syntax/modules.html#syntax-table"><span class="std std-ref">table</span></a>, or a location within a linear <a class="reference internal" href="../syntax/modules.html#syntax-mem"><span class="std std-ref">memory</span></a>.</p></li>
<li><p>There is no undefined behavior,
i.e., the <a class="reference internal" href="../exec/index.html#exec"><span class="std std-ref">execution rules</span></a> cover all possible cases that can occur in a <a class="reference internal" href="../valid/index.html#valid"><span class="std std-ref">valid</span></a> program, and the rules are mutually consistent.</p></li>
</ul>
<p>Soundness also is instrumental in ensuring additional properties, most notably, <em>encapsulation</em> of function and module scopes: no <a class="reference internal" href="../syntax/modules.html#syntax-local"><span class="std std-ref">locals</span></a> can be accessed outside their own function and no <a class="reference internal" href="../syntax/modules.html#syntax-module"><span class="std std-ref">module</span></a> components can be accessed outside their own module unless they are explicitly <a class="reference internal" href="../syntax/modules.html#syntax-export"><span class="std std-ref">exported</span></a> or <a class="reference internal" href="../syntax/modules.html#syntax-import"><span class="std std-ref">imported</span></a>.</p>
<p>The typing rules defining WebAssembly <a class="reference internal" href="../valid/index.html#valid"><span class="std std-ref">validation</span></a> only cover the <em>static</em> components of a WebAssembly program.
In order to state and prove soundness precisely, the typing rules must be extended to the <em>dynamic</em> components of the abstract <a class="reference internal" href="../exec/runtime.html#syntax-runtime"><span class="std std-ref">runtime</span></a>, that is, the <a class="reference internal" href="../exec/runtime.html#syntax-store"><span class="std std-ref">store</span></a>, <a class="reference internal" href="../exec/runtime.html#syntax-config"><span class="std std-ref">configurations</span></a>, and <a class="reference internal" href="../exec/runtime.html#syntax-instr-admin"><span class="std std-ref">administrative instructions</span></a>. <a class="footnote-reference brackets" href="#cite-pldi2017" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
<section id="contexts">
<span id="context-ext"></span><span id="index-1"></span><h2>Contexts<a class="headerlink" href="#contexts" title="Link to this heading">¶</a></h2>
<p>In order to check <a class="reference internal" href="../valid/conventions.html#aux-roll-rectype"><span class="std std-ref">rolled up</span></a> recursive types,
the <a class="reference internal" href="../valid/conventions.html#context"><span class="std std-ref">context</span></a> is locally extended with an additional component that records the <a class="reference internal" href="../syntax/types.html#syntax-subtype"><span class="std std-ref">sub type</span></a> corresponding to each <a class="reference internal" href="../valid/conventions.html#syntax-rectypeidx"><span class="std std-ref">recursive type index</span></a> within the current <a class="reference internal" href="../syntax/types.html#syntax-rectype"><span class="std std-ref">recursive type</span></a>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{llll}
\def\mathdef1587#1{{}}\mathdef1587{context} &amp; C &amp;::=&amp;
  \{~ \dots, \href{../appendix/properties.html#context-ext}{\mathsf{recs}} ~ \href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}^\ast ~\} \\
\end{array}\end{split}\]</div>
</section>
<section id="types">
<span id="valid-types-ext"></span><span id="index-2"></span><h2>Types<a class="headerlink" href="#types" title="Link to this heading">¶</a></h2>
<p>Well-formedness for <a class="reference internal" href="../valid/conventions.html#type-ext"><span class="std std-ref">extended type forms</span></a> is defined as follows.</p>
<section id="heap-type-xref-valid-conventions-syntax-heaptype-ext-mathsf-bot">
<span id="valid-heaptype-ext"></span><h3><a class="reference internal" href="../valid/conventions.html#syntax-heaptype-ext"><span class="std std-ref">Heap Type</span></a> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-heaptype-ext}{\mathsf{bot}}\)</span><a class="headerlink" href="#heap-type-xref-valid-conventions-syntax-heaptype-ext-mathsf-bot" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The heap type is valid.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
}{
  C \href{../valid/types.html#valid-heaptype}{\vdash} \href{../valid/conventions.html#syntax-heaptype-ext}{\mathsf{bot}} : \href{../valid/types.html#valid-heaptype}{\mathsf{ok}}
}\]</div>
</section>
<section id="heap-type-xref-syntax-types-syntax-heaptype-mathsf-rec-i">
<h3><a class="reference internal" href="../valid/conventions.html#syntax-heaptype-ext"><span class="std std-ref">Heap Type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-heaptype}{\mathsf{rec}}~i\)</span><a class="headerlink" href="#heap-type-xref-syntax-types-syntax-heaptype-mathsf-rec-i" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The recursive type index <span class="math notranslate nohighlight">\(i\)</span> must exist in <span class="math notranslate nohighlight">\(C.\href{../appendix/properties.html#context-ext}{\mathsf{recs}}\)</span>.</p></li>
<li><p>Then the heap type is valid.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  C.\href{../appendix/properties.html#context-ext}{\mathsf{recs}}[i] = \href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}
}{
  C \href{../valid/types.html#valid-heaptype}{\vdash} \href{../syntax/types.html#syntax-heaptype}{\mathsf{rec}}~i : \href{../valid/types.html#valid-heaptype}{\mathsf{ok}}
}\]</div>
</section>
<section id="value-type-xref-valid-conventions-syntax-valtype-ext-mathsf-bot">
<span id="valid-valtype-ext"></span><h3><a class="reference internal" href="../valid/conventions.html#syntax-valtype-ext"><span class="std std-ref">Value Type</span></a> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-valtype-ext}{\mathsf{bot}}\)</span><a class="headerlink" href="#value-type-xref-valid-conventions-syntax-valtype-ext-mathsf-bot" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The value type is valid.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
}{
  C \href{../valid/types.html#valid-valtype}{\vdash} \href{../valid/conventions.html#syntax-valtype-ext}{\mathsf{bot}} : \href{../valid/types.html#valid-valtype}{\mathsf{ok}}
}\]</div>
</section>
<section id="recursive-types-xref-syntax-types-syntax-rectype-mathsf-rec-xref-syntax-types-syntax-subtype-mathit-subtype-ast">
<span id="valid-rectype-ext"></span><h3><a class="reference internal" href="../syntax/types.html#syntax-rectype"><span class="std std-ref">Recursive Types</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-rectype}{\mathsf{rec}}~\href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}^\ast\)</span><a class="headerlink" href="#recursive-types-xref-syntax-types-syntax-rectype-mathsf-rec-xref-syntax-types-syntax-subtype-mathit-subtype-ast" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>Let <span class="math notranslate nohighlight">\(C'\)</span> be the current <a class="reference internal" href="../valid/conventions.html#context"><span class="std std-ref">context</span></a> <span class="math notranslate nohighlight">\(C\)</span>, but where <span class="math notranslate nohighlight">\(\href{../appendix/properties.html#context-ext}{\mathsf{recs}}\)</span> is <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}^\ast\)</span>.</p></li>
<li><p>There must be a <a class="reference internal" href="../syntax/modules.html#syntax-typeidx"><span class="std std-ref">type index</span></a> <span class="math notranslate nohighlight">\(x\)</span>, such that for each <a class="reference internal" href="../syntax/types.html#syntax-subtype"><span class="std std-ref">sub type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}^\ast\)</span>:</p>
<ul>
<li><p>Under the context <span class="math notranslate nohighlight">\(C'\)</span>, the <a class="reference internal" href="../syntax/types.html#syntax-subtype"><span class="std std-ref">sub type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}_i\)</span> must be <a class="reference internal" href="../valid/types.html#valid-subtype"><span class="std std-ref">valid</span></a> for <a class="reference internal" href="../syntax/modules.html#syntax-typeidx"><span class="std std-ref">type index</span></a> <span class="math notranslate nohighlight">\(x+i\)</span> and <a class="reference internal" href="../valid/conventions.html#syntax-rectypeidx"><span class="std std-ref">recursive type index</span></a> <span class="math notranslate nohighlight">\(i\)</span>.</p></li>
</ul>
</li>
<li><p>Then the recursive type is valid for the <a class="reference internal" href="../syntax/modules.html#syntax-typeidx"><span class="std std-ref">type index</span></a> <span class="math notranslate nohighlight">\(x\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  C,\href{../appendix/properties.html#context-ext}{\mathsf{recs}}~\href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}^\ast \href{../valid/types.html#valid-rectype}{\vdash} \href{../syntax/types.html#syntax-rectype}{\mathsf{rec}}~\href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}^\ast : {\href{../valid/types.html#valid-rectype}{\mathsf{ok}}}(x,0)
}{
  C \href{../valid/types.html#valid-rectype}{\vdash} \href{../syntax/types.html#syntax-rectype}{\mathsf{rec}}~\href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}^\ast : {\href{../valid/types.html#valid-rectype}{\mathsf{ok}}}(x)
}\]</div>
<div class="math notranslate nohighlight">
\[\frac{
}{
  C \href{../valid/types.html#valid-rectype}{\vdash} \href{../syntax/types.html#syntax-rectype}{\mathsf{rec}}~\epsilon : {\href{../valid/types.html#valid-rectype}{\mathsf{ok}}}(x,i)
}
\qquad
\frac{
  C \href{../valid/types.html#valid-subtype}{\vdash} \href{../syntax/types.html#syntax-subtype}{\mathit{subtype}} : {\href{../valid/types.html#valid-subtype}{\mathsf{ok}}}(x,i)
  \qquad
  C \href{../valid/types.html#valid-rectype}{\vdash} \href{../syntax/types.html#syntax-rectype}{\mathsf{rec}}~{\href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}'}^\ast : {\href{../valid/types.html#valid-rectype}{\mathsf{ok}}}(x+1,i+1)
}{
  C \href{../valid/types.html#valid-rectype}{\vdash} \href{../syntax/types.html#syntax-rectype}{\mathsf{rec}}~\href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}~{\href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}'}^\ast : {\href{../valid/types.html#valid-rectype}{\mathsf{ok}}}(x,i)
}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These rules are a generalisation of the ones <a class="reference internal" href="../valid/types.html#valid-rectype"><span class="std std-ref">previously given</span></a>.</p>
</div>
</section>
<section id="sub-types-xref-syntax-types-syntax-subtype-mathsf-sub-xref-syntax-types-syntax-subtype-mathsf-final-mathit-ht-ast-xref-syntax-types-syntax-comptype-mathit-comptype">
<span id="valid-subtype-ext"></span><h3><a class="reference internal" href="../syntax/types.html#syntax-subtype"><span class="std std-ref">Sub types</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-subtype}{\mathsf{sub}}~\href{../syntax/types.html#syntax-subtype}{\mathsf{final}}^?~\mathit{ht}^\ast~\href{../syntax/types.html#syntax-comptype}{\mathit{comptype}}\)</span><a class="headerlink" href="#sub-types-xref-syntax-types-syntax-subtype-mathsf-sub-xref-syntax-types-syntax-subtype-mathsf-final-mathit-ht-ast-xref-syntax-types-syntax-comptype-mathit-comptype" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../syntax/types.html#syntax-comptype"><span class="std std-ref">composite type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-comptype}{\mathit{comptype}}\)</span> must be <a class="reference internal" href="../valid/types.html#valid-comptype"><span class="std std-ref">valid</span></a>.</p></li>
<li><p>The sequence <span class="math notranslate nohighlight">\(\mathit{ht}^\ast\)</span> may be no longer than <span class="math notranslate nohighlight">\(1\)</span>.</p></li>
<li><p>For every <a class="reference internal" href="../syntax/types.html#syntax-heaptype"><span class="std std-ref">heap type</span></a> <span class="math notranslate nohighlight">\(\mathit{ht}_k\)</span> in <span class="math notranslate nohighlight">\(\mathit{ht}^\ast\)</span>:</p>
<ul>
<li><p>The <a class="reference internal" href="../syntax/types.html#syntax-heaptype"><span class="std std-ref">heap type</span></a> <span class="math notranslate nohighlight">\(\mathit{ht}_k\)</span> must be ordered before a <a class="reference internal" href="../syntax/modules.html#syntax-typeidx"><span class="std std-ref">type index</span></a> <span class="math notranslate nohighlight">\(x\)</span> and <a class="reference internal" href="../valid/conventions.html#syntax-rectypeidx"><span class="std std-ref">recursive type index</span></a> a <span class="math notranslate nohighlight">\(i\)</span>, meaning:</p>
<ul>
<li><p>Either <span class="math notranslate nohighlight">\(\mathit{ht}_k\)</span> is a <a class="reference internal" href="../valid/conventions.html#syntax-deftype"><span class="std std-ref">defined type</span></a>.</p></li>
<li><p>Or <span class="math notranslate nohighlight">\(\mathit{ht}_k\)</span> is a <a class="reference internal" href="../syntax/modules.html#syntax-typeidx"><span class="std std-ref">type index</span></a> <span class="math notranslate nohighlight">\(y_k\)</span> that is smaller than <span class="math notranslate nohighlight">\(x\)</span>.</p></li>
<li><p>Or <span class="math notranslate nohighlight">\(\mathit{ht}_k\)</span> is a <a class="reference internal" href="../valid/conventions.html#syntax-rectypeidx"><span class="std std-ref">recursive type index</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-heaptype}{\mathsf{rec}}~j_k\)</span> where <span class="math notranslate nohighlight">\(j_k\)</span> is smaller than <span class="math notranslate nohighlight">\(i\)</span>.</p></li>
</ul>
</li>
<li><p>Let <a class="reference internal" href="../syntax/types.html#syntax-subtype"><span class="std std-ref">sub type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}_k\)</span> be the <a class="reference internal" href="#aux-unroll-heaptype"><span class="std std-ref">unrolling</span></a> of the <a class="reference internal" href="../syntax/types.html#syntax-heaptype"><span class="std std-ref">heap type</span></a> <span class="math notranslate nohighlight">\(\mathit{ht}_k\)</span>, meaning:</p>
<ul>
<li><p>Either <span class="math notranslate nohighlight">\(\mathit{ht}_k\)</span> is a <a class="reference internal" href="../valid/conventions.html#syntax-deftype"><span class="std std-ref">defined type</span></a> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}_k\)</span>, then <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}_k\)</span> must be the <a class="reference internal" href="../valid/conventions.html#aux-unroll-deftype"><span class="std std-ref">unrolling</span></a> of <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}_k\)</span>.</p></li>
<li><p>Or <span class="math notranslate nohighlight">\(\mathit{ht}_k\)</span> is a <a class="reference internal" href="../syntax/modules.html#syntax-typeidx"><span class="std std-ref">type index</span></a> <span class="math notranslate nohighlight">\(y_k\)</span>, then <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}_k\)</span> must be the <a class="reference internal" href="../valid/conventions.html#aux-unroll-deftype"><span class="std std-ref">unrolling</span></a> of the <a class="reference internal" href="../valid/conventions.html#syntax-deftype"><span class="std std-ref">defined type</span></a> <span class="math notranslate nohighlight">\(C.\href{../valid/conventions.html#context}{\mathsf{types}}[y_k]\)</span>.</p></li>
<li><p>Or <span class="math notranslate nohighlight">\(\mathit{ht}_k\)</span> is a <a class="reference internal" href="../valid/conventions.html#syntax-rectypeidx"><span class="std std-ref">recursive type index</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-heaptype}{\mathsf{rec}}~j_k\)</span>, then <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}_k\)</span> must be <span class="math notranslate nohighlight">\(C.\href{../appendix/properties.html#context-ext}{\mathsf{recs}}[j_k]\)</span>.</p></li>
</ul>
</li>
<li><p>The <a class="reference internal" href="../syntax/types.html#syntax-subtype"><span class="std std-ref">sub type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}_k\)</span> must not contain <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-subtype}{\mathsf{final}}\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-comptype}{\mathit{comptype}}'_k\)</span> be the <a class="reference internal" href="../syntax/types.html#syntax-comptype"><span class="std std-ref">composite type</span></a> in <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}_k\)</span>.</p></li>
<li><p>The <a class="reference internal" href="../syntax/types.html#syntax-comptype"><span class="std std-ref">composite type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-comptype}{\mathit{comptype}}\)</span> must <a class="reference internal" href="../valid/matching.html#match-comptype"><span class="std std-ref">match</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-comptype}{\mathit{comptype}}'_k\)</span>.</p></li>
</ul>
</li>
<li><p>Then the sub type is valid for the <a class="reference internal" href="../syntax/modules.html#syntax-typeidx"><span class="std std-ref">type index</span></a> <span class="math notranslate nohighlight">\(x\)</span> and <a class="reference internal" href="../valid/conventions.html#syntax-rectypeidx"><span class="std std-ref">recursive type index</span></a> <span class="math notranslate nohighlight">\(i\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}\frac{
  \begin{array}{&#64;{}c&#64;{}}
  |\mathit{ht}^\ast| \leq 1
  \qquad
  (\mathit{ht} \prec x,i)^\ast
  \qquad
  (\href{../appendix/properties.html#aux-unroll-heaptype}{\mathrm{unroll}}_{C}(\mathit{ht}) = \href{../syntax/types.html#syntax-subtype}{\mathsf{sub}}~{\mathit{ht}'}^\ast~\href{../syntax/types.html#syntax-comptype}{\mathit{comptype}}')^\ast
  \\
  C \href{../valid/types.html#valid-comptype}{\vdash} \href{../syntax/types.html#syntax-comptype}{\mathit{comptype}} : \href{../valid/types.html#valid-comptype}{\mathsf{ok}}
  \qquad
  (C \href{../valid/matching.html#match-comptype}{\vdash} \href{../syntax/types.html#syntax-comptype}{\mathit{comptype}} \href{../valid/matching.html#match-comptype}{\leq} \href{../syntax/types.html#syntax-comptype}{\mathit{comptype}}')^\ast
  \end{array}
}{
  C \href{../valid/types.html#valid-subtype}{\vdash} \href{../syntax/types.html#syntax-subtype}{\mathsf{sub}}~\href{../syntax/types.html#syntax-subtype}{\mathsf{final}}^?~\mathit{ht}^\ast~\href{../syntax/types.html#syntax-comptype}{\mathit{comptype}} : {\href{../valid/types.html#valid-subtype}{\mathsf{ok}}}(x,i)
}\end{split}\]</div>
<p id="aux-unroll-heaptype">where:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{&#64;{}lll&#64;{}}
(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}} \prec x,i) &amp;=&amp; {\mathrm{true}} \\
(y \prec x,i) &amp;=&amp; y &lt; x \\
(\href{../syntax/types.html#syntax-heaptype}{\mathsf{rec}}~j \prec x,i) &amp;=&amp; j &lt; i \\
[2ex]
\href{../appendix/properties.html#aux-unroll-heaptype}{\mathrm{unroll}}_{C}(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}) &amp;=&amp; \href{../valid/conventions.html#aux-unroll-deftype}{\mathrm{unroll}}(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}) \\
\href{../appendix/properties.html#aux-unroll-heaptype}{\mathrm{unroll}}_{C}(y) &amp;=&amp; \href{../valid/conventions.html#aux-unroll-deftype}{\mathrm{unroll}}(C.\href{../valid/conventions.html#context}{\mathsf{types}}[y]) \\
\href{../appendix/properties.html#aux-unroll-heaptype}{\mathrm{unroll}}_{C}(\href{../syntax/types.html#syntax-heaptype}{\mathsf{rec}}~j) &amp;=&amp; C.\href{../appendix/properties.html#context-ext}{\mathsf{recs}}[j] \\
\end{array}\end{split}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This rule is a generalisation of the ones <a class="reference internal" href="../valid/types.html#valid-subtype"><span class="std std-ref">previously given</span></a>, which only allowed type indices as supertypes.</p>
</div>
</section>
<section id="defined-types-xref-syntax-types-syntax-rectype-mathit-rectype-i">
<span id="valid-deftype"></span><span id="index-3"></span><h3><a class="reference internal" href="../valid/conventions.html#syntax-deftype"><span class="std std-ref">Defined types</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-rectype}{\mathit{rectype}}.i\)</span><a class="headerlink" href="#defined-types-xref-syntax-types-syntax-rectype-mathit-rectype-i" title="Link to this heading">¶</a></h3>
<p>The <a class="reference internal" href="../valid/conventions.html#syntax-deftype"><span class="std std-ref">defined type</span></a> <span class="math notranslate nohighlight">\(({\href{../syntax/types.html#syntax-rectype}{\mathit{rectype}}} {.} i)\)</span> is <a class="reference internal" href="#valid-deftype"><span class="std std-ref">valid</span></a> if:</p>
<blockquote>
<div><ul class="simple">
<li><p>The <a class="reference internal" href="../syntax/types.html#syntax-rectype"><span class="std std-ref">recursive type</span></a> <span class="math notranslate nohighlight">\({\href{../syntax/types.html#syntax-rectype}{\mathit{rectype}}}\)</span> is <a class="reference internal" href="../valid/types.html#valid-rectype"><span class="std std-ref">valid</span></a> for the type index <span class="math notranslate nohighlight">\(x\)</span>.</p></li>
<li><p>The <a class="reference internal" href="../syntax/types.html#syntax-rectype"><span class="std std-ref">recursive type</span></a> <span class="math notranslate nohighlight">\({\href{../syntax/types.html#syntax-rectype}{\mathit{rectype}}}\)</span> is of the form <span class="math notranslate nohighlight">\((\href{../syntax/types.html#syntax-rectype}{\mathsf{rec}}~{{\href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}}^{n}})\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(i\)</span> is less than <span class="math notranslate nohighlight">\(n\)</span>.</p></li>
</ul>
</div></blockquote>
<div class="math notranslate nohighlight">
\[\begin{array}{&#64;{}c&#64;{}}\displaystyle
\frac{
C \href{../valid/types.html#valid-rectype}{\vdash} {\href{../syntax/types.html#syntax-rectype}{\mathit{rectype}}} : {\href{../valid/types.html#valid-subtype}{\mathsf{ok}}}{(x)}
 \qquad
{\href{../syntax/types.html#syntax-rectype}{\mathit{rectype}}} = \href{../syntax/types.html#syntax-rectype}{\mathsf{rec}}~{{\href{../syntax/types.html#syntax-subtype}{\mathit{subtype}}}^{n}}
 \qquad
i &lt; n
}{
C \href{../appendix/properties.html#valid-deftype}{\vdash} {\href{../syntax/types.html#syntax-rectype}{\mathit{rectype}}} {.} i : \href{../appendix/properties.html#valid-deftype}{\mathsf{ok}}
}
\qquad
\end{array}\]</div>
</section>
</section>
<section id="subtyping">
<span id="match-heaptype-ext"></span><span id="index-4"></span><h2>Subtyping<a class="headerlink" href="#subtyping" title="Link to this heading">¶</a></h2>
<p>In a <a class="reference internal" href="../valid/conventions.html#aux-roll-rectype"><span class="std std-ref">rolled-up</span></a> <a class="reference internal" href="../syntax/types.html#syntax-rectype"><span class="std std-ref">recursive type</span></a>, a <a class="reference internal" href="../valid/conventions.html#syntax-rectypeidx"><span class="std std-ref">recursive type indices</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-heaptype}{\mathsf{rec}}~i\)</span> <a class="reference internal" href="../valid/matching.html#match-heaptype"><span class="std std-ref">matches</span></a> another <a class="reference internal" href="../syntax/types.html#syntax-heaptype"><span class="std std-ref">heap type</span></a> <span class="math notranslate nohighlight">\(\mathit{ht}\)</span> if:</p>
<ul class="simple">
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-subtype}{\mathsf{sub}}~\href{../syntax/types.html#syntax-subtype}{\mathsf{final}}^?~{\mathit{ht}'}^\ast~\href{../syntax/types.html#syntax-comptype}{\mathit{comptype}}\)</span> be the <a class="reference internal" href="../syntax/types.html#syntax-subtype"><span class="std std-ref">sub type</span></a> <span class="math notranslate nohighlight">\(C.\href{../appendix/properties.html#context-ext}{\mathsf{recs}}[i]\)</span>.</p></li>
<li><p>The heap type <span class="math notranslate nohighlight">\(\mathit{ht}\)</span> is contained in <span class="math notranslate nohighlight">\({\mathit{ht}'}^\ast\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  C.\href{../appendix/properties.html#context-ext}{\mathsf{recs}}[i] = \href{../syntax/types.html#syntax-subtype}{\mathsf{sub}}~\href{../syntax/types.html#syntax-subtype}{\mathsf{final}}^?~(\mathit{ht}_1^\ast~\mathit{ht}~\mathit{ht}_2^\ast)~\href{../syntax/types.html#syntax-comptype}{\mathit{comptype}}
}{
  C \href{../valid/matching.html#match-heaptype}{\vdash} \href{../syntax/types.html#syntax-heaptype}{\mathsf{rec}}~i \href{../valid/matching.html#match-heaptype}{\leq} \mathit{ht}
}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This rule is only invoked when checking <a class="reference internal" href="#valid-rectype-ext"><span class="std std-ref">validity</span></a> of <a class="reference internal" href="../valid/conventions.html#aux-roll-rectype"><span class="std std-ref">rolled-up</span></a> <a class="reference internal" href="../syntax/types.html#syntax-rectype"><span class="std std-ref">recursive types</span></a>.</p>
</div>
</section>
<section id="results">
<span id="valid-result"></span><span id="index-5"></span><h2>Results<a class="headerlink" href="#results" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="../exec/runtime.html#syntax-result"><span class="std std-ref">Results</span></a> can be classified by <a class="reference internal" href="../syntax/types.html#syntax-resulttype"><span class="std std-ref">result types</span></a> as follows.</p>
<section id="results-xref-exec-runtime-syntax-val-mathit-val-ast">
<h3><a class="reference internal" href="../exec/runtime.html#syntax-result"><span class="std std-ref">Results</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast\)</span><a class="headerlink" href="#results-xref-exec-runtime-syntax-val-mathit-val-ast" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-val"><span class="std std-ref">value</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast\)</span>:</p>
<ul>
<li><p>The value <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}_i\)</span> is <a class="reference internal" href="../exec/values.html#valid-val"><span class="std std-ref">valid</span></a> with some <a class="reference internal" href="../syntax/types.html#syntax-valtype"><span class="std std-ref">value type</span></a> <span class="math notranslate nohighlight">\(t_i\)</span>.</p></li>
</ul>
</li>
<li><p>Let <span class="math notranslate nohighlight">\(t^\ast\)</span> be the concatenation of all <span class="math notranslate nohighlight">\(t_i\)</span>.</p></li>
<li><p>Then the result is valid with <a class="reference internal" href="../syntax/types.html#syntax-resulttype"><span class="std std-ref">result type</span></a> <span class="math notranslate nohighlight">\([t^\ast]\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  (S \href{../exec/values.html#valid-val}{\vdash} \href{../exec/runtime.html#syntax-val}{\mathit{val}} : t)^\ast
}{
  S \href{../appendix/properties.html#valid-result}{\vdash} \href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast : [t^\ast]
}\]</div>
</section>
<section id="results-xref-exec-runtime-syntax-ref-mathsf-ref-exn-a-xref-syntax-instructions-syntax-instr-control-mathsf-throw-ref">
<h3><a class="reference internal" href="../exec/runtime.html#syntax-result"><span class="std std-ref">Results</span></a> <span class="math notranslate nohighlight">\((\href{../exec/runtime.html#syntax-ref}{\mathsf{ref{.}exn}}~a)~\href{../syntax/instructions.html#syntax-instr-control}{\mathsf{throw\_ref}}\)</span><a class="headerlink" href="#results-xref-exec-runtime-syntax-ref-mathsf-ref-exn-a-xref-syntax-instructions-syntax-instr-control-mathsf-throw-ref" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The value <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-ref}{\mathsf{ref{.}exn}}~a\)</span> must be <a class="reference internal" href="../exec/values.html#valid-val"><span class="std std-ref">valid</span></a>.</p></li>
<li><p>Then the result is valid with <a class="reference internal" href="../syntax/types.html#syntax-resulttype"><span class="std std-ref">result type</span></a> <span class="math notranslate nohighlight">\([t^\ast]\)</span>, for any <a class="reference internal" href="../valid/types.html#valid-resulttype"><span class="std std-ref">valid</span></a> <a class="reference internal" href="../valid/conventions.html#type-closed"><span class="std std-ref">closed</span></a> <a class="reference internal" href="../syntax/types.html#syntax-resulttype"><span class="std std-ref">result types</span></a>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  S \href{../exec/values.html#valid-val}{\vdash} \href{../exec/runtime.html#syntax-ref}{\mathsf{ref{.}exn}}~a : \href{../syntax/types.html#syntax-reftype}{\mathsf{ref}}~\href{../syntax/types.html#syntax-heaptype}{\mathsf{exn}}
  \qquad
  \href{../valid/types.html#valid-resulttype}{\vdash} [t^\ast] : \href{../valid/types.html#valid-resulttype}{\mathsf{ok}}
}{
  S \href{../appendix/properties.html#valid-result}{\vdash} (\href{../exec/runtime.html#syntax-ref}{\mathsf{ref{.}exn}}~a)~\href{../syntax/instructions.html#syntax-instr-control}{\mathsf{throw\_ref}} : [{t'}^\ast]
}\]</div>
</section>
<section id="results-xref-exec-runtime-syntax-trap-mathsf-trap">
<h3><a class="reference internal" href="../exec/runtime.html#syntax-result"><span class="std std-ref">Results</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-trap}{\mathsf{trap}}\)</span><a class="headerlink" href="#results-xref-exec-runtime-syntax-trap-mathsf-trap" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The result is valid with <a class="reference internal" href="../syntax/types.html#syntax-resulttype"><span class="std std-ref">result type</span></a> <span class="math notranslate nohighlight">\([t^\ast]\)</span>, for any <a class="reference internal" href="../valid/types.html#valid-resulttype"><span class="std std-ref">valid</span></a> <a class="reference internal" href="../valid/conventions.html#type-closed"><span class="std std-ref">closed</span></a> <a class="reference internal" href="../syntax/types.html#syntax-resulttype"><span class="std std-ref">result types</span></a>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  \href{../valid/types.html#valid-resulttype}{\vdash} [t^\ast] : \href{../valid/types.html#valid-resulttype}{\mathsf{ok}}
}{
  S \href{../appendix/properties.html#valid-result}{\vdash} \href{../exec/runtime.html#syntax-trap}{\mathsf{trap}} : [t^\ast]
}\]</div>
</section>
</section>
<section id="store-validity">
<span id="valid-store"></span><span id="module-context"></span><h2>Store Validity<a class="headerlink" href="#store-validity" title="Link to this heading">¶</a></h2>
<p>The following typing rules specify when a runtime <a class="reference internal" href="../exec/runtime.html#syntax-store"><span class="std std-ref">store</span></a> <span class="math notranslate nohighlight">\(S\)</span> is <em>valid</em>.
A valid store must consist of
<a class="reference internal" href="../exec/runtime.html#syntax-taginst"><span class="std std-ref">tag</span></a>,
<a class="reference internal" href="../exec/runtime.html#syntax-globalinst"><span class="std std-ref">global</span></a>,
<a class="reference internal" href="../exec/runtime.html#syntax-meminst"><span class="std std-ref">memory</span></a>,
<a class="reference internal" href="../exec/runtime.html#syntax-tableinst"><span class="std std-ref">table</span></a>,
<a class="reference internal" href="../exec/runtime.html#syntax-funcinst"><span class="std std-ref">function</span></a>,
<a class="reference internal" href="../exec/runtime.html#syntax-datainst"><span class="std std-ref">data</span></a>,
<a class="reference internal" href="../exec/runtime.html#syntax-eleminst"><span class="std std-ref">element</span></a>,
<a class="reference internal" href="../exec/runtime.html#syntax-structinst"><span class="std std-ref">structure</span></a>,
<a class="reference internal" href="../exec/runtime.html#syntax-arrayinst"><span class="std std-ref">array</span></a>,
<a class="reference internal" href="../exec/runtime.html#syntax-exninst"><span class="std std-ref">exception</span></a>,
and
<a class="reference internal" href="../exec/runtime.html#syntax-moduleinst"><span class="std std-ref">module</span></a>
instances that are themselves valid, relative to <span class="math notranslate nohighlight">\(S\)</span>.</p>
<p>To that end, each kind of instance is classified by a respective
<a class="reference internal" href="../syntax/types.html#syntax-tagtype"><span class="std std-ref">tag</span></a>,
<a class="reference internal" href="../syntax/types.html#syntax-globaltype"><span class="std std-ref">global</span></a>,
<a class="reference internal" href="../syntax/types.html#syntax-memtype"><span class="std std-ref">memory</span></a>,
<a class="reference internal" href="../syntax/types.html#syntax-tabletype"><span class="std std-ref">table</span></a>,
<a class="reference internal" href="../syntax/types.html#syntax-functype"><span class="std std-ref">function</span></a>, or
<a class="reference internal" href="../exec/runtime.html#syntax-eleminst"><span class="std std-ref">element</span></a>,
type, or just <span class="math notranslate nohighlight">\(\mathsf{ok}\)</span> in the case of
<a class="reference internal" href="../exec/runtime.html#syntax-datainst"><span class="std std-ref">data</span></a>
<a class="reference internal" href="../exec/runtime.html#syntax-structinst"><span class="std std-ref">structures</span></a>,
<a class="reference internal" href="../exec/runtime.html#syntax-arrayinst"><span class="std std-ref">arrays</span></a>, or
<a class="reference internal" href="../exec/runtime.html#syntax-exninst"><span class="std std-ref">exceptions</span></a>.
Module instances are classified by <em>module contexts</em>, which are regular <a class="reference internal" href="../valid/conventions.html#context"><span class="std std-ref">contexts</span></a> repurposed as module types describing the <a class="reference internal" href="../syntax/modules.html#syntax-index"><span class="std std-ref">index spaces</span></a> defined by a module.</p>
<section id="store-s">
<span id="index-6"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-store"><span class="std std-ref">Store</span></a> <span class="math notranslate nohighlight">\(S\)</span><a class="headerlink" href="#store-s" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>Each <a class="reference internal" href="../exec/runtime.html#syntax-taginst"><span class="std std-ref">tag instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-taginst}{\mathit{taginst}}_i\)</span> in <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{tags}}\)</span> must be <a class="reference internal" href="#valid-taginst"><span class="std std-ref">valid</span></a> with some <a class="reference internal" href="../syntax/types.html#syntax-tagtype"><span class="std std-ref">tag type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-tagtype}{\mathit{tagtype}}_i\)</span>.</p></li>
<li><p>Each <a class="reference internal" href="../exec/runtime.html#syntax-globalinst"><span class="std std-ref">global instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-globalinst}{\mathit{globalinst}}_i\)</span> in <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{globals}}\)</span> must be <a class="reference internal" href="#valid-globalinst"><span class="std std-ref">valid</span></a> with some  <a class="reference internal" href="../syntax/types.html#syntax-globaltype"><span class="std std-ref">global type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-globaltype}{\mathit{globaltype}}_i\)</span>.</p></li>
<li><p>Each <a class="reference internal" href="../exec/runtime.html#syntax-meminst"><span class="std std-ref">memory instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}_i\)</span> in <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{mems}}\)</span> must be <a class="reference internal" href="#valid-meminst"><span class="std std-ref">valid</span></a> with some <a class="reference internal" href="../syntax/types.html#syntax-memtype"><span class="std std-ref">memory type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-memtype}{\mathit{memtype}}_i\)</span>.</p></li>
<li><p>Each <a class="reference internal" href="../exec/runtime.html#syntax-tableinst"><span class="std std-ref">table instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}_i\)</span> in <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{tables}}\)</span> must be <a class="reference internal" href="#valid-tableinst"><span class="std std-ref">valid</span></a> with some <a class="reference internal" href="../syntax/types.html#syntax-tabletype"><span class="std std-ref">table type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-tabletype}{\mathit{tabletype}}_i\)</span>.</p></li>
<li><p>Each <a class="reference internal" href="../exec/runtime.html#syntax-funcinst"><span class="std std-ref">function instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}}_i\)</span> in <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{funcs}}\)</span> must be <a class="reference internal" href="#valid-funcinst"><span class="std std-ref">valid</span></a> with some <a class="reference internal" href="../valid/conventions.html#syntax-deftype"><span class="std std-ref">defined type</span></a> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}_i\)</span>.</p></li>
<li><p>Each <a class="reference internal" href="../exec/runtime.html#syntax-datainst"><span class="std std-ref">data instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-datainst}{\mathit{datainst}}_i\)</span> in <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{datas}}\)</span> must be <a class="reference internal" href="#valid-datainst"><span class="std std-ref">valid</span></a>.</p></li>
<li><p>Each <a class="reference internal" href="../exec/runtime.html#syntax-eleminst"><span class="std std-ref">element instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-eleminst}{\mathit{eleminst}}_i\)</span> in <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{elems}}\)</span> must be <a class="reference internal" href="#valid-eleminst"><span class="std std-ref">valid</span></a> with some <a class="reference internal" href="../syntax/types.html#syntax-reftype"><span class="std std-ref">reference type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-reftype}{\mathit{reftype}}_i\)</span>.</p></li>
<li><p>Each <a class="reference internal" href="../exec/runtime.html#syntax-structinst"><span class="std std-ref">structure instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-structinst}{\mathit{structinst}}_i\)</span> in <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{structs}}\)</span> must be <a class="reference internal" href="#valid-structinst"><span class="std std-ref">valid</span></a>.</p></li>
<li><p>Each <a class="reference internal" href="../exec/runtime.html#syntax-arrayinst"><span class="std std-ref">array instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-arrayinst}{\mathit{arrayinst}}_i\)</span> in <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{arrays}}\)</span> must be <a class="reference internal" href="#valid-arrayinst"><span class="std std-ref">valid</span></a>.</p></li>
<li><p>Each <a class="reference internal" href="../exec/runtime.html#syntax-exninst"><span class="std std-ref">exception instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-exninst}{\mathit{exninst}}_i\)</span> in <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{exns}}\)</span> must be <a class="reference internal" href="#valid-exninst"><span class="std std-ref">valid</span></a>.</p></li>
<li><p>No <a class="reference internal" href="../exec/runtime.html#syntax-ref"><span class="std std-ref">reference</span></a> to a bound <a class="reference internal" href="../exec/runtime.html#syntax-structaddr"><span class="std std-ref">structure address</span></a> must be reachable from itself through a path consisting only of indirections through immutable structure, or array <a class="reference internal" href="../syntax/types.html#syntax-fieldtype"><span class="std std-ref">fields</span></a> or fields of <a class="reference internal" href="../exec/runtime.html#syntax-exninst"><span class="std std-ref">exception instances</span></a>.</p></li>
<li><p>No <a class="reference internal" href="../exec/runtime.html#syntax-ref"><span class="std std-ref">reference</span></a> to a bound <a class="reference internal" href="../exec/runtime.html#syntax-arrayaddr"><span class="std std-ref">array address</span></a> must be reachable from itself through a path consisting only of indirections through immutable structure or array <a class="reference internal" href="../syntax/types.html#syntax-fieldtype"><span class="std std-ref">fields</span></a> or fields of <a class="reference internal" href="../exec/runtime.html#syntax-exninst"><span class="std std-ref">exception instances</span></a>.</p></li>
<li><p>No <a class="reference internal" href="../exec/runtime.html#syntax-ref"><span class="std std-ref">reference</span></a> to a bound <a class="reference internal" href="../exec/runtime.html#syntax-exnaddr"><span class="std std-ref">exception address</span></a> must be reachable from itself through a path consisting only of indirections through immutable structure or array <a class="reference internal" href="../syntax/types.html#syntax-fieldtype"><span class="std std-ref">fields</span></a> or fields of <a class="reference internal" href="../exec/runtime.html#syntax-exninst"><span class="std std-ref">exception instances</span></a>.</p></li>
<li><p>Then the store is valid.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}~\\[-1ex]
\frac{
  \begin{array}{&#64;{}c&#64;{}}
  (S \href{../appendix/properties.html#valid-taginst}{\vdash} \href{../exec/runtime.html#syntax-taginst}{\mathit{taginst}} : \href{../syntax/types.html#syntax-tagtype}{\mathit{tagtype}})^\ast
  \qquad
  (S \href{../appendix/properties.html#valid-globalinst}{\vdash} \href{../exec/runtime.html#syntax-globalinst}{\mathit{globalinst}} : \href{../syntax/types.html#syntax-globaltype}{\mathit{globaltype}})^\ast
  \\
  (S \href{../appendix/properties.html#valid-meminst}{\vdash} \href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}} : \href{../syntax/types.html#syntax-memtype}{\mathit{memtype}})^\ast
  \qquad
  (S \href{../appendix/properties.html#valid-tableinst}{\vdash} \href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}} : \href{../syntax/types.html#syntax-tabletype}{\mathit{tabletype}})^\ast
  \\
  (S \href{../appendix/properties.html#valid-funcinst}{\vdash} \href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}} : \href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}})^\ast
  \qquad
  (S \href{../appendix/properties.html#valid-datainst}{\vdash} \href{../exec/runtime.html#syntax-datainst}{\mathit{datainst}} : \href{../appendix/properties.html#valid-datainst}{\mathsf{ok}})^\ast
  \qquad
  (S \href{../appendix/properties.html#valid-eleminst}{\vdash} \href{../exec/runtime.html#syntax-eleminst}{\mathit{eleminst}} : \href{../syntax/types.html#syntax-reftype}{\mathit{reftype}})^\ast
  \\
  (S \href{../appendix/properties.html#valid-structinst}{\vdash} \href{../exec/runtime.html#syntax-structinst}{\mathit{structinst}} : \href{../appendix/properties.html#valid-structinst}{\mathsf{ok}})^\ast
  \qquad
  (S \href{../appendix/properties.html#valid-arrayinst}{\vdash} \href{../exec/runtime.html#syntax-arrayinst}{\mathit{arrayinst}} : \href{../appendix/properties.html#valid-arrayinst}{\mathsf{ok}})^\ast
  \qquad
  (S \href{../appendix/properties.html#valid-exninst}{\vdash} \href{../exec/runtime.html#syntax-exninst}{\mathit{exninst}} : \href{../appendix/properties.html#valid-exninst}{\mathsf{ok}})^\ast
  \\
  S = \{
    \begin{array}[t]{&#64;{}l&#64;{}}
    \href{../exec/runtime.html#syntax-store}{\mathsf{tags}}~\href{../exec/runtime.html#syntax-taginst}{\mathit{taginst}}^\ast,
    \href{../exec/runtime.html#syntax-store}{\mathsf{globals}}~\href{../exec/runtime.html#syntax-globalinst}{\mathit{globalinst}}^\ast,
    \href{../exec/runtime.html#syntax-store}{\mathsf{mems}}~\href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}^\ast,
    \href{../exec/runtime.html#syntax-store}{\mathsf{tables}}~\href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}^\ast,
    \href{../exec/runtime.html#syntax-store}{\mathsf{funcs}}~\href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}}^\ast, \\
    \href{../exec/runtime.html#syntax-store}{\mathsf{datas}}~\href{../exec/runtime.html#syntax-datainst}{\mathit{datainst}}^\ast,
    \href{../exec/runtime.html#syntax-store}{\mathsf{elems}}~\href{../exec/runtime.html#syntax-eleminst}{\mathit{eleminst}}^\ast,
    \href{../exec/runtime.html#syntax-store}{\mathsf{structs}}~\href{../exec/runtime.html#syntax-structinst}{\mathit{structinst}}^\ast,
    \href{../exec/runtime.html#syntax-store}{\mathsf{arrays}}~\href{../exec/runtime.html#syntax-arrayinst}{\mathit{arrayinst}}^\ast,
    \href{../exec/runtime.html#syntax-store}{\mathsf{exns}}~\href{../exec/runtime.html#syntax-exninst}{\mathit{exninst}}^\ast \}
    \end{array}
  \\
  (S.\href{../exec/runtime.html#syntax-store}{\mathsf{structs}}[a_{\mathrm{s}}] = \href{../exec/runtime.html#syntax-structinst}{\mathit{structinst}})^\ast
  \qquad
  ((\href{../exec/runtime.html#syntax-ref}{\mathsf{ref{.}struct}}~a_{\mathrm{s}}) \not\gg^+_S (\href{../exec/runtime.html#syntax-ref}{\mathsf{ref{.}struct}}~a_{\mathrm{s}}))^\ast
  \\
  (S.\href{../exec/runtime.html#syntax-store}{\mathsf{arrays}}[a_{\mathrm{a}}] = \href{../exec/runtime.html#syntax-arrayinst}{\mathit{arrayinst}})^\ast
  \qquad
  ((\href{../exec/runtime.html#syntax-ref}{\mathsf{ref{.}array}}~a_{\mathrm{a}}) \not\gg^+_S (\href{../exec/runtime.html#syntax-ref}{\mathsf{ref{.}array}}~a_{\mathrm{a}}))^\ast
  \\
  (S.\href{../exec/runtime.html#syntax-store}{\mathsf{exns}}[a_{\mathrm{e}}] = \href{../exec/runtime.html#syntax-exninst}{\mathit{exninst}})^\ast
  \qquad
  ((\href{../exec/runtime.html#syntax-ref}{\mathsf{ref{.}exn}}~a_{\mathrm{e}}) \not\gg^+_S (\href{../exec/runtime.html#syntax-ref}{\mathsf{ref{.}exn}}~a_{\mathrm{e}}))^\ast
  \end{array}
}{
  \href{../appendix/properties.html#valid-store}{\vdash} S : \href{../appendix/properties.html#valid-store}{\mathsf{ok}}
}\end{split}\]</div>
<p id="index-7">where <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}_1 \gg^+_S \href{../exec/runtime.html#syntax-val}{\mathit{val}}_2\)</span> denotes the transitive closure of the following <em>immutable reachability</em> relation on <a class="reference internal" href="../exec/runtime.html#syntax-val"><span class="std std-ref">values</span></a>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{&#64;{}lcll&#64;{}}
(\href{../exec/runtime.html#syntax-ref}{\mathsf{ref{.}struct}}~a) &amp;\gg_S&amp; S.\href{../exec/runtime.html#syntax-store}{\mathsf{structs}}[a].\href{../exec/runtime.html#syntax-structinst}{\mathsf{fields}}[i]
  &amp; \mathrel{\mbox{if}} \href{../valid/conventions.html#aux-expand-deftype}{\mathrm{expand}}(S.\href{../exec/runtime.html#syntax-store}{\mathsf{structs}}[a].\href{../exec/runtime.html#syntax-structinst}{\mathsf{type}}) = \href{../syntax/types.html#syntax-comptype}{\mathsf{struct}}~\mathit{ft}_1^i~\mathit{st}~\mathit{ft}_2^\ast \\
(\href{../exec/runtime.html#syntax-ref}{\mathsf{ref{.}array}}~a) &amp;\gg_S&amp; S.\href{../exec/runtime.html#syntax-store}{\mathsf{arrays}}[a].\href{../exec/runtime.html#syntax-arrayinst}{\mathsf{fields}}[i]
  &amp; \mathrel{\mbox{if}} \href{../valid/conventions.html#aux-expand-deftype}{\mathrm{expand}}(S.\href{../exec/runtime.html#syntax-store}{\mathsf{arrays}}[a].\href{../exec/runtime.html#syntax-arrayinst}{\mathsf{type}}) = \href{../syntax/types.html#syntax-comptype}{\mathsf{array}}~\mathit{st} \\
(\href{../exec/runtime.html#syntax-ref}{\mathsf{ref{.}exn}}~a) &amp;\gg_S&amp; S.\href{../exec/runtime.html#syntax-store}{\mathsf{exns}}[a].\href{../exec/runtime.html#syntax-exninst}{\mathsf{fields}}[i] \\
(\href{../exec/runtime.html#syntax-ref}{\mathsf{ref{.}extern}}~\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}) &amp;\gg_S&amp; \href{../exec/runtime.html#syntax-ref}{\mathit{ref}} \\
\end{array}\end{split}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The constraint on reachability through immutable fields prevents the presence of cyclic data structures that can not be constructed in the language.
Cycles can only be formed using mutation.</p>
</div>
</section>
<section id="tag-instances-xref-exec-runtime-syntax-taginst-mathsf-type-xref-syntax-types-syntax-tagtype-mathit-tagtype">
<span id="valid-taginst"></span><span id="index-8"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-taginst"><span class="std std-ref">Tag Instances</span></a> <span class="math notranslate nohighlight">\(\{ \href{../exec/runtime.html#syntax-taginst}{\mathsf{type}}~\href{../syntax/types.html#syntax-tagtype}{\mathit{tagtype}} \}\)</span><a class="headerlink" href="#tag-instances-xref-exec-runtime-syntax-taginst-mathsf-type-xref-syntax-types-syntax-tagtype-mathit-tagtype" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../syntax/types.html#syntax-tagtype"><span class="std std-ref">tag type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-tagtype}{\mathit{tagtype}}\)</span> must be <a class="reference internal" href="../valid/types.html#valid-tagtype"><span class="std std-ref">valid</span></a> under the empty <a class="reference internal" href="../valid/conventions.html#context"><span class="std std-ref">context</span></a>.</p></li>
<li><p>Then the tag instance is valid with <a class="reference internal" href="../syntax/types.html#syntax-tagtype"><span class="std std-ref">tag type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-tagtype}{\mathit{tagtype}}\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  \href{../valid/types.html#valid-tagtype}{\vdash} \href{../syntax/types.html#syntax-tagtype}{\mathit{tagtype}} : \href{../valid/types.html#valid-tagtype}{\mathsf{ok}}
}{
  S \href{../appendix/properties.html#valid-taginst}{\vdash} \{ \href{../exec/runtime.html#syntax-taginst}{\mathsf{type}}~\href{../syntax/types.html#syntax-tagtype}{\mathit{tagtype}} \} : \href{../syntax/types.html#syntax-tagtype}{\mathit{tagtype}}
}\]</div>
</section>
<section id="global-instances-xref-exec-runtime-syntax-globalinst-mathsf-type-xref-syntax-types-syntax-mut-mathit-mut-t-xref-exec-runtime-syntax-globalinst-mathsf-value-xref-exec-runtime-syntax-val-mathit-val">
<span id="valid-globalinst"></span><span id="index-9"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-globalinst"><span class="std std-ref">Global Instances</span></a> <span class="math notranslate nohighlight">\(\{ \href{../exec/runtime.html#syntax-globalinst}{\mathsf{type}}~\href{../syntax/types.html#syntax-mut}{\mathit{mut}}~t, \href{../exec/runtime.html#syntax-globalinst}{\mathsf{value}}~\href{../exec/runtime.html#syntax-val}{\mathit{val}} \}\)</span><a class="headerlink" href="#global-instances-xref-exec-runtime-syntax-globalinst-mathsf-type-xref-syntax-types-syntax-mut-mathit-mut-t-xref-exec-runtime-syntax-globalinst-mathsf-value-xref-exec-runtime-syntax-val-mathit-val" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../syntax/types.html#syntax-globaltype"><span class="std std-ref">global type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-mut}{\mathit{mut}}~t\)</span> must be <a class="reference internal" href="../valid/types.html#valid-globaltype"><span class="std std-ref">valid</span></a> under the empty <a class="reference internal" href="../valid/conventions.html#context"><span class="std std-ref">context</span></a>.</p></li>
<li><p>The <a class="reference internal" href="../exec/runtime.html#syntax-val"><span class="std std-ref">value</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}\)</span> must be <a class="reference internal" href="../exec/values.html#valid-val"><span class="std std-ref">valid</span></a> with some <a class="reference internal" href="../syntax/types.html#syntax-valtype"><span class="std std-ref">value type</span></a> <span class="math notranslate nohighlight">\(t'\)</span>.</p></li>
<li><p>The <a class="reference internal" href="../syntax/types.html#syntax-valtype"><span class="std std-ref">value type</span></a> <span class="math notranslate nohighlight">\(t'\)</span> must <a class="reference internal" href="../valid/matching.html#match-valtype"><span class="std std-ref">match</span></a> the <a class="reference internal" href="../syntax/types.html#syntax-valtype"><span class="std std-ref">value type</span></a> <span class="math notranslate nohighlight">\(t\)</span>.</p></li>
<li><p>Then the global instance is valid with <a class="reference internal" href="../syntax/types.html#syntax-globaltype"><span class="std std-ref">global type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-mut}{\mathit{mut}}~t\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  \href{../valid/types.html#valid-globaltype}{\vdash} \href{../syntax/types.html#syntax-mut}{\mathit{mut}}~t : \href{../valid/types.html#valid-globaltype}{\mathsf{ok}}
  \qquad
  S \href{../exec/values.html#valid-val}{\vdash} \href{../exec/runtime.html#syntax-val}{\mathit{val}} : t'
  \qquad
  \href{../valid/matching.html#match-valtype}{\vdash} t' \href{../valid/matching.html#match-valtype}{\leq} t
}{
  S \href{../appendix/properties.html#valid-globalinst}{\vdash} \{ \href{../exec/runtime.html#syntax-globalinst}{\mathsf{type}}~\href{../syntax/types.html#syntax-mut}{\mathit{mut}}~t, \href{../exec/runtime.html#syntax-globalinst}{\mathsf{value}}~\href{../exec/runtime.html#syntax-val}{\mathit{val}} \} : \href{../syntax/types.html#syntax-mut}{\mathit{mut}}~t
}\]</div>
</section>
<section id="memory-instances-xref-exec-runtime-syntax-meminst-mathsf-type-xref-syntax-types-syntax-addrtype-mathit-addrtype-xref-syntax-types-syntax-limits-mathit-limits-xref-exec-runtime-syntax-meminst-mathsf-bytes-b-ast">
<span id="valid-meminst"></span><span id="index-10"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-meminst"><span class="std std-ref">Memory Instances</span></a> <span class="math notranslate nohighlight">\(\{ \href{../exec/runtime.html#syntax-meminst}{\mathsf{type}}~(\href{../syntax/types.html#syntax-addrtype}{\mathit{addrtype}}~\href{../syntax/types.html#syntax-limits}{\mathit{limits}}), \href{../exec/runtime.html#syntax-meminst}{\mathsf{bytes}}~b^\ast \}\)</span><a class="headerlink" href="#memory-instances-xref-exec-runtime-syntax-meminst-mathsf-type-xref-syntax-types-syntax-addrtype-mathit-addrtype-xref-syntax-types-syntax-limits-mathit-limits-xref-exec-runtime-syntax-meminst-mathsf-bytes-b-ast" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../syntax/types.html#syntax-memtype"><span class="std std-ref">memory type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-addrtype}{\mathit{addrtype}}~\href{../syntax/types.html#syntax-limits}{\mathit{limits}}\)</span> must be <a class="reference internal" href="../valid/types.html#valid-memtype"><span class="std std-ref">valid</span></a> under the empty <a class="reference internal" href="../valid/conventions.html#context"><span class="std std-ref">context</span></a>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-limits}{\mathit{limits}}\)</span> be <span class="math notranslate nohighlight">\([n\,{..}\,m]\)</span>.</p></li>
<li><p>The length of <span class="math notranslate nohighlight">\(b^\ast\)</span> must equal <span class="math notranslate nohighlight">\(m\)</span> multiplied by the <a class="reference internal" href="../exec/runtime.html#page-size"><span class="std std-ref">page size</span></a> <span class="math notranslate nohighlight">\(64\,\mathrm{Ki}\)</span>.</p></li>
<li><p>Then the memory instance is valid with <a class="reference internal" href="../syntax/types.html#syntax-memtype"><span class="std std-ref">memory type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-addrtype}{\mathit{addrtype}}~\href{../syntax/types.html#syntax-limits}{\mathit{limits}}\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  \href{../valid/types.html#valid-memtype}{\vdash} \href{../syntax/types.html#syntax-addrtype}{\mathit{addrtype}}~[n\,{..}\,m] : \href{../valid/types.html#valid-memtype}{\mathsf{ok}}
  \qquad
  |b^\ast| = n \cdot 64\,\mathrm{Ki}
}{
  S \href{../appendix/properties.html#valid-meminst}{\vdash} \{ \href{../exec/runtime.html#syntax-meminst}{\mathsf{type}}~(\href{../syntax/types.html#syntax-addrtype}{\mathit{addrtype}}~[n\,{..}\,m]), \href{../exec/runtime.html#syntax-meminst}{\mathsf{bytes}}~b^\ast \} : \href{../syntax/types.html#syntax-addrtype}{\mathit{addrtype}}~[n\,{..}\,m]
}\]</div>
</section>
<section id="table-instances-xref-exec-runtime-syntax-tableinst-mathsf-type-xref-syntax-types-syntax-addrtype-mathit-addrtype-xref-syntax-types-syntax-limits-mathit-limits-t-xref-exec-runtime-syntax-tableinst-mathsf-elem-xref-exec-runtime-syntax-ref-mathit-ref-ast">
<span id="valid-tableinst"></span><span id="index-11"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-tableinst"><span class="std std-ref">Table Instances</span></a> <span class="math notranslate nohighlight">\(\{ \href{../exec/runtime.html#syntax-tableinst}{\mathsf{type}}~(\href{../syntax/types.html#syntax-addrtype}{\mathit{addrtype}}~\href{../syntax/types.html#syntax-limits}{\mathit{limits}}~t), \href{../exec/runtime.html#syntax-tableinst}{\mathsf{elem}}~\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^\ast \}\)</span><a class="headerlink" href="#table-instances-xref-exec-runtime-syntax-tableinst-mathsf-type-xref-syntax-types-syntax-addrtype-mathit-addrtype-xref-syntax-types-syntax-limits-mathit-limits-t-xref-exec-runtime-syntax-tableinst-mathsf-elem-xref-exec-runtime-syntax-ref-mathit-ref-ast" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../syntax/types.html#syntax-tabletype"><span class="std std-ref">table type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-addrtype}{\mathit{addrtype}}~\href{../syntax/types.html#syntax-limits}{\mathit{limits}}~t\)</span> must be <a class="reference internal" href="../valid/types.html#valid-tabletype"><span class="std std-ref">valid</span></a> under the empty <a class="reference internal" href="../valid/conventions.html#context"><span class="std std-ref">context</span></a>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-limits}{\mathit{limits}}\)</span> be <span class="math notranslate nohighlight">\([n\,{..}\,m]\)</span>.</p></li>
<li><p>The length of <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^\ast\)</span> must equal <span class="math notranslate nohighlight">\(n\)</span>.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-ref"><span class="std std-ref">reference</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}_i\)</span> in the table’s elements <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^n\)</span>:</p>
<ul>
<li><p>The <a class="reference internal" href="../exec/runtime.html#syntax-ref"><span class="std std-ref">reference</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}_i\)</span> must be <a class="reference internal" href="../exec/values.html#valid-ref"><span class="std std-ref">valid</span></a> with some <a class="reference internal" href="../syntax/types.html#syntax-reftype"><span class="std std-ref">reference type</span></a> <span class="math notranslate nohighlight">\(t'_i\)</span>.</p></li>
<li><p>The <a class="reference internal" href="../syntax/types.html#syntax-reftype"><span class="std std-ref">reference type</span></a> <span class="math notranslate nohighlight">\(t'_i\)</span> must <a class="reference internal" href="../valid/matching.html#match-reftype"><span class="std std-ref">match</span></a> the <a class="reference internal" href="../syntax/types.html#syntax-reftype"><span class="std std-ref">reference type</span></a> <span class="math notranslate nohighlight">\(t\)</span>.</p></li>
</ul>
</li>
<li><p>Then the table instance is valid with <a class="reference internal" href="../syntax/types.html#syntax-tabletype"><span class="std std-ref">table type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-addrtype}{\mathit{addrtype}}~\href{../syntax/types.html#syntax-limits}{\mathit{limits}}~t\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  \href{../valid/types.html#valid-tabletype}{\vdash} \href{../syntax/types.html#syntax-addrtype}{\mathit{addrtype}}~[n\,{..}\,m]~t : \href{../valid/types.html#valid-tabletype}{\mathsf{ok}}
  \qquad
  |\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^\ast| = n
  \qquad
  (S \vdash \href{../exec/runtime.html#syntax-ref}{\mathit{ref}} : t')^\ast
  \qquad
  (\href{../valid/matching.html#match-reftype}{\vdash} t' \href{../valid/matching.html#match-valtype}{\leq} t)^\ast
}{
  S \href{../appendix/properties.html#valid-tableinst}{\vdash} \{ \href{../exec/runtime.html#syntax-tableinst}{\mathsf{type}}~(\href{../syntax/types.html#syntax-addrtype}{\mathit{addrtype}}~[n\,{..}\,m]~t), \href{../exec/runtime.html#syntax-tableinst}{\mathsf{elem}}~\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^\ast \} : \href{../syntax/types.html#syntax-addrtype}{\mathit{addrtype}}~[n\,{..}\,m]~t
}\]</div>
</section>
<section id="function-instances-xref-exec-runtime-syntax-funcinst-mathsf-type-xref-valid-conventions-syntax-deftype-mathit-deftype-xref-exec-runtime-syntax-funcinst-mathsf-module-xref-exec-runtime-syntax-moduleinst-mathit-moduleinst-xref-exec-runtime-syntax-funcinst-mathsf-code-xref-syntax-modules-syntax-func-mathit-func">
<span id="valid-funcinst"></span><span id="index-12"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-funcinst"><span class="std std-ref">Function Instances</span></a> <span class="math notranslate nohighlight">\(\{\href{../exec/runtime.html#syntax-funcinst}{\mathsf{type}}~\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}, \href{../exec/runtime.html#syntax-funcinst}{\mathsf{module}}~\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}, \href{../exec/runtime.html#syntax-funcinst}{\mathsf{code}}~\href{../syntax/modules.html#syntax-func}{\mathit{func}}\}\)</span><a class="headerlink" href="#function-instances-xref-exec-runtime-syntax-funcinst-mathsf-type-xref-valid-conventions-syntax-deftype-mathit-deftype-xref-exec-runtime-syntax-funcinst-mathsf-module-xref-exec-runtime-syntax-moduleinst-mathit-moduleinst-xref-exec-runtime-syntax-funcinst-mathsf-code-xref-syntax-modules-syntax-func-mathit-func" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../valid/conventions.html#syntax-deftype"><span class="std std-ref">defined type</span></a> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}\)</span> must be <a class="reference internal" href="#valid-deftype"><span class="std std-ref">valid</span></a> under an empty <a class="reference internal" href="../valid/conventions.html#context"><span class="std std-ref">context</span></a>.</p></li>
<li><p>The <a class="reference internal" href="../exec/runtime.html#syntax-moduleinst"><span class="std std-ref">module instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}\)</span> must be <a class="reference internal" href="#valid-moduleinst"><span class="std std-ref">valid</span></a> with some <a class="reference internal" href="../valid/conventions.html#context"><span class="std std-ref">context</span></a> <span class="math notranslate nohighlight">\(C\)</span>.</p></li>
<li><p>Under <a class="reference internal" href="../valid/conventions.html#context"><span class="std std-ref">context</span></a> <span class="math notranslate nohighlight">\(C\)</span>:</p>
<ul>
<li><p>The <a class="reference internal" href="../syntax/modules.html#syntax-func"><span class="std std-ref">function</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-func}{\mathit{func}}\)</span> must be <a class="reference internal" href="../valid/modules.html#valid-func"><span class="std std-ref">valid</span></a> with some <a class="reference internal" href="../valid/conventions.html#syntax-deftype"><span class="std std-ref">defined type</span></a> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}'\)</span>.</p></li>
<li><p>The <a class="reference internal" href="../valid/conventions.html#syntax-deftype"><span class="std std-ref">defined type</span></a> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}'\)</span> must <a class="reference internal" href="../valid/matching.html#match-deftype"><span class="std std-ref">match</span></a> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}\)</span>.</p></li>
</ul>
</li>
<li><p>Then the function instance is valid with <a class="reference internal" href="../valid/conventions.html#syntax-deftype"><span class="std std-ref">defined type</span></a> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}\frac{
  \begin{array}{&#64;{}c&#64;{}}
  \href{../appendix/properties.html#valid-deftype}{\vdash} \href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}} : \href{../appendix/properties.html#valid-deftype}{\mathsf{ok}}
  \qquad
  S \href{../appendix/properties.html#valid-moduleinst}{\vdash} \href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}} : C
  \\
  C \href{../valid/modules.html#valid-func}{\vdash} \href{../syntax/modules.html#syntax-func}{\mathit{func}} : \href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}'
  \qquad
  C \href{../valid/matching.html#match-deftype}{\vdash} \href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}' \href{../valid/matching.html#match-deftype}{\leq} \href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}
  \end{array}
}{
  S \href{../appendix/properties.html#valid-funcinst}{\vdash} \{\href{../exec/runtime.html#syntax-funcinst}{\mathsf{type}}~\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}, \href{../exec/runtime.html#syntax-funcinst}{\mathsf{module}}~\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}, \href{../exec/runtime.html#syntax-funcinst}{\mathsf{code}}~\href{../syntax/modules.html#syntax-func}{\mathit{func}}\} : \href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}
}\end{split}\]</div>
</section>
<section id="host-function-instances-xref-exec-runtime-syntax-funcinst-mathsf-type-xref-valid-conventions-syntax-deftype-mathit-deftype-xref-exec-runtime-syntax-funcinst-mathsf-hostfunc-mathit-hf">
<span id="valid-hostfuncinst"></span><span id="index-13"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-funcinst"><span class="std std-ref">Host Function Instances</span></a> <span class="math notranslate nohighlight">\(\{\href{../exec/runtime.html#syntax-funcinst}{\mathsf{type}}~\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}, \href{../exec/runtime.html#syntax-funcinst}{\mathsf{hostfunc}}~\mathit{hf}\}\)</span><a class="headerlink" href="#host-function-instances-xref-exec-runtime-syntax-funcinst-mathsf-type-xref-valid-conventions-syntax-deftype-mathit-deftype-xref-exec-runtime-syntax-funcinst-mathsf-hostfunc-mathit-hf" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../valid/conventions.html#syntax-deftype"><span class="std std-ref">defined type</span></a> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}\)</span> must be <a class="reference internal" href="#valid-deftype"><span class="std std-ref">valid</span></a> under an empty <a class="reference internal" href="../valid/conventions.html#context"><span class="std std-ref">context</span></a>.</p></li>
<li><p>The <a class="reference internal" href="../valid/conventions.html#aux-expand-deftype"><span class="std std-ref">expansion</span></a> of <a class="reference internal" href="../valid/conventions.html#syntax-deftype"><span class="std std-ref">defined type</span></a> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}\)</span> must be some <a class="reference internal" href="../syntax/types.html#syntax-functype"><span class="std std-ref">function type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-comptype}{\mathsf{func}}~[t_1^\ast] \href{../syntax/types.html#syntax-comptype}{\rightarrow} [t_2^\ast]\)</span>.</p></li>
<li><p>For every <a class="reference internal" href="#valid-store"><span class="std std-ref">valid</span></a> <a class="reference internal" href="../exec/runtime.html#syntax-store"><span class="std std-ref">store</span></a> <span class="math notranslate nohighlight">\(S_1\)</span> <a class="reference internal" href="#extend-store"><span class="std std-ref">extending</span></a> <span class="math notranslate nohighlight">\(S\)</span> and every sequence <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast\)</span> of <a class="reference internal" href="../exec/runtime.html#syntax-val"><span class="std std-ref">values</span></a> whose <a class="reference internal" href="../exec/values.html#valid-val"><span class="std std-ref">types</span></a> coincide with <span class="math notranslate nohighlight">\(t_1^\ast\)</span>:</p>
<ul>
<li><p><a class="reference internal" href="../exec/instructions.html#exec-invoke-host"><span class="std std-ref">Executing</span></a> <span class="math notranslate nohighlight">\(\mathit{hf}\)</span> in store <span class="math notranslate nohighlight">\(S_1\)</span> with arguments <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast\)</span> has a non-empty set of possible outcomes.</p></li>
<li><p>For every element <span class="math notranslate nohighlight">\(R\)</span> of this set:</p>
<ul>
<li><p>Either <span class="math notranslate nohighlight">\(R\)</span> must be <span class="math notranslate nohighlight">\(\bot\)</span> (i.e., divergence).</p></li>
<li><p>Or <span class="math notranslate nohighlight">\(R\)</span> consists of a <a class="reference internal" href="#valid-store"><span class="std std-ref">valid</span></a> <a class="reference internal" href="../exec/runtime.html#syntax-store"><span class="std std-ref">store</span></a> <span class="math notranslate nohighlight">\(S_2\)</span> <a class="reference internal" href="#extend-store"><span class="std std-ref">extending</span></a> <span class="math notranslate nohighlight">\(S_1\)</span> and a <a class="reference internal" href="../exec/runtime.html#syntax-result"><span class="std std-ref">result</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-result}{\mathit{result}}\)</span> whose <a class="reference internal" href="#valid-result"><span class="std std-ref">type</span></a> coincides with <span class="math notranslate nohighlight">\([t_2^\ast]\)</span>.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Then the function instance is valid with <a class="reference internal" href="../valid/conventions.html#syntax-deftype"><span class="std std-ref">defined type</span></a> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}\frac{
  \begin{array}[b]{&#64;{}r&#64;{}}
  \href{../appendix/properties.html#valid-deftype}{\vdash} \href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}} : \href{../appendix/properties.html#valid-deftype}{\mathsf{ok}}
  \\
  \href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}} \approx \href{../syntax/types.html#syntax-comptype}{\mathsf{func}}~ [t_1^\ast] \href{../syntax/types.html#syntax-comptype}{\rightarrow} [t_2^\ast]
  \end{array}
  \quad
  \begin{array}[b]{&#64;{}l&#64;{}}
  \forall S_1, \href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast,~
    {\href{../appendix/properties.html#valid-store}{\vdash} S_1 : \href{../appendix/properties.html#valid-store}{\mathsf{ok}}} \wedge
    {\href{../appendix/properties.html#extend-store}{\vdash} S \href{../appendix/properties.html#extend}{\preceq} S_1} \wedge
    {S_1 \href{../appendix/properties.html#valid-result}{\vdash} \href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast : [t_1^\ast]}
    \Longrightarrow {} \\ \qquad
    \mathit{hf}(S_1; \href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast) \supset \emptyset \wedge {} \\ \qquad
  \forall R \in \mathit{hf}(S_1; \href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast),~
    R = \bot \vee {} \\ \qquad\qquad
    \exists S_2, \href{../exec/runtime.html#syntax-result}{\mathit{result}},~
    {\href{../appendix/properties.html#valid-store}{\vdash} S_2 : \href{../appendix/properties.html#valid-store}{\mathsf{ok}}} \wedge
    {\href{../appendix/properties.html#extend-store}{\vdash} S_1 \href{../appendix/properties.html#extend}{\preceq} S_2} \wedge
    {S_2 \href{../appendix/properties.html#valid-result}{\vdash} \href{../exec/runtime.html#syntax-result}{\mathit{result}} : [t_2^\ast]} \wedge
    R = (S_2; \href{../exec/runtime.html#syntax-result}{\mathit{result}})
  \end{array}
}{
  S \href{../appendix/properties.html#valid-funcinst}{\vdash} \{\href{../exec/runtime.html#syntax-funcinst}{\mathsf{type}}~\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}, \href{../exec/runtime.html#syntax-funcinst}{\mathsf{hostfunc}}~\mathit{hf}\} : \href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}
}\end{split}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This rule states that, if appropriate pre-conditions about store and arguments are satisfied, then executing the host function must satisfy appropriate post-conditions about store and results.
The post-conditions match the ones in the <a class="reference internal" href="../exec/instructions.html#exec-invoke-host"><span class="std std-ref">execution rule</span></a> for invoking host functions.</p>
<p>Any store under which the function is invoked is assumed to be an extension of the current store.
That way, the function itself is able to make sufficient assumptions about future stores.</p>
</div>
</section>
<section id="data-instances-xref-exec-runtime-syntax-datainst-mathsf-bytes-b-ast">
<span id="valid-datainst"></span><span id="index-14"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-eleminst"><span class="std std-ref">Data Instances</span></a> <span class="math notranslate nohighlight">\(\{ \href{../exec/runtime.html#syntax-datainst}{\mathsf{bytes}}~b^\ast \}\)</span><a class="headerlink" href="#data-instances-xref-exec-runtime-syntax-datainst-mathsf-bytes-b-ast" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The data instance is valid.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
}{
  S \href{../appendix/properties.html#valid-datainst}{\vdash} \{ \href{../exec/runtime.html#syntax-datainst}{\mathsf{bytes}}~b^\ast \} : \href{../appendix/properties.html#valid-datainst}{\mathsf{ok}}
}\]</div>
</section>
<section id="element-instances-xref-exec-runtime-syntax-eleminst-mathsf-type-t-xref-exec-runtime-syntax-eleminst-mathsf-elem-xref-exec-runtime-syntax-ref-mathit-ref-ast">
<span id="valid-eleminst"></span><span id="index-15"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-eleminst"><span class="std std-ref">Element Instances</span></a> <span class="math notranslate nohighlight">\(\{ \href{../exec/runtime.html#syntax-eleminst}{\mathsf{type}}~t, \href{../exec/runtime.html#syntax-eleminst}{\mathsf{elem}}~\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^\ast \}\)</span><a class="headerlink" href="#element-instances-xref-exec-runtime-syntax-eleminst-mathsf-type-t-xref-exec-runtime-syntax-eleminst-mathsf-elem-xref-exec-runtime-syntax-ref-mathit-ref-ast" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../syntax/types.html#syntax-reftype"><span class="std std-ref">reference type</span></a> <span class="math notranslate nohighlight">\(t\)</span> must be <a class="reference internal" href="../valid/types.html#valid-reftype"><span class="std std-ref">valid</span></a> under the empty <a class="reference internal" href="../valid/conventions.html#context"><span class="std std-ref">context</span></a>.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-ref"><span class="std std-ref">reference</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}_i\)</span> in the elements <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^n\)</span>:</p>
<ul>
<li><p>The <a class="reference internal" href="../exec/runtime.html#syntax-ref"><span class="std std-ref">reference</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}_i\)</span> must be <a class="reference internal" href="../exec/values.html#valid-ref"><span class="std std-ref">valid</span></a> with some <a class="reference internal" href="../syntax/types.html#syntax-reftype"><span class="std std-ref">reference type</span></a> <span class="math notranslate nohighlight">\(t'_i\)</span>.</p></li>
<li><p>The <a class="reference internal" href="../syntax/types.html#syntax-reftype"><span class="std std-ref">reference type</span></a> <span class="math notranslate nohighlight">\(t'_i\)</span> must <a class="reference internal" href="../valid/matching.html#match-reftype"><span class="std std-ref">match</span></a> the <a class="reference internal" href="../syntax/types.html#syntax-reftype"><span class="std std-ref">reference type</span></a> <span class="math notranslate nohighlight">\(t\)</span>.</p></li>
</ul>
</li>
<li><p>Then the element instance is valid with <a class="reference internal" href="../syntax/types.html#syntax-reftype"><span class="std std-ref">reference type</span></a> <span class="math notranslate nohighlight">\(t\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  \href{../valid/types.html#valid-reftype}{\vdash} t : \href{../valid/types.html#valid-reftype}{\mathsf{ok}}
  \qquad
  (S \href{../exec/values.html#valid-val}{\vdash} \href{../exec/runtime.html#syntax-ref}{\mathit{ref}} : t')^\ast
  \qquad
  (\href{../valid/matching.html#match-reftype}{\vdash} t' \href{../valid/matching.html#match-valtype}{\leq} t)^\ast
}{
  S \href{../appendix/properties.html#valid-eleminst}{\vdash} \{ \href{../exec/runtime.html#syntax-eleminst}{\mathsf{type}}~t, \href{../exec/runtime.html#syntax-eleminst}{\mathsf{elem}}~\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^\ast \} : t
}\]</div>
</section>
<section id="structure-instances-xref-exec-runtime-syntax-structinst-mathsf-type-xref-valid-conventions-syntax-deftype-mathit-deftype-xref-exec-runtime-syntax-structinst-mathsf-fields-xref-exec-runtime-syntax-fieldval-mathit-fieldval-ast">
<span id="valid-structinst"></span><span id="index-16"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-structinst"><span class="std std-ref">Structure Instances</span></a> <span class="math notranslate nohighlight">\(\{ \href{../exec/runtime.html#syntax-structinst}{\mathsf{type}}~\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}, \href{../exec/runtime.html#syntax-structinst}{\mathsf{fields}}~\href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}^\ast \}\)</span><a class="headerlink" href="#structure-instances-xref-exec-runtime-syntax-structinst-mathsf-type-xref-valid-conventions-syntax-deftype-mathit-deftype-xref-exec-runtime-syntax-structinst-mathsf-fields-xref-exec-runtime-syntax-fieldval-mathit-fieldval-ast" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../valid/conventions.html#syntax-deftype"><span class="std std-ref">defined type</span></a> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}\)</span> must be <a class="reference internal" href="#valid-deftype"><span class="std std-ref">valid</span></a> under the empty <a class="reference internal" href="../valid/conventions.html#context"><span class="std std-ref">context</span></a>.</p></li>
<li><p>The <a class="reference internal" href="../valid/conventions.html#aux-expand-deftype"><span class="std std-ref">expansion</span></a> of <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}\)</span> must be a <a class="reference internal" href="../syntax/types.html#syntax-structtype"><span class="std std-ref">structure type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-comptype}{\mathsf{struct}}~\href{../syntax/types.html#syntax-fieldtype}{\mathit{fieldtype}}^\ast\)</span>.</p></li>
<li><p>The length of the sequence of <a class="reference internal" href="../exec/runtime.html#syntax-fieldval"><span class="std std-ref">field values</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}^\ast\)</span> must be the same as the length of the sequence of <a class="reference internal" href="../syntax/types.html#syntax-fieldtype"><span class="std std-ref">field types</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-fieldtype}{\mathit{fieldtype}}^\ast\)</span>.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-fieldval"><span class="std std-ref">field value</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}^\ast\)</span> and corresponding <a class="reference internal" href="../syntax/types.html#syntax-fieldtype"><span class="std std-ref">field type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-fieldtype}{\mathit{fieldtype}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-fieldtype}{\mathit{fieldtype}}^\ast\)</span>:</p>
<ul>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-fieldtype}{\mathit{fieldtype}}_i\)</span> be <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-mut}{\mathit{mut}}~\href{../syntax/types.html#syntax-storagetype}{\mathit{storagetype}}_i\)</span>.</p></li>
<li><p>The <a class="reference internal" href="../exec/runtime.html#syntax-fieldval"><span class="std std-ref">field value</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}_i\)</span> must be <a class="reference internal" href="#valid-fieldval"><span class="std std-ref">valid</span></a> with <a class="reference internal" href="../syntax/types.html#syntax-storagetype"><span class="std std-ref">storage type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-storagetype}{\mathit{storagetype}}_i\)</span>.</p></li>
</ul>
</li>
<li><p>Then the structure instance is valid.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  \href{../appendix/properties.html#valid-deftype}{\vdash} \mathit{dt} : \href{../appendix/properties.html#valid-deftype}{\mathsf{ok}}
  \qquad
  \href{../valid/conventions.html#aux-expand-deftype}{\mathrm{expand}}(\mathit{dt}) = \href{../syntax/types.html#syntax-comptype}{\mathsf{struct}}~(\href{../syntax/types.html#syntax-mut}{\mathit{mut}}~\mathit{st})^\ast
  \qquad
  (S \href{../appendix/properties.html#valid-fieldval}{\vdash} \mathit{fv} : \mathit{st})^\ast
}{
  S \href{../appendix/properties.html#valid-structinst}{\vdash} \{ \href{../exec/runtime.html#syntax-structinst}{\mathsf{type}}~\mathit{dt}, \href{../exec/runtime.html#syntax-structinst}{\mathsf{fields}}~\mathit{fv}^\ast \} : \href{../appendix/properties.html#valid-structinst}{\mathsf{ok}}
}\]</div>
</section>
<section id="array-instances-xref-exec-runtime-syntax-arrayinst-mathsf-type-xref-valid-conventions-syntax-deftype-mathit-deftype-xref-exec-runtime-syntax-arrayinst-mathsf-fields-xref-exec-runtime-syntax-fieldval-mathit-fieldval-ast">
<span id="valid-arrayinst"></span><span id="index-17"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-arrayinst"><span class="std std-ref">Array Instances</span></a> <span class="math notranslate nohighlight">\(\{ \href{../exec/runtime.html#syntax-arrayinst}{\mathsf{type}}~\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}, \href{../exec/runtime.html#syntax-arrayinst}{\mathsf{fields}}~\href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}^\ast \}\)</span><a class="headerlink" href="#array-instances-xref-exec-runtime-syntax-arrayinst-mathsf-type-xref-valid-conventions-syntax-deftype-mathit-deftype-xref-exec-runtime-syntax-arrayinst-mathsf-fields-xref-exec-runtime-syntax-fieldval-mathit-fieldval-ast" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../valid/conventions.html#syntax-deftype"><span class="std std-ref">defined type</span></a> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}\)</span> must be <a class="reference internal" href="#valid-deftype"><span class="std std-ref">valid</span></a> under the empty <a class="reference internal" href="../valid/conventions.html#context"><span class="std std-ref">context</span></a>.</p></li>
<li><p>The <a class="reference internal" href="../valid/conventions.html#aux-expand-deftype"><span class="std std-ref">expansion</span></a> of <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}\)</span> must be an <a class="reference internal" href="../syntax/types.html#syntax-arraytype"><span class="std std-ref">array type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-comptype}{\mathsf{array}}~\href{../syntax/types.html#syntax-fieldtype}{\mathit{fieldtype}}\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-fieldtype}{\mathit{fieldtype}}\)</span> be <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-mut}{\mathit{mut}}~\href{../syntax/types.html#syntax-storagetype}{\mathit{storagetype}}\)</span>.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-fieldval"><span class="std std-ref">field value</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}^\ast\)</span>:</p>
<ul>
<li><p>The <a class="reference internal" href="../exec/runtime.html#syntax-fieldval"><span class="std std-ref">field value</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}_i\)</span> must be <a class="reference internal" href="#valid-fieldval"><span class="std std-ref">valid</span></a> with <a class="reference internal" href="../syntax/types.html#syntax-storagetype"><span class="std std-ref">storage type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-storagetype}{\mathit{storagetype}}\)</span>.</p></li>
</ul>
</li>
<li><p>Then the array instance is valid.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  \href{../appendix/properties.html#valid-deftype}{\vdash} \mathit{dt} : \href{../appendix/properties.html#valid-deftype}{\mathsf{ok}}
  \qquad
  \href{../valid/conventions.html#aux-expand-deftype}{\mathrm{expand}}(\mathit{dt}) = \href{../syntax/types.html#syntax-comptype}{\mathsf{array}}~(\href{../syntax/types.html#syntax-mut}{\mathit{mut}}~\mathit{st})
  \qquad
  (S \href{../appendix/properties.html#valid-fieldval}{\vdash} \mathit{fv} : \mathit{st})^\ast
}{
  S \href{../appendix/properties.html#valid-arrayinst}{\vdash} \{ \href{../exec/runtime.html#syntax-arrayinst}{\mathsf{type}}~\mathit{dt}, \href{../exec/runtime.html#syntax-arrayinst}{\mathsf{fields}}~\mathit{fv}^\ast \} : \href{../appendix/properties.html#valid-arrayinst}{\mathsf{ok}}
}\]</div>
</section>
<section id="field-values-xref-exec-runtime-syntax-fieldval-mathit-fieldval">
<span id="valid-packval"></span><span id="valid-fieldval"></span><span id="index-18"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-fieldval"><span class="std std-ref">Field Values</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}\)</span><a class="headerlink" href="#field-values-xref-exec-runtime-syntax-fieldval-mathit-fieldval" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}\)</span> is a <a class="reference internal" href="../exec/runtime.html#syntax-val"><span class="std std-ref">value</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}\)</span>, then:</p>
<ul>
<li><p>The value <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}\)</span> must be <a class="reference internal" href="../exec/values.html#valid-val"><span class="std std-ref">valid</span></a> with <a class="reference internal" href="../syntax/types.html#syntax-valtype"><span class="std std-ref">value type</span></a> <span class="math notranslate nohighlight">\(t\)</span>.</p></li>
<li><p>Then the field value is valid with <a class="reference internal" href="../syntax/types.html#syntax-valtype"><span class="std std-ref">value type</span></a> <span class="math notranslate nohighlight">\(t\)</span>.</p></li>
</ul>
</li>
<li><p>Else, <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}\)</span> is a <a class="reference internal" href="../exec/runtime.html#syntax-packval"><span class="std std-ref">packed value</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-packval}{\mathit{packval}}\)</span>:</p>
<ul>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-packtype}{\mathit{packtype}}.\href{../exec/runtime.html#syntax-packval}{\mathsf{pack}}~i\)</span> be the field value <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}\)</span>.</p></li>
<li><p>Then the field value is valid with <a class="reference internal" href="../syntax/types.html#syntax-packtype"><span class="std std-ref">packed type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-packtype}{\mathit{packtype}}\)</span>.</p></li>
</ul>
</li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
}{
  S \href{../appendix/properties.html#valid-packval}{\vdash} \mathit{pt}.\href{../exec/runtime.html#syntax-packval}{\mathsf{pack}}~i : \mathit{pt}
}\]</div>
</section>
<section id="exception-instances-xref-exec-runtime-syntax-exninst-mathsf-tag-a-xref-exec-runtime-syntax-exninst-mathsf-fields-xref-exec-runtime-syntax-val-mathit-val-ast">
<span id="valid-exninst"></span><span id="index-19"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-exninst"><span class="std std-ref">Exception Instances</span></a> <span class="math notranslate nohighlight">\(\{ \href{../exec/runtime.html#syntax-exninst}{\mathsf{tag}}~a, \href{../exec/runtime.html#syntax-exninst}{\mathsf{fields}}~\href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast \}\)</span><a class="headerlink" href="#exception-instances-xref-exec-runtime-syntax-exninst-mathsf-tag-a-xref-exec-runtime-syntax-exninst-mathsf-fields-xref-exec-runtime-syntax-val-mathit-val-ast" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The store entry <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{tags}}[a]\)</span> must exist.</p></li>
<li><p>The <a class="reference internal" href="../valid/conventions.html#aux-expand-deftype"><span class="std std-ref">expansion</span></a> of the <a class="reference internal" href="../syntax/types.html#syntax-tagtype"><span class="std std-ref">tag type</span></a> <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{tags}}[a].\href{../exec/runtime.html#syntax-taginst}{\mathsf{type}}\)</span> must be some <a class="reference internal" href="../syntax/types.html#syntax-functype"><span class="std std-ref">function type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-comptype}{\mathsf{func}}~[t^\ast] \href{../syntax/types.html#syntax-comptype}{\rightarrow} [{t'}^\ast]\)</span>.</p></li>
<li><p>The <a class="reference internal" href="../syntax/types.html#syntax-resulttype"><span class="std std-ref">result type</span></a> <span class="math notranslate nohighlight">\([{t'}^\ast]\)</span> must be empty.</p></li>
<li><p>The sequence <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}^ast\)</span> of <a class="reference internal" href="../exec/runtime.html#syntax-val"><span class="std std-ref">values</span></a> must have the same length as the sequence <span class="math notranslate nohighlight">\(t^\ast\)</span> of <a class="reference internal" href="../syntax/types.html#syntax-valtype"><span class="std std-ref">value types</span></a>.</p></li>
<li><p>For each value <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}^ast\)</span> and corresponding value type <span class="math notranslate nohighlight">\(t_i\)</span> in <span class="math notranslate nohighlight">\(t^\ast\)</span>, the value <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}_i\)</span> must be valid with type <span class="math notranslate nohighlight">\(t_i\)</span>.</p></li>
<li><p>Then the exception instance is valid.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  S.\href{../exec/runtime.html#syntax-store}{\mathsf{tags}}[a].\href{../exec/runtime.html#syntax-taginst}{\mathsf{type}} \approx \href{../syntax/types.html#syntax-comptype}{\mathsf{func}}~ [t^\ast] \href{../syntax/types.html#syntax-comptype}{\rightarrow} []
  \qquad
  (S \href{../exec/values.html#valid-val}{\vdash} \href{../exec/runtime.html#syntax-val}{\mathit{val}} : t)^\ast
}{
  S \href{../appendix/properties.html#valid-exninst}{\vdash} \{ \href{../exec/runtime.html#syntax-exninst}{\mathsf{tag}}~a, \href{../exec/runtime.html#syntax-exninst}{\mathsf{fields}}~\href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast \} : \href{../appendix/properties.html#valid-exninst}{\mathsf{ok}}
}\]</div>
</section>
<section id="export-instances-xref-exec-runtime-syntax-exportinst-mathsf-name-xref-syntax-values-syntax-name-mathit-name-xref-exec-runtime-syntax-exportinst-mathsf-addr-xref-exec-runtime-syntax-externaddr-mathit-externaddr">
<span id="valid-exportinst"></span><span id="index-20"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-exportinst"><span class="std std-ref">Export Instances</span></a> <span class="math notranslate nohighlight">\(\{ \href{../exec/runtime.html#syntax-exportinst}{\mathsf{name}}~\href{../syntax/values.html#syntax-name}{\mathit{name}}, \href{../exec/runtime.html#syntax-exportinst}{\mathsf{addr}}~\href{../exec/runtime.html#syntax-externaddr}{\mathit{externaddr}} \}\)</span><a class="headerlink" href="#export-instances-xref-exec-runtime-syntax-exportinst-mathsf-name-xref-syntax-values-syntax-name-mathit-name-xref-exec-runtime-syntax-exportinst-mathsf-addr-xref-exec-runtime-syntax-externaddr-mathit-externaddr" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../exec/runtime.html#syntax-externaddr"><span class="std std-ref">external address</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externaddr}{\mathit{externaddr}}\)</span> must be <a class="reference internal" href="../exec/values.html#valid-externaddr"><span class="std std-ref">valid</span></a> with some <a class="reference internal" href="../syntax/types.html#syntax-externtype"><span class="std std-ref">external type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-externtype}{\mathit{externtype}}\)</span>.</p></li>
<li><p>Then the export instance is valid.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  S \href{../exec/values.html#valid-externaddr}{\vdash} \href{../exec/runtime.html#syntax-externaddr}{\mathit{externaddr}} : \href{../syntax/types.html#syntax-externtype}{\mathit{externtype}}
}{
  S \href{../appendix/properties.html#valid-exportinst}{\vdash} \{ \href{../exec/runtime.html#syntax-exportinst}{\mathsf{name}}~\href{../syntax/values.html#syntax-name}{\mathit{name}}, \href{../exec/runtime.html#syntax-exportinst}{\mathsf{addr}}~\href{../exec/runtime.html#syntax-externaddr}{\mathit{externaddr}} \} : \href{../appendix/properties.html#valid-exportinst}{\mathsf{ok}}
}\]</div>
</section>
<section id="module-instances-xref-exec-runtime-syntax-moduleinst-mathit-moduleinst">
<span id="valid-moduleinst"></span><span id="index-21"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-moduleinst"><span class="std std-ref">Module Instances</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}\)</span><a class="headerlink" href="#module-instances-xref-exec-runtime-syntax-moduleinst-mathit-moduleinst" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>Each <a class="reference internal" href="../valid/conventions.html#syntax-deftype"><span class="std std-ref">defined type</span></a> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}.\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{types}}\)</span> must be <a class="reference internal" href="#valid-deftype"><span class="std std-ref">valid</span></a> under the empty <a class="reference internal" href="../valid/conventions.html#context"><span class="std std-ref">context</span></a>.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-tagaddr"><span class="std std-ref">tag address</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-tagaddr}{\mathit{tagaddr}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}.\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{tags}}\)</span>, the <a class="reference internal" href="../exec/runtime.html#syntax-externaddr"><span class="std std-ref">external address</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externaddr}{\mathsf{tag}}~\href{../exec/runtime.html#syntax-tagaddr}{\mathit{tagaddr}}_i\)</span> must be <a class="reference internal" href="../exec/values.html#valid-externaddr-tag"><span class="std std-ref">valid</span></a> with some <a class="reference internal" href="../syntax/types.html#syntax-externtype"><span class="std std-ref">external type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-externtype}{\mathsf{tag}}~\href{../syntax/types.html#syntax-tagtype}{\mathit{tagtype}}_i\)</span>.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-globaladdr"><span class="std std-ref">global address</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-globaladdr}{\mathit{globaladdr}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}.\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{globals}}\)</span>, the <a class="reference internal" href="../exec/runtime.html#syntax-externaddr"><span class="std std-ref">external address</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externaddr}{\mathsf{global}}~\href{../exec/runtime.html#syntax-globaladdr}{\mathit{globaladdr}}_i\)</span> must be <a class="reference internal" href="../exec/values.html#valid-externaddr-global"><span class="std std-ref">valid</span></a> with some <a class="reference internal" href="../syntax/types.html#syntax-externtype"><span class="std std-ref">external type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-externtype}{\mathsf{global}}~\href{../syntax/types.html#syntax-globaltype}{\mathit{globaltype}}_i\)</span>.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-memaddr"><span class="std std-ref">memory address</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-memaddr}{\mathit{memaddr}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}.\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{mems}}\)</span>, the <a class="reference internal" href="../exec/runtime.html#syntax-externaddr"><span class="std std-ref">external address</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externaddr}{\mathsf{mem}}~\href{../exec/runtime.html#syntax-memaddr}{\mathit{memaddr}}_i\)</span> must be <a class="reference internal" href="../exec/values.html#valid-externaddr-mem"><span class="std std-ref">valid</span></a> with some <a class="reference internal" href="../syntax/types.html#syntax-externtype"><span class="std std-ref">external type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-externtype}{\mathsf{mem}}~\href{../syntax/types.html#syntax-memtype}{\mathit{memtype}}_i\)</span>.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-tableaddr"><span class="std std-ref">table address</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-tableaddr}{\mathit{tableaddr}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}.\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{tables}}\)</span>, the <a class="reference internal" href="../exec/runtime.html#syntax-externaddr"><span class="std std-ref">external address</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externaddr}{\mathsf{table}}~\href{../exec/runtime.html#syntax-tableaddr}{\mathit{tableaddr}}_i\)</span> must be <a class="reference internal" href="../exec/values.html#valid-externaddr-table"><span class="std std-ref">valid</span></a> with some <a class="reference internal" href="../syntax/types.html#syntax-externtype"><span class="std std-ref">external type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-externtype}{\mathsf{table}}~\href{../syntax/types.html#syntax-tabletype}{\mathit{tabletype}}_i\)</span>.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-funcaddr"><span class="std std-ref">function address</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}.\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{funcs}}\)</span>, the <a class="reference internal" href="../exec/runtime.html#syntax-externaddr"><span class="std std-ref">external address</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externaddr}{\mathsf{func}}~\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}_i\)</span> must be <a class="reference internal" href="../exec/values.html#valid-externaddr-func"><span class="std std-ref">valid</span></a> with some <a class="reference internal" href="../syntax/types.html#syntax-externtype"><span class="std std-ref">external type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-externtype}{\mathsf{func}}~\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}_{\mathsf{F}i}\)</span>.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-dataaddr"><span class="std std-ref">data address</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-dataaddr}{\mathit{dataaddr}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}.\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{datas}}\)</span>, the <a class="reference internal" href="../exec/runtime.html#syntax-datainst"><span class="std std-ref">data instance</span></a> <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{datas}}[\href{../exec/runtime.html#syntax-dataaddr}{\mathit{dataaddr}}_i]\)</span> must be <a class="reference internal" href="#valid-datainst"><span class="std std-ref">valid</span></a> with <span class="math notranslate nohighlight">\(\mathit{ok}_i\)</span>.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-elemaddr"><span class="std std-ref">element address</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-elemaddr}{\mathit{elemaddr}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}.\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{elems}}\)</span>, the <a class="reference internal" href="../exec/runtime.html#syntax-eleminst"><span class="std std-ref">element instance</span></a> <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{elems}}[\href{../exec/runtime.html#syntax-elemaddr}{\mathit{elemaddr}}_i]\)</span> must be <a class="reference internal" href="#valid-eleminst"><span class="std std-ref">valid</span></a> with some <a class="reference internal" href="../syntax/types.html#syntax-reftype"><span class="std std-ref">reference type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-reftype}{\mathit{reftype}}_i\)</span>.</p></li>
<li><p>Each <a class="reference internal" href="../exec/runtime.html#syntax-exportinst"><span class="std std-ref">export instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-exportinst}{\mathit{exportinst}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}.\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{exports}}\)</span> must be <a class="reference internal" href="#valid-exportinst"><span class="std std-ref">valid</span></a>.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-exportinst"><span class="std std-ref">export instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-exportinst}{\mathit{exportinst}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}.\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{exports}}\)</span>, the <a class="reference internal" href="../syntax/values.html#syntax-name"><span class="std std-ref">name</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-exportinst}{\mathit{exportinst}}_i.\href{../exec/runtime.html#syntax-exportinst}{\mathsf{name}}\)</span> must be different from any other name occurring in <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}.\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{exports}}\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}^\ast\)</span> be the concatenation of all <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}_i\)</span> in order.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-tagtype}{\mathit{tagtype}}^\ast\)</span> be the concatenation of all <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-tagtype}{\mathit{tagtype}}_i\)</span> in order.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-globaltype}{\mathit{globaltype}}^\ast\)</span> be the concatenation of all <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-globaltype}{\mathit{globaltype}}_i\)</span> in order.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-memtype}{\mathit{memtype}}^\ast\)</span> be the concatenation of all <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-memtype}{\mathit{memtype}}_i\)</span> in order.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-tabletype}{\mathit{tabletype}}^\ast\)</span> be the concatenation of all <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-tabletype}{\mathit{tabletype}}_i\)</span> in order.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}_{\mathsf{F}}^\ast\)</span> be the concatenation of all <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}_{\mathsf{F}i}\)</span> in order.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-reftype}{\mathit{reftype}}^\ast\)</span> be the concatenation of all <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-reftype}{\mathit{reftype}}_i\)</span> in order.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\mathit{ok}^\ast\)</span> be the concatenation of all <span class="math notranslate nohighlight">\(\mathit{ok}_i\)</span> in order.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(m\)</span> be the length of <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}.\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{funcs}}\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(x^\ast\)</span> be the sequence of <a class="reference internal" href="../syntax/modules.html#syntax-funcidx"><span class="std std-ref">function indices</span></a> from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(m-1\)</span>.</p></li>
<li><p>Then the module instance is valid with <a class="reference internal" href="../valid/conventions.html#context"><span class="std std-ref">context</span></a>
<span class="math notranslate nohighlight">\(\{\href{../valid/conventions.html#context}{\mathsf{types}}~\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}^\ast,\)</span> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#context}{\mathsf{tags}}~\href{../syntax/types.html#syntax-tagtype}{\mathit{tagtype}}^\ast,\)</span> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#context}{\mathsf{globals}}~\href{../syntax/types.html#syntax-globaltype}{\mathit{globaltype}}^\ast,\)</span> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#context}{\mathsf{mems}}~\href{../syntax/types.html#syntax-memtype}{\mathit{memtype}}^\ast,\)</span> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#context}{\mathsf{tables}}~\href{../syntax/types.html#syntax-tabletype}{\mathit{tabletype}}^\ast,\)</span> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#context}{\mathsf{funcs}}~\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}_{\mathsf{F}}^\ast,\)</span> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#context}{\mathsf{datas}}~\mathit{ok}^\ast,\)</span> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#context}{\mathsf{elems}}~\href{../syntax/types.html#syntax-reftype}{\mathit{reftype}}^\ast,\)</span> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#context}{\mathsf{refs}}~x^\ast\}\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}~\\[-1ex]
\frac{
  \begin{array}{&#64;{}c&#64;{}}
  (\href{../appendix/properties.html#valid-deftype}{\vdash} \href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}} : \href{../appendix/properties.html#valid-deftype}{\mathsf{ok}})^\ast
  \qquad
  (S \href{../exec/values.html#valid-externaddr}{\vdash} \href{../exec/runtime.html#syntax-externaddr}{\mathsf{tag}}~\href{../exec/runtime.html#syntax-tagaddr}{\mathit{tagaddr}} : \href{../syntax/types.html#syntax-externtype}{\mathsf{tag}}~\href{../syntax/types.html#syntax-tagtype}{\mathit{tagtype}})^\ast
  \\
  (S \href{../exec/values.html#valid-externaddr}{\vdash} \href{../exec/runtime.html#syntax-externaddr}{\mathsf{global}}~\href{../exec/runtime.html#syntax-globaladdr}{\mathit{globaladdr}} : \href{../syntax/types.html#syntax-externtype}{\mathsf{global}}~\href{../syntax/types.html#syntax-globaltype}{\mathit{globaltype}})^\ast
  \qquad
  (S \href{../exec/values.html#valid-externaddr}{\vdash} \href{../exec/runtime.html#syntax-externaddr}{\mathsf{func}}~\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}} : \href{../syntax/types.html#syntax-externtype}{\mathsf{func}}~\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}_{\mathsf{F}})^\ast
  \\
  (S \href{../exec/values.html#valid-externaddr}{\vdash} \href{../exec/runtime.html#syntax-externaddr}{\mathsf{mem}}~\href{../exec/runtime.html#syntax-memaddr}{\mathit{memaddr}} : \href{../syntax/types.html#syntax-externtype}{\mathsf{mem}}~\href{../syntax/types.html#syntax-memtype}{\mathit{memtype}})^\ast
  \qquad
  (S \href{../exec/values.html#valid-externaddr}{\vdash} \href{../exec/runtime.html#syntax-externaddr}{\mathsf{table}}~\href{../exec/runtime.html#syntax-tableaddr}{\mathit{tableaddr}} : \href{../syntax/types.html#syntax-externtype}{\mathsf{table}}~\href{../syntax/types.html#syntax-tabletype}{\mathit{tabletype}})^\ast
  \\
  (S \href{../appendix/properties.html#valid-datainst}{\vdash} S.\href{../exec/runtime.html#syntax-store}{\mathsf{datas}}[\href{../exec/runtime.html#syntax-dataaddr}{\mathit{dataaddr}}] : \mathit{ok})^\ast
  \qquad
  (S \href{../appendix/properties.html#valid-eleminst}{\vdash} S.\href{../exec/runtime.html#syntax-store}{\mathsf{elems}}[\href{../exec/runtime.html#syntax-elemaddr}{\mathit{elemaddr}}] : \href{../syntax/types.html#syntax-reftype}{\mathit{reftype}})^\ast
  \\
  (S \href{../appendix/properties.html#valid-exportinst}{\vdash} \href{../exec/runtime.html#syntax-exportinst}{\mathit{exportinst}} : \href{../appendix/properties.html#valid-exportinst}{\mathsf{ok}})^\ast
  \qquad
  (\href{../exec/runtime.html#syntax-exportinst}{\mathit{exportinst}}.\href{../exec/runtime.html#syntax-exportinst}{\mathsf{name}})^\ast ~\mbox{disjoint}
  \end{array}
}{
  S \href{../appendix/properties.html#valid-moduleinst}{\vdash} \{
    \begin{array}[t]{&#64;{}l&#64;{~}l&#64;{}}
    \href{../exec/runtime.html#syntax-moduleinst}{\mathsf{types}} &amp; \href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}^\ast, \\
    \href{../exec/runtime.html#syntax-moduleinst}{\mathsf{tags}} &amp; \href{../exec/runtime.html#syntax-tagaddr}{\mathit{tagaddr}}^\ast, \\
    \href{../exec/runtime.html#syntax-moduleinst}{\mathsf{globals}} &amp; \href{../exec/runtime.html#syntax-globaladdr}{\mathit{globaladdr}}^\ast, \\
    \href{../exec/runtime.html#syntax-moduleinst}{\mathsf{mems}} &amp; \href{../exec/runtime.html#syntax-memaddr}{\mathit{memaddr}}^\ast, \\
    \href{../exec/runtime.html#syntax-moduleinst}{\mathsf{tables}} &amp; \href{../exec/runtime.html#syntax-tableaddr}{\mathit{tableaddr}}^\ast, \\
    \href{../exec/runtime.html#syntax-moduleinst}{\mathsf{funcs}} &amp; \href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}^\ast, \\
    \href{../exec/runtime.html#syntax-moduleinst}{\mathsf{datas}} &amp; \href{../exec/runtime.html#syntax-dataaddr}{\mathit{dataaddr}}^\ast, \\
    \href{../exec/runtime.html#syntax-moduleinst}{\mathsf{elems}} &amp; \href{../exec/runtime.html#syntax-elemaddr}{\mathit{elemaddr}}^\ast, \\
    \href{../exec/runtime.html#syntax-moduleinst}{\mathsf{exports}} &amp; \href{../exec/runtime.html#syntax-exportinst}{\mathit{exportinst}}^\ast ~\} : \{
      \begin{array}[t]{&#64;{}l&#64;{~}l&#64;{}}
      \href{../valid/conventions.html#context}{\mathsf{types}} &amp; \href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}^\ast, \\
      \href{../valid/conventions.html#context}{\mathsf{tags}} &amp; \href{../syntax/types.html#syntax-tagtype}{\mathit{tagtype}}^\ast, \\
      \href{../valid/conventions.html#context}{\mathsf{globals}} &amp; \href{../syntax/types.html#syntax-globaltype}{\mathit{globaltype}}^\ast, \\
      \href{../valid/conventions.html#context}{\mathsf{mems}} &amp; \href{../syntax/types.html#syntax-memtype}{\mathit{memtype}}^\ast, \\
      \href{../valid/conventions.html#context}{\mathsf{tables}} &amp; \href{../syntax/types.html#syntax-tabletype}{\mathit{tabletype}}^\ast, \\
      \href{../valid/conventions.html#context}{\mathsf{funcs}} &amp; \href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}_{\mathsf{F}}^\ast, \\
      \href{../valid/conventions.html#context}{\mathsf{datas}} &amp; \mathit{ok}^\ast, \\
      \href{../valid/conventions.html#context}{\mathsf{elems}} &amp; \href{../syntax/types.html#syntax-reftype}{\mathit{reftype}}^\ast, \\
      \href{../valid/conventions.html#context}{\mathsf{refs}} &amp; 0 \dots (|\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}^\ast|-1) ~\}
      \end{array}
    \end{array}
}\end{split}\]</div>
</section>
</section>
<section id="configuration-validity">
<span id="valid-config"></span><span id="frame-context"></span><span id="index-22"></span><h2>Configuration Validity<a class="headerlink" href="#configuration-validity" title="Link to this heading">¶</a></h2>
<p>To relate the WebAssembly <a class="reference internal" href="../valid/index.html#valid"><span class="std std-ref">type system</span></a> to its <a class="reference internal" href="../exec/index.html#exec"><span class="std std-ref">execution semantics</span></a>, the <a class="reference internal" href="../valid/instructions.html#valid-instr"><span class="std std-ref">typing rules for instructions</span></a> must be extended to <a class="reference internal" href="../exec/runtime.html#syntax-config"><span class="std std-ref">configurations</span></a> <span class="math notranslate nohighlight">\(S;T\)</span>,
which relates the <a class="reference internal" href="../exec/runtime.html#syntax-store"><span class="std std-ref">store</span></a> to execution <a class="reference internal" href="../exec/runtime.html#syntax-thread"><span class="std std-ref">threads</span></a>.</p>
<p>Configurations and threads are classified by their <a class="reference internal" href="../syntax/types.html#syntax-resulttype"><span class="std std-ref">result type</span></a>.
In addition to the store <span class="math notranslate nohighlight">\(S\)</span>, threads are typed under a <em>return type</em> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-resulttype}{\mathit{resulttype}}^?\)</span>, which controls whether and with which type a <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr-control}{\mathsf{return}}\)</span> instruction is allowed.
This type is absent (<span class="math notranslate nohighlight">\(\epsilon\)</span>) except for instruction sequences inside an administrative <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-frame}{\mathsf{frame}}\)</span> instruction.</p>
<p>Finally, <a class="reference internal" href="../exec/runtime.html#syntax-frame"><span class="std std-ref">frames</span></a> are classified with <em>frame contexts</em>, which extend the <a class="reference internal" href="#module-context"><span class="std std-ref">module contexts</span></a> of a frame’s associated <a class="reference internal" href="../exec/runtime.html#syntax-moduleinst"><span class="std std-ref">module instance</span></a> with the <a class="reference internal" href="../syntax/modules.html#syntax-local"><span class="std std-ref">locals</span></a> that the frame contains.</p>
<section id="configurations-s-t">
<span id="index-23"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-config"><span class="std std-ref">Configurations</span></a> <span class="math notranslate nohighlight">\(S;T\)</span><a class="headerlink" href="#configurations-s-t" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../exec/runtime.html#syntax-store"><span class="std std-ref">store</span></a> <span class="math notranslate nohighlight">\(S\)</span> must be <a class="reference internal" href="#valid-store"><span class="std std-ref">valid</span></a>.</p></li>
<li><p>Under no allowed return type,
the <a class="reference internal" href="../exec/runtime.html#syntax-thread"><span class="std std-ref">thread</span></a> <span class="math notranslate nohighlight">\(T\)</span> must be <a class="reference internal" href="#valid-thread"><span class="std std-ref">valid</span></a> with some <a class="reference internal" href="../syntax/types.html#syntax-resulttype"><span class="std std-ref">result type</span></a> <span class="math notranslate nohighlight">\([t^\ast]\)</span>.</p></li>
<li><p>Then the configuration is valid with the <a class="reference internal" href="../syntax/types.html#syntax-resulttype"><span class="std std-ref">result type</span></a> <span class="math notranslate nohighlight">\([t^\ast]\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  \href{../appendix/properties.html#valid-store}{\vdash} S : \href{../appendix/properties.html#valid-store}{\mathsf{ok}}
  \qquad
  S; \epsilon \href{../appendix/properties.html#valid-thread}{\vdash} T : [t^\ast]
}{
  \href{../appendix/properties.html#valid-config}{\vdash} S; T : [t^\ast]
}\]</div>
</section>
<section id="threads-f-xref-syntax-instructions-syntax-instr-mathit-instr-ast">
<span id="valid-thread"></span><span id="index-24"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-thread"><span class="std std-ref">Threads</span></a> <span class="math notranslate nohighlight">\(F;\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast\)</span><a class="headerlink" href="#threads-f-xref-syntax-instructions-syntax-instr-mathit-instr-ast" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-resulttype}{\mathit{resulttype}}^?\)</span> be the current allowed return type.</p></li>
<li><p>The <a class="reference internal" href="../exec/runtime.html#syntax-frame"><span class="std std-ref">frame</span></a> <span class="math notranslate nohighlight">\(F\)</span> must be <a class="reference internal" href="#valid-frame"><span class="std std-ref">valid</span></a> with a <a class="reference internal" href="../valid/conventions.html#context"><span class="std std-ref">context</span></a> <span class="math notranslate nohighlight">\(C\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(C'\)</span> be the same <a class="reference internal" href="../valid/conventions.html#context"><span class="std std-ref">context</span></a> as <span class="math notranslate nohighlight">\(C\)</span>, but with <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#context}{\mathsf{return}}\)</span> set to <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-resulttype}{\mathit{resulttype}}^?\)</span>.</p></li>
<li><p>Under context <span class="math notranslate nohighlight">\(C'\)</span>,
the instruction sequence <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast\)</span> must be <a class="reference internal" href="../valid/instructions.html#valid-instrs"><span class="std std-ref">valid</span></a> with some type <span class="math notranslate nohighlight">\([] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}} [t^\ast]\)</span>.</p></li>
<li><p>Then the thread is valid with the <a class="reference internal" href="../syntax/types.html#syntax-resulttype"><span class="std std-ref">result type</span></a> <span class="math notranslate nohighlight">\([t^\ast]\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  S \href{../appendix/properties.html#valid-frame}{\vdash} F : C
  \qquad
  S; C,\href{../valid/conventions.html#context}{\mathsf{return}}~\href{../syntax/types.html#syntax-resulttype}{\mathit{resulttype}}^? \href{../valid/instructions.html#valid-instrs}{\vdash} \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast : [] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}} [t^\ast]
}{
  S; \href{../syntax/types.html#syntax-resulttype}{\mathit{resulttype}}^? \href{../appendix/properties.html#valid-thread}{\vdash} F; \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast : [t^\ast]
}\]</div>
</section>
<section id="frames-xref-exec-runtime-syntax-frame-mathsf-locals-xref-exec-runtime-syntax-val-mathit-val-ast-xref-exec-runtime-syntax-frame-mathsf-module-xref-exec-runtime-syntax-moduleinst-mathit-moduleinst">
<span id="valid-frame"></span><span id="index-25"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-frame"><span class="std std-ref">Frames</span></a> <span class="math notranslate nohighlight">\(\{\href{../exec/runtime.html#syntax-frame}{\mathsf{locals}}~\href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast, \href{../exec/runtime.html#syntax-frame}{\mathsf{module}}~\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}\}\)</span><a class="headerlink" href="#frames-xref-exec-runtime-syntax-frame-mathsf-locals-xref-exec-runtime-syntax-val-mathit-val-ast-xref-exec-runtime-syntax-frame-mathsf-module-xref-exec-runtime-syntax-moduleinst-mathit-moduleinst" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../exec/runtime.html#syntax-moduleinst"><span class="std std-ref">module instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}\)</span> must be <a class="reference internal" href="#valid-moduleinst"><span class="std std-ref">valid</span></a> with some <a class="reference internal" href="#module-context"><span class="std std-ref">module context</span></a> <span class="math notranslate nohighlight">\(C\)</span>.</p></li>
<li><p>Each <a class="reference internal" href="../exec/runtime.html#syntax-val"><span class="std std-ref">value</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast\)</span> must be <a class="reference internal" href="../exec/values.html#valid-val"><span class="std std-ref">valid</span></a> with some <a class="reference internal" href="../syntax/types.html#syntax-valtype"><span class="std std-ref">value type</span></a> <span class="math notranslate nohighlight">\(t_i\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(t^\ast\)</span> be the concatenation of all <span class="math notranslate nohighlight">\(t_i\)</span> in order.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(C'\)</span> be the same <a class="reference internal" href="../valid/conventions.html#context"><span class="std std-ref">context</span></a> as <span class="math notranslate nohighlight">\(C\)</span>, but with the <a class="reference internal" href="../syntax/types.html#syntax-valtype"><span class="std std-ref">value types</span></a> <span class="math notranslate nohighlight">\(t^\ast\)</span> prepended to the <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#context}{\mathsf{locals}}\)</span> list.</p></li>
<li><p>Then the frame is valid with <a class="reference internal" href="#frame-context"><span class="std std-ref">frame context</span></a> <span class="math notranslate nohighlight">\(C'\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  S \href{../appendix/properties.html#valid-moduleinst}{\vdash} \href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}} : C
  \qquad
  (S \href{../exec/values.html#valid-val}{\vdash} \href{../exec/runtime.html#syntax-val}{\mathit{val}} : t)^\ast
}{
  S \href{../appendix/properties.html#valid-frame}{\vdash} \{\href{../exec/runtime.html#syntax-frame}{\mathsf{locals}}~\href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast, \href{../exec/runtime.html#syntax-frame}{\mathsf{module}}~\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}\} : (C, \href{../valid/conventions.html#context}{\mathsf{locals}}~t^\ast)
}\]</div>
</section>
</section>
<section id="administrative-instructions">
<span id="valid-instr-admin"></span><span id="index-26"></span><h2>Administrative Instructions<a class="headerlink" href="#administrative-instructions" title="Link to this heading">¶</a></h2>
<p>Typing rules for <a class="reference internal" href="../exec/runtime.html#syntax-instr-admin"><span class="std std-ref">administrative instructions</span></a> are specified as follows.
In addition to the <a class="reference internal" href="../valid/conventions.html#context"><span class="std std-ref">context</span></a> <span class="math notranslate nohighlight">\(C\)</span>, typing of these instructions is defined under a given <a class="reference internal" href="../exec/runtime.html#syntax-store"><span class="std std-ref">store</span></a> <span class="math notranslate nohighlight">\(S\)</span>.</p>
<p>To that end, all previous typing judgements <span class="math notranslate nohighlight">\(C \vdash \mathit{prop}\)</span> are generalized to include the store, as in <span class="math notranslate nohighlight">\(S; C \vdash \mathit{prop}\)</span>, by implicitly adding <span class="math notranslate nohighlight">\(S\)</span> to all rules – <span class="math notranslate nohighlight">\(S\)</span> is never modified by the pre-existing rules, but it is accessed in the extra rules for <a class="reference internal" href="#valid-instr-admin"><span class="std std-ref">administrative instructions</span></a> given below.</p>
<section id="xref-exec-runtime-syntax-trap-mathsf-trap">
<span id="index-27"></span><h3><span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-trap}{\mathsf{trap}}\)</span><a class="headerlink" href="#xref-exec-runtime-syntax-trap-mathsf-trap" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The instruction is valid with any <a class="reference internal" href="../valid/types.html#valid-instrtype"><span class="std std-ref">valid</span></a> <a class="reference internal" href="../valid/conventions.html#syntax-instrtype"><span class="std std-ref">instruction type</span></a> of the form <span class="math notranslate nohighlight">\([t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}} [t_2^\ast]\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  C \href{../valid/types.html#valid-instrtype}{\vdash} [t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}} [t_2^\ast] : \href{../valid/types.html#valid-instrtype}{\mathsf{ok}}
}{
  S; C \href{../appendix/properties.html#valid-instr-admin}{\vdash} \href{../exec/runtime.html#syntax-trap}{\mathsf{trap}} : [t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}} [t_2^\ast]
}\]</div>
</section>
<section id="xref-exec-runtime-syntax-val-mathit-val">
<span id="index-28"></span><h3><span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}\)</span><a class="headerlink" href="#xref-exec-runtime-syntax-val-mathit-val" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The value <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}\)</span> must be valid with <a class="reference internal" href="../syntax/types.html#syntax-valtype"><span class="std std-ref">value type</span></a> <span class="math notranslate nohighlight">\(t\)</span>.</p></li>
<li><p>Then it is valid as an instruction with type <span class="math notranslate nohighlight">\([] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}} [t]\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  S \href{../exec/values.html#valid-val}{\vdash} \href{../exec/runtime.html#syntax-val}{\mathit{val}} : t
}{
  S; C \href{../appendix/properties.html#valid-instr-admin}{\vdash} \href{../exec/runtime.html#syntax-val}{\mathit{val}} : [] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}} [t]
}\]</div>
</section>
<section id="xref-exec-instructions-exec-invoke-mathsf-invoke-xref-exec-runtime-syntax-funcaddr-mathit-funcaddr">
<span id="index-29"></span><h3><span class="math notranslate nohighlight">\(\href{../exec/instructions.html#exec-invoke}{\mathsf{invoke}}~\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}\)</span><a class="headerlink" href="#xref-exec-instructions-exec-invoke-mathsf-invoke-xref-exec-runtime-syntax-funcaddr-mathit-funcaddr" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../exec/runtime.html#syntax-externaddr"><span class="std std-ref">external function address</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externaddr}{\mathsf{func}}~\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}\)</span> must be <a class="reference internal" href="../exec/values.html#valid-externaddr-func"><span class="std std-ref">valid</span></a> with <a class="reference internal" href="../syntax/types.html#syntax-externtype"><span class="std std-ref">external function type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-externtype}{\mathsf{func}}~\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}'\)</span>.</p></li>
<li><p>The <a class="reference internal" href="../valid/conventions.html#aux-expand-deftype"><span class="std std-ref">expansion</span></a> of the <a class="reference internal" href="../valid/conventions.html#syntax-deftype"><span class="std std-ref">defined type</span></a> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}\)</span> must be some <a class="reference internal" href="../syntax/types.html#syntax-functype"><span class="std std-ref">function type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-comptype}{\mathsf{func}}~[t_1^\ast] \href{../syntax/types.html#syntax-comptype}{\rightarrow} [t_2^\ast])\)</span>.</p></li>
<li><p>Then the instruction is valid with type <span class="math notranslate nohighlight">\([t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}} [t_2^\ast]\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  S \href{../exec/values.html#valid-externaddr}{\vdash} \href{../exec/runtime.html#syntax-externaddr}{\mathsf{func}}~\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}} : \href{../syntax/types.html#syntax-externtype}{\mathsf{func}}~\href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}}
  \qquad
  \href{../valid/conventions.html#syntax-deftype}{\mathit{deftype}} \approx \href{../syntax/types.html#syntax-comptype}{\mathsf{func}}~[t_1^\ast] \href{../syntax/types.html#syntax-comptype}{\rightarrow} [t_2^\ast]
}{
  S; C \href{../appendix/properties.html#valid-instr-admin}{\vdash} \href{../exec/instructions.html#exec-invoke}{\mathsf{invoke}}~\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}} : [t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}} [t_2^\ast]
}\]</div>
</section>
<section id="xref-exec-runtime-syntax-label-mathsf-label-n-xref-syntax-instructions-syntax-instr-mathit-instr-0-ast-xref-syntax-instructions-syntax-instr-mathit-instr-ast">
<span id="index-30"></span><h3><span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-label}{\mathsf{label}}_n\{\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}_0^\ast\}~\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast\)</span><a class="headerlink" href="#xref-exec-runtime-syntax-label-mathsf-label-n-xref-syntax-instructions-syntax-instr-mathit-instr-0-ast-xref-syntax-instructions-syntax-instr-mathit-instr-ast" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The instruction sequence <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}_0^\ast\)</span> must be <a class="reference internal" href="../valid/instructions.html#valid-instrs"><span class="std std-ref">valid</span></a> with some type <span class="math notranslate nohighlight">\([t_1^n] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}}_{x^\ast} [t_2^*]\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(C'\)</span> be the same <a class="reference internal" href="../valid/conventions.html#context"><span class="std std-ref">context</span></a> as <span class="math notranslate nohighlight">\(C\)</span>, but with the <a class="reference internal" href="../syntax/types.html#syntax-resulttype"><span class="std std-ref">result type</span></a> <span class="math notranslate nohighlight">\([t_1^n]\)</span> prepended to the <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#context}{\mathsf{labels}}\)</span> list.</p></li>
<li><p>Under context <span class="math notranslate nohighlight">\(C'\)</span>,
the instruction sequence <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast\)</span> must be <a class="reference internal" href="../valid/instructions.html#valid-instrs"><span class="std std-ref">valid</span></a> with type <span class="math notranslate nohighlight">\([] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}}_{{x'}^\ast} [t_2^*]\)</span>.</p></li>
<li><p>Then the compound instruction is valid with type <span class="math notranslate nohighlight">\([] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}} [t_2^*]\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  S; C \href{../valid/instructions.html#valid-instrs}{\vdash} \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}_0^\ast : [t_1^n] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}}_{x^\ast} [t_2^*]
  \qquad
  S; C,\href{../valid/conventions.html#context}{\mathsf{labels}}\,[t_1^n] \href{../valid/instructions.html#valid-instrs}{\vdash} \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast : [] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}}_{{x'}^\ast} [t_2^*]
}{
  S; C \href{../appendix/properties.html#valid-instr-admin}{\vdash} \href{../exec/runtime.html#syntax-label}{\mathsf{label}}_n\{\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}_0^\ast\}~\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast : [] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}} [t_2^*]
}\]</div>
</section>
<section id="xref-exec-runtime-syntax-frame-mathsf-frame-n-f-xref-syntax-instructions-syntax-instr-mathit-instr-ast">
<span id="index-31"></span><h3><span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-frame}{\mathsf{frame}}_n\{F\}~\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast\)</span><a class="headerlink" href="#xref-exec-runtime-syntax-frame-mathsf-frame-n-f-xref-syntax-instructions-syntax-instr-mathit-instr-ast" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>Under the <a class="reference internal" href="../valid/types.html#valid-resulttype"><span class="std std-ref">valid</span></a> return type <span class="math notranslate nohighlight">\([t^n]\)</span>,
the <a class="reference internal" href="../exec/runtime.html#syntax-frame"><span class="std std-ref">thread</span></a> <span class="math notranslate nohighlight">\(F; \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast\)</span> must be <a class="reference internal" href="#valid-frame"><span class="std std-ref">valid</span></a> with <a class="reference internal" href="../syntax/types.html#syntax-resulttype"><span class="std std-ref">result type</span></a> <span class="math notranslate nohighlight">\([t^n]\)</span>.</p></li>
<li><p>Then the compound instruction is valid with type <span class="math notranslate nohighlight">\([] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}} [t^n]\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  C \href{../valid/types.html#valid-resulttype}{\vdash} [t^n] : \href{../valid/types.html#valid-resulttype}{\mathsf{ok}}
  \qquad
  S; [t^n] \href{../valid/instructions.html#valid-instrs}{\vdash} F; \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast : [t^n]
}{
  S; C \href{../appendix/properties.html#valid-instr-admin}{\vdash} \href{../exec/runtime.html#syntax-frame}{\mathsf{frame}}_n\{F\}~\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast : [] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}} [t^n]
}\]</div>
</section>
<section id="xref-exec-runtime-syntax-handler-mathsf-handler-n-xref-syntax-instructions-syntax-catch-mathit-catch-ast-xref-syntax-instructions-syntax-instr-mathit-instr-ast">
<span id="index-32"></span><h3><span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-handler}{\mathsf{handler}}_n\{\href{../syntax/instructions.html#syntax-catch}{\mathit{catch}}^\ast\}~\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast\)</span><a class="headerlink" href="#xref-exec-runtime-syntax-handler-mathsf-handler-n-xref-syntax-instructions-syntax-catch-mathit-catch-ast-xref-syntax-instructions-syntax-instr-mathit-instr-ast" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>For every <a class="reference internal" href="../syntax/instructions.html#syntax-catch"><span class="std std-ref">catch clause</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-catch}{\mathit{catch}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-catch}{\mathit{catch}}^\ast\)</span>, <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-catch}{\mathit{catch}}_i\)</span> must be <a class="reference internal" href="../valid/instructions.html#valid-catch"><span class="std std-ref">valid</span></a>.</p></li>
<li><p>The instruction sequence <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast\)</span> must be <a class="reference internal" href="../valid/instructions.html#valid-instrs"><span class="std std-ref">valid</span></a> with some type <span class="math notranslate nohighlight">\([t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}} [t_2^\ast]\)</span>.</p></li>
<li><p>Then the compound instruction is valid with type <span class="math notranslate nohighlight">\([t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}} [t_2^\ast]\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}\frac{
  \begin{array}{c}
  (C \href{../valid/instructions.html#valid-catch}{\vdash} \href{../syntax/instructions.html#syntax-catch}{\mathit{catch}} : \href{../valid/instructions.html#valid-catch}{\mathsf{ok}})^\ast
  \qquad
  S; C \href{../valid/instructions.html#valid-instrs}{\vdash} \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast : [t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}} [t_2^\ast] \\
  \end{array}
}{
  S; C \href{../appendix/properties.html#valid-instr-admin}{\vdash} \href{../exec/runtime.html#syntax-handler}{\mathsf{handler}}_n\{\href{../syntax/instructions.html#syntax-catch}{\mathit{catch}}^\ast\}~\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast : [t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}} [t_2^\ast]
}\end{split}\]</div>
</section>
</section>
<section id="store-extension">
<span id="extend"></span><span id="index-33"></span><h2>Store Extension<a class="headerlink" href="#store-extension" title="Link to this heading">¶</a></h2>
<p>Programs can mutate the <a class="reference internal" href="../exec/runtime.html#syntax-store"><span class="std std-ref">store</span></a> and its contained instances.
Any such modification must respect certain invariants, such as not removing allocated instances or changing immutable definitions.
While these invariants are inherent to the execution semantics of WebAssembly <a class="reference internal" href="../exec/instructions.html#exec-instr"><span class="std std-ref">instructions</span></a> and <a class="reference internal" href="../exec/modules.html#exec-instantiation"><span class="std std-ref">modules</span></a>,
<a class="reference internal" href="../exec/runtime.html#syntax-hostfunc"><span class="std std-ref">host functions</span></a> do not automatically adhere to them. Consequently, the required invariants must be stated as explicit constraints on the <a class="reference internal" href="../exec/instructions.html#exec-invoke-host"><span class="std std-ref">invocation</span></a> of host functions.
Soundness only holds when the <a class="reference internal" href="../intro/overview.html#embedder"><span class="std std-ref">embedder</span></a> ensures these constraints.</p>
<p>The necessary constraints are codified by the notion of store <em>extension</em>:
a store state <span class="math notranslate nohighlight">\(S'\)</span> extends state <span class="math notranslate nohighlight">\(S\)</span>, written <span class="math notranslate nohighlight">\(S \href{../appendix/properties.html#extend}{\preceq} S'\)</span>, when the following rules hold.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Extension does not imply that the new store is valid, which is defined separately <a class="reference internal" href="#valid-store"><span class="std std-ref">above</span></a>.</p>
</div>
<section id="extend-store">
<span id="index-34"></span><span id="id2"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-store"><span class="std std-ref">Store</span></a> <span class="math notranslate nohighlight">\(S\)</span><a class="headerlink" href="#extend-store" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The length of <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{tags}}\)</span> must not shrink.</p></li>
<li><p>The length of <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{globals}}\)</span> must not shrink.</p></li>
<li><p>The length of <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{mems}}\)</span> must not shrink.</p></li>
<li><p>The length of <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{tables}}\)</span> must not shrink.</p></li>
<li><p>The length of <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{funcs}}\)</span> must not shrink.</p></li>
<li><p>The length of <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{datas}}\)</span> must not shrink.</p></li>
<li><p>The length of <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{elems}}\)</span> must not shrink.</p></li>
<li><p>The length of <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{structs}}\)</span> must not shrink.</p></li>
<li><p>The length of <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{arrays}}\)</span> must not shrink.</p></li>
<li><p>The length of <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{exns}}\)</span> must not shrink.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-taginst"><span class="std std-ref">tag instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-taginst}{\mathit{taginst}}_i\)</span> in the original <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{tags}}\)</span>, the new tag instance must be an <a class="reference internal" href="#extend-taginst"><span class="std std-ref">extension</span></a> of the old.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-globalinst"><span class="std std-ref">global instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-globalinst}{\mathit{globalinst}}_i\)</span> in the original <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{globals}}\)</span>, the new global instance must be an <a class="reference internal" href="#extend-globalinst"><span class="std std-ref">extension</span></a> of the old.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-meminst"><span class="std std-ref">memory instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}_i\)</span> in the original <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{mems}}\)</span>, the new memory instance must be an <a class="reference internal" href="#extend-meminst"><span class="std std-ref">extension</span></a> of the old.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-tableinst"><span class="std std-ref">table instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}_i\)</span> in the original <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{tables}}\)</span>, the new table instance must be an <a class="reference internal" href="#extend-tableinst"><span class="std std-ref">extension</span></a> of the old.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-funcinst"><span class="std std-ref">function instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}}_i\)</span> in the original <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{funcs}}\)</span>, the new function instance must be an <a class="reference internal" href="#extend-funcinst"><span class="std std-ref">extension</span></a> of the old.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-datainst"><span class="std std-ref">data instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-datainst}{\mathit{datainst}}_i\)</span> in the original <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{datas}}\)</span>, the new data instance must be an <a class="reference internal" href="#extend-datainst"><span class="std std-ref">extension</span></a> of the old.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-eleminst"><span class="std std-ref">element instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-eleminst}{\mathit{eleminst}}_i\)</span> in the original <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{elems}}\)</span>, the new element instance must be an <a class="reference internal" href="#extend-eleminst"><span class="std std-ref">extension</span></a> of the old.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-structinst"><span class="std std-ref">structure instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-structinst}{\mathit{structinst}}_i\)</span> in the original <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{structs}}\)</span>, the new structure instance must be an <a class="reference internal" href="#extend-structinst"><span class="std std-ref">extension</span></a> of the old.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-arrayinst"><span class="std std-ref">array instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-arrayinst}{\mathit{arrayinst}}_i\)</span> in the original <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{arrays}}\)</span>, the new array instance must be an <a class="reference internal" href="#extend-arrayinst"><span class="std std-ref">extension</span></a> of the old.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-exninst"><span class="std std-ref">exception instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-exninst}{\mathit{exninst}}_i\)</span> in the original <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{exns}}\)</span>, the new exception instance must be an <a class="reference internal" href="#extend-datainst"><span class="std std-ref">extension</span></a> of the old.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}\frac{
  \begin{array}{&#64;{}ccc&#64;{}}
  S_1.\href{../exec/runtime.html#syntax-store}{\mathsf{tags}} = \href{../exec/runtime.html#syntax-taginst}{\mathit{taginst}}_1^\ast &amp;
  S_2.\href{../exec/runtime.html#syntax-store}{\mathsf{tags}} = {\href{../exec/runtime.html#syntax-taginst}{\mathit{taginst}}'_1}^\ast~\href{../exec/runtime.html#syntax-taginst}{\mathit{taginst}}_2^\ast &amp;
  (\href{../appendix/properties.html#extend-taginst}{\vdash} \href{../exec/runtime.html#syntax-taginst}{\mathit{taginst}}_1 \href{../appendix/properties.html#extend}{\preceq} \href{../exec/runtime.html#syntax-taginst}{\mathit{taginst}}'_1)^\ast
  \\
  S_1.\href{../exec/runtime.html#syntax-store}{\mathsf{globals}} = \href{../exec/runtime.html#syntax-globalinst}{\mathit{globalinst}}_1^\ast &amp;
  S_2.\href{../exec/runtime.html#syntax-store}{\mathsf{globals}} = {\href{../exec/runtime.html#syntax-globalinst}{\mathit{globalinst}}'_1}^\ast~\href{../exec/runtime.html#syntax-globalinst}{\mathit{globalinst}}_2^\ast &amp;
  (\href{../appendix/properties.html#extend-globalinst}{\vdash} \href{../exec/runtime.html#syntax-globalinst}{\mathit{globalinst}}_1 \href{../appendix/properties.html#extend}{\preceq} \href{../exec/runtime.html#syntax-globalinst}{\mathit{globalinst}}'_1)^\ast
  \\
  S_1.\href{../exec/runtime.html#syntax-store}{\mathsf{mems}} = \href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}_1^\ast &amp;
  S_2.\href{../exec/runtime.html#syntax-store}{\mathsf{mems}} = {\href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}'_1}^\ast~\href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}_2^\ast &amp;
  (\href{../appendix/properties.html#extend-meminst}{\vdash} \href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}_1 \href{../appendix/properties.html#extend}{\preceq} \href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}'_1)^\ast
  \\
  S_1.\href{../exec/runtime.html#syntax-store}{\mathsf{tables}} = \href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}_1^\ast &amp;
  S_2.\href{../exec/runtime.html#syntax-store}{\mathsf{tables}} = {\href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}'_1}^\ast~\href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}_2^\ast &amp;
  (\href{../appendix/properties.html#extend-tableinst}{\vdash} \href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}_1 \href{../appendix/properties.html#extend}{\preceq} \href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}'_1)^\ast \\
  S_1.\href{../exec/runtime.html#syntax-store}{\mathsf{funcs}} = \href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}}_1^\ast &amp;
  S_2.\href{../exec/runtime.html#syntax-store}{\mathsf{funcs}} = {\href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}}'_1}^\ast~\href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}}_2^\ast &amp;
  (\href{../appendix/properties.html#extend-funcinst}{\vdash} \href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}}_1 \href{../appendix/properties.html#extend}{\preceq} \href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}}'_1)^\ast
  \\
  S_1.\href{../exec/runtime.html#syntax-store}{\mathsf{datas}} = \href{../exec/runtime.html#syntax-datainst}{\mathit{datainst}}_1^\ast &amp;
  S_2.\href{../exec/runtime.html#syntax-store}{\mathsf{datas}} = {\href{../exec/runtime.html#syntax-datainst}{\mathit{datainst}}'_1}^\ast~\href{../exec/runtime.html#syntax-datainst}{\mathit{datainst}}_2^\ast &amp;
  (\href{../appendix/properties.html#extend-datainst}{\vdash} \href{../exec/runtime.html#syntax-datainst}{\mathit{datainst}}_1 \href{../appendix/properties.html#extend}{\preceq} \href{../exec/runtime.html#syntax-datainst}{\mathit{datainst}}'_1)^\ast
  \\
  S_1.\href{../exec/runtime.html#syntax-store}{\mathsf{elems}} = \href{../exec/runtime.html#syntax-eleminst}{\mathit{eleminst}}_1^\ast &amp;
  S_2.\href{../exec/runtime.html#syntax-store}{\mathsf{elems}} = {\href{../exec/runtime.html#syntax-eleminst}{\mathit{eleminst}}'_1}^\ast~\href{../exec/runtime.html#syntax-eleminst}{\mathit{eleminst}}_2^\ast &amp;
  (\href{../appendix/properties.html#extend-eleminst}{\vdash} \href{../exec/runtime.html#syntax-eleminst}{\mathit{eleminst}}_1 \href{../appendix/properties.html#extend}{\preceq} \href{../exec/runtime.html#syntax-eleminst}{\mathit{eleminst}}'_1)^\ast
  \\
  S_1.\href{../exec/runtime.html#syntax-store}{\mathsf{structs}} = \href{../exec/runtime.html#syntax-structinst}{\mathit{structinst}}_1^\ast &amp;
  S_2.\href{../exec/runtime.html#syntax-store}{\mathsf{structs}} = {\href{../exec/runtime.html#syntax-structinst}{\mathit{structinst}}'_1}^\ast~\href{../exec/runtime.html#syntax-structinst}{\mathit{structinst}}_2^\ast &amp;
  (\href{../appendix/properties.html#extend-structinst}{\vdash} \href{../exec/runtime.html#syntax-structinst}{\mathit{structinst}}_1 \href{../appendix/properties.html#extend}{\preceq} \href{../exec/runtime.html#syntax-structinst}{\mathit{structinst}}'_1)^\ast
  \\
  S_1.\href{../exec/runtime.html#syntax-store}{\mathsf{arrays}} = \href{../exec/runtime.html#syntax-arrayinst}{\mathit{arrayinst}}_1^\ast &amp;
  S_2.\href{../exec/runtime.html#syntax-store}{\mathsf{arrays}} = {\href{../exec/runtime.html#syntax-arrayinst}{\mathit{arrayinst}}'_1}^\ast~\href{../exec/runtime.html#syntax-arrayinst}{\mathit{arrayinst}}_2^\ast &amp;
  (\href{../appendix/properties.html#extend-arrayinst}{\vdash} \href{../exec/runtime.html#syntax-arrayinst}{\mathit{arrayinst}}_1 \href{../appendix/properties.html#extend}{\preceq} \href{../exec/runtime.html#syntax-arrayinst}{\mathit{arrayinst}}'_1)^\ast
  \\
  S_1.\href{../exec/runtime.html#syntax-store}{\mathsf{exns}} = \href{../exec/runtime.html#syntax-exninst}{\mathit{exninst}}_1^\ast &amp;
  S_2.\href{../exec/runtime.html#syntax-store}{\mathsf{exns}} = {\href{../exec/runtime.html#syntax-exninst}{\mathit{exninst}}'_1}^\ast~\href{../exec/runtime.html#syntax-exninst}{\mathit{exninst}}_2^\ast &amp;
  (\href{../appendix/properties.html#extend-exninst}{\vdash} \href{../exec/runtime.html#syntax-exninst}{\mathit{exninst}}_1 \href{../appendix/properties.html#extend}{\preceq} \href{../exec/runtime.html#syntax-exninst}{\mathit{exninst}}'_1)^\ast
  \\
  \end{array}
}{
  \href{../appendix/properties.html#extend-store}{\vdash} S_1 \href{../appendix/properties.html#extend}{\preceq} S_2
}\end{split}\]</div>
</section>
<section id="tag-instance-xref-exec-runtime-syntax-taginst-mathit-taginst">
<span id="extend-taginst"></span><span id="index-35"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-taginst"><span class="std std-ref">Tag Instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-taginst}{\mathit{taginst}}\)</span><a class="headerlink" href="#tag-instance-xref-exec-runtime-syntax-taginst-mathit-taginst" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>A tag instance must remain unchanged.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
}{
  \href{../appendix/properties.html#extend-taginst}{\vdash} \href{../exec/runtime.html#syntax-taginst}{\mathit{taginst}} \href{../appendix/properties.html#extend}{\preceq} \href{../exec/runtime.html#syntax-taginst}{\mathit{taginst}}
}\]</div>
</section>
<section id="global-instance-xref-exec-runtime-syntax-globalinst-mathit-globalinst">
<span id="extend-globalinst"></span><span id="index-36"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-globalinst"><span class="std std-ref">Global Instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-globalinst}{\mathit{globalinst}}\)</span><a class="headerlink" href="#global-instance-xref-exec-runtime-syntax-globalinst-mathit-globalinst" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../syntax/types.html#syntax-globaltype"><span class="std std-ref">global type</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-globalinst}{\mathit{globalinst}}.\href{../exec/runtime.html#syntax-globalinst}{\mathsf{type}}\)</span> must remain unchanged.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-mut}{\mathit{mut}}~t\)</span> be the structure of <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-globalinst}{\mathit{globalinst}}.\href{../exec/runtime.html#syntax-globalinst}{\mathsf{type}}\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-mut}{\mathit{mut}}\)</span> is empty, then the <a class="reference internal" href="../exec/runtime.html#syntax-val"><span class="std std-ref">value</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-globalinst}{\mathit{globalinst}}.\href{../exec/runtime.html#syntax-globalinst}{\mathsf{value}}\)</span> must remain unchanged.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  \href{../syntax/types.html#syntax-mut}{\mathit{mut}} = \href{../syntax/types.html#syntax-mut}{\mathsf{mut}} \vee \href{../exec/runtime.html#syntax-val}{\mathit{val}}_1 = \href{../exec/runtime.html#syntax-val}{\mathit{val}}_2
}{
  \href{../appendix/properties.html#extend-globalinst}{\vdash} \{\href{../exec/runtime.html#syntax-globalinst}{\mathsf{type}}~(\href{../syntax/types.html#syntax-mut}{\mathit{mut}}~t), \href{../exec/runtime.html#syntax-globalinst}{\mathsf{value}}~\href{../exec/runtime.html#syntax-val}{\mathit{val}}_1\} \href{../appendix/properties.html#extend}{\preceq} \{\href{../exec/runtime.html#syntax-globalinst}{\mathsf{type}}~(\href{../syntax/types.html#syntax-mut}{\mathit{mut}}~t), \href{../exec/runtime.html#syntax-globalinst}{\mathsf{value}}~\href{../exec/runtime.html#syntax-val}{\mathit{val}}_2\}
}\]</div>
</section>
<section id="memory-instance-xref-exec-runtime-syntax-meminst-mathit-meminst">
<span id="extend-meminst"></span><span id="index-37"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-meminst"><span class="std std-ref">Memory Instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}\)</span><a class="headerlink" href="#memory-instance-xref-exec-runtime-syntax-meminst-mathit-meminst" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../syntax/types.html#syntax-memtype"><span class="std std-ref">memory type</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}.\href{../exec/runtime.html#syntax-meminst}{\mathsf{type}}\)</span> must remain unchanged.</p></li>
<li><p>The length of <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}.\href{../exec/runtime.html#syntax-meminst}{\mathsf{bytes}}\)</span> must not shrink.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  n_1 \leq n_2
}{
  \href{../appendix/properties.html#extend-meminst}{\vdash} \{\href{../exec/runtime.html#syntax-meminst}{\mathsf{type}}~\mathit{mt}, \href{../exec/runtime.html#syntax-meminst}{\mathsf{bytes}}~b_1^{n_1}\} \href{../appendix/properties.html#extend}{\preceq} \{\href{../exec/runtime.html#syntax-meminst}{\mathsf{type}}~\mathit{mt}, \href{../exec/runtime.html#syntax-meminst}{\mathsf{bytes}}~b_2^{n_2}\}
}\]</div>
</section>
<section id="table-instance-xref-exec-runtime-syntax-tableinst-mathit-tableinst">
<span id="extend-tableinst"></span><span id="index-38"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-tableinst"><span class="std std-ref">Table Instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}\)</span><a class="headerlink" href="#table-instance-xref-exec-runtime-syntax-tableinst-mathit-tableinst" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../syntax/types.html#syntax-tabletype"><span class="std std-ref">table type</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}.\href{../exec/runtime.html#syntax-tableinst}{\mathsf{type}}\)</span> must remain unchanged.</p></li>
<li><p>The length of <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}.\href{../exec/runtime.html#syntax-tableinst}{\mathsf{elem}}\)</span> must not shrink.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  n_1 \leq n_2
}{
  \href{../appendix/properties.html#extend-tableinst}{\vdash} \{\href{../exec/runtime.html#syntax-tableinst}{\mathsf{type}}~\mathit{tt}, \href{../exec/runtime.html#syntax-tableinst}{\mathsf{elem}}~(\mathit{fa}_1^?)^{n_1}\} \href{../appendix/properties.html#extend}{\preceq} \{\href{../exec/runtime.html#syntax-tableinst}{\mathsf{type}}~\mathit{tt}, \href{../exec/runtime.html#syntax-tableinst}{\mathsf{elem}}~(\mathit{fa}_2^?)^{n_2}\}
}\]</div>
</section>
<section id="function-instance-xref-exec-runtime-syntax-funcinst-mathit-funcinst">
<span id="extend-funcinst"></span><span id="index-39"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-funcinst"><span class="std std-ref">Function Instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}}\)</span><a class="headerlink" href="#function-instance-xref-exec-runtime-syntax-funcinst-mathit-funcinst" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>A function instance must remain unchanged.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
}{
  \href{../appendix/properties.html#extend-funcinst}{\vdash} \href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}} \href{../appendix/properties.html#extend}{\preceq} \href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}}
}\]</div>
</section>
<section id="data-instance-xref-exec-runtime-syntax-datainst-mathit-datainst">
<span id="extend-datainst"></span><span id="index-40"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-datainst"><span class="std std-ref">Data Instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-datainst}{\mathit{datainst}}\)</span><a class="headerlink" href="#data-instance-xref-exec-runtime-syntax-datainst-mathit-datainst" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The list <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-datainst}{\mathit{datainst}}.\href{../exec/runtime.html#syntax-datainst}{\mathsf{bytes}}\)</span> must:</p>
<ul>
<li><p>either remain unchanged,</p></li>
<li><p>or shrink to length <span class="math notranslate nohighlight">\(0\)</span>.</p></li>
</ul>
</li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
}{
  \href{../appendix/properties.html#extend-datainst}{\vdash} \{\href{../exec/runtime.html#syntax-datainst}{\mathsf{bytes}}~b^\ast\} \href{../appendix/properties.html#extend}{\preceq} \{\href{../exec/runtime.html#syntax-datainst}{\mathsf{bytes}}~b^\ast\}
}\]</div>
<div class="math notranslate nohighlight">
\[\frac{
}{
  \href{../appendix/properties.html#extend-datainst}{\vdash} \{\href{../exec/runtime.html#syntax-datainst}{\mathsf{bytes}}~b^\ast\} \href{../appendix/properties.html#extend}{\preceq} \{\href{../exec/runtime.html#syntax-datainst}{\mathsf{bytes}}~\epsilon\}
}\]</div>
</section>
<section id="element-instance-xref-exec-runtime-syntax-eleminst-mathit-eleminst">
<span id="extend-eleminst"></span><span id="index-41"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-eleminst"><span class="std std-ref">Element Instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-eleminst}{\mathit{eleminst}}\)</span><a class="headerlink" href="#element-instance-xref-exec-runtime-syntax-eleminst-mathit-eleminst" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../syntax/types.html#syntax-reftype"><span class="std std-ref">reference type</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-eleminst}{\mathit{eleminst}}.\href{../exec/runtime.html#syntax-eleminst}{\mathsf{type}}\)</span> must remain unchanged.</p></li>
<li><p>The list <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-eleminst}{\mathit{eleminst}}.\href{../exec/runtime.html#syntax-eleminst}{\mathsf{elem}}\)</span> must:</p>
<ul>
<li><p>either remain unchanged,</p></li>
<li><p>or shrink to length <span class="math notranslate nohighlight">\(0\)</span>.</p></li>
</ul>
</li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
}{
  \href{../appendix/properties.html#extend-eleminst}{\vdash} \{\href{../exec/runtime.html#syntax-eleminst}{\mathsf{type}}~t, \href{../exec/runtime.html#syntax-eleminst}{\mathsf{elem}}~a^\ast\} \href{../appendix/properties.html#extend}{\preceq} \{\href{../exec/runtime.html#syntax-eleminst}{\mathsf{type}}~t, \href{../exec/runtime.html#syntax-eleminst}{\mathsf{elem}}~a^\ast\}
}\]</div>
<div class="math notranslate nohighlight">
\[\frac{
}{
  \href{../appendix/properties.html#extend-eleminst}{\vdash} \{\href{../exec/runtime.html#syntax-eleminst}{\mathsf{type}}~t, \href{../exec/runtime.html#syntax-eleminst}{\mathsf{elem}}~a^\ast\} \href{../appendix/properties.html#extend}{\preceq} \{\href{../exec/runtime.html#syntax-eleminst}{\mathsf{type}}~t, \href{../exec/runtime.html#syntax-eleminst}{\mathsf{elem}}~\epsilon\}
}\]</div>
</section>
<section id="structure-instance-xref-exec-runtime-syntax-structinst-mathit-structinst">
<span id="extend-structinst"></span><span id="index-42"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-structinst"><span class="std std-ref">Structure Instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-structinst}{\mathit{structinst}}\)</span><a class="headerlink" href="#structure-instance-xref-exec-runtime-syntax-structinst-mathit-structinst" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../valid/conventions.html#syntax-deftype"><span class="std std-ref">defined type</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-structinst}{\mathit{structinst}}.\href{../exec/runtime.html#syntax-structinst}{\mathsf{type}}\)</span> must remain unchanged.</p></li>
<li><p>Assert: due to <a class="reference internal" href="#valid-structinst"><span class="std std-ref">store well-formedness</span></a>, the <a class="reference internal" href="../valid/conventions.html#aux-expand-deftype"><span class="std std-ref">expansion</span></a> of <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-structinst}{\mathit{structinst}}.\href{../exec/runtime.html#syntax-structinst}{\mathsf{type}}\)</span> is a <a class="reference internal" href="../syntax/types.html#syntax-structtype"><span class="std std-ref">structure type</span></a>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-comptype}{\mathsf{struct}}~\href{../syntax/types.html#syntax-fieldtype}{\mathit{fieldtype}}^\ast\)</span> be the <a class="reference internal" href="../valid/conventions.html#aux-expand-deftype"><span class="std std-ref">expansion</span></a> of <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-structinst}{\mathit{structinst}}.\href{../exec/runtime.html#syntax-structinst}{\mathsf{type}}\)</span>.</p></li>
<li><p>The length of the list <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-structinst}{\mathit{structinst}}.\href{../exec/runtime.html#syntax-structinst}{\mathsf{fields}}\)</span> must remain unchanged.</p></li>
<li><p>Assert: due to <a class="reference internal" href="#valid-structinst"><span class="std std-ref">store well-formedness</span></a>, the length of <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-structinst}{\mathit{structinst}}.\href{../exec/runtime.html#syntax-structinst}{\mathsf{fields}}\)</span> is the same as the length of <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-fieldtype}{\mathit{fieldtype}}^\ast\)</span>.</p></li>
<li><p>For each <a class="reference internal" href="../exec/runtime.html#syntax-fieldval"><span class="std std-ref">field value</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-structinst}{\mathit{structinst}}.\href{../exec/runtime.html#syntax-structinst}{\mathsf{fields}}\)</span> and corresponding <a class="reference internal" href="../syntax/types.html#syntax-fieldtype"><span class="std std-ref">field type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-fieldtype}{\mathit{fieldtype}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-fieldtype}{\mathit{fieldtype}}^\ast\)</span>:</p>
<ul>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-mut}{\mathit{mut}}_i~\mathit{st}_i\)</span> be the structure of <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-fieldtype}{\mathit{fieldtype}}_i\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-mut}{\mathit{mut}}_i\)</span> is empty, then the <a class="reference internal" href="../exec/runtime.html#syntax-fieldval"><span class="std std-ref">field value</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}_i\)</span> must remain unchanged.</p></li>
</ul>
</li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  (\href{../syntax/types.html#syntax-mut}{\mathit{mut}} = \href{../syntax/types.html#syntax-mut}{\mathsf{mut}} \vee \href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}_1 = \href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}_2)^\ast
}{
  \href{../appendix/properties.html#extend-structinst}{\vdash} \{\href{../exec/runtime.html#syntax-structinst}{\mathsf{type}}~(\href{../syntax/types.html#syntax-mut}{\mathit{mut}}~\mathit{st})^\ast, \href{../exec/runtime.html#syntax-structinst}{\mathsf{fields}}~\href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}_1^\ast\} \href{../appendix/properties.html#extend}{\preceq} \{\href{../exec/runtime.html#syntax-structinst}{\mathsf{type}}~(\href{../syntax/types.html#syntax-mut}{\mathit{mut}}~\mathit{st})^\ast, \href{../exec/runtime.html#syntax-structinst}{\mathsf{fields}}~\href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}_2^\ast\}
}\]</div>
</section>
<section id="array-instance-xref-exec-runtime-syntax-arrayinst-mathit-arrayinst">
<span id="extend-arrayinst"></span><span id="index-43"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-arrayinst"><span class="std std-ref">Array Instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-arrayinst}{\mathit{arrayinst}}\)</span><a class="headerlink" href="#array-instance-xref-exec-runtime-syntax-arrayinst-mathit-arrayinst" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../valid/conventions.html#syntax-deftype"><span class="std std-ref">defined type</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-arrayinst}{\mathit{arrayinst}}.\href{../exec/runtime.html#syntax-arrayinst}{\mathsf{type}}\)</span> must remain unchanged.</p></li>
<li><p>Assert: due to <a class="reference internal" href="#valid-arrayinst"><span class="std std-ref">store well-formedness</span></a>, the <a class="reference internal" href="../valid/conventions.html#aux-expand-deftype"><span class="std std-ref">expansion</span></a> of <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-arrayinst}{\mathit{arrayinst}}.\href{../exec/runtime.html#syntax-arrayinst}{\mathsf{type}}\)</span> is an <a class="reference internal" href="../syntax/types.html#syntax-arraytype"><span class="std std-ref">array type</span></a>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-comptype}{\mathsf{array}}~\href{../syntax/types.html#syntax-fieldtype}{\mathit{fieldtype}}\)</span> be the <a class="reference internal" href="../valid/conventions.html#aux-expand-deftype"><span class="std std-ref">expansion</span></a> of <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-arrayinst}{\mathit{arrayinst}}.\href{../exec/runtime.html#syntax-arrayinst}{\mathsf{type}}\)</span>.</p></li>
<li><p>The length of the list <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-arrayinst}{\mathit{arrayinst}}.\href{../exec/runtime.html#syntax-arrayinst}{\mathsf{fields}}\)</span> must remain unchanged.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-mut}{\mathit{mut}}~\mathit{st}\)</span> be the structure of <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-fieldtype}{\mathit{fieldtype}}\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-mut}{\mathit{mut}}\)</span> is empty, then the sequence of <a class="reference internal" href="../exec/runtime.html#syntax-fieldval"><span class="std std-ref">field values</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-arrayinst}{\mathit{arrayinst}}.\href{../exec/runtime.html#syntax-arrayinst}{\mathsf{fields}}\)</span> must remain unchanged.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  \href{../syntax/types.html#syntax-mut}{\mathit{mut}} = \href{../syntax/types.html#syntax-mut}{\mathsf{mut}} \vee \href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}_1^\ast = \href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}_2^\ast
}{
  \href{../appendix/properties.html#extend-arrayinst}{\vdash} \{\href{../exec/runtime.html#syntax-arrayinst}{\mathsf{type}}~(\href{../syntax/types.html#syntax-mut}{\mathit{mut}}~\mathit{st}), \href{../exec/runtime.html#syntax-arrayinst}{\mathsf{fields}}~\href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}_1^\ast\} \href{../appendix/properties.html#extend}{\preceq} \{\href{../exec/runtime.html#syntax-arrayinst}{\mathsf{type}}~(\href{../syntax/types.html#syntax-mut}{\mathit{mut}}~\mathit{st}), \href{../exec/runtime.html#syntax-arrayinst}{\mathsf{fields}}~\href{../exec/runtime.html#syntax-fieldval}{\mathit{fieldval}}_2^\ast\}
}\]</div>
</section>
<section id="exception-instance-xref-exec-runtime-syntax-exninst-mathit-exninst">
<span id="extend-exninst"></span><span id="index-44"></span><h3><a class="reference internal" href="../exec/runtime.html#syntax-exninst"><span class="std std-ref">Exception Instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-exninst}{\mathit{exninst}}\)</span><a class="headerlink" href="#exception-instance-xref-exec-runtime-syntax-exninst-mathit-exninst" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>An exception instance must remain unchanged.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
}{
  \href{../appendix/properties.html#extend-exninst}{\vdash} \href{../exec/runtime.html#syntax-exninst}{\mathit{exninst}} \href{../appendix/properties.html#extend}{\preceq} \href{../exec/runtime.html#syntax-exninst}{\mathit{exninst}}
}\]</div>
</section>
</section>
<section id="theorems">
<span id="soundness-statement"></span><span id="index-45"></span><h2>Theorems<a class="headerlink" href="#theorems" title="Link to this heading">¶</a></h2>
<p>Given the definition of <a class="reference internal" href="#valid-config"><span class="std std-ref">valid configurations</span></a>,
the standard soundness theorems hold. <a class="footnote-reference brackets" href="#cite-cpp2018" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#cite-fm2021" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p>
<p><strong>Theorem (Preservation).</strong>
If a <a class="reference internal" href="../exec/runtime.html#syntax-config"><span class="std std-ref">configuration</span></a> <span class="math notranslate nohighlight">\(S;T\)</span> is <a class="reference internal" href="#valid-config"><span class="std std-ref">valid</span></a> with <a class="reference internal" href="../syntax/types.html#syntax-resulttype"><span class="std std-ref">result type</span></a> <span class="math notranslate nohighlight">\([t^\ast]\)</span> (i.e., <span class="math notranslate nohighlight">\(\href{../appendix/properties.html#valid-config}{\vdash} S;T : [t^\ast]\)</span>),
and steps to <span class="math notranslate nohighlight">\(S';T'\)</span> (i.e., <span class="math notranslate nohighlight">\(S;T \href{../exec/conventions.html#exec-notation}{\hookrightarrow} S';T'\)</span>),
then <span class="math notranslate nohighlight">\(S';T'\)</span> is a valid configuration with the same result type (i.e., <span class="math notranslate nohighlight">\(\href{../appendix/properties.html#valid-config}{\vdash} S';T' : [t^\ast]\)</span>).
Furthermore, <span class="math notranslate nohighlight">\(S'\)</span> is an <a class="reference internal" href="#extend-store"><span class="std std-ref">extension</span></a> of <span class="math notranslate nohighlight">\(S\)</span> (i.e., <span class="math notranslate nohighlight">\(\href{../appendix/properties.html#extend-store}{\vdash} S \href{../appendix/properties.html#extend}{\preceq} S'\)</span>).</p>
<p>A <em>terminal</em> <a class="reference internal" href="../exec/runtime.html#syntax-thread"><span class="std std-ref">thread</span></a> is one whose sequence of <a class="reference internal" href="../syntax/instructions.html#syntax-instr"><span class="std std-ref">instructions</span></a> is a <a class="reference internal" href="../exec/runtime.html#syntax-result"><span class="std std-ref">result</span></a>.
A terminal configuration is a configuration whose thread is terminal.</p>
<p><strong>Theorem (Progress).</strong>
If a <a class="reference internal" href="../exec/runtime.html#syntax-config"><span class="std std-ref">configuration</span></a> <span class="math notranslate nohighlight">\(S;T\)</span> is <a class="reference internal" href="#valid-config"><span class="std std-ref">valid</span></a> (i.e., <span class="math notranslate nohighlight">\(\href{../appendix/properties.html#valid-config}{\vdash} S;T : [t^\ast]\)</span> for some <a class="reference internal" href="../syntax/types.html#syntax-resulttype"><span class="std std-ref">result type</span></a> <span class="math notranslate nohighlight">\([t^\ast]\)</span>),
then either it is terminal,
or it can step to some configuration <span class="math notranslate nohighlight">\(S';T'\)</span> (i.e., <span class="math notranslate nohighlight">\(S;T \href{../exec/conventions.html#exec-notation}{\hookrightarrow} S';T'\)</span>).</p>
<p>From Preservation and Progress the soundness of the WebAssembly type system follows directly.</p>
<p><strong>Corollary (Soundness).</strong>
If a <a class="reference internal" href="../exec/runtime.html#syntax-config"><span class="std std-ref">configuration</span></a> <span class="math notranslate nohighlight">\(S;T\)</span> is <a class="reference internal" href="#valid-config"><span class="std std-ref">valid</span></a> (i.e., <span class="math notranslate nohighlight">\(\href{../appendix/properties.html#valid-config}{\vdash} S;T : [t^\ast]\)</span> for some <a class="reference internal" href="../syntax/types.html#syntax-resulttype"><span class="std std-ref">result type</span></a> <span class="math notranslate nohighlight">\([t^\ast]\)</span>),
then it either diverges or takes a finite number of steps to reach a terminal configuration <span class="math notranslate nohighlight">\(S';T'\)</span> (i.e., <span class="math notranslate nohighlight">\(S;T \href{../exec/conventions.html#exec-notation}{\hookrightarrow}^\ast S';T'\)</span>) that is valid with the same result type (i.e., <span class="math notranslate nohighlight">\(\href{../appendix/properties.html#valid-config}{\vdash} S';T' : [t^\ast]\)</span>)
and where <span class="math notranslate nohighlight">\(S'\)</span> is an <a class="reference internal" href="#extend-store"><span class="std std-ref">extension</span></a> of <span class="math notranslate nohighlight">\(S\)</span> (i.e., <span class="math notranslate nohighlight">\(\href{../appendix/properties.html#extend-store}{\vdash} S \href{../appendix/properties.html#extend}{\preceq} S'\)</span>).</p>
<p>In other words, every thread in a valid configuration either runs forever, traps, throws an exception, or terminates with a result that has the expected type.
Consequently, given a <a class="reference internal" href="#valid-store"><span class="std std-ref">valid store</span></a>, no computation defined by <a class="reference internal" href="../exec/modules.html#exec-instantiation"><span class="std std-ref">instantiation</span></a> or <a class="reference internal" href="../exec/modules.html#exec-invocation"><span class="std std-ref">invocation</span></a> of a valid module can “crash” or otherwise (mis)behave in ways not covered by the <a class="reference internal" href="../exec/index.html#exec"><span class="std std-ref">execution</span></a> semantics given in this specification.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="cite-pldi2017" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>The formalization and theorems are derived from the following article:
Andreas Haas, Andreas Rossberg, Derek Schuff, Ben Titzer, Dan Gohman, Luke Wagner, Alon Zakai, JF Bastien, Michael Holman. <a class="reference external" href="https://dl.acm.org/citation.cfm?doid=3062341.3062363">Bringing the Web up to Speed with WebAssembly</a>. Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2017). ACM 2017.</p>
</aside>
<aside class="footnote brackets" id="cite-cpp2018" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span>
<p>A machine-verified version of the formalization and soundness proof of the PLDI 2017 paper is described in the following article:
Conrad Watt. <a class="reference external" href="https://dl.acm.org/citation.cfm?id=3167082">Mechanising and Verifying the WebAssembly Specification</a>. Proceedings of the 7th ACM SIGPLAN Conference on Certified Programs and Proofs (CPP 2018). ACM 2018.</p>
</aside>
<aside class="footnote brackets" id="cite-fm2021" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">3</a><span class="fn-bracket">]</span></span>
<p>Machine-verified formalizations and soundness proofs of the semantics from the official specification are described in the following article:
Conrad Watt, Xiaojia Rao, Jean Pichon-Pharabod, Martin Bodin, Philippa Gardner. <a class="reference external" href="https://link.springer.com/chapter/10.1007/978-3-030-90870-6_4">Two Mechanisations of WebAssembly 1.0</a>. Proceedings of the 24th International Symposium on Formal Methods (FM 2021). Springer 2021.</p>
</aside>
</aside>
</section>
</section>
<section id="type-system-properties">
<span id="index-46"></span><h1>Type System Properties<a class="headerlink" href="#type-system-properties" title="Link to this heading">¶</a></h1>
<section id="principal-types">
<span id="principality"></span><span id="index-47"></span><h2>Principal Types<a class="headerlink" href="#principal-types" title="Link to this heading">¶</a></h2>
<p>The <a class="reference internal" href="../valid/conventions.html#type-system"><span class="std std-ref">type system</span></a> of WebAssembly features both <a class="reference internal" href="../valid/matching.html#match"><span class="std std-ref">subtyping</span></a> and simple forms of <a class="reference internal" href="../valid/instructions.html#polymorphism"><span class="std std-ref">polymorphism</span></a> for <a class="reference internal" href="../valid/conventions.html#syntax-instrtype"><span class="std std-ref">instruction types</span></a>.
That has the effect that every instruction or instruction sequence can be classified with multiple different instruction types.</p>
<p>However, the typing rules still allow deriving <em>principal types</em> for instruction sequences.
That is, every valid instruction sequence has one particular type scheme, possibly containing some unconstrained place holder <em>type variables</em>, that is a subtype of all its valid instruction types, after substituting its type variables with suitable specific types.</p>
<p>Moreover, when deriving an instruction type in a “forward” manner, i.e., the <em>input</em> of the instruction sequence is already fixed to specific types,
then it has a principal <em>output</em> type expressible without type variables, up to a possibly <a class="reference internal" href="../valid/instructions.html#polymorphism"><span class="std std-ref">polymorphic stack</span></a> bottom representable with one single variable.
In other words, “forward” principal types are effectively <em>closed</em>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For example, in isolation, the instruction <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr-ref}{\mathsf{ref{.}as\_non\_null}}\)</span> has the type <span class="math notranslate nohighlight">\([(\href{../syntax/types.html#syntax-reftype}{\mathsf{ref}}~\href{../syntax/types.html#syntax-reftype}{\mathsf{null}}~\mathit{ht})] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}} [(\href{../syntax/types.html#syntax-reftype}{\mathsf{ref}}~\mathit{ht})]\)</span> for any choice of valid <a class="reference internal" href="../syntax/modules.html#syntax-type"><span class="std std-ref">heap type</span></a> <span class="math notranslate nohighlight">\(\mathit{ht}\)</span>.
Moreover, if the input type <span class="math notranslate nohighlight">\([(\href{../syntax/types.html#syntax-reftype}{\mathsf{ref}}~\href{../syntax/types.html#syntax-reftype}{\mathsf{null}}~\mathit{ht})]\)</span> is already determined, i.e., a specific <span class="math notranslate nohighlight">\(\mathit{ht}\)</span> is given, then the output type <span class="math notranslate nohighlight">\([(\href{../syntax/types.html#syntax-reftype}{\mathsf{ref}}~\mathit{ht})]\)</span> is fully determined as well.</p>
<p>The implication of the latter property is that a validator for <em>complete</em> instruction sequences (as they occur in valid modules) can be implemented with a simple left-to-right <a class="reference internal" href="algorithm.html#algo-valid"><span class="std std-ref">algorithm</span></a> that does not require the introduction of type variables.</p>
<p>A typing algorithm capable of handling <em>partial</em> instruction sequences (as might be considered for program analysis or program manipulation)
needs to introduce type variables and perform substitutions,
but it does not need to perform backtracking or record any non-syntactic constraints on these type variables.</p>
</div>
<p>Technically, the <a class="reference internal" href="../syntax/modules.html#syntax-type"><span class="std std-ref">syntax</span></a> of <a class="reference internal" href="../syntax/types.html#syntax-heaptype"><span class="std std-ref">heap</span></a>, <a class="reference internal" href="../syntax/types.html#syntax-valtype"><span class="std std-ref">value</span></a>, and <a class="reference internal" href="../syntax/types.html#syntax-resulttype"><span class="std std-ref">result</span></a> types can be enriched with type variables as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{llll}
\def\mathdef1587#1{{}}\mathdef1587{nullability} &amp; \mathit{null} &amp;::=&amp;
  \href{../syntax/types.html#syntax-reftype}{\mathsf{null}}^? ~|~ \alpha_{\mathit{null}} \\
\def\mathdef1587#1{{}}\mathdef1587{heap type} &amp; \href{../syntax/types.html#syntax-heaptype}{\mathit{heaptype}} &amp;::=&amp;
  \dots ~|~ \alpha_{\href{../syntax/types.html#syntax-heaptype}{\mathit{heaptype}}} \\
\def\mathdef1587#1{{}}\mathdef1587{reference type} &amp; \href{../syntax/types.html#syntax-reftype}{\mathit{reftype}} &amp;::=&amp;
  \href{../syntax/types.html#syntax-reftype}{\mathsf{ref}}~\mathit{null}~\href{../syntax/types.html#syntax-heaptype}{\mathit{heaptype}} \\
\def\mathdef1587#1{{}}\mathdef1587{value type} &amp; \href{../syntax/types.html#syntax-valtype}{\mathit{valtype}} &amp;::=&amp;
  \dots ~|~ \alpha_{\href{../syntax/types.html#syntax-valtype}{\mathit{valtype}}} ~|~ \alpha_{\mathit{numvectype}} \\
\def\mathdef1587#1{{}}\mathdef1587{result type} &amp; \href{../syntax/types.html#syntax-resulttype}{\mathit{resulttype}} &amp;::=&amp;
  [\alpha_{\href{../syntax/types.html#syntax-valtype}{\mathit{valtype}}^\ast}^?~\href{../syntax/types.html#syntax-valtype}{\mathit{valtype}}^\ast] \\
\end{array}\end{split}\]</div>
<p>where each <span class="math notranslate nohighlight">\(\alpha_{\mathit{xyz}}\)</span> ranges over a set of type variables for syntactic class <span class="math notranslate nohighlight">\(\mathit{xyz}\)</span>, respectively.
The special class <span class="math notranslate nohighlight">\(\mathit{numvectype}\)</span> is defined as <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-numtype}{\mathit{numtype}} ~|~ \href{../syntax/types.html#syntax-vectype}{\mathit{vectype}} ~|~ \href{../valid/conventions.html#syntax-valtype-ext}{\mathsf{bot}}\)</span>,
and is only needed to handle unannotated <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr-parametric}{\mathsf{select}}\)</span> instructions.</p>
<p>A type is <em>closed</em> when it does not contain any type variables, and <em>open</em> otherwise.
A <em>type substitution</em> <span class="math notranslate nohighlight">\(\sigma\)</span> is a finite mapping from type variables to closed types of the respective syntactic class.
When applied to an open type, it replaces the type variables <span class="math notranslate nohighlight">\(\alpha\)</span> from its domain with the respective <span class="math notranslate nohighlight">\(\sigma(\alpha)\)</span>.</p>
<p><strong>Theorem (Principal Types).</strong>
If an instruction sequence <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast\)</span> is <a class="reference internal" href="#valid-config"><span class="std std-ref">valid</span></a> with some closed <a class="reference internal" href="../valid/conventions.html#syntax-instrtype"><span class="std std-ref">instruction type</span></a> <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-instrtype}{\mathit{instrtype}}\)</span> (i.e., <span class="math notranslate nohighlight">\(C \href{../valid/instructions.html#valid-instrs}{\vdash} \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast : \href{../valid/conventions.html#syntax-instrtype}{\mathit{instrtype}}\)</span>),
then it is also valid with a possibly open instruction type <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-instrtype}{\mathit{instrtype}}_{\min}\)</span> (i.e., <span class="math notranslate nohighlight">\(C \href{../valid/instructions.html#valid-instrs}{\vdash} \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast : \href{../valid/conventions.html#syntax-instrtype}{\mathit{instrtype}}_{\min}\)</span>),
such that for <em>every</em> closed type <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-instrtype}{\mathit{instrtype}}'\)</span> with which <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast\)</span> is valid (i.e., for all <span class="math notranslate nohighlight">\(C \href{../valid/instructions.html#valid-instrs}{\vdash} \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast : \href{../valid/conventions.html#syntax-instrtype}{\mathit{instrtype}}'\)</span>),
there exists a substitution <span class="math notranslate nohighlight">\(\sigma\)</span>,
such that <span class="math notranslate nohighlight">\(\sigma(\href{../valid/conventions.html#syntax-instrtype}{\mathit{instrtype}}_{\min})\)</span> is a subtype of <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-instrtype}{\mathit{instrtype}}'\)</span> (i.e., <span class="math notranslate nohighlight">\(C \href{../valid/matching.html#match-instrtype}{\vdash} \sigma(\href{../valid/conventions.html#syntax-instrtype}{\mathit{instrtype}}_{\min}) \href{../valid/matching.html#match-instrtype}{\leq} \href{../valid/conventions.html#syntax-instrtype}{\mathit{instrtype}}'\)</span>).
Furthermore, <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-instrtype}{\mathit{instrtype}}_{\min}\)</span> is unique up to the choice of type variables.</p>
<p><strong>Theorem (Closed Principal Forward Types).</strong>
If closed input type <span class="math notranslate nohighlight">\([t_1^\ast]\)</span> is given and the instruction sequence <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast\)</span> is <a class="reference internal" href="#valid-config"><span class="std std-ref">valid</span></a> with <a class="reference internal" href="../valid/conventions.html#syntax-instrtype"><span class="std std-ref">instruction type</span></a> <span class="math notranslate nohighlight">\([t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}}_{x^\ast} [t_2^\ast]\)</span> (i.e., <span class="math notranslate nohighlight">\(C \href{../valid/instructions.html#valid-instrs}{\vdash} \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast : [t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}}_{x^\ast} [t_2^\ast]\)</span>),
then it is also valid with instruction type <span class="math notranslate nohighlight">\([t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}}_{x^\ast} [\alpha_{\href{../syntax/types.html#syntax-valtype}{\mathit{valtype}}^\ast}~t^\ast]\)</span> (i.e., <span class="math notranslate nohighlight">\(C \href{../valid/instructions.html#valid-instrs}{\vdash} \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast : [t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}}_{x^\ast} [\alpha_{\href{../syntax/types.html#syntax-valtype}{\mathit{valtype}}^\ast}~t^\ast]\)</span>),
where all <span class="math notranslate nohighlight">\(t^\ast\)</span> are closed,
such that for <em>every</em> closed result type <span class="math notranslate nohighlight">\([{t'_2}^\ast]\)</span> with which <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast\)</span> is valid (i.e., for all <span class="math notranslate nohighlight">\(C \href{../valid/instructions.html#valid-instrs}{\vdash} \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast : [t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}}_{x^\ast} [{t'_2}^\ast]\)</span>),
there exists a substitution <span class="math notranslate nohighlight">\(\sigma\)</span>,
such that <span class="math notranslate nohighlight">\([{t'_2}^\ast] = [\sigma(\alpha_{\href{../syntax/types.html#syntax-valtype}{\mathit{valtype}}^\ast})~t^\ast]\)</span>.</p>
</section>
<section id="type-lattice">
<span id="index-48"></span><h2>Type Lattice<a class="headerlink" href="#type-lattice" title="Link to this heading">¶</a></h2>
<p>The <a class="reference internal" href="#principality"><span class="std std-ref">Principal Types</span></a> property depends on the existence of a <em>greatest lower bound</em> for any pair of types.</p>
<p><strong>Theorem (Greatest Lower Bounds for Value Types).</strong>
For any two value types <span class="math notranslate nohighlight">\(t_1\)</span> and <span class="math notranslate nohighlight">\(t_2\)</span> that are <a class="reference internal" href="../valid/types.html#valid-valtype"><span class="std std-ref">valid</span></a>
(i.e., <span class="math notranslate nohighlight">\(C \href{../valid/types.html#valid-valtype}{\vdash} t_1 : \href{../valid/types.html#valid-valtype}{\mathsf{ok}}\)</span> and <span class="math notranslate nohighlight">\(C \href{../valid/types.html#valid-valtype}{\vdash} t_2 : \href{../valid/types.html#valid-valtype}{\mathsf{ok}}\)</span>),
there exists a valid value type <span class="math notranslate nohighlight">\(t\)</span> that is a subtype of both <span class="math notranslate nohighlight">\(t_1\)</span> and <span class="math notranslate nohighlight">\(t_2\)</span>
(i.e., <span class="math notranslate nohighlight">\(C \href{../valid/types.html#valid-valtype}{\vdash} t : \href{../valid/types.html#valid-valtype}{\mathsf{ok}}\)</span> and <span class="math notranslate nohighlight">\(C \href{../valid/matching.html#match-valtype}{\vdash} t \href{../valid/matching.html#match-valtype}{\leq} t_1\)</span> and <span class="math notranslate nohighlight">\(C \href{../valid/matching.html#match-valtype}{\vdash} t \href{../valid/matching.html#match-valtype}{\leq} t_2\)</span>),
such that <em>every</em> valid value type <span class="math notranslate nohighlight">\(t'\)</span> that also is a subtype of both <span class="math notranslate nohighlight">\(t_1\)</span> and <span class="math notranslate nohighlight">\(t_2\)</span>
(i.e., for all <span class="math notranslate nohighlight">\(C \href{../valid/types.html#valid-valtype}{\vdash} t' : \href{../valid/types.html#valid-valtype}{\mathsf{ok}}\)</span> and <span class="math notranslate nohighlight">\(C \href{../valid/matching.html#match-valtype}{\vdash} t' \href{../valid/matching.html#match-valtype}{\leq} t_1\)</span> and <span class="math notranslate nohighlight">\(C \href{../valid/matching.html#match-valtype}{\vdash} t' \href{../valid/matching.html#match-valtype}{\leq} t_2\)</span>),
is a subtype of <span class="math notranslate nohighlight">\(t\)</span>
(i.e., <span class="math notranslate nohighlight">\(C \href{../valid/matching.html#match-valtype}{\vdash} t' \href{../valid/matching.html#match-valtype}{\leq} t\)</span>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The greatest lower bound of two types may be <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-valtype-ext}{\mathsf{bot}}\)</span>.</p>
</div>
<p><strong>Theorem (Conditional Least Upper Bounds for Value Types).</strong>
Any two value types <span class="math notranslate nohighlight">\(t_1\)</span> and <span class="math notranslate nohighlight">\(t_2\)</span> that are <a class="reference internal" href="../valid/types.html#valid-valtype"><span class="std std-ref">valid</span></a>
(i.e., <span class="math notranslate nohighlight">\(C \href{../valid/types.html#valid-valtype}{\vdash} t_1 : \href{../valid/types.html#valid-valtype}{\mathsf{ok}}\)</span> and <span class="math notranslate nohighlight">\(C \href{../valid/types.html#valid-valtype}{\vdash} t_2 : \href{../valid/types.html#valid-valtype}{\mathsf{ok}}\)</span>)
either have no common supertype,
or there exists a valid value type <span class="math notranslate nohighlight">\(t\)</span> that is a supertype of both <span class="math notranslate nohighlight">\(t_1\)</span> and <span class="math notranslate nohighlight">\(t_2\)</span>
(i.e., <span class="math notranslate nohighlight">\(C \href{../valid/types.html#valid-valtype}{\vdash} t : \href{../valid/types.html#valid-valtype}{\mathsf{ok}}\)</span> and <span class="math notranslate nohighlight">\(C \href{../valid/matching.html#match-valtype}{\vdash} t_1 \href{../valid/matching.html#match-valtype}{\leq} t\)</span> and <span class="math notranslate nohighlight">\(C \href{../valid/matching.html#match-valtype}{\vdash} t_2 \href{../valid/matching.html#match-valtype}{\leq} t\)</span>),
such that <em>every</em> valid value type <span class="math notranslate nohighlight">\(t'\)</span> that also is a supertype of both <span class="math notranslate nohighlight">\(t_1\)</span> and <span class="math notranslate nohighlight">\(t_2\)</span>
(i.e., for all <span class="math notranslate nohighlight">\(C \href{../valid/types.html#valid-valtype}{\vdash} t' : \href{../valid/types.html#valid-valtype}{\mathsf{ok}}\)</span> and <span class="math notranslate nohighlight">\(C \href{../valid/matching.html#match-valtype}{\vdash} t_1 \href{../valid/matching.html#match-valtype}{\leq} t'\)</span> and <span class="math notranslate nohighlight">\(C \href{../valid/matching.html#match-valtype}{\vdash} t_2 \href{../valid/matching.html#match-valtype}{\leq} t'\)</span>),
is a supertype of <span class="math notranslate nohighlight">\(t\)</span>
(i.e., <span class="math notranslate nohighlight">\(C \href{../valid/matching.html#match-valtype}{\vdash} t \href{../valid/matching.html#match-valtype}{\leq} t'\)</span>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If a top type was added to the type system,
a least upper bound would exist for any two types.</p>
</div>
<p><strong>Corollary (Type Lattice).</strong>
Assuming the addition of a provisional top type,
<a class="reference internal" href="../syntax/types.html#syntax-valtype"><span class="std std-ref">value types</span></a> form a lattice with respect to their <a class="reference internal" href="../valid/matching.html#match-valtype"><span class="std std-ref">subtype</span></a> relation.</p>
<p>Finally, value types can be partitioned into multiple disjoint hierarchies that are not related by subtyping, except through <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-valtype-ext}{\mathsf{bot}}\)</span>.</p>
<p><strong>Theorem (Disjoint Subtype Hierarchies).</strong>
The greatest lower bound of two <a class="reference internal" href="../syntax/types.html#syntax-valtype"><span class="std std-ref">value types</span></a> is <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-valtype-ext}{\mathsf{bot}}\)</span> or <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-reftype}{\mathsf{ref}}~\href{../valid/conventions.html#syntax-valtype-ext}{\mathsf{bot}}\)</span>
if and only if they do not have a least upper bound.</p>
<p>In other words, types that do not have common supertypes,
do not have common subtypes either (other than <span class="math notranslate nohighlight">\(\href{../valid/conventions.html#syntax-valtype-ext}{\mathsf{bot}}\)</span> or <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-reftype}{\mathsf{ref}}~\href{../valid/conventions.html#syntax-valtype-ext}{\mathsf{bot}}\)</span>), and vice versa.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Types from disjoint hierarchies can safely be represented in mutually incompatible ways in an implementation,
because their values can never flow to the same place.</p>
</div>
</section>
<section id="compositionality">
<span id="index-49"></span><h2>Compositionality<a class="headerlink" href="#compositionality" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="../valid/instructions.html#valid-instrs"><span class="std std-ref">Valid</span></a> <a class="reference internal" href="../syntax/instructions.html#syntax-instr"><span class="std std-ref">instruction sequences</span></a> can be freely <em>composed</em>, as long as their types match up.</p>
<p><strong>Theorem (Composition).</strong>
If two instruction sequences <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}_1^\ast\)</span> and <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}_2^\ast\)</span> are valid with types <span class="math notranslate nohighlight">\([t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}}_{x_1^\ast} [t^\ast]\)</span> and  <span class="math notranslate nohighlight">\([t^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}}_{x_2^\ast} [t_2^\ast]\)</span>, respectively (i.e., <span class="math notranslate nohighlight">\(C \href{../valid/instructions.html#valid-instrs}{\vdash} \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}_1^\ast : [t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}}_{x_1^\ast} [t^\ast]\)</span> and <span class="math notranslate nohighlight">\(C \href{../valid/instructions.html#valid-instrs}{\vdash} \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}_1^\ast : [t^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}}_{x_2^\ast} [t_2^\ast]\)</span>),
then the concatenated instruction sequence <span class="math notranslate nohighlight">\((\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}_1^\ast\;\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}_2^\ast)\)</span> is valid with type <span class="math notranslate nohighlight">\([t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}}_{x_1^\ast\,x_2^\ast} [t_2^\ast]\)</span> (i.e., <span class="math notranslate nohighlight">\(C \href{../valid/instructions.html#valid-instrs}{\vdash} \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}_1^\ast\;\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}_2^\ast : [t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}}_{x_1^\ast\,x_2^\ast} [t_2^\ast]\)</span>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>More generally, instead of a shared type <span class="math notranslate nohighlight">\([t^\ast]\)</span>, it suffices if the output type of <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}_1^\ast\)</span> is a <a class="reference internal" href="../valid/matching.html#match-resulttype"><span class="std std-ref">subtype</span></a> of the input type of  <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}_1^\ast\)</span>,
since the subtype can always be weakened to its supertype by subsumption.</p>
</div>
<p>Inversely, valid instruction sequences can also freely be <em>decomposed</em>, that is, splitting them anywhere produces two instruction sequences that are both <a class="reference internal" href="../valid/instructions.html#valid-instrs"><span class="std std-ref">valid</span></a>.</p>
<p><strong>Theorem (Decomposition).</strong>
If an instruction sequence <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast\)</span> that is valid with type <span class="math notranslate nohighlight">\([t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}}_{x^\ast} [t_2^\ast]\)</span> (i.e., <span class="math notranslate nohighlight">\(C \href{../valid/instructions.html#valid-instrs}{\vdash} \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast : [t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}}_{x^\ast} [t_2^\ast]\)</span>)
is split into two instruction sequences <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}_1^\ast\)</span> and <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}_2^\ast\)</span> at any point (i.e., <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast = \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}_1^\ast\;\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}_2^\ast\)</span>),
then these are separately valid with some types <span class="math notranslate nohighlight">\([t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}}_{x_1^\ast} [t^\ast]\)</span> and  <span class="math notranslate nohighlight">\([t^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}}_{x_2^\ast} [t_2^\ast]\)</span>, respectively (i.e., <span class="math notranslate nohighlight">\(C \href{../valid/instructions.html#valid-instrs}{\vdash} \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}_1^\ast : [t_1^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}}_{x_1^\ast} [t^\ast]\)</span> and <span class="math notranslate nohighlight">\(C \href{../valid/instructions.html#valid-instrs}{\vdash} \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}_1^\ast : [t^\ast] \mathrel{\href{../valid/conventions.html#syntax-instrtype}{\rightarrow}}_{x_2^\ast} [t_2^\ast]\)</span>),
where <span class="math notranslate nohighlight">\(x^\ast = x_1^\ast\;x_2^\ast\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This property holds because validation is required even for unreachable code.
Without that, <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}_2^\ast\)</span> might not be valid in isolation.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;2017-2025, WebAssembly Community Group.
      
    </div>

    

    
  </body>
</html>