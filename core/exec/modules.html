
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Modules &#8212; WebAssembly 2.0 (Draft 2024-08-09)</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script>window.MathJax = {"tex": {"maxBuffer": 30720}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Binary Format" href="../binary/index.html" />
    <link rel="prev" title="Instructions" href="instructions.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/webassembly.png" alt="Logo"/>
            </a></p><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../syntax/index.html">Structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../valid/index.html">Validation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Execution</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="conventions.html">Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="runtime.html">Runtime Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="numerics.html">Numerics</a></li>
<li class="toctree-l2"><a class="reference internal" href="instructions.html">Instructions</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Modules</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../binary/index.html">Binary Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../text/index.html">Text Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">Appendix</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index-types.html">Index of Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index-instructions.html">Index of Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index-rules.html">Index of Semantic Rules</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="../genindex.html">Index</a></li>
    
    <li class="toctree-l1"><a href="../_download/WebAssembly.pdf">Download as PDF</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="modules">
<h1>Modules<a class="headerlink" href="#modules" title="Permalink to this heading">¶</a></h1>
<p>For modules, the execution semantics primarily defines <a class="reference internal" href="#exec-instantiation"><span class="std std-ref">instantiation</span></a>, which <a class="reference internal" href="#alloc"><span class="std std-ref">allocates</span></a> instances for a module and its contained definitions, initializes <a class="reference internal" href="../syntax/modules.html#syntax-table"><span class="std std-ref">tables</span></a> and <a class="reference internal" href="../syntax/modules.html#syntax-mem"><span class="std std-ref">memories</span></a> from contained <a class="reference internal" href="../syntax/modules.html#syntax-elem"><span class="std std-ref">element</span></a> and <a class="reference internal" href="../syntax/modules.html#syntax-data"><span class="std std-ref">data</span></a> segments, and invokes the <a class="reference internal" href="../syntax/modules.html#syntax-start"><span class="std std-ref">start function</span></a> if present. It also includes <a class="reference internal" href="#exec-invocation"><span class="std std-ref">invocation</span></a> of exported functions.</p>
<p>Instantiation depends on a number of auxiliary notions for <a class="reference internal" href="../valid/types.html#exec-import"><span class="std std-ref">type-checking imports</span></a> and <a class="reference internal" href="#alloc"><span class="std std-ref">allocating</span></a> instances.</p>
<section id="external-typing">
<span id="valid-externval"></span><span id="index-0"></span><h2>External Typing<a class="headerlink" href="#external-typing" title="Permalink to this heading">¶</a></h2>
<p>For the purpose of checking <a class="reference internal" href="runtime.html#syntax-externval"><span class="std std-ref">external values</span></a> against <a class="reference internal" href="../syntax/modules.html#syntax-import"><span class="std std-ref">imports</span></a>,
such values are classified by <a class="reference internal" href="../syntax/types.html#syntax-externtype"><span class="std std-ref">external types</span></a>.
The following auxiliary typing rules specify this typing relation relative to a <a class="reference internal" href="runtime.html#syntax-store"><span class="std std-ref">store</span></a> <span class="math notranslate nohighlight">\(S\)</span> in which the referenced instances live.</p>
<section id="xref-exec-runtime-syntax-externval-mathsf-func-a">
<span id="valid-externval-func"></span><span id="index-1"></span><h3><span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathsf{func}}~a\)</span><a class="headerlink" href="#xref-exec-runtime-syntax-externval-mathsf-func-a" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>The store entry <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{funcs}}[a]\)</span> must exist.</p></li>
<li><p>Then <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathsf{func}}~a\)</span> is valid with <a class="reference internal" href="../syntax/types.html#syntax-externtype"><span class="std std-ref">external type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-externtype}{\mathsf{func}}~S.\href{../exec/runtime.html#syntax-store}{\mathsf{funcs}}[a].\href{../exec/runtime.html#syntax-funcinst}{\mathsf{type}}\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
}{
  S \href{../exec/modules.html#valid-externval}{\vdash} \href{../exec/runtime.html#syntax-externval}{\mathsf{func}}~a : \href{../syntax/types.html#syntax-externtype}{\mathsf{func}}~S.\href{../exec/runtime.html#syntax-store}{\mathsf{funcs}}[a].\href{../exec/runtime.html#syntax-funcinst}{\mathsf{type}}
}\]</div>
</section>
<section id="xref-exec-runtime-syntax-externval-mathsf-table-a">
<span id="valid-externval-table"></span><span id="index-2"></span><h3><span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathsf{table}}~a\)</span><a class="headerlink" href="#xref-exec-runtime-syntax-externval-mathsf-table-a" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>The store entry <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{tables}}[a]\)</span> must exist.</p></li>
<li><p>Then <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathsf{table}}~a\)</span> is valid with <a class="reference internal" href="../syntax/types.html#syntax-externtype"><span class="std std-ref">external type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-externtype}{\mathsf{table}}~S.\href{../exec/runtime.html#syntax-store}{\mathsf{tables}}[a].\href{../exec/runtime.html#syntax-tableinst}{\mathsf{type}}\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
}{
  S \href{../exec/modules.html#valid-externval}{\vdash} \href{../exec/runtime.html#syntax-externval}{\mathsf{table}}~a : \href{../syntax/types.html#syntax-externtype}{\mathsf{table}}~S.\href{../exec/runtime.html#syntax-store}{\mathsf{tables}}[a].\href{../exec/runtime.html#syntax-tableinst}{\mathsf{type}}
}\]</div>
</section>
<section id="xref-exec-runtime-syntax-externval-mathsf-mem-a">
<span id="valid-externval-mem"></span><span id="index-3"></span><h3><span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathsf{mem}}~a\)</span><a class="headerlink" href="#xref-exec-runtime-syntax-externval-mathsf-mem-a" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>The store entry <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{mems}}[a]\)</span> must exist.</p></li>
<li><p>Then <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathsf{mem}}~a\)</span> is valid with <a class="reference internal" href="../syntax/types.html#syntax-externtype"><span class="std std-ref">external type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-externtype}{\mathsf{mem}}~S.\href{../exec/runtime.html#syntax-store}{\mathsf{mems}}[a].\href{../exec/runtime.html#syntax-meminst}{\mathsf{type}}\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
}{
  S \href{../exec/modules.html#valid-externval}{\vdash} \href{../exec/runtime.html#syntax-externval}{\mathsf{mem}}~a : \href{../syntax/types.html#syntax-externtype}{\mathsf{mem}}~S.\href{../exec/runtime.html#syntax-store}{\mathsf{mems}}[a].\href{../exec/runtime.html#syntax-meminst}{\mathsf{type}}
}\]</div>
</section>
<section id="xref-exec-runtime-syntax-externval-mathsf-global-a">
<span id="valid-externval-global"></span><span id="index-4"></span><h3><span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathsf{global}}~a\)</span><a class="headerlink" href="#xref-exec-runtime-syntax-externval-mathsf-global-a" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>The store entry <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{globals}}[a]\)</span> must exist.</p></li>
<li><p>Then <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathsf{global}}~a\)</span> is valid with <a class="reference internal" href="../syntax/types.html#syntax-externtype"><span class="std std-ref">external type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-externtype}{\mathsf{global}}~S.\href{../exec/runtime.html#syntax-store}{\mathsf{globals}}[a].\href{../exec/runtime.html#syntax-globalinst}{\mathsf{type}}\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
}{
  S \href{../exec/modules.html#valid-externval}{\vdash} \href{../exec/runtime.html#syntax-externval}{\mathsf{global}}~a : \href{../syntax/types.html#syntax-externtype}{\mathsf{global}}~S.\href{../exec/runtime.html#syntax-store}{\mathsf{globals}}[a].\href{../exec/runtime.html#syntax-globalinst}{\mathsf{type}}
}\]</div>
</section>
</section>
<section id="value-typing">
<span id="valid-val"></span><span id="index-5"></span><h2>Value Typing<a class="headerlink" href="#value-typing" title="Permalink to this heading">¶</a></h2>
<p>For the purpose of checking argument <a class="reference internal" href="runtime.html#syntax-externval"><span class="std std-ref">values</span></a> against the parameter types of exported <a class="reference internal" href="../syntax/modules.html#syntax-func"><span class="std std-ref">functions</span></a>,
values are classified by <a class="reference internal" href="../syntax/types.html#syntax-valtype"><span class="std std-ref">value types</span></a>.
The following auxiliary typing rules specify this typing relation relative to a <a class="reference internal" href="runtime.html#syntax-store"><span class="std std-ref">store</span></a> <span class="math notranslate nohighlight">\(S\)</span> in which possibly referenced addresses live.</p>
<section id="numeric-values-t-xref-syntax-instructions-syntax-instr-numeric-mathsf-const-c">
<span id="valid-num"></span><h3><a class="reference internal" href="runtime.html#syntax-val"><span class="std std-ref">Numeric Values</span></a> <span class="math notranslate nohighlight">\(t.\href{../syntax/instructions.html#syntax-instr-numeric}{\mathsf{const}}~c\)</span><a class="headerlink" href="#numeric-values-t-xref-syntax-instructions-syntax-instr-numeric-mathsf-const-c" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>The value is valid with <a class="reference internal" href="../syntax/types.html#syntax-numtype"><span class="std std-ref">number type</span></a> <span class="math notranslate nohighlight">\(t\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
}{
  S \href{../exec/modules.html#valid-val}{\vdash} t.\href{../syntax/instructions.html#syntax-instr-numeric}{\mathsf{const}}~c : t
}\]</div>
</section>
<section id="null-references-xref-syntax-instructions-syntax-instr-ref-mathsf-ref-null-t">
<span id="valid-ref"></span><h3><a class="reference internal" href="runtime.html#syntax-ref"><span class="std std-ref">Null References</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr-ref}{\mathsf{ref{.}null}}~t\)</span><a class="headerlink" href="#null-references-xref-syntax-instructions-syntax-instr-ref-mathsf-ref-null-t" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>The value is valid with <a class="reference internal" href="../syntax/types.html#syntax-reftype"><span class="std std-ref">reference type</span></a> <span class="math notranslate nohighlight">\(t\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
}{
  S \href{../exec/modules.html#valid-val}{\vdash} \href{../syntax/instructions.html#syntax-instr-ref}{\mathsf{ref{.}null}}~t : t
}\]</div>
</section>
<section id="function-references-xref-exec-runtime-syntax-ref-mathsf-ref-a">
<h3><a class="reference internal" href="runtime.html#syntax-ref"><span class="std std-ref">Function References</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-ref}{\mathsf{ref}}~a\)</span><a class="headerlink" href="#function-references-xref-exec-runtime-syntax-ref-mathsf-ref-a" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="runtime.html#syntax-externval"><span class="std std-ref">external value</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathsf{func}}~a\)</span> must be <a class="reference internal" href="#valid-externval"><span class="std std-ref">valid</span></a>.</p></li>
<li><p>Then the value is valid with <a class="reference internal" href="../syntax/types.html#syntax-reftype"><span class="std std-ref">reference type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-reftype}{\mathsf{funcref}}\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
  S \href{../exec/modules.html#valid-externval}{\vdash} \href{../exec/runtime.html#syntax-externval}{\mathsf{func}}~a : \href{../syntax/types.html#syntax-externtype}{\mathsf{func}}~\href{../syntax/types.html#syntax-functype}{\mathit{functype}}
}{
  S \href{../exec/modules.html#valid-val}{\vdash} \href{../exec/runtime.html#syntax-ref}{\mathsf{ref}}~a : \href{../syntax/types.html#syntax-reftype}{\mathsf{funcref}}
}\]</div>
</section>
<section id="external-references-xref-exec-runtime-syntax-ref-extern-mathsf-ref-extern-a">
<h3><a class="reference internal" href="runtime.html#syntax-ref-extern"><span class="std std-ref">External References</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-ref.extern}{\mathsf{ref{.}extern}}~a\)</span><a class="headerlink" href="#external-references-xref-exec-runtime-syntax-ref-extern-mathsf-ref-extern-a" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>The value is valid with <a class="reference internal" href="../syntax/types.html#syntax-reftype"><span class="std std-ref">reference type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-reftype}{\mathsf{externref}}\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\frac{
}{
  S \href{../exec/modules.html#valid-val}{\vdash} \href{../exec/runtime.html#syntax-ref.extern}{\mathsf{ref{.}extern}}~a : \href{../syntax/types.html#syntax-reftype}{\mathsf{externref}}
}\]</div>
</section>
</section>
<section id="allocation">
<span id="alloc"></span><span id="index-6"></span><h2>Allocation<a class="headerlink" href="#allocation" title="Permalink to this heading">¶</a></h2>
<p>New instances of <a class="reference internal" href="runtime.html#syntax-funcinst"><span class="std std-ref">functions</span></a>, <a class="reference internal" href="runtime.html#syntax-tableinst"><span class="std std-ref">tables</span></a>, <a class="reference internal" href="runtime.html#syntax-meminst"><span class="std std-ref">memories</span></a>, and <a class="reference internal" href="runtime.html#syntax-globalinst"><span class="std std-ref">globals</span></a> are <em>allocated</em> in a <a class="reference internal" href="runtime.html#syntax-store"><span class="std std-ref">store</span></a> <span class="math notranslate nohighlight">\(S\)</span>, as defined by the following auxiliary functions.</p>
<section id="functions">
<span id="alloc-func"></span><span id="index-7"></span><h3><a class="reference internal" href="runtime.html#syntax-funcinst"><span class="std std-ref">Functions</span></a><a class="headerlink" href="#functions" title="Permalink to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-func}{\mathit{func}}\)</span> be the <a class="reference internal" href="../syntax/modules.html#syntax-func"><span class="std std-ref">function</span></a> to allocate and <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}\)</span> its <a class="reference internal" href="runtime.html#syntax-moduleinst"><span class="std std-ref">module instance</span></a>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(a\)</span> be the first free <a class="reference internal" href="runtime.html#syntax-funcaddr"><span class="std std-ref">function address</span></a> in <span class="math notranslate nohighlight">\(S\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-functype}{\mathit{functype}}\)</span> be the <a class="reference internal" href="../syntax/types.html#syntax-functype"><span class="std std-ref">function type</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}.\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{types}}[\href{../syntax/modules.html#syntax-func}{\mathit{func}}.\href{../syntax/modules.html#syntax-func}{\mathsf{type}}]\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}}\)</span> be the <a class="reference internal" href="runtime.html#syntax-funcinst"><span class="std std-ref">function instance</span></a> <span class="math notranslate nohighlight">\(\{ \href{../exec/runtime.html#syntax-funcinst}{\mathsf{type}}~\href{../syntax/types.html#syntax-functype}{\mathit{functype}}, \href{../exec/runtime.html#syntax-funcinst}{\mathsf{module}}~\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}, \href{../exec/runtime.html#syntax-funcinst}{\mathsf{code}}~\href{../syntax/modules.html#syntax-func}{\mathit{func}} \}\)</span>.</p></li>
<li><p>Append <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}}\)</span> to the <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-store}{\mathsf{funcs}}\)</span> of <span class="math notranslate nohighlight">\(S\)</span>.</p></li>
<li><p>Return <span class="math notranslate nohighlight">\(a\)</span>.</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}~\\[-1ex]
\begin{array}{rlll}
\href{../exec/modules.html#alloc-func}{\mathrm{allocfunc}}(S, \href{../syntax/modules.html#syntax-func}{\mathit{func}}, \href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}) &amp;=&amp; S', \href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}} \\[1ex]
\mbox{where:} \hfill \\
\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}} &amp;=&amp; |S.\href{../exec/runtime.html#syntax-store}{\mathsf{funcs}}| \\
\href{../syntax/types.html#syntax-functype}{\mathit{functype}} &amp;=&amp; \href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}.\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{types}}[\href{../syntax/modules.html#syntax-func}{\mathit{func}}.\href{../syntax/modules.html#syntax-func}{\mathsf{type}}] \\
\href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}} &amp;=&amp; \{ \href{../exec/runtime.html#syntax-funcinst}{\mathsf{type}}~\href{../syntax/types.html#syntax-functype}{\mathit{functype}}, \href{../exec/runtime.html#syntax-funcinst}{\mathsf{module}}~\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}, \href{../exec/runtime.html#syntax-funcinst}{\mathsf{code}}~\href{../syntax/modules.html#syntax-func}{\mathit{func}} \} \\
S' &amp;=&amp; S \href{../syntax/conventions.html#notation-compose}{\oplus} \{\href{../exec/runtime.html#syntax-store}{\mathsf{funcs}}~\href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}}\} \\
\end{array}\end{split}\]</div>
</section>
<section id="host-functions">
<span id="alloc-hostfunc"></span><span id="index-8"></span><h3><a class="reference internal" href="runtime.html#syntax-hostfunc"><span class="std std-ref">Host Functions</span></a><a class="headerlink" href="#host-functions" title="Permalink to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-hostfunc}{\mathit{hostfunc}}\)</span> be the <a class="reference internal" href="runtime.html#syntax-hostfunc"><span class="std std-ref">host function</span></a> to allocate and <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-functype}{\mathit{functype}}\)</span> its <a class="reference internal" href="../syntax/types.html#syntax-functype"><span class="std std-ref">function type</span></a>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(a\)</span> be the first free <a class="reference internal" href="runtime.html#syntax-funcaddr"><span class="std std-ref">function address</span></a> in <span class="math notranslate nohighlight">\(S\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}}\)</span> be the <a class="reference internal" href="runtime.html#syntax-funcinst"><span class="std std-ref">function instance</span></a> <span class="math notranslate nohighlight">\(\{ \href{../exec/runtime.html#syntax-funcinst}{\mathsf{type}}~\href{../syntax/types.html#syntax-functype}{\mathit{functype}}, \href{../exec/runtime.html#syntax-funcinst}{\mathsf{hostcode}}~\href{../exec/runtime.html#syntax-hostfunc}{\mathit{hostfunc}} \}\)</span>.</p></li>
<li><p>Append <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}}\)</span> to the <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-store}{\mathsf{funcs}}\)</span> of <span class="math notranslate nohighlight">\(S\)</span>.</p></li>
<li><p>Return <span class="math notranslate nohighlight">\(a\)</span>.</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}~\\[-1ex]
\begin{array}{rlll}
\href{../exec/modules.html#alloc-hostfunc}{\mathrm{allochostfunc}}(S, \href{../syntax/types.html#syntax-functype}{\mathit{functype}}, \href{../exec/runtime.html#syntax-hostfunc}{\mathit{hostfunc}}) &amp;=&amp; S', \href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}} \\[1ex]
\mbox{where:} \hfill \\
\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}} &amp;=&amp; |S.\href{../exec/runtime.html#syntax-store}{\mathsf{funcs}}| \\
\href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}} &amp;=&amp; \{ \href{../exec/runtime.html#syntax-funcinst}{\mathsf{type}}~\href{../syntax/types.html#syntax-functype}{\mathit{functype}}, \href{../exec/runtime.html#syntax-funcinst}{\mathsf{hostcode}}~\href{../exec/runtime.html#syntax-hostfunc}{\mathit{hostfunc}} \} \\
S' &amp;=&amp; S \href{../syntax/conventions.html#notation-compose}{\oplus} \{\href{../exec/runtime.html#syntax-store}{\mathsf{funcs}}~\href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}}\} \\
\end{array}\end{split}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Host functions are never allocated by the WebAssembly semantics itself,
but may be allocated by the <a class="reference internal" href="../intro/overview.html#embedder"><span class="std std-ref">embedder</span></a>.</p>
</div>
</section>
<section id="tables">
<span id="alloc-table"></span><span id="index-9"></span><h3><a class="reference internal" href="runtime.html#syntax-tableinst"><span class="std std-ref">Tables</span></a><a class="headerlink" href="#tables" title="Permalink to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-tabletype}{\mathit{tabletype}}\)</span> be the <a class="reference internal" href="../syntax/types.html#syntax-tabletype"><span class="std std-ref">table type</span></a> to allocate and <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}\)</span> the initialization value.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\((\{\href{../syntax/types.html#syntax-limits}{\mathsf{min}}~n, \href{../syntax/types.html#syntax-limits}{\mathsf{max}}~m^?\}~\href{../syntax/types.html#syntax-reftype}{\mathit{reftype}})\)</span> be the structure of <a class="reference internal" href="../syntax/types.html#syntax-tabletype"><span class="std std-ref">table type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-tabletype}{\mathit{tabletype}}\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(a\)</span> be the first free <a class="reference internal" href="runtime.html#syntax-tableaddr"><span class="std std-ref">table address</span></a> in <span class="math notranslate nohighlight">\(S\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}\)</span> be the <a class="reference internal" href="runtime.html#syntax-tableinst"><span class="std std-ref">table instance</span></a> <span class="math notranslate nohighlight">\(\{ \href{../exec/runtime.html#syntax-tableinst}{\mathsf{type}}~\href{../syntax/types.html#syntax-tabletype}{\mathit{tabletype}}, \href{../exec/runtime.html#syntax-tableinst}{\mathsf{elem}}~\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^n \}\)</span> with <span class="math notranslate nohighlight">\(n\)</span> elements set to <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}\)</span>.</p></li>
<li><p>Append <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}\)</span> to the <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-store}{\mathsf{tables}}\)</span> of <span class="math notranslate nohighlight">\(S\)</span>.</p></li>
<li><p>Return <span class="math notranslate nohighlight">\(a\)</span>.</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{rlll}
\href{../exec/modules.html#alloc-table}{\mathrm{alloctable}}(S, \href{../syntax/types.html#syntax-tabletype}{\mathit{tabletype}}, \href{../exec/runtime.html#syntax-ref}{\mathit{ref}}) &amp;=&amp; S', \href{../exec/runtime.html#syntax-tableaddr}{\mathit{tableaddr}} \\[1ex]
\mbox{where:} \hfill \\
\href{../syntax/types.html#syntax-tabletype}{\mathit{tabletype}} &amp;=&amp; \{\href{../syntax/types.html#syntax-limits}{\mathsf{min}}~n, \href{../syntax/types.html#syntax-limits}{\mathsf{max}}~m^?\}~\href{../syntax/types.html#syntax-reftype}{\mathit{reftype}} \\
\href{../exec/runtime.html#syntax-tableaddr}{\mathit{tableaddr}} &amp;=&amp; |S.\href{../exec/runtime.html#syntax-store}{\mathsf{tables}}| \\
\href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}} &amp;=&amp; \{ \href{../exec/runtime.html#syntax-tableinst}{\mathsf{type}}~\href{../syntax/types.html#syntax-tabletype}{\mathit{tabletype}}, \href{../exec/runtime.html#syntax-tableinst}{\mathsf{elem}}~\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^n \} \\
S' &amp;=&amp; S \href{../syntax/conventions.html#notation-compose}{\oplus} \{\href{../exec/runtime.html#syntax-store}{\mathsf{tables}}~\href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}\} \\
\end{array}\end{split}\]</div>
</section>
<section id="memories">
<span id="alloc-mem"></span><span id="index-10"></span><h3><a class="reference internal" href="runtime.html#syntax-meminst"><span class="std std-ref">Memories</span></a><a class="headerlink" href="#memories" title="Permalink to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-memtype}{\mathit{memtype}}\)</span> be the <a class="reference internal" href="../syntax/types.html#syntax-memtype"><span class="std std-ref">memory type</span></a> to allocate.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\{\href{../syntax/types.html#syntax-limits}{\mathsf{min}}~n, \href{../syntax/types.html#syntax-limits}{\mathsf{max}}~m^?\}\)</span> be the structure of <a class="reference internal" href="../syntax/types.html#syntax-memtype"><span class="std std-ref">memory type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-memtype}{\mathit{memtype}}\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(a\)</span> be the first free <a class="reference internal" href="runtime.html#syntax-memaddr"><span class="std std-ref">memory address</span></a> in <span class="math notranslate nohighlight">\(S\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}\)</span> be the <a class="reference internal" href="runtime.html#syntax-meminst"><span class="std std-ref">memory instance</span></a> <span class="math notranslate nohighlight">\(\{ \href{../exec/runtime.html#syntax-meminst}{\mathsf{type}}~\href{../syntax/types.html#syntax-memtype}{\mathit{memtype}}, \href{../exec/runtime.html#syntax-meminst}{\mathsf{data}}~(\def\mathdef2203#1{\mathtt{0x#1}}\mathdef2203{00})^{n \cdot 64\,\mathrm{Ki}} \}\)</span> that contains <span class="math notranslate nohighlight">\(n\)</span> pages of zeroed <a class="reference internal" href="../syntax/values.html#syntax-byte"><span class="std std-ref">bytes</span></a>.</p></li>
<li><p>Append <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}\)</span> to the <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-store}{\mathsf{mems}}\)</span> of <span class="math notranslate nohighlight">\(S\)</span>.</p></li>
<li><p>Return <span class="math notranslate nohighlight">\(a\)</span>.</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{rlll}
\href{../exec/modules.html#alloc-mem}{\mathrm{allocmem}}(S, \href{../syntax/types.html#syntax-memtype}{\mathit{memtype}}) &amp;=&amp; S', \href{../exec/runtime.html#syntax-memaddr}{\mathit{memaddr}} \\[1ex]
\mbox{where:} \hfill \\
\href{../syntax/types.html#syntax-memtype}{\mathit{memtype}} &amp;=&amp; \{\href{../syntax/types.html#syntax-limits}{\mathsf{min}}~n, \href{../syntax/types.html#syntax-limits}{\mathsf{max}}~m^?\} \\
\href{../exec/runtime.html#syntax-memaddr}{\mathit{memaddr}} &amp;=&amp; |S.\href{../exec/runtime.html#syntax-store}{\mathsf{mems}}| \\
\href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}} &amp;=&amp; \{ \href{../exec/runtime.html#syntax-meminst}{\mathsf{type}}~\href{../syntax/types.html#syntax-memtype}{\mathit{memtype}}, \href{../exec/runtime.html#syntax-meminst}{\mathsf{data}}~(\def\mathdef2204#1{\mathtt{0x#1}}\mathdef2204{00})^{n \cdot 64\,\mathrm{Ki}} \} \\
S' &amp;=&amp; S \href{../syntax/conventions.html#notation-compose}{\oplus} \{\href{../exec/runtime.html#syntax-store}{\mathsf{mems}}~\href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}\} \\
\end{array}\end{split}\]</div>
</section>
<section id="globals">
<span id="alloc-global"></span><span id="index-11"></span><h3><a class="reference internal" href="runtime.html#syntax-globalinst"><span class="std std-ref">Globals</span></a><a class="headerlink" href="#globals" title="Permalink to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-globaltype}{\mathit{globaltype}}\)</span> be the <a class="reference internal" href="../syntax/types.html#syntax-globaltype"><span class="std std-ref">global type</span></a> to allocate and <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}\)</span> the <a class="reference internal" href="runtime.html#syntax-val"><span class="std std-ref">value</span></a> to initialize the global with.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(a\)</span> be the first free <a class="reference internal" href="runtime.html#syntax-globaladdr"><span class="std std-ref">global address</span></a> in <span class="math notranslate nohighlight">\(S\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-globalinst}{\mathit{globalinst}}\)</span> be the <a class="reference internal" href="runtime.html#syntax-globalinst"><span class="std std-ref">global instance</span></a> <span class="math notranslate nohighlight">\(\{ \href{../exec/runtime.html#syntax-globalinst}{\mathsf{type}}~\href{../syntax/types.html#syntax-globaltype}{\mathit{globaltype}}, \href{../exec/runtime.html#syntax-globalinst}{\mathsf{value}}~\href{../exec/runtime.html#syntax-val}{\mathit{val}} \}\)</span>.</p></li>
<li><p>Append <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-globalinst}{\mathit{globalinst}}\)</span> to the <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-store}{\mathsf{globals}}\)</span> of <span class="math notranslate nohighlight">\(S\)</span>.</p></li>
<li><p>Return <span class="math notranslate nohighlight">\(a\)</span>.</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{rlll}
\href{../exec/modules.html#alloc-global}{\mathrm{allocglobal}}(S, \href{../syntax/types.html#syntax-globaltype}{\mathit{globaltype}}, \href{../exec/runtime.html#syntax-val}{\mathit{val}}) &amp;=&amp; S', \href{../exec/runtime.html#syntax-globaladdr}{\mathit{globaladdr}} \\[1ex]
\mbox{where:} \hfill \\
\href{../exec/runtime.html#syntax-globaladdr}{\mathit{globaladdr}} &amp;=&amp; |S.\href{../exec/runtime.html#syntax-store}{\mathsf{globals}}| \\
\href{../exec/runtime.html#syntax-globalinst}{\mathit{globalinst}} &amp;=&amp; \{ \href{../exec/runtime.html#syntax-globalinst}{\mathsf{type}}~\href{../syntax/types.html#syntax-globaltype}{\mathit{globaltype}}, \href{../exec/runtime.html#syntax-globalinst}{\mathsf{value}}~\href{../exec/runtime.html#syntax-val}{\mathit{val}} \} \\
S' &amp;=&amp; S \href{../syntax/conventions.html#notation-compose}{\oplus} \{\href{../exec/runtime.html#syntax-store}{\mathsf{globals}}~\href{../exec/runtime.html#syntax-globalinst}{\mathit{globalinst}}\} \\
\end{array}\end{split}\]</div>
</section>
<section id="element-segments">
<span id="alloc-elem"></span><span id="index-12"></span><h3><a class="reference internal" href="runtime.html#syntax-eleminst"><span class="std std-ref">Element segments</span></a><a class="headerlink" href="#element-segments" title="Permalink to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-reftype}{\mathit{reftype}}\)</span> be the elements’ type and <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^\ast\)</span> the vector of <a class="reference internal" href="runtime.html#syntax-ref"><span class="std std-ref">references</span></a> to allocate.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(a\)</span> be the first free <a class="reference internal" href="runtime.html#syntax-elemaddr"><span class="std std-ref">element address</span></a> in <span class="math notranslate nohighlight">\(S\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-eleminst}{\mathit{eleminst}}\)</span> be the <a class="reference internal" href="runtime.html#syntax-eleminst"><span class="std std-ref">element instance</span></a> <span class="math notranslate nohighlight">\(\{ \href{../exec/runtime.html#syntax-eleminst}{\mathsf{type}}~\href{../syntax/types.html#syntax-reftype}{\mathit{reftype}}, \href{../exec/runtime.html#syntax-eleminst}{\mathsf{elem}}~\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^\ast \}\)</span>.</p></li>
<li><p>Append <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-eleminst}{\mathit{eleminst}}\)</span> to the <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-store}{\mathsf{elems}}\)</span> of <span class="math notranslate nohighlight">\(S\)</span>.</p></li>
<li><p>Return <span class="math notranslate nohighlight">\(a\)</span>.</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{rlll}
\href{../exec/modules.html#alloc-elem}{\mathrm{allocelem}}(S, \href{../syntax/types.html#syntax-reftype}{\mathit{reftype}}, \href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^\ast) &amp;=&amp; S', \href{../exec/runtime.html#syntax-elemaddr}{\mathit{elemaddr}} \\[1ex]
\mbox{where:} \hfill \\
\href{../exec/runtime.html#syntax-elemaddr}{\mathit{elemaddr}} &amp;=&amp; |S.\href{../exec/runtime.html#syntax-store}{\mathsf{elems}}| \\
\href{../exec/runtime.html#syntax-eleminst}{\mathit{eleminst}} &amp;=&amp; \{ \href{../exec/runtime.html#syntax-eleminst}{\mathsf{type}}~\href{../syntax/types.html#syntax-reftype}{\mathit{reftype}}, \href{../exec/runtime.html#syntax-eleminst}{\mathsf{elem}}~\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^\ast \} \\
S' &amp;=&amp; S \href{../syntax/conventions.html#notation-compose}{\oplus} \{\href{../exec/runtime.html#syntax-store}{\mathsf{elems}}~\href{../exec/runtime.html#syntax-eleminst}{\mathit{eleminst}}\} \\
\end{array}\end{split}\]</div>
</section>
<section id="data-segments">
<span id="alloc-data"></span><span id="index-13"></span><h3><a class="reference internal" href="runtime.html#syntax-datainst"><span class="std std-ref">Data segments</span></a><a class="headerlink" href="#data-segments" title="Permalink to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p>Let <span class="math notranslate nohighlight">\(b^\ast\)</span> be the vector of <a class="reference internal" href="../syntax/values.html#syntax-byte"><span class="std std-ref">bytes</span></a> to allocate.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(a\)</span> be the first free <a class="reference internal" href="runtime.html#syntax-dataaddr"><span class="std std-ref">data address</span></a> in <span class="math notranslate nohighlight">\(S\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-datainst}{\mathit{datainst}}\)</span> be the <a class="reference internal" href="runtime.html#syntax-datainst"><span class="std std-ref">data instance</span></a> <span class="math notranslate nohighlight">\(\{ \href{../exec/runtime.html#syntax-datainst}{\mathsf{data}}~b^\ast \}\)</span>.</p></li>
<li><p>Append <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-datainst}{\mathit{datainst}}\)</span> to the <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-store}{\mathsf{datas}}\)</span> of <span class="math notranslate nohighlight">\(S\)</span>.</p></li>
<li><p>Return <span class="math notranslate nohighlight">\(a\)</span>.</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{rlll}
\href{../exec/modules.html#alloc-data}{\mathrm{allocdata}}(S, b^\ast) &amp;=&amp; S', \href{../exec/runtime.html#syntax-dataaddr}{\mathit{dataaddr}} \\[1ex]
\mbox{where:} \hfill \\
\href{../exec/runtime.html#syntax-dataaddr}{\mathit{dataaddr}} &amp;=&amp; |S.\href{../exec/runtime.html#syntax-store}{\mathsf{datas}}| \\
\href{../exec/runtime.html#syntax-datainst}{\mathit{datainst}} &amp;=&amp; \{ \href{../exec/runtime.html#syntax-datainst}{\mathsf{data}}~b^\ast \} \\
S' &amp;=&amp; S \href{../syntax/conventions.html#notation-compose}{\oplus} \{\href{../exec/runtime.html#syntax-store}{\mathsf{datas}}~\href{../exec/runtime.html#syntax-datainst}{\mathit{datainst}}\} \\
\end{array}\end{split}\]</div>
</section>
<section id="growing-tables">
<span id="grow-table"></span><span id="index-14"></span><h3>Growing <a class="reference internal" href="runtime.html#syntax-tableinst"><span class="std std-ref">tables</span></a><a class="headerlink" href="#growing-tables" title="Permalink to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}\)</span> be the <a class="reference internal" href="runtime.html#syntax-tableinst"><span class="std std-ref">table instance</span></a> to grow, <span class="math notranslate nohighlight">\(n\)</span> the number of elements by which to grow it, and <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}\)</span> the initialization value.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\mathit{len}\)</span> be <span class="math notranslate nohighlight">\(n\)</span> added to the length of <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}.\href{../exec/runtime.html#syntax-tableinst}{\mathsf{elem}}\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(\mathit{len}\)</span> is larger than or equal to <span class="math notranslate nohighlight">\(2^{32}\)</span>, then fail.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-limits}{\mathit{limits}}~t\)</span> be the structure of <a class="reference internal" href="../syntax/types.html#syntax-tabletype"><span class="std std-ref">table type</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}.\href{../exec/runtime.html#syntax-tableinst}{\mathsf{type}}\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-limits}{\mathit{limits}}'\)</span> be <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-limits}{\mathit{limits}}\)</span> with <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-limits}{\mathsf{min}}\)</span> updated to <span class="math notranslate nohighlight">\(\mathit{len}\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-limits}{\mathit{limits}}'\)</span> is not <a class="reference internal" href="../valid/types.html#valid-limits"><span class="std std-ref">valid</span></a>, then fail.</p></li>
<li><p>Append <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^n\)</span> to <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}.\href{../exec/runtime.html#syntax-tableinst}{\mathsf{elem}}\)</span>.</p></li>
<li><p>Set <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}.\href{../exec/runtime.html#syntax-tableinst}{\mathsf{type}}\)</span> to the <a class="reference internal" href="../syntax/types.html#syntax-tabletype"><span class="std std-ref">table type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-limits}{\mathit{limits}}'~t\)</span>.</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{rllll}
\href{../exec/modules.html#grow-table}{\mathrm{growtable}}(\href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}, n, \href{../exec/runtime.html#syntax-ref}{\mathit{ref}}) &amp;=&amp; \href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}} \href{../syntax/conventions.html#notation-replace}{\mathrel{\mbox{with}}} \href{../exec/runtime.html#syntax-tableinst}{\mathsf{type}} = \href{../syntax/types.html#syntax-limits}{\mathit{limits}}'~t \href{../syntax/conventions.html#notation-replace}{\mathrel{\mbox{with}}} \href{../exec/runtime.html#syntax-tableinst}{\mathsf{elem}} = \href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}.\href{../exec/runtime.html#syntax-tableinst}{\mathsf{elem}}~\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^n \\
  &amp;&amp; (
    \begin{array}[t]{&#64;{}r&#64;{~}l&#64;{}}
    \mathrel{\mbox{if}} &amp; \mathit{len} = n + |\href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}.\href{../exec/runtime.html#syntax-tableinst}{\mathsf{elem}}| \\
    \wedge &amp; \mathit{len} &lt; 2^{32} \\
    \wedge &amp; \href{../syntax/types.html#syntax-limits}{\mathit{limits}}~t = \href{../exec/runtime.html#syntax-tableinst}{\mathit{tableinst}}.\href{../exec/runtime.html#syntax-tableinst}{\mathsf{type}} \\
    \wedge &amp; \href{../syntax/types.html#syntax-limits}{\mathit{limits}}' = \href{../syntax/types.html#syntax-limits}{\mathit{limits}} \href{../syntax/conventions.html#notation-replace}{\mathrel{\mbox{with}}} \href{../syntax/types.html#syntax-limits}{\mathsf{min}} = \mathit{len} \\
    \wedge &amp; \href{../valid/types.html#valid-limits}{\vdash} \href{../syntax/types.html#syntax-limits}{\mathit{limits}}' \mathrel{\mbox{ok}}) \\
    \end{array} \\
\end{array}\end{split}\]</div>
</section>
<section id="growing-memories">
<span id="grow-mem"></span><span id="index-15"></span><h3>Growing <a class="reference internal" href="runtime.html#syntax-meminst"><span class="std std-ref">memories</span></a><a class="headerlink" href="#growing-memories" title="Permalink to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}\)</span> be the <a class="reference internal" href="runtime.html#syntax-meminst"><span class="std std-ref">memory instance</span></a> to grow and <span class="math notranslate nohighlight">\(n\)</span> the number of <a class="reference internal" href="runtime.html#page-size"><span class="std std-ref">pages</span></a> by which to grow it.</p></li>
<li><p>Assert: The length of <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}.\href{../exec/runtime.html#syntax-meminst}{\mathsf{data}}\)</span> is divisible by the <a class="reference internal" href="runtime.html#page-size"><span class="std std-ref">page size</span></a> <span class="math notranslate nohighlight">\(64\,\mathrm{Ki}\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\mathit{len}\)</span> be <span class="math notranslate nohighlight">\(n\)</span> added to the length of <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}.\href{../exec/runtime.html#syntax-meminst}{\mathsf{data}}\)</span> divided by the <a class="reference internal" href="runtime.html#page-size"><span class="std std-ref">page size</span></a> <span class="math notranslate nohighlight">\(64\,\mathrm{Ki}\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(\mathit{len}\)</span> is larger than <span class="math notranslate nohighlight">\(2^{16}\)</span>, then fail.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-limits}{\mathit{limits}}\)</span> be the structure of <a class="reference internal" href="../syntax/types.html#syntax-memtype"><span class="std std-ref">memory type</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}.\href{../exec/runtime.html#syntax-meminst}{\mathsf{type}}\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-limits}{\mathit{limits}}'\)</span> be <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-limits}{\mathit{limits}}\)</span> with <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-limits}{\mathsf{min}}\)</span> updated to <span class="math notranslate nohighlight">\(\mathit{len}\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-limits}{\mathit{limits}}'\)</span> is not <a class="reference internal" href="../valid/types.html#valid-limits"><span class="std std-ref">valid</span></a>, then fail.</p></li>
<li><p>Append <span class="math notranslate nohighlight">\(n\)</span> times <span class="math notranslate nohighlight">\(64\,\mathrm{Ki}\)</span> <a class="reference internal" href="../syntax/values.html#syntax-byte"><span class="std std-ref">bytes</span></a> with value <span class="math notranslate nohighlight">\(\def\mathdef2205#1{\mathtt{0x#1}}\mathdef2205{00}\)</span> to <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}.\href{../exec/runtime.html#syntax-meminst}{\mathsf{data}}\)</span>.</p></li>
<li><p>Set <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}.\href{../exec/runtime.html#syntax-meminst}{\mathsf{type}}\)</span> to the <a class="reference internal" href="../syntax/types.html#syntax-memtype"><span class="std std-ref">memory type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-limits}{\mathit{limits}}'\)</span>.</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{rllll}
\href{../exec/modules.html#grow-mem}{\mathrm{growmem}}(\href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}, n) &amp;=&amp; \href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}} \href{../syntax/conventions.html#notation-replace}{\mathrel{\mbox{with}}} \href{../exec/runtime.html#syntax-meminst}{\mathsf{type}} = \href{../syntax/types.html#syntax-limits}{\mathit{limits}}' \href{../syntax/conventions.html#notation-replace}{\mathrel{\mbox{with}}} \href{../exec/runtime.html#syntax-meminst}{\mathsf{data}} = \href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}.\href{../exec/runtime.html#syntax-meminst}{\mathsf{data}}~(\def\mathdef2206#1{\mathtt{0x#1}}\mathdef2206{00})^{n \cdot 64\,\mathrm{Ki}} \\
  &amp;&amp; (
    \begin{array}[t]{&#64;{}r&#64;{~}l&#64;{}}
    \mathrel{\mbox{if}} &amp; \mathit{len} = n + |\href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}.\href{../exec/runtime.html#syntax-meminst}{\mathsf{data}}| / 64\,\mathrm{Ki} \\
    \wedge &amp; \mathit{len} \leq 2^{16} \\
    \wedge &amp; \href{../syntax/types.html#syntax-limits}{\mathit{limits}} = \href{../exec/runtime.html#syntax-meminst}{\mathit{meminst}}.\href{../exec/runtime.html#syntax-meminst}{\mathsf{type}} \\
    \wedge &amp; \href{../syntax/types.html#syntax-limits}{\mathit{limits}}' = \href{../syntax/types.html#syntax-limits}{\mathit{limits}} \href{../syntax/conventions.html#notation-replace}{\mathrel{\mbox{with}}} \href{../syntax/types.html#syntax-limits}{\mathsf{min}} = \mathit{len} \\
    \wedge &amp; \href{../valid/types.html#valid-limits}{\vdash} \href{../syntax/types.html#syntax-limits}{\mathit{limits}}' \mathrel{\mbox{ok}}) \\
    \end{array} \\
\end{array}\end{split}\]</div>
</section>
<section id="alloc-module">
<span id="index-16"></span><span id="id1"></span><h3><a class="reference internal" href="runtime.html#syntax-moduleinst"><span class="std std-ref">Modules</span></a><a class="headerlink" href="#alloc-module" title="Permalink to this heading">¶</a></h3>
<p>The allocation function for <a class="reference internal" href="../syntax/modules.html#syntax-module"><span class="std std-ref">modules</span></a> requires a suitable list of <a class="reference internal" href="runtime.html#syntax-externval"><span class="std std-ref">external values</span></a> that are assumed to <a class="reference internal" href="../valid/types.html#match-externtype"><span class="std std-ref">match</span></a> the <a class="reference internal" href="../syntax/modules.html#syntax-import"><span class="std std-ref">import</span></a> vector of the module,
a list of initialization <a class="reference internal" href="runtime.html#syntax-val"><span class="std std-ref">values</span></a> for the module’s <a class="reference internal" href="../syntax/modules.html#syntax-global"><span class="std std-ref">globals</span></a>,
and list of <a class="reference internal" href="runtime.html#syntax-ref"><span class="std std-ref">reference</span></a> vectors for the module’s <a class="reference internal" href="../syntax/modules.html#syntax-elem"><span class="std std-ref">element segments</span></a>.</p>
<ol class="arabic simple">
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-module}{\mathit{module}}\)</span> be the <a class="reference internal" href="../syntax/modules.html#syntax-module"><span class="std std-ref">module</span></a> to allocate and <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_{\mathrm{im}}^\ast\)</span> the vector of <a class="reference internal" href="runtime.html#syntax-externval"><span class="std std-ref">external values</span></a> providing the module’s imports, <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast\)</span> the initialization <a class="reference internal" href="runtime.html#syntax-val"><span class="std std-ref">values</span></a> of the module’s <a class="reference internal" href="../syntax/modules.html#syntax-global"><span class="std std-ref">globals</span></a>, and <span class="math notranslate nohighlight">\((\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^\ast)^\ast\)</span> the <a class="reference internal" href="runtime.html#syntax-ref"><span class="std std-ref">reference</span></a> vectors of the module’s <a class="reference internal" href="../syntax/modules.html#syntax-elem"><span class="std std-ref">element segments</span></a>.</p></li>
<li><p>For each <a class="reference internal" href="../syntax/modules.html#syntax-func"><span class="std std-ref">function</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-func}{\mathit{func}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{funcs}}\)</span>, do:</p>
<ol class="loweralpha simple">
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}_i\)</span> be the <a class="reference internal" href="runtime.html#syntax-funcaddr"><span class="std std-ref">function address</span></a> resulting from <a class="reference internal" href="#alloc-func"><span class="std std-ref">allocating</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-func}{\mathit{func}}_i\)</span> for the <a class="reference internal" href="runtime.html#syntax-moduleinst"><span class="std std-ref">module instance</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}\)</span> defined below.</p></li>
</ol>
</li>
<li><p>For each <a class="reference internal" href="../syntax/modules.html#syntax-table"><span class="std std-ref">table</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-table}{\mathit{table}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{tables}}\)</span>, do:</p>
<ol class="loweralpha simple">
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-limits}{\mathit{limits}}_i~t_i\)</span> be the <a class="reference internal" href="../syntax/types.html#syntax-tabletype"><span class="std std-ref">table type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-table}{\mathit{table}}_i.\href{../syntax/modules.html#syntax-table}{\mathsf{type}}\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-tableaddr}{\mathit{tableaddr}}_i\)</span> be the <a class="reference internal" href="runtime.html#syntax-tableaddr"><span class="std std-ref">table address</span></a> resulting from <a class="reference internal" href="#alloc-table"><span class="std std-ref">allocating</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-table}{\mathit{table}}_i.\href{../syntax/modules.html#syntax-table}{\mathsf{type}}\)</span> with initialization value <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr-ref}{\mathsf{ref{.}null}}~t_i\)</span>.</p></li>
</ol>
</li>
<li><p>For each <a class="reference internal" href="../syntax/modules.html#syntax-mem"><span class="std std-ref">memory</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-mem}{\mathit{mem}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{mems}}\)</span>, do:</p>
<ol class="loweralpha simple">
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-memaddr}{\mathit{memaddr}}_i\)</span> be the <a class="reference internal" href="runtime.html#syntax-memaddr"><span class="std std-ref">memory address</span></a> resulting from <a class="reference internal" href="#alloc-mem"><span class="std std-ref">allocating</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-mem}{\mathit{mem}}_i.\href{../syntax/modules.html#syntax-mem}{\mathsf{type}}\)</span>.</p></li>
</ol>
</li>
<li><p>For each <a class="reference internal" href="../syntax/modules.html#syntax-global"><span class="std std-ref">global</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-global}{\mathit{global}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{globals}}\)</span>, do:</p>
<ol class="loweralpha simple">
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-globaladdr}{\mathit{globaladdr}}_i\)</span> be the <a class="reference internal" href="runtime.html#syntax-globaladdr"><span class="std std-ref">global address</span></a> resulting from <a class="reference internal" href="#alloc-global"><span class="std std-ref">allocating</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-global}{\mathit{global}}_i.\href{../syntax/modules.html#syntax-global}{\mathsf{type}}\)</span> with initializer value <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast[i]\)</span>.</p></li>
</ol>
</li>
<li><p>For each <a class="reference internal" href="../syntax/modules.html#syntax-elem"><span class="std std-ref">element segment</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-elem}{\mathit{elem}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{elems}}\)</span>, do:</p>
<ol class="loweralpha simple">
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-elemaddr}{\mathit{elemaddr}}_i\)</span> be the <a class="reference internal" href="runtime.html#syntax-elemaddr"><span class="std std-ref">element address</span></a> resulting from <a class="reference internal" href="#alloc-elem"><span class="std std-ref">allocating</span></a> an <a class="reference internal" href="runtime.html#syntax-eleminst"><span class="std std-ref">element instance</span></a> of <a class="reference internal" href="../syntax/types.html#syntax-reftype"><span class="std std-ref">reference type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-elem}{\mathit{elem}}_i.\href{../syntax/modules.html#syntax-elem}{\mathsf{type}}\)</span> with contents <span class="math notranslate nohighlight">\((\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^\ast)^\ast[i]\)</span>.</p></li>
</ol>
</li>
<li><p>For each <a class="reference internal" href="../syntax/modules.html#syntax-data"><span class="std std-ref">data segment</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-data}{\mathit{data}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{datas}}\)</span>, do:</p>
<ol class="loweralpha simple">
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-dataaddr}{\mathit{dataaddr}}_i\)</span> be the <a class="reference internal" href="runtime.html#syntax-dataaddr"><span class="std std-ref">data address</span></a> resulting from <a class="reference internal" href="#alloc-data"><span class="std std-ref">allocating</span></a> a <a class="reference internal" href="runtime.html#syntax-datainst"><span class="std std-ref">data instance</span></a> with contents <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-data}{\mathit{data}}_i.\href{../syntax/modules.html#syntax-data}{\mathsf{init}}\)</span>.</p></li>
</ol>
</li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}^\ast\)</span> be the concatenation of the <a class="reference internal" href="runtime.html#syntax-funcaddr"><span class="std std-ref">function addresses</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}_i\)</span> in index order.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-tableaddr}{\mathit{tableaddr}}^\ast\)</span> be the concatenation of the <a class="reference internal" href="runtime.html#syntax-tableaddr"><span class="std std-ref">table addresses</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-tableaddr}{\mathit{tableaddr}}_i\)</span> in index order.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-memaddr}{\mathit{memaddr}}^\ast\)</span> be the concatenation of the <a class="reference internal" href="runtime.html#syntax-memaddr"><span class="std std-ref">memory addresses</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-memaddr}{\mathit{memaddr}}_i\)</span> in index order.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-globaladdr}{\mathit{globaladdr}}^\ast\)</span> be the concatenation of the <a class="reference internal" href="runtime.html#syntax-globaladdr"><span class="std std-ref">global addresses</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-globaladdr}{\mathit{globaladdr}}_i\)</span> in index order.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-elemaddr}{\mathit{elemaddr}}^\ast\)</span> be the concatenation of the <a class="reference internal" href="runtime.html#syntax-elemaddr"><span class="std std-ref">element addresses</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-elemaddr}{\mathit{elemaddr}}_i\)</span> in index order.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-dataaddr}{\mathit{dataaddr}}^\ast\)</span> be the concatenation of the <a class="reference internal" href="runtime.html#syntax-dataaddr"><span class="std std-ref">data addresses</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-dataaddr}{\mathit{dataaddr}}_i\)</span> in index order.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}_{\mathrm{mod}}^\ast\)</span> be the list of <a class="reference internal" href="runtime.html#syntax-funcaddr"><span class="std std-ref">function addresses</span></a> extracted from <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_{\mathrm{im}}^\ast\)</span>, concatenated with <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}^\ast\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-tableaddr}{\mathit{tableaddr}}_{\mathrm{mod}}^\ast\)</span> be the list of <a class="reference internal" href="runtime.html#syntax-tableaddr"><span class="std std-ref">table addresses</span></a> extracted from <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_{\mathrm{im}}^\ast\)</span>, concatenated with <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-tableaddr}{\mathit{tableaddr}}^\ast\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-memaddr}{\mathit{memaddr}}_{\mathrm{mod}}^\ast\)</span> be the list of <a class="reference internal" href="runtime.html#syntax-memaddr"><span class="std std-ref">memory addresses</span></a> extracted from <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_{\mathrm{im}}^\ast\)</span>, concatenated with <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-memaddr}{\mathit{memaddr}}^\ast\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-globaladdr}{\mathit{globaladdr}}_{\mathrm{mod}}^\ast\)</span> be the list of <a class="reference internal" href="runtime.html#syntax-globaladdr"><span class="std std-ref">global addresses</span></a> extracted from <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_{\mathrm{im}}^\ast\)</span>, concatenated with <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-globaladdr}{\mathit{globaladdr}}^\ast\)</span>.</p></li>
<li><p>For each <a class="reference internal" href="../syntax/modules.html#syntax-export"><span class="std std-ref">export</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-export}{\mathit{export}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{exports}}\)</span>, do:</p>
<ol class="loweralpha simple">
<li><p>If <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-export}{\mathit{export}}_i\)</span> is a function export for <a class="reference internal" href="../syntax/modules.html#syntax-funcidx"><span class="std std-ref">function index</span></a> <span class="math notranslate nohighlight">\(x\)</span>, then let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_i\)</span> be the <a class="reference internal" href="runtime.html#syntax-externval"><span class="std std-ref">external value</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathsf{func}}~(\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}_{\mathrm{mod}}^\ast[x])\)</span>.</p></li>
<li><p>Else, if <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-export}{\mathit{export}}_i\)</span> is a table export for <a class="reference internal" href="../syntax/modules.html#syntax-tableidx"><span class="std std-ref">table index</span></a> <span class="math notranslate nohighlight">\(x\)</span>, then let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_i\)</span> be the <a class="reference internal" href="runtime.html#syntax-externval"><span class="std std-ref">external value</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathsf{table}}~(\href{../exec/runtime.html#syntax-tableaddr}{\mathit{tableaddr}}_{\mathrm{mod}}^\ast[x])\)</span>.</p></li>
<li><p>Else, if <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-export}{\mathit{export}}_i\)</span> is a memory export for <a class="reference internal" href="../syntax/modules.html#syntax-memidx"><span class="std std-ref">memory index</span></a> <span class="math notranslate nohighlight">\(x\)</span>, then let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_i\)</span> be the <a class="reference internal" href="runtime.html#syntax-externval"><span class="std std-ref">external value</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathsf{mem}}~(\href{../exec/runtime.html#syntax-memaddr}{\mathit{memaddr}}_{\mathrm{mod}}^\ast[x])\)</span>.</p></li>
<li><p>Else, if <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-export}{\mathit{export}}_i\)</span> is a global export for <a class="reference internal" href="../syntax/modules.html#syntax-globalidx"><span class="std std-ref">global index</span></a> <span class="math notranslate nohighlight">\(x\)</span>, then let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_i\)</span> be the <a class="reference internal" href="runtime.html#syntax-externval"><span class="std std-ref">external value</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathsf{global}}~(\href{../exec/runtime.html#syntax-globaladdr}{\mathit{globaladdr}}_{\mathrm{mod}}^\ast[x])\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-exportinst}{\mathit{exportinst}}_i\)</span> be the <a class="reference internal" href="runtime.html#syntax-exportinst"><span class="std std-ref">export instance</span></a> <span class="math notranslate nohighlight">\(\{\href{../exec/runtime.html#syntax-exportinst}{\mathsf{name}}~(\href{../syntax/modules.html#syntax-export}{\mathit{export}}_i.\href{../syntax/modules.html#syntax-export}{\mathsf{name}}), \href{../exec/runtime.html#syntax-exportinst}{\mathsf{value}}~\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_i\}\)</span>.</p></li>
</ol>
</li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-exportinst}{\mathit{exportinst}}^\ast\)</span> be the concatenation of the <a class="reference internal" href="runtime.html#syntax-exportinst"><span class="std std-ref">export instances</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-exportinst}{\mathit{exportinst}}_i\)</span> in index order.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}\)</span> be the <a class="reference internal" href="runtime.html#syntax-moduleinst"><span class="std std-ref">module instance</span></a> <span class="math notranslate nohighlight">\(\{\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{types}}~(\href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{types}}),\)</span> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{funcaddrs}}~\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}_{\mathrm{mod}}^\ast,\)</span> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{tableaddrs}}~\href{../exec/runtime.html#syntax-tableaddr}{\mathit{tableaddr}}_{\mathrm{mod}}^\ast,\)</span> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{memaddrs}}~\href{../exec/runtime.html#syntax-memaddr}{\mathit{memaddr}}_{\mathrm{mod}}^\ast,\)</span> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{globaladdrs}}~\href{../exec/runtime.html#syntax-globaladdr}{\mathit{globaladdr}}_{\mathrm{mod}}^\ast,\)</span> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{exports}}~\href{../exec/runtime.html#syntax-exportinst}{\mathit{exportinst}}^\ast\}\)</span>.</p></li>
<li><p>Return <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}\)</span>.</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}~\\
\begin{array}{rlll}
\href{../exec/modules.html#alloc-module}{\mathrm{allocmodule}}(S, \href{../syntax/modules.html#syntax-module}{\mathit{module}}, \href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_{\mathrm{im}}^\ast, \href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast, (\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^\ast)^\ast) &amp;=&amp; S', \href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}
\end{array}\end{split}\]</div>
<p>where:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{&#64;{}rlll&#64;{}}
\href{../syntax/modules.html#syntax-table}{\mathit{table}}^\ast &amp;=&amp; \href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{tables}} \\
\href{../syntax/modules.html#syntax-mem}{\mathit{mem}}^\ast &amp;=&amp; \href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{mems}} \\
\href{../syntax/modules.html#syntax-global}{\mathit{global}}^\ast &amp;=&amp; \href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{globals}} \\
\href{../syntax/modules.html#syntax-elem}{\mathit{elem}}^\ast &amp;=&amp; \href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{elems}} \\
\href{../syntax/modules.html#syntax-data}{\mathit{data}}^\ast &amp;=&amp; \href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{datas}} \\
\href{../syntax/modules.html#syntax-export}{\mathit{export}}^\ast &amp;=&amp; \href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{exports}} \\[1ex]
\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}} &amp;=&amp; \{~
  \begin{array}[t]{&#64;{}l&#64;{}}
  \href{../exec/runtime.html#syntax-moduleinst}{\mathsf{types}}~\href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{types}}, \\
  \href{../exec/runtime.html#syntax-moduleinst}{\mathsf{funcaddrs}}~\href{../exec/runtime.html#syntax-externval}{\mathrm{funcs}}(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_{\mathrm{im}}^\ast)~\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}^\ast, \\
  \href{../exec/runtime.html#syntax-moduleinst}{\mathsf{tableaddrs}}~\href{../exec/runtime.html#syntax-externval}{\mathrm{tables}}(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_{\mathrm{im}}^\ast)~\href{../exec/runtime.html#syntax-tableaddr}{\mathit{tableaddr}}^\ast, \\
  \href{../exec/runtime.html#syntax-moduleinst}{\mathsf{memaddrs}}~\href{../exec/runtime.html#syntax-externval}{\mathrm{mems}}(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_{\mathrm{im}}^\ast)~\href{../exec/runtime.html#syntax-memaddr}{\mathit{memaddr}}^\ast, \\
  \href{../exec/runtime.html#syntax-moduleinst}{\mathsf{globaladdrs}}~\href{../exec/runtime.html#syntax-externval}{\mathrm{globals}}(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_{\mathrm{im}}^\ast)~\href{../exec/runtime.html#syntax-globaladdr}{\mathit{globaladdr}}^\ast, \\
  \href{../exec/runtime.html#syntax-moduleinst}{\mathsf{elemaddrs}}~\href{../exec/runtime.html#syntax-elemaddr}{\mathit{elemaddr}}^\ast, \\
  \href{../exec/runtime.html#syntax-moduleinst}{\mathsf{dataaddrs}}~\href{../exec/runtime.html#syntax-dataaddr}{\mathit{dataaddr}}^\ast, \\
  \href{../exec/runtime.html#syntax-moduleinst}{\mathsf{exports}}~\href{../exec/runtime.html#syntax-exportinst}{\mathit{exportinst}}^\ast ~\}
  \end{array} \\[1ex]
S_1, \href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}^\ast &amp;=&amp;
  \href{../exec/modules.html#alloc-func}{\mathrm{allocfunc}}^\ast(S, \href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{funcs}}, \href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}) \\
S_2, \href{../exec/runtime.html#syntax-tableaddr}{\mathit{tableaddr}}^\ast &amp;=&amp;
  \href{../exec/modules.html#alloc-table}{\mathrm{alloctable}}^\ast(S_1, (\href{../syntax/modules.html#syntax-table}{\mathit{table}}.\href{../syntax/modules.html#syntax-table}{\mathsf{type}})^\ast, (\href{../syntax/instructions.html#syntax-instr-ref}{\mathsf{ref{.}null}}~t)^\ast)
  \quad (\mathrel{\mbox{where}} (\href{../syntax/modules.html#syntax-table}{\mathit{table}}.\href{../syntax/modules.html#syntax-table}{\mathsf{type}})^\ast = (\href{../syntax/types.html#syntax-limits}{\mathit{limits}}~t)^\ast) \\
S_3, \href{../exec/runtime.html#syntax-memaddr}{\mathit{memaddr}}^\ast &amp;=&amp;
  \href{../exec/modules.html#alloc-mem}{\mathrm{allocmem}}^\ast(S_2, (\href{../syntax/modules.html#syntax-mem}{\mathit{mem}}.\href{../syntax/modules.html#syntax-mem}{\mathsf{type}})^\ast) \\
S_4, \href{../exec/runtime.html#syntax-globaladdr}{\mathit{globaladdr}}^\ast &amp;=&amp;
  \href{../exec/modules.html#alloc-global}{\mathrm{allocglobal}}^\ast(S_3, (\href{../syntax/modules.html#syntax-global}{\mathit{global}}.\href{../syntax/modules.html#syntax-global}{\mathsf{type}})^\ast, \href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast) \\
S_5, \href{../exec/runtime.html#syntax-elemaddr}{\mathit{elemaddr}}^\ast &amp;=&amp;
  \href{../exec/modules.html#alloc-elem}{\mathrm{allocelem}}^\ast(S_4, (\href{../syntax/modules.html#syntax-elem}{\mathit{elem}}.\href{../syntax/modules.html#syntax-elem}{\mathsf{type}})^\ast, (\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^\ast)^\ast) \\
S', \href{../exec/runtime.html#syntax-dataaddr}{\mathit{dataaddr}}^\ast &amp;=&amp;
  \href{../exec/modules.html#alloc-data}{\mathrm{allocdata}}^\ast(S_5, (\href{../syntax/modules.html#syntax-data}{\mathit{data}}.\href{../syntax/modules.html#syntax-data}{\mathsf{init}})^\ast) \\
\href{../exec/runtime.html#syntax-exportinst}{\mathit{exportinst}}^\ast &amp;=&amp;
  \{ \href{../exec/runtime.html#syntax-exportinst}{\mathsf{name}}~(\href{../syntax/modules.html#syntax-export}{\mathit{export}}.\href{../syntax/modules.html#syntax-export}{\mathsf{name}}), \href{../exec/runtime.html#syntax-exportinst}{\mathsf{value}}~\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_{\mathrm{ex}} \}^\ast \\[1ex]
\href{../exec/runtime.html#syntax-externval}{\mathrm{funcs}}(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_{\mathrm{ex}}^\ast) &amp;=&amp; (\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}.\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{funcaddrs}}[x])^\ast
  \qquad~ (\mathrel{\mbox{where}} x^\ast = \href{../syntax/modules.html#syntax-exportdesc}{\mathrm{funcs}}(\href{../syntax/modules.html#syntax-export}{\mathit{export}}^\ast)) \\
\href{../exec/runtime.html#syntax-externval}{\mathrm{tables}}(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_{\mathrm{ex}}^\ast) &amp;=&amp; (\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}.\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{tableaddrs}}[x])^\ast
  \qquad (\mathrel{\mbox{where}} x^\ast = \href{../syntax/modules.html#syntax-exportdesc}{\mathrm{tables}}(\href{../syntax/modules.html#syntax-export}{\mathit{export}}^\ast)) \\
\href{../exec/runtime.html#syntax-externval}{\mathrm{mems}}(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_{\mathrm{ex}}^\ast) &amp;=&amp; (\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}.\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{memaddrs}}[x])^\ast
  \qquad (\mathrel{\mbox{where}} x^\ast = \href{../syntax/modules.html#syntax-exportdesc}{\mathrm{mems}}(\href{../syntax/modules.html#syntax-export}{\mathit{export}}^\ast)) \\
\href{../exec/runtime.html#syntax-externval}{\mathrm{globals}}(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_{\mathrm{ex}}^\ast) &amp;=&amp; (\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}.\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{globaladdrs}}[x])^\ast
  \qquad\!\!\! (\mathrel{\mbox{where}} x^\ast = \href{../syntax/modules.html#syntax-exportdesc}{\mathrm{globals}}(\href{../syntax/modules.html#syntax-export}{\mathit{export}}^\ast)) \\
\end{array}\end{split}\]</div>
<p>Here, the notation <span class="math notranslate nohighlight">\(\mathrm{allocx}^\ast\)</span> is shorthand for multiple <a class="reference internal" href="#alloc"><span class="std std-ref">allocations</span></a> of object kind <span class="math notranslate nohighlight">\(X\)</span>, defined as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{rlll}
\mathrm{allocx}^\ast(S_0, X^n, \dots) &amp;=&amp; S_n, a^n \\[1ex]
\mbox{where for all $i &lt; n$:} \hfill \\
S_{i+1}, a^n[i] &amp;=&amp; \mathrm{allocx}(S_i, X^n[i], \dots)
\end{array}\end{split}\]</div>
<p>Moreover, if the dots <span class="math notranslate nohighlight">\(\dots\)</span> are a sequence <span class="math notranslate nohighlight">\(A^n\)</span> (as for globals or tables), then the elements of this sequence are passed to the allocation function pointwise.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The definition of module allocation is mutually recursive with the allocation of its associated functions, because the resulting module instance <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}\)</span> is passed to the function allocator as an argument, in order to form the necessary closures.
In an implementation, this recursion is easily unraveled by mutating one or the other in a secondary step.</p>
</div>
</section>
</section>
<section id="instantiation">
<span id="exec-instantiation"></span><span id="exec-module"></span><span id="index-17"></span><h2>Instantiation<a class="headerlink" href="#instantiation" title="Permalink to this heading">¶</a></h2>
<p>Given a <a class="reference internal" href="runtime.html#syntax-store"><span class="std std-ref">store</span></a> <span class="math notranslate nohighlight">\(S\)</span>, a <a class="reference internal" href="../syntax/modules.html#syntax-module"><span class="std std-ref">module</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-module}{\mathit{module}}\)</span> is instantiated with a list of <a class="reference internal" href="runtime.html#syntax-externval"><span class="std std-ref">external values</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}^n\)</span> supplying the required imports as follows.</p>
<p>Instantiation checks that the module is <a class="reference internal" href="../valid/index.html#valid"><span class="std std-ref">valid</span></a> and the provided imports <a class="reference internal" href="../valid/types.html#match-externtype"><span class="std std-ref">match</span></a> the declared types,
and may <em>fail</em> with an error otherwise.
Instantiation can also result in a <a class="reference internal" href="../intro/overview.html#trap"><span class="std std-ref">trap</span></a> from initializing a table or memory from an active segment or from executing the start function.
It is up to the <a class="reference internal" href="../intro/overview.html#embedder"><span class="std std-ref">embedder</span></a> to define how such conditions are reported.</p>
<ol class="arabic simple">
<li><p>If <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-module}{\mathit{module}}\)</span> is not <a class="reference internal" href="../valid/modules.html#valid-module"><span class="std std-ref">valid</span></a>, then:</p>
<ol class="loweralpha simple">
<li><p>Fail.</p></li>
</ol>
</li>
<li><p>Assert: <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-module}{\mathit{module}}\)</span> is <a class="reference internal" href="../valid/modules.html#valid-module"><span class="std std-ref">valid</span></a> with <a class="reference internal" href="../syntax/types.html#syntax-externtype"><span class="std std-ref">external types</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-externtype}{\mathit{externtype}}_{\mathrm{im}}^m\)</span> classifying its <a class="reference internal" href="../syntax/modules.html#syntax-import"><span class="std std-ref">imports</span></a>.</p></li>
<li><p>If the number <span class="math notranslate nohighlight">\(m\)</span> of <a class="reference internal" href="../syntax/modules.html#syntax-import"><span class="std std-ref">imports</span></a> is not equal to the number <span class="math notranslate nohighlight">\(n\)</span> of provided <a class="reference internal" href="runtime.html#syntax-externval"><span class="std std-ref">external values</span></a>, then:</p>
<ol class="loweralpha simple">
<li><p>Fail.</p></li>
</ol>
</li>
<li><p>For each <a class="reference internal" href="runtime.html#syntax-externval"><span class="std std-ref">external value</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}^n\)</span> and <a class="reference internal" href="../syntax/types.html#syntax-externtype"><span class="std std-ref">external type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-externtype}{\mathit{externtype}}'_i\)</span> in <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-externtype}{\mathit{externtype}}_{\mathrm{im}}^n\)</span>, do:</p>
<ol class="loweralpha simple">
<li><p>If <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}_i\)</span> is not <a class="reference internal" href="#valid-externval"><span class="std std-ref">valid</span></a> with an <a class="reference internal" href="../syntax/types.html#syntax-externtype"><span class="std std-ref">external type</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-externtype}{\mathit{externtype}}_i\)</span> in store <span class="math notranslate nohighlight">\(S\)</span>, then:</p>
<ol class="lowerroman simple">
<li><p>Fail.</p></li>
</ol>
</li>
<li><p>If <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-externtype}{\mathit{externtype}}_i\)</span> does not <a class="reference internal" href="../valid/types.html#match-externtype"><span class="std std-ref">match</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-externtype}{\mathit{externtype}}'_i\)</span>, then:</p>
<ol class="lowerroman simple">
<li><p>Fail.</p></li>
</ol>
</li>
</ol>
</li>
</ol>
<ol class="arabic" id="exec-initvals" start="5">
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}_{\mathrm{init}}\)</span> be the auxiliary module <a class="reference internal" href="runtime.html#syntax-moduleinst"><span class="std std-ref">instance</span></a> <span class="math notranslate nohighlight">\(\{\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{globaladdrs}}~\href{../exec/runtime.html#syntax-externval}{\mathrm{globals}}(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}^n), \href{../exec/runtime.html#syntax-moduleinst}{\mathsf{funcaddrs}}~\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}.\href{../exec/runtime.html#syntax-moduleinst}{\mathsf{funcaddrs}}\}\)</span> that only consists of the imported globals and the imported and allocated functions from the final module instance <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}\)</span>, defined below.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(F_{\mathrm{init}}\)</span> be the auxiliary <a class="reference internal" href="runtime.html#syntax-frame"><span class="std std-ref">frame</span></a> <span class="math notranslate nohighlight">\(\{ \href{../exec/runtime.html#syntax-frame}{\mathsf{module}}~\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}_{\mathrm{init}}, \href{../exec/runtime.html#syntax-frame}{\mathsf{locals}}~\epsilon \}\)</span>.</p></li>
<li><p>Push the frame <span class="math notranslate nohighlight">\(F_{\mathrm{init}}\)</span> to the stack.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast\)</span> be the vector of <a class="reference internal" href="../syntax/modules.html#syntax-global"><span class="std std-ref">global</span></a> initialization <a class="reference internal" href="runtime.html#syntax-val"><span class="std std-ref">values</span></a> determined by <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-module}{\mathit{module}}\)</span> and <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}^n\)</span>. These may be calculated as follows.</p>
<ol class="loweralpha simple">
<li><p>For each <a class="reference internal" href="../syntax/modules.html#syntax-global"><span class="std std-ref">global</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-global}{\mathit{global}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{globals}}\)</span>, do:</p>
<ol class="lowerroman simple">
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}_i\)</span> be the result of <a class="reference internal" href="instructions.html#exec-expr"><span class="std std-ref">evaluating</span></a> the initializer expression <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-global}{\mathit{global}}_i.\href{../syntax/modules.html#syntax-global}{\mathsf{init}}\)</span>.</p></li>
</ol>
</li>
<li><p>Assert: due to <a class="reference internal" href="../valid/modules.html#valid-module"><span class="std std-ref">validation</span></a>, the frame <span class="math notranslate nohighlight">\(F_{\mathrm{init}}\)</span> is now on the top of the stack.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast\)</span> be the concatenation of <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}_i\)</span> in index order.</p></li>
</ol>
</li>
<li><p>Let <span class="math notranslate nohighlight">\((\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^\ast)^\ast\)</span> be the list of <a class="reference internal" href="runtime.html#syntax-ref"><span class="std std-ref">reference</span></a> vectors determined by the <a class="reference internal" href="../syntax/modules.html#syntax-elem"><span class="std std-ref">element segments</span></a> in <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-module}{\mathit{module}}\)</span>. These may be calculated as follows.</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>For each <a class="reference internal" href="../syntax/modules.html#syntax-elem"><span class="std std-ref">element segment</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-elem}{\mathit{elem}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{elems}}\)</span>, and for each element <a class="reference internal" href="../syntax/instructions.html#syntax-expr"><span class="std std-ref">expression</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-expr}{\mathit{expr}}_{ij}\)</span> in <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-elem}{\mathit{elem}}_i.\href{../syntax/modules.html#syntax-elem}{\mathsf{init}}\)</span>, do:</p>
<ol class="lowerroman simple">
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}_{ij}\)</span> be the result of <a class="reference internal" href="instructions.html#exec-expr"><span class="std std-ref">evaluating</span></a> the initializer expression <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-expr}{\mathit{expr}}_{ij}\)</span>.</p></li>
</ol>
</li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^\ast_i\)</span> be the concatenation of function elements <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}_{ij}\)</span> in order of index <span class="math notranslate nohighlight">\(j\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\((\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^\ast)^\ast\)</span> be the concatenation of function element vectors <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^\ast_i\)</span> in order of index <span class="math notranslate nohighlight">\(i\)</span>.</p></li>
</ol>
</div></blockquote>
</li>
<li><p>Pop the frame <span class="math notranslate nohighlight">\(F_{\mathrm{init}}\)</span> from the stack.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}\)</span> be a new module instance <a class="reference internal" href="#alloc-module"><span class="std std-ref">allocated</span></a> from <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-module}{\mathit{module}}\)</span> in store <span class="math notranslate nohighlight">\(S\)</span> with imports <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-externval}{\mathit{externval}}^n\)</span>, global initializer values <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast\)</span>, and element segment contents <span class="math notranslate nohighlight">\((\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^\ast)^\ast\)</span>, and let <span class="math notranslate nohighlight">\(S'\)</span> be the extended store produced by module allocation.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(F\)</span> be the auxiliary <a class="reference internal" href="runtime.html#syntax-frame"><span class="std std-ref">frame</span></a> <span class="math notranslate nohighlight">\(\{ \href{../exec/runtime.html#syntax-frame}{\mathsf{module}}~\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}, \href{../exec/runtime.html#syntax-frame}{\mathsf{locals}}~\epsilon \}\)</span>.</p></li>
<li><p>Push the frame <span class="math notranslate nohighlight">\(F\)</span> to the stack.</p></li>
<li><p>For each <a class="reference internal" href="../syntax/modules.html#syntax-elem"><span class="std std-ref">element segment</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-elem}{\mathit{elem}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{elems}}\)</span> whose <a class="reference internal" href="../syntax/modules.html#syntax-elemmode"><span class="std std-ref">mode</span></a> is of the form <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-elemmode}{\mathsf{active}}~\{ \href{../syntax/modules.html#syntax-elem}{\mathsf{table}}~\href{../syntax/modules.html#syntax-tableidx}{\mathit{tableidx}}_i, \href{../syntax/modules.html#syntax-elem}{\mathsf{offset}}~\mathit{einstr}^\ast_i~\href{../syntax/instructions.html#syntax-instr-control}{\mathsf{end}} \}\)</span>, do:</p>
<ol class="loweralpha simple">
<li><p>Let <span class="math notranslate nohighlight">\(n\)</span> be the length of the vector <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-elem}{\mathit{elem}}_i.\href{../syntax/modules.html#syntax-elem}{\mathsf{init}}\)</span>.</p></li>
<li><p><a class="reference internal" href="instructions.html#exec-instr-seq"><span class="std std-ref">Execute</span></a> the instruction sequence <span class="math notranslate nohighlight">\(\mathit{einstr}^\ast_i\)</span>.</p></li>
<li><p><a class="reference internal" href="instructions.html#exec-const"><span class="std std-ref">Execute</span></a> the instruction <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-valtype}{\mathsf{i32}}.\href{../syntax/instructions.html#syntax-instr-numeric}{\mathsf{const}}~0\)</span>.</p></li>
<li><p><a class="reference internal" href="instructions.html#exec-const"><span class="std std-ref">Execute</span></a> the instruction <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-valtype}{\mathsf{i32}}.\href{../syntax/instructions.html#syntax-instr-numeric}{\mathsf{const}}~n\)</span>.</p></li>
<li><p><a class="reference internal" href="instructions.html#exec-table-init"><span class="std std-ref">Execute</span></a> the instruction <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr-table}{\mathsf{table.init}}~\href{../syntax/modules.html#syntax-tableidx}{\mathit{tableidx}}_i~i\)</span>.</p></li>
<li><p><a class="reference internal" href="instructions.html#exec-elem-drop"><span class="std std-ref">Execute</span></a> the instruction <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr-table}{\mathsf{elem.drop}}~i\)</span>.</p></li>
</ol>
</li>
<li><p>For each <a class="reference internal" href="../syntax/modules.html#syntax-elem"><span class="std std-ref">element segment</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-elem}{\mathit{elem}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{elems}}\)</span> whose <a class="reference internal" href="../syntax/modules.html#syntax-elemmode"><span class="std std-ref">mode</span></a> is of the form <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-elemmode}{\mathsf{declarative}}\)</span>, do:</p>
<ol class="loweralpha simple">
<li><p><a class="reference internal" href="instructions.html#exec-elem-drop"><span class="std std-ref">Execute</span></a> the instruction <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr-table}{\mathsf{elem.drop}}~i\)</span>.</p></li>
</ol>
</li>
<li><p>For each <a class="reference internal" href="../syntax/modules.html#syntax-data"><span class="std std-ref">data segment</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-data}{\mathit{data}}_i\)</span> in <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{datas}}\)</span> whose <a class="reference internal" href="../syntax/modules.html#syntax-datamode"><span class="std std-ref">mode</span></a> is of the form <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-datamode}{\mathsf{active}}~\{ \href{../syntax/modules.html#syntax-data}{\mathsf{memory}}~\href{../syntax/modules.html#syntax-memidx}{\mathit{memidx}}_i, \href{../syntax/modules.html#syntax-data}{\mathsf{offset}}~\mathit{dinstr}^\ast_i~\href{../syntax/instructions.html#syntax-instr-control}{\mathsf{end}} \}\)</span>, do:</p>
<ol class="loweralpha simple">
<li><p>Assert: <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-memidx}{\mathit{memidx}}_i\)</span> is <span class="math notranslate nohighlight">\(0\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(n\)</span> be the length of the vector <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-data}{\mathit{data}}_i.\href{../syntax/modules.html#syntax-data}{\mathsf{init}}\)</span>.</p></li>
<li><p><a class="reference internal" href="instructions.html#exec-instr-seq"><span class="std std-ref">Execute</span></a> the instruction sequence <span class="math notranslate nohighlight">\(\mathit{dinstr}^\ast_i\)</span>.</p></li>
<li><p><a class="reference internal" href="instructions.html#exec-const"><span class="std std-ref">Execute</span></a> the instruction <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-valtype}{\mathsf{i32}}.\href{../syntax/instructions.html#syntax-instr-numeric}{\mathsf{const}}~0\)</span>.</p></li>
<li><p><a class="reference internal" href="instructions.html#exec-const"><span class="std std-ref">Execute</span></a> the instruction <span class="math notranslate nohighlight">\(\href{../syntax/types.html#syntax-valtype}{\mathsf{i32}}.\href{../syntax/instructions.html#syntax-instr-numeric}{\mathsf{const}}~n\)</span>.</p></li>
<li><p><a class="reference internal" href="instructions.html#exec-memory-init"><span class="std std-ref">Execute</span></a> the instruction <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr-memory}{\mathsf{memory.init}}~i\)</span>.</p></li>
<li><p><a class="reference internal" href="instructions.html#exec-data-drop"><span class="std std-ref">Execute</span></a> the instruction <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr-memory}{\mathsf{data.drop}}~i\)</span>.</p></li>
</ol>
</li>
<li><p>If the <a class="reference internal" href="../syntax/modules.html#syntax-start"><span class="std std-ref">start function</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{start}}\)</span> is not empty, then:</p>
<ol class="loweralpha simple">
<li><p>Let <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-start}{\mathit{start}}\)</span> be the <a class="reference internal" href="../syntax/modules.html#syntax-start"><span class="std std-ref">start function</span></a> <span class="math notranslate nohighlight">\(\href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{start}}\)</span>.</p></li>
<li><p><a class="reference internal" href="instructions.html#exec-call"><span class="std std-ref">Execute</span></a> the instruction <span class="math notranslate nohighlight">\(\href{../syntax/instructions.html#syntax-instr-control}{\mathsf{call}}~\href{../syntax/modules.html#syntax-start}{\mathit{start}}.\href{../syntax/modules.html#syntax-start}{\mathsf{func}}\)</span>.</p></li>
</ol>
</li>
<li><p>Assert: due to <a class="reference internal" href="../valid/modules.html#valid-module"><span class="std std-ref">validation</span></a>, the frame <span class="math notranslate nohighlight">\(F\)</span> is now on the top of the stack.</p></li>
<li><p>Pop the frame <span class="math notranslate nohighlight">\(F\)</span> from the stack.</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}~\\
\begin{array}{&#64;{}rcll}
\href{../exec/modules.html#exec-instantiation}{\mathrm{instantiate}}(S, \href{../syntax/modules.html#syntax-module}{\mathit{module}}, \href{../exec/runtime.html#syntax-externval}{\mathit{externval}}^k) &amp;=&amp; S'; F;
  \begin{array}[t]{&#64;{}l&#64;{}}
  \mathrm{runelem}_0(\href{../syntax/modules.html#syntax-elem}{\mathit{elem}}^n[0])~\dots~\mathrm{runelem}_{n-1}(\href{../syntax/modules.html#syntax-elem}{\mathit{elem}}^n[n-1]) \\
  \mathrm{rundata}_0(\href{../syntax/modules.html#syntax-data}{\mathit{data}}^m[0])~\dots~\mathrm{rundata}_{m-1}(\href{../syntax/modules.html#syntax-data}{\mathit{data}}^m[m-1]) \\
  (\href{../syntax/instructions.html#syntax-instr-control}{\mathsf{call}}~\href{../syntax/modules.html#syntax-start}{\mathit{start}}.\href{../syntax/modules.html#syntax-start}{\mathsf{func}})^? \\
  \end{array} \\
&amp;(\mathrel{\mbox{if}}
  &amp; \href{../valid/modules.html#valid-module}{\vdash} \href{../syntax/modules.html#syntax-module}{\mathit{module}} : \href{../syntax/types.html#syntax-externtype}{\mathit{externtype}}_{\mathrm{im}}^k \href{../syntax/types.html#syntax-functype}{\rightarrow} \href{../syntax/types.html#syntax-externtype}{\mathit{externtype}}_{\mathrm{ex}}^\ast \\
  &amp;\wedge&amp; (S \href{../exec/modules.html#valid-externval}{\vdash} \href{../exec/runtime.html#syntax-externval}{\mathit{externval}} : \href{../syntax/types.html#syntax-externtype}{\mathit{externtype}})^k \\
  &amp;\wedge&amp; (\href{../valid/types.html#match-externtype}{\vdash} \href{../syntax/types.html#syntax-externtype}{\mathit{externtype}} \href{../valid/types.html#match-externtype}{\leq} \href{../syntax/types.html#syntax-externtype}{\mathit{externtype}}_{\mathrm{im}})^k \\[1ex]
  &amp;\wedge&amp; \href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{globals}} = \href{../syntax/modules.html#syntax-global}{\mathit{global}}^\ast \\
  &amp;\wedge&amp; \href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{elems}} = \href{../syntax/modules.html#syntax-elem}{\mathit{elem}}^n \\
  &amp;\wedge&amp; \href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{datas}} = \href{../syntax/modules.html#syntax-data}{\mathit{data}}^m \\
  &amp;\wedge&amp; \href{../syntax/modules.html#syntax-module}{\mathit{module}}.\href{../syntax/modules.html#syntax-module}{\mathsf{start}} = \href{../syntax/modules.html#syntax-start}{\mathit{start}}^? \\
  &amp;\wedge&amp; (\href{../syntax/instructions.html#syntax-expr}{\mathit{expr}}_{\mathrm{g}} = \href{../syntax/modules.html#syntax-global}{\mathit{global}}.\href{../syntax/modules.html#syntax-global}{\mathsf{init}})^\ast \\
  &amp;\wedge&amp; (\href{../syntax/instructions.html#syntax-expr}{\mathit{expr}}_{\mathrm{e}}^\ast = \href{../syntax/modules.html#syntax-elem}{\mathit{elem}}.\href{../syntax/modules.html#syntax-elem}{\mathsf{init}})^n \\[1ex]
  &amp;\wedge&amp; S', \href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}} = \href{../exec/modules.html#alloc-module}{\mathrm{allocmodule}}(S, \href{../syntax/modules.html#syntax-module}{\mathit{module}}, \href{../exec/runtime.html#syntax-externval}{\mathit{externval}}^k, \href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast, (\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^\ast)^n) \\
  &amp;\wedge&amp; F = \{ \href{../exec/runtime.html#syntax-frame}{\mathsf{module}}~\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}, \href{../exec/runtime.html#syntax-frame}{\mathsf{locals}}~\epsilon \} \\[1ex]
  &amp;\wedge&amp; (S'; F; \href{../syntax/instructions.html#syntax-expr}{\mathit{expr}}_{\mathrm{g}} \href{../exec/conventions.html#exec-notation}{\hookrightarrow}^\ast S'; F; \href{../exec/runtime.html#syntax-val}{\mathit{val}}~\href{../syntax/instructions.html#syntax-instr-control}{\mathsf{end}})^\ast \\
  &amp;\wedge&amp; ((S'; F; \href{../syntax/instructions.html#syntax-expr}{\mathit{expr}}_{\mathrm{e}} \href{../exec/conventions.html#exec-notation}{\hookrightarrow}^\ast S'; F; \href{../exec/runtime.html#syntax-ref}{\mathit{ref}}~\href{../syntax/instructions.html#syntax-instr-control}{\mathsf{end}})^\ast)^n) \\
\end{array}\end{split}\]</div>
<p>where:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{&#64;{}l}
\mathrm{runelem}_i(\{\href{../syntax/modules.html#syntax-elem}{\mathsf{type}}~\mathit{et}, \href{../syntax/modules.html#syntax-elem}{\mathsf{init}}~\href{../syntax/instructions.html#syntax-expr}{\mathit{expr}}^n, \href{../syntax/modules.html#syntax-elem}{\mathsf{mode}}~\href{../syntax/modules.html#syntax-elemmode}{\mathsf{passive}}\}) \quad=\quad \epsilon \\
\mathrm{runelem}_i(\{\href{../syntax/modules.html#syntax-elem}{\mathsf{type}}~\mathit{et}, \href{../syntax/modules.html#syntax-elem}{\mathsf{init}}~\href{../syntax/instructions.html#syntax-expr}{\mathit{expr}}^n, \href{../syntax/modules.html#syntax-elem}{\mathsf{mode}}~\href{../syntax/modules.html#syntax-elemmode}{\mathsf{active}} \{\href{../syntax/modules.html#syntax-elem}{\mathsf{table}}~x, \href{../syntax/modules.html#syntax-elem}{\mathsf{offset}}~\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast~\href{../syntax/instructions.html#syntax-instr-control}{\mathsf{end}}\}\}) \quad=\\ \qquad
  \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast~(\href{../syntax/types.html#syntax-valtype}{\mathsf{i32}}.\href{../syntax/instructions.html#syntax-instr-numeric}{\mathsf{const}}~0)~(\href{../syntax/types.html#syntax-valtype}{\mathsf{i32}}.\href{../syntax/instructions.html#syntax-instr-numeric}{\mathsf{const}}~n)~(\href{../syntax/instructions.html#syntax-instr-table}{\mathsf{table.init}}~x~i)~(\href{../syntax/instructions.html#syntax-instr-table}{\mathsf{elem.drop}}~i) \\
\mathrm{runelem}_i(\{\href{../syntax/modules.html#syntax-elem}{\mathsf{type}}~\mathit{et}, \href{../syntax/modules.html#syntax-elem}{\mathsf{init}}~\href{../syntax/instructions.html#syntax-expr}{\mathit{expr}}^n, \href{../syntax/modules.html#syntax-elem}{\mathsf{mode}}~\href{../syntax/modules.html#syntax-elemmode}{\mathsf{declarative}}\}) \quad=\\ \qquad
  (\href{../syntax/instructions.html#syntax-instr-table}{\mathsf{elem.drop}}~i) \\[1ex]
\mathrm{rundata}_i(\{\href{../syntax/modules.html#syntax-data}{\mathsf{init}}~b^n, \href{../syntax/modules.html#syntax-data}{\mathsf{mode}}~\href{../syntax/modules.html#syntax-datamode}{\mathsf{passive}}\}) \quad=\quad \epsilon \\
\mathrm{rundata}_i(\{\href{../syntax/modules.html#syntax-data}{\mathsf{init}}~b^n, \href{../syntax/modules.html#syntax-data}{\mathsf{mode}}~\href{../syntax/modules.html#syntax-datamode}{\mathsf{active}} \{\href{../syntax/modules.html#syntax-data}{\mathsf{memory}}~0, \href{../syntax/modules.html#syntax-data}{\mathsf{offset}}~\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast~\href{../syntax/instructions.html#syntax-instr-control}{\mathsf{end}}\}\}) \quad=\\ \qquad
  \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast~(\href{../syntax/types.html#syntax-valtype}{\mathsf{i32}}.\href{../syntax/instructions.html#syntax-instr-numeric}{\mathsf{const}}~0)~(\href{../syntax/types.html#syntax-valtype}{\mathsf{i32}}.\href{../syntax/instructions.html#syntax-instr-numeric}{\mathsf{const}}~n)~(\href{../syntax/instructions.html#syntax-instr-memory}{\mathsf{memory.init}}~i)~(\href{../syntax/instructions.html#syntax-instr-memory}{\mathsf{data.drop}}~i) \\
\end{array}\end{split}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Module <a class="reference internal" href="#alloc-module"><span class="std std-ref">allocation</span></a> and the <a class="reference internal" href="instructions.html#exec-expr"><span class="std std-ref">evaluation</span></a> of <a class="reference internal" href="../syntax/modules.html#syntax-global"><span class="std std-ref">global</span></a> initializers and <a class="reference internal" href="../syntax/modules.html#syntax-elem"><span class="std std-ref">element segments</span></a> are mutually recursive because the global initialization <a class="reference internal" href="runtime.html#syntax-val"><span class="std std-ref">values</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast\)</span> and element segment contents <span class="math notranslate nohighlight">\((\href{../exec/runtime.html#syntax-ref}{\mathit{ref}}^\ast)^\ast\)</span> are passed to the module allocator while depending on the module instance <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-moduleinst}{\mathit{moduleinst}}\)</span> and store <span class="math notranslate nohighlight">\(S'\)</span> returned by allocation.
However, this recursion is just a specification device.
In practice, the initialization values can <a class="reference internal" href="#exec-initvals"><span class="std std-ref">be determined</span></a> beforehand by staging module allocation such that first, the module’s own <a class="reference internal" href="runtime.html#syntax-funcinst"><span class="std std-ref">function instances</span></a> are pre-allocated in the store, then the initializer expressions are evaluated, then the rest of the module instance is allocated, and finally the new function instances’ <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-frame}{\mathsf{module}}\)</span> fields are set to that module instance.
This is possible because <a class="reference internal" href="../valid/modules.html#valid-module"><span class="std std-ref">validation</span></a> ensures that initialization expressions cannot actually call a function, only take their reference.</p>
<p>All failure conditions are checked before any observable mutation of the store takes place.
Store mutation is not atomic;
it happens in individual steps that may be interleaved with other threads.</p>
<p><a class="reference internal" href="instructions.html#exec-expr"><span class="std std-ref">Evaluation</span></a> of <a class="reference internal" href="../valid/instructions.html#valid-constant"><span class="std std-ref">constant expressions</span></a> does not affect the store.</p>
</div>
</section>
<section id="invocation">
<span id="exec-invocation"></span><span id="index-18"></span><h2>Invocation<a class="headerlink" href="#invocation" title="Permalink to this heading">¶</a></h2>
<p>Once a <a class="reference internal" href="../syntax/modules.html#syntax-module"><span class="std std-ref">module</span></a> has been <a class="reference internal" href="#exec-instantiation"><span class="std std-ref">instantiated</span></a>, any exported function can be <em>invoked</em> externally via its <a class="reference internal" href="runtime.html#syntax-funcaddr"><span class="std std-ref">function address</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}\)</span> in the <a class="reference internal" href="runtime.html#syntax-store"><span class="std std-ref">store</span></a> <span class="math notranslate nohighlight">\(S\)</span> and an appropriate list <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast\)</span> of argument <a class="reference internal" href="runtime.html#syntax-val"><span class="std std-ref">values</span></a>.</p>
<p>Invocation may <em>fail</em> with an error if the arguments do not fit the <a class="reference internal" href="../syntax/types.html#syntax-functype"><span class="std std-ref">function type</span></a>.
Invocation can also result in a <a class="reference internal" href="../intro/overview.html#trap"><span class="std std-ref">trap</span></a>.
It is up to the <a class="reference internal" href="../intro/overview.html#embedder"><span class="std std-ref">embedder</span></a> to define how such conditions are reported.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the <a class="reference internal" href="../intro/overview.html#embedder"><span class="std std-ref">embedder</span></a> API performs type checks itself, either statically or dynamically, before performing an invocation, then no failure other than traps can occur.</p>
</div>
<p>The following steps are performed:</p>
<ol class="arabic simple">
<li><p>Assert: <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{funcs}}[\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}]\)</span> exists.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}}\)</span> be the <a class="reference internal" href="runtime.html#syntax-funcinst"><span class="std std-ref">function instance</span></a> <span class="math notranslate nohighlight">\(S.\href{../exec/runtime.html#syntax-store}{\mathsf{funcs}}[\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}]\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\([t_1^n] \href{../syntax/types.html#syntax-functype}{\rightarrow} [t_2^m]\)</span> be the <a class="reference internal" href="../syntax/types.html#syntax-functype"><span class="std std-ref">function type</span></a> <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-funcinst}{\mathit{funcinst}}.\href{../exec/runtime.html#syntax-funcinst}{\mathsf{type}}\)</span>.</p></li>
<li><p>If the length <span class="math notranslate nohighlight">\(|\href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast|\)</span> of the provided argument values is different from the number <span class="math notranslate nohighlight">\(n\)</span> of expected arguments, then:</p>
<ol class="loweralpha simple">
<li><p>Fail.</p></li>
</ol>
</li>
<li><p>For each <a class="reference internal" href="../syntax/types.html#syntax-valtype"><span class="std std-ref">value type</span></a> <span class="math notranslate nohighlight">\(t_i\)</span> in <span class="math notranslate nohighlight">\(t_1^n\)</span> and corresponding <a class="reference internal" href="runtime.html#syntax-val"><span class="std std-ref">value</span></a> <span class="math notranslate nohighlight">\(val_i\)</span> in <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast\)</span>, do:</p>
<ol class="loweralpha simple">
<li><p>If <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}_i\)</span> is not <a class="reference internal" href="#valid-val"><span class="std std-ref">valid</span></a> with value type <span class="math notranslate nohighlight">\(t_i\)</span>, then:</p>
<ol class="lowerroman simple">
<li><p>Fail.</p></li>
</ol>
</li>
</ol>
</li>
<li><p>Let <span class="math notranslate nohighlight">\(F\)</span> be the dummy <a class="reference internal" href="runtime.html#syntax-frame"><span class="std std-ref">frame</span></a> <span class="math notranslate nohighlight">\(\{ \href{../exec/runtime.html#syntax-frame}{\mathsf{module}}~\{\}, \href{../exec/runtime.html#syntax-frame}{\mathsf{locals}}~\epsilon \}\)</span>.</p></li>
<li><p>Push the frame <span class="math notranslate nohighlight">\(F\)</span> to the stack.</p></li>
<li><p>Push the values <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}^\ast\)</span> to the stack.</p></li>
<li><p><a class="reference internal" href="instructions.html#exec-invoke"><span class="std std-ref">Invoke</span></a> the function instance at address <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}\)</span>.</p></li>
</ol>
<p>Once the function has returned, the following steps are executed:</p>
<ol class="arabic simple">
<li><p>Assert: due to <a class="reference internal" href="../valid/modules.html#valid-func"><span class="std std-ref">validation</span></a>, <span class="math notranslate nohighlight">\(m\)</span> <a class="reference internal" href="runtime.html#syntax-val"><span class="std std-ref">values</span></a> are on the top of the stack.</p></li>
<li><p>Pop <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}_{\mathrm{res}}^m\)</span> from the stack.</p></li>
<li><p>Assert: due to <a class="reference internal" href="../valid/modules.html#valid-module"><span class="std std-ref">validation</span></a>, the frame <span class="math notranslate nohighlight">\(F\)</span> is now on the top of the stack.</p></li>
<li><p>Pop the frame <span class="math notranslate nohighlight">\(F\)</span> from the stack.</p></li>
</ol>
<p>The values <span class="math notranslate nohighlight">\(\href{../exec/runtime.html#syntax-val}{\mathit{val}}_{\mathrm{res}}^m\)</span> are returned as the results of the invocation.</p>
<div class="math notranslate nohighlight">
\[\begin{split}~\\[-1ex]
\begin{array}{&#64;{}lcl}
\href{../exec/modules.html#exec-invocation}{\mathrm{invoke}}(S, \href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}, \href{../exec/runtime.html#syntax-val}{\mathit{val}}^n) &amp;=&amp; S; F; \href{../exec/runtime.html#syntax-val}{\mathit{val}}^n~(\href{../exec/runtime.html#syntax-invoke}{\mathsf{invoke}}~\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}) \\
  &amp;(\mathrel{\mbox{if}} &amp; S.\href{../exec/runtime.html#syntax-store}{\mathsf{funcs}}[\href{../exec/runtime.html#syntax-funcaddr}{\mathit{funcaddr}}].\href{../exec/runtime.html#syntax-funcinst}{\mathsf{type}} = [t_1^n] \href{../syntax/types.html#syntax-functype}{\rightarrow} [t_2^m] \\
  &amp;\wedge&amp; (S \href{../exec/modules.html#valid-val}{\vdash} \href{../exec/runtime.html#syntax-val}{\mathit{val}} : t_1)^n \\
  &amp;\wedge&amp; F = \{ \href{../exec/runtime.html#syntax-frame}{\mathsf{module}}~\{\}, \href{../exec/runtime.html#syntax-frame}{\mathsf{locals}}~\epsilon \}) \\
\end{array}\end{split}\]</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;2022, WebAssembly Community Group.
      
    </div>

    

    
  </body>
</html>